/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _ramda = __webpack_require__(1);\n\nvar _flyd = __webpack_require__(2);\n\nvar _flyd2 = _interopRequireDefault(_flyd);\n\nvar _app = __webpack_require__(9);\n\nvar _actions = __webpack_require__(74);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar patch = __webpack_require__(89).init([__webpack_require__(91), __webpack_require__(92), __webpack_require__(93), __webpack_require__(94)]);\n\nvar update = function update(model, action) {\n  return _actions.Action.case((0, _ramda.map)((0, _ramda.flip)(_ramda.apply)([model, action]), _actions.actions), action);\n};\n\n// Streams\nvar action$ = (0, _flyd.stream)(); // All modifications to the state originate here\nvar model$ = _flyd2.default.scan(update, (0, _app.init)(), action$); // Contains the entire state of the application\nvar vnode$ = _flyd2.default.map((0, _app.view)(action$), model$); // Stream of virtual nodes to render\n\n// flyd.map( console.log.bind(console), model$ )  // Uncomment to log state on every update\n_flyd2.default.map(function (x) {\n  return console.dir(x.table);\n}, model$); // Uncomment to log state on every update\n\nvar container = document.getElementById('container');\n_flyd2.default.scan(patch, container, vnode$);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/OTU1MiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBOztBQUNBOzs7O0FBUUE7O0FBQ0E7Ozs7QUFSQSxJQUFNLFFBQVEsb0JBQVEsRUFBUixFQUFvQixJQUFwQixDQUF5QixDQUNyQyxvQkFBUSxFQUFSLENBRHFDLEVBRXJDLG9CQUFRLEVBQVIsQ0FGcUMsRUFHckMsb0JBQVEsRUFBUixDQUhxQyxFQUlyQyxvQkFBUSxFQUFSLENBSnFDLENBQXpCLENBQWQ7O0FBV0EsSUFBTSxTQUNOLFNBRE0sTUFDTixDQUFFLEtBQUYsRUFBUyxNQUFUO0FBQUEsU0FBcUIsZ0JBQU8sSUFBUCxDQUFhLGdCQUFLLCtCQUFZLENBQUUsS0FBRixFQUFTLE1BQVQsQ0FBWixDQUFMLG1CQUFiLEVBQTZELE1BQTdELENBQXJCO0FBQUEsQ0FEQTs7O0FBS0EsSUFBTSxVQUFVLG1CQUFoQixDO0FBQ0EsSUFBTSxTQUFTLGVBQUssSUFBTCxDQUFXLE1BQVgsRUFBbUIsZ0JBQW5CLEVBQTJCLE9BQTNCLENBQWYsQztBQUNBLElBQU0sU0FBUyxlQUFLLEdBQUwsQ0FBVSxlQUFNLE9BQU4sQ0FBVixFQUEyQixNQUEzQixDQUFmLEM7OztBQUdBLGVBQUssR0FBTCxDQUFVO0FBQUEsU0FBSyxRQUFRLEdBQVIsQ0FBWSxFQUFFLEtBQWQsQ0FBTDtBQUFBLENBQVYsRUFBcUMsTUFBckMsRTs7QUFFQSxJQUFNLFlBQVksU0FBUyxjQUFULENBQXlCLFdBQXpCLENBQWxCO0FBQ0EsZUFBSyxJQUFMLENBQVcsS0FBWCxFQUFrQixTQUFsQixFQUE2QixNQUE3QiIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbWFwLCBhcHBseSwgZmxpcCB9IGZyb20gJ3JhbWRhJ1xuaW1wb3J0IGZseWQsIHsgc3RyZWFtIH0gZnJvbSAnZmx5ZCdcbmNvbnN0IHBhdGNoID0gcmVxdWlyZSgnc25hYmJkb20nKS5pbml0KFtcbiAgcmVxdWlyZSgnc25hYmJkb20vbW9kdWxlcy9jbGFzcycpLFxuICByZXF1aXJlKCdzbmFiYmRvbS9tb2R1bGVzL3Byb3BzJyksXG4gIHJlcXVpcmUoJ3NuYWJiZG9tL21vZHVsZXMvZXZlbnRsaXN0ZW5lcnMnKSxcbiAgcmVxdWlyZSgnc25hYmJkb20vbW9kdWxlcy9zdHlsZScpLFxuXSlcblxuaW1wb3J0IHsgaW5pdCwgdmlldyB9IGZyb20gJ2FwcCdcbmltcG9ydCB7IEFjdGlvbiwgYWN0aW9ucyB9IGZyb20gJ2FjdGlvbnMnXG5cblxuY29uc3QgdXBkYXRlID1cbiggbW9kZWwsIGFjdGlvbiApID0+IEFjdGlvbi5jYXNlKCBtYXAoIGZsaXAoYXBwbHkpKFsgbW9kZWwsIGFjdGlvbiBdKSwgYWN0aW9ucyApLCBhY3Rpb24gKVxuXG5cbi8vIFN0cmVhbXNcbmNvbnN0IGFjdGlvbiQgPSBzdHJlYW0oKSAvLyBBbGwgbW9kaWZpY2F0aW9ucyB0byB0aGUgc3RhdGUgb3JpZ2luYXRlIGhlcmVcbmNvbnN0IG1vZGVsJCA9IGZseWQuc2NhbiggdXBkYXRlLCBpbml0KCksIGFjdGlvbiQgKSAvLyBDb250YWlucyB0aGUgZW50aXJlIHN0YXRlIG9mIHRoZSBhcHBsaWNhdGlvblxuY29uc3Qgdm5vZGUkID0gZmx5ZC5tYXAoIHZpZXcoIGFjdGlvbiQgKSwgbW9kZWwkICkgLy8gU3RyZWFtIG9mIHZpcnR1YWwgbm9kZXMgdG8gcmVuZGVyXG5cbi8vIGZseWQubWFwKCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpLCBtb2RlbCQgKSAgLy8gVW5jb21tZW50IHRvIGxvZyBzdGF0ZSBvbiBldmVyeSB1cGRhdGVcbmZseWQubWFwKCB4ID0+IGNvbnNvbGUuZGlyKHgudGFibGUpLCBtb2RlbCQgKSAgLy8gVW5jb21tZW50IHRvIGxvZyBzdGF0ZSBvbiBldmVyeSB1cGRhdGVcblxuY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoICdjb250YWluZXInIClcbmZseWQuc2NhbiggcGF0Y2gsIGNvbnRhaW5lciwgdm5vZGUkIClcblxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvaW5kZXguanNcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	eval("//  Ramda v0.21.0\n//  https://github.com/ramda/ramda\n//  (c) 2013-2016 Scott Sauyet, Michael Hurley, and David Chambers\n//  Ramda may be freely distributed under the MIT license.\n\n;(function() {\n\n  'use strict';\n\n  /**\n     * A special placeholder value used to specify \"gaps\" within curried functions,\n     * allowing partial application of any combination of arguments, regardless of\n     * their positions.\n     *\n     * If `g` is a curried ternary function and `_` is `R.__`, the following are\n     * equivalent:\n     *\n     *   - `g(1, 2, 3)`\n     *   - `g(_, 2, 3)(1)`\n     *   - `g(_, _, 3)(1)(2)`\n     *   - `g(_, _, 3)(1, 2)`\n     *   - `g(_, 2, _)(1, 3)`\n     *   - `g(_, 2)(1)(3)`\n     *   - `g(_, 2)(1, 3)`\n     *   - `g(_, 2)(_, 3)(1)`\n     *\n     * @constant\n     * @memberOf R\n     * @since v0.6.0\n     * @category Function\n     * @example\n     *\n     *      var greet = R.replace('{name}', R.__, 'Hello, {name}!');\n     *      greet('Alice'); //=> 'Hello, Alice!'\n     */\n    var __ = { '@@functional/placeholder': true };\n\n    /* eslint-disable no-unused-vars */\n    var _arity = function _arity(n, fn) {\n        /* eslint-disable no-unused-vars */\n        switch (n) {\n        case 0:\n            return function () {\n                return fn.apply(this, arguments);\n            };\n        case 1:\n            return function (a0) {\n                return fn.apply(this, arguments);\n            };\n        case 2:\n            return function (a0, a1) {\n                return fn.apply(this, arguments);\n            };\n        case 3:\n            return function (a0, a1, a2) {\n                return fn.apply(this, arguments);\n            };\n        case 4:\n            return function (a0, a1, a2, a3) {\n                return fn.apply(this, arguments);\n            };\n        case 5:\n            return function (a0, a1, a2, a3, a4) {\n                return fn.apply(this, arguments);\n            };\n        case 6:\n            return function (a0, a1, a2, a3, a4, a5) {\n                return fn.apply(this, arguments);\n            };\n        case 7:\n            return function (a0, a1, a2, a3, a4, a5, a6) {\n                return fn.apply(this, arguments);\n            };\n        case 8:\n            return function (a0, a1, a2, a3, a4, a5, a6, a7) {\n                return fn.apply(this, arguments);\n            };\n        case 9:\n            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {\n                return fn.apply(this, arguments);\n            };\n        case 10:\n            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {\n                return fn.apply(this, arguments);\n            };\n        default:\n            throw new Error('First argument to _arity must be a non-negative integer no greater than ten');\n        }\n    };\n\n    var _arrayFromIterator = function _arrayFromIterator(iter) {\n        var list = [];\n        var next;\n        while (!(next = iter.next()).done) {\n            list.push(next.value);\n        }\n        return list;\n    };\n\n    var _arrayOf = function _arrayOf() {\n        return Array.prototype.slice.call(arguments);\n    };\n\n    var _cloneRegExp = function _cloneRegExp(pattern) {\n        return new RegExp(pattern.source, (pattern.global ? 'g' : '') + (pattern.ignoreCase ? 'i' : '') + (pattern.multiline ? 'm' : '') + (pattern.sticky ? 'y' : '') + (pattern.unicode ? 'u' : ''));\n    };\n\n    var _complement = function _complement(f) {\n        return function () {\n            return !f.apply(this, arguments);\n        };\n    };\n\n    /**\n     * Private `concat` function to merge two array-like objects.\n     *\n     * @private\n     * @param {Array|Arguments} [set1=[]] An array-like object.\n     * @param {Array|Arguments} [set2=[]] An array-like object.\n     * @return {Array} A new, merged array.\n     * @example\n     *\n     *      _concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]\n     */\n    var _concat = function _concat(set1, set2) {\n        set1 = set1 || [];\n        set2 = set2 || [];\n        var idx;\n        var len1 = set1.length;\n        var len2 = set2.length;\n        var result = [];\n        idx = 0;\n        while (idx < len1) {\n            result[result.length] = set1[idx];\n            idx += 1;\n        }\n        idx = 0;\n        while (idx < len2) {\n            result[result.length] = set2[idx];\n            idx += 1;\n        }\n        return result;\n    };\n\n    var _containsWith = function _containsWith(pred, x, list) {\n        var idx = 0;\n        var len = list.length;\n        while (idx < len) {\n            if (pred(x, list[idx])) {\n                return true;\n            }\n            idx += 1;\n        }\n        return false;\n    };\n\n    var _filter = function _filter(fn, list) {\n        var idx = 0;\n        var len = list.length;\n        var result = [];\n        while (idx < len) {\n            if (fn(list[idx])) {\n                result[result.length] = list[idx];\n            }\n            idx += 1;\n        }\n        return result;\n    };\n\n    var _forceReduced = function _forceReduced(x) {\n        return {\n            '@@transducer/value': x,\n            '@@transducer/reduced': true\n        };\n    };\n\n    // String(x => x) evaluates to \"x => x\", so the pattern may not match.\n    var _functionName = function _functionName(f) {\n        // String(x => x) evaluates to \"x => x\", so the pattern may not match.\n        var match = String(f).match(/^function (\\w*)/);\n        return match == null ? '' : match[1];\n    };\n\n    var _has = function _has(prop, obj) {\n        return Object.prototype.hasOwnProperty.call(obj, prop);\n    };\n\n    var _identity = function _identity(x) {\n        return x;\n    };\n\n    var _isArguments = function () {\n        var toString = Object.prototype.toString;\n        return toString.call(arguments) === '[object Arguments]' ? function _isArguments(x) {\n            return toString.call(x) === '[object Arguments]';\n        } : function _isArguments(x) {\n            return _has('callee', x);\n        };\n    }();\n\n    /**\n     * Tests whether or not an object is an array.\n     *\n     * @private\n     * @param {*} val The object to test.\n     * @return {Boolean} `true` if `val` is an array, `false` otherwise.\n     * @example\n     *\n     *      _isArray([]); //=> true\n     *      _isArray(null); //=> false\n     *      _isArray({}); //=> false\n     */\n    var _isArray = Array.isArray || function _isArray(val) {\n        return val != null && val.length >= 0 && Object.prototype.toString.call(val) === '[object Array]';\n    };\n\n    var _isFunction = function _isNumber(x) {\n        return Object.prototype.toString.call(x) === '[object Function]';\n    };\n\n    /**\n     * Determine if the passed argument is an integer.\n     *\n     * @private\n     * @param {*} n\n     * @category Type\n     * @return {Boolean}\n     */\n    var _isInteger = Number.isInteger || function _isInteger(n) {\n        return n << 0 === n;\n    };\n\n    var _isNumber = function _isNumber(x) {\n        return Object.prototype.toString.call(x) === '[object Number]';\n    };\n\n    var _isObject = function _isObject(x) {\n        return Object.prototype.toString.call(x) === '[object Object]';\n    };\n\n    var _isPlaceholder = function _isPlaceholder(a) {\n        return a != null && typeof a === 'object' && a['@@functional/placeholder'] === true;\n    };\n\n    var _isRegExp = function _isRegExp(x) {\n        return Object.prototype.toString.call(x) === '[object RegExp]';\n    };\n\n    var _isString = function _isString(x) {\n        return Object.prototype.toString.call(x) === '[object String]';\n    };\n\n    var _isTransformer = function _isTransformer(obj) {\n        return typeof obj['@@transducer/step'] === 'function';\n    };\n\n    var _map = function _map(fn, functor) {\n        var idx = 0;\n        var len = functor.length;\n        var result = Array(len);\n        while (idx < len) {\n            result[idx] = fn(functor[idx]);\n            idx += 1;\n        }\n        return result;\n    };\n\n    // Based on https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n    var _objectAssign = function _objectAssign(target) {\n        if (target == null) {\n            throw new TypeError('Cannot convert undefined or null to object');\n        }\n        var output = Object(target);\n        var idx = 1;\n        var length = arguments.length;\n        while (idx < length) {\n            var source = arguments[idx];\n            if (source != null) {\n                for (var nextKey in source) {\n                    if (_has(nextKey, source)) {\n                        output[nextKey] = source[nextKey];\n                    }\n                }\n            }\n            idx += 1;\n        }\n        return output;\n    };\n\n    var _of = function _of(x) {\n        return [x];\n    };\n\n    var _pipe = function _pipe(f, g) {\n        return function () {\n            return g.call(this, f.apply(this, arguments));\n        };\n    };\n\n    var _pipeP = function _pipeP(f, g) {\n        return function () {\n            var ctx = this;\n            return f.apply(ctx, arguments).then(function (x) {\n                return g.call(ctx, x);\n            });\n        };\n    };\n\n    // \\b matches word boundary; [\\b] matches backspace\n    var _quote = function _quote(s) {\n        var escaped = s.replace(/\\\\/g, '\\\\\\\\').replace(/[\\b]/g, '\\\\b')    // \\b matches word boundary; [\\b] matches backspace\n    .replace(/\\f/g, '\\\\f').replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r').replace(/\\t/g, '\\\\t').replace(/\\v/g, '\\\\v').replace(/\\0/g, '\\\\0');\n        return '\"' + escaped.replace(/\"/g, '\\\\\"') + '\"';\n    };\n\n    var _reduced = function _reduced(x) {\n        return x && x['@@transducer/reduced'] ? x : {\n            '@@transducer/value': x,\n            '@@transducer/reduced': true\n        };\n    };\n\n    /**\n     * An optimized, private array `slice` implementation.\n     *\n     * @private\n     * @param {Arguments|Array} args The array or arguments object to consider.\n     * @param {Number} [from=0] The array index to slice from, inclusive.\n     * @param {Number} [to=args.length] The array index to slice to, exclusive.\n     * @return {Array} A new, sliced array.\n     * @example\n     *\n     *      _slice([1, 2, 3, 4, 5], 1, 3); //=> [2, 3]\n     *\n     *      var firstThreeArgs = function(a, b, c, d) {\n     *        return _slice(arguments, 0, 3);\n     *      };\n     *      firstThreeArgs(1, 2, 3, 4); //=> [1, 2, 3]\n     */\n    var _slice = function _slice(args, from, to) {\n        switch (arguments.length) {\n        case 1:\n            return _slice(args, 0, args.length);\n        case 2:\n            return _slice(args, from, args.length);\n        default:\n            var list = [];\n            var idx = 0;\n            var len = Math.max(0, Math.min(args.length, to) - from);\n            while (idx < len) {\n                list[idx] = args[from + idx];\n                idx += 1;\n            }\n            return list;\n        }\n    };\n\n    /**\n     * Polyfill from <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString>.\n     */\n    var _toISOString = function () {\n        var pad = function pad(n) {\n            return (n < 10 ? '0' : '') + n;\n        };\n        return typeof Date.prototype.toISOString === 'function' ? function _toISOString(d) {\n            return d.toISOString();\n        } : function _toISOString(d) {\n            return d.getUTCFullYear() + '-' + pad(d.getUTCMonth() + 1) + '-' + pad(d.getUTCDate()) + 'T' + pad(d.getUTCHours()) + ':' + pad(d.getUTCMinutes()) + ':' + pad(d.getUTCSeconds()) + '.' + (d.getUTCMilliseconds() / 1000).toFixed(3).slice(2, 5) + 'Z';\n        };\n    }();\n\n    var _xfBase = {\n        init: function () {\n            return this.xf['@@transducer/init']();\n        },\n        result: function (result) {\n            return this.xf['@@transducer/result'](result);\n        }\n    };\n\n    var _xwrap = function () {\n        function XWrap(fn) {\n            this.f = fn;\n        }\n        XWrap.prototype['@@transducer/init'] = function () {\n            throw new Error('init not implemented on XWrap');\n        };\n        XWrap.prototype['@@transducer/result'] = function (acc) {\n            return acc;\n        };\n        XWrap.prototype['@@transducer/step'] = function (acc, x) {\n            return this.f(acc, x);\n        };\n        return function _xwrap(fn) {\n            return new XWrap(fn);\n        };\n    }();\n\n    var _aperture = function _aperture(n, list) {\n        var idx = 0;\n        var limit = list.length - (n - 1);\n        var acc = new Array(limit >= 0 ? limit : 0);\n        while (idx < limit) {\n            acc[idx] = _slice(list, idx, idx + n);\n            idx += 1;\n        }\n        return acc;\n    };\n\n    var _assign = typeof Object.assign === 'function' ? Object.assign : _objectAssign;\n\n    /**\n     * Similar to hasMethod, this checks whether a function has a [methodname]\n     * function. If it isn't an array it will execute that function otherwise it\n     * will default to the ramda implementation.\n     *\n     * @private\n     * @param {Function} fn ramda implemtation\n     * @param {String} methodname property to check for a custom implementation\n     * @return {Object} Whatever the return value of the method is.\n     */\n    var _checkForMethod = function _checkForMethod(methodname, fn) {\n        return function () {\n            var length = arguments.length;\n            if (length === 0) {\n                return fn();\n            }\n            var obj = arguments[length - 1];\n            return _isArray(obj) || typeof obj[methodname] !== 'function' ? fn.apply(this, arguments) : obj[methodname].apply(obj, _slice(arguments, 0, length - 1));\n        };\n    };\n\n    /**\n     * Optimized internal one-arity curry function.\n     *\n     * @private\n     * @category Function\n     * @param {Function} fn The function to curry.\n     * @return {Function} The curried function.\n     */\n    var _curry1 = function _curry1(fn) {\n        return function f1(a) {\n            if (arguments.length === 0 || _isPlaceholder(a)) {\n                return f1;\n            } else {\n                return fn.apply(this, arguments);\n            }\n        };\n    };\n\n    /**\n     * Optimized internal two-arity curry function.\n     *\n     * @private\n     * @category Function\n     * @param {Function} fn The function to curry.\n     * @return {Function} The curried function.\n     */\n    var _curry2 = function _curry2(fn) {\n        return function f2(a, b) {\n            switch (arguments.length) {\n            case 0:\n                return f2;\n            case 1:\n                return _isPlaceholder(a) ? f2 : _curry1(function (_b) {\n                    return fn(a, _b);\n                });\n            default:\n                return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function (_a) {\n                    return fn(_a, b);\n                }) : _isPlaceholder(b) ? _curry1(function (_b) {\n                    return fn(a, _b);\n                }) : fn(a, b);\n            }\n        };\n    };\n\n    /**\n     * Optimized internal three-arity curry function.\n     *\n     * @private\n     * @category Function\n     * @param {Function} fn The function to curry.\n     * @return {Function} The curried function.\n     */\n    var _curry3 = function _curry3(fn) {\n        return function f3(a, b, c) {\n            switch (arguments.length) {\n            case 0:\n                return f3;\n            case 1:\n                return _isPlaceholder(a) ? f3 : _curry2(function (_b, _c) {\n                    return fn(a, _b, _c);\n                });\n            case 2:\n                return _isPlaceholder(a) && _isPlaceholder(b) ? f3 : _isPlaceholder(a) ? _curry2(function (_a, _c) {\n                    return fn(_a, b, _c);\n                }) : _isPlaceholder(b) ? _curry2(function (_b, _c) {\n                    return fn(a, _b, _c);\n                }) : _curry1(function (_c) {\n                    return fn(a, b, _c);\n                });\n            default:\n                return _isPlaceholder(a) && _isPlaceholder(b) && _isPlaceholder(c) ? f3 : _isPlaceholder(a) && _isPlaceholder(b) ? _curry2(function (_a, _b) {\n                    return fn(_a, _b, c);\n                }) : _isPlaceholder(a) && _isPlaceholder(c) ? _curry2(function (_a, _c) {\n                    return fn(_a, b, _c);\n                }) : _isPlaceholder(b) && _isPlaceholder(c) ? _curry2(function (_b, _c) {\n                    return fn(a, _b, _c);\n                }) : _isPlaceholder(a) ? _curry1(function (_a) {\n                    return fn(_a, b, c);\n                }) : _isPlaceholder(b) ? _curry1(function (_b) {\n                    return fn(a, _b, c);\n                }) : _isPlaceholder(c) ? _curry1(function (_c) {\n                    return fn(a, b, _c);\n                }) : fn(a, b, c);\n            }\n        };\n    };\n\n    /**\n     * Internal curryN function.\n     *\n     * @private\n     * @category Function\n     * @param {Number} length The arity of the curried function.\n     * @param {Array} received An array of arguments received thus far.\n     * @param {Function} fn The function to curry.\n     * @return {Function} The curried function.\n     */\n    var _curryN = function _curryN(length, received, fn) {\n        return function () {\n            var combined = [];\n            var argsIdx = 0;\n            var left = length;\n            var combinedIdx = 0;\n            while (combinedIdx < received.length || argsIdx < arguments.length) {\n                var result;\n                if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {\n                    result = received[combinedIdx];\n                } else {\n                    result = arguments[argsIdx];\n                    argsIdx += 1;\n                }\n                combined[combinedIdx] = result;\n                if (!_isPlaceholder(result)) {\n                    left -= 1;\n                }\n                combinedIdx += 1;\n            }\n            return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));\n        };\n    };\n\n    /**\n     * Returns a function that dispatches with different strategies based on the\n     * object in list position (last argument). If it is an array, executes [fn].\n     * Otherwise, if it has a function with [methodname], it will execute that\n     * function (functor case). Otherwise, if it is a transformer, uses transducer\n     * [xf] to return a new transformer (transducer case). Otherwise, it will\n     * default to executing [fn].\n     *\n     * @private\n     * @param {String} methodname property to check for a custom implementation\n     * @param {Function} xf transducer to initialize if object is transformer\n     * @param {Function} fn default ramda implementation\n     * @return {Function} A function that dispatches on object in list position\n     */\n    var _dispatchable = function _dispatchable(methodname, xf, fn) {\n        return function () {\n            var length = arguments.length;\n            if (length === 0) {\n                return fn();\n            }\n            var obj = arguments[length - 1];\n            if (!_isArray(obj)) {\n                var args = _slice(arguments, 0, length - 1);\n                if (typeof obj[methodname] === 'function') {\n                    return obj[methodname].apply(obj, args);\n                }\n                if (_isTransformer(obj)) {\n                    var transducer = xf.apply(null, args);\n                    return transducer(obj);\n                }\n            }\n            return fn.apply(this, arguments);\n        };\n    };\n\n    var _dropLastWhile = function dropLastWhile(pred, list) {\n        var idx = list.length - 1;\n        while (idx >= 0 && pred(list[idx])) {\n            idx -= 1;\n        }\n        return _slice(list, 0, idx + 1);\n    };\n\n    var _xall = function () {\n        function XAll(f, xf) {\n            this.xf = xf;\n            this.f = f;\n            this.all = true;\n        }\n        XAll.prototype['@@transducer/init'] = _xfBase.init;\n        XAll.prototype['@@transducer/result'] = function (result) {\n            if (this.all) {\n                result = this.xf['@@transducer/step'](result, true);\n            }\n            return this.xf['@@transducer/result'](result);\n        };\n        XAll.prototype['@@transducer/step'] = function (result, input) {\n            if (!this.f(input)) {\n                this.all = false;\n                result = _reduced(this.xf['@@transducer/step'](result, false));\n            }\n            return result;\n        };\n        return _curry2(function _xall(f, xf) {\n            return new XAll(f, xf);\n        });\n    }();\n\n    var _xany = function () {\n        function XAny(f, xf) {\n            this.xf = xf;\n            this.f = f;\n            this.any = false;\n        }\n        XAny.prototype['@@transducer/init'] = _xfBase.init;\n        XAny.prototype['@@transducer/result'] = function (result) {\n            if (!this.any) {\n                result = this.xf['@@transducer/step'](result, false);\n            }\n            return this.xf['@@transducer/result'](result);\n        };\n        XAny.prototype['@@transducer/step'] = function (result, input) {\n            if (this.f(input)) {\n                this.any = true;\n                result = _reduced(this.xf['@@transducer/step'](result, true));\n            }\n            return result;\n        };\n        return _curry2(function _xany(f, xf) {\n            return new XAny(f, xf);\n        });\n    }();\n\n    var _xaperture = function () {\n        function XAperture(n, xf) {\n            this.xf = xf;\n            this.pos = 0;\n            this.full = false;\n            this.acc = new Array(n);\n        }\n        XAperture.prototype['@@transducer/init'] = _xfBase.init;\n        XAperture.prototype['@@transducer/result'] = function (result) {\n            this.acc = null;\n            return this.xf['@@transducer/result'](result);\n        };\n        XAperture.prototype['@@transducer/step'] = function (result, input) {\n            this.store(input);\n            return this.full ? this.xf['@@transducer/step'](result, this.getCopy()) : result;\n        };\n        XAperture.prototype.store = function (input) {\n            this.acc[this.pos] = input;\n            this.pos += 1;\n            if (this.pos === this.acc.length) {\n                this.pos = 0;\n                this.full = true;\n            }\n        };\n        XAperture.prototype.getCopy = function () {\n            return _concat(_slice(this.acc, this.pos), _slice(this.acc, 0, this.pos));\n        };\n        return _curry2(function _xaperture(n, xf) {\n            return new XAperture(n, xf);\n        });\n    }();\n\n    var _xdrop = function () {\n        function XDrop(n, xf) {\n            this.xf = xf;\n            this.n = n;\n        }\n        XDrop.prototype['@@transducer/init'] = _xfBase.init;\n        XDrop.prototype['@@transducer/result'] = _xfBase.result;\n        XDrop.prototype['@@transducer/step'] = function (result, input) {\n            if (this.n > 0) {\n                this.n -= 1;\n                return result;\n            }\n            return this.xf['@@transducer/step'](result, input);\n        };\n        return _curry2(function _xdrop(n, xf) {\n            return new XDrop(n, xf);\n        });\n    }();\n\n    var _xdropLast = function () {\n        function XDropLast(n, xf) {\n            this.xf = xf;\n            this.pos = 0;\n            this.full = false;\n            this.acc = new Array(n);\n        }\n        XDropLast.prototype['@@transducer/init'] = _xfBase.init;\n        XDropLast.prototype['@@transducer/result'] = function (result) {\n            this.acc = null;\n            return this.xf['@@transducer/result'](result);\n        };\n        XDropLast.prototype['@@transducer/step'] = function (result, input) {\n            if (this.full) {\n                result = this.xf['@@transducer/step'](result, this.acc[this.pos]);\n            }\n            this.store(input);\n            return result;\n        };\n        XDropLast.prototype.store = function (input) {\n            this.acc[this.pos] = input;\n            this.pos += 1;\n            if (this.pos === this.acc.length) {\n                this.pos = 0;\n                this.full = true;\n            }\n        };\n        return _curry2(function _xdropLast(n, xf) {\n            return new XDropLast(n, xf);\n        });\n    }();\n\n    var _xdropRepeatsWith = function () {\n        function XDropRepeatsWith(pred, xf) {\n            this.xf = xf;\n            this.pred = pred;\n            this.lastValue = undefined;\n            this.seenFirstValue = false;\n        }\n        XDropRepeatsWith.prototype['@@transducer/init'] = function () {\n            return this.xf['@@transducer/init']();\n        };\n        XDropRepeatsWith.prototype['@@transducer/result'] = function (result) {\n            return this.xf['@@transducer/result'](result);\n        };\n        XDropRepeatsWith.prototype['@@transducer/step'] = function (result, input) {\n            var sameAsLast = false;\n            if (!this.seenFirstValue) {\n                this.seenFirstValue = true;\n            } else if (this.pred(this.lastValue, input)) {\n                sameAsLast = true;\n            }\n            this.lastValue = input;\n            return sameAsLast ? result : this.xf['@@transducer/step'](result, input);\n        };\n        return _curry2(function _xdropRepeatsWith(pred, xf) {\n            return new XDropRepeatsWith(pred, xf);\n        });\n    }();\n\n    var _xdropWhile = function () {\n        function XDropWhile(f, xf) {\n            this.xf = xf;\n            this.f = f;\n        }\n        XDropWhile.prototype['@@transducer/init'] = _xfBase.init;\n        XDropWhile.prototype['@@transducer/result'] = _xfBase.result;\n        XDropWhile.prototype['@@transducer/step'] = function (result, input) {\n            if (this.f) {\n                if (this.f(input)) {\n                    return result;\n                }\n                this.f = null;\n            }\n            return this.xf['@@transducer/step'](result, input);\n        };\n        return _curry2(function _xdropWhile(f, xf) {\n            return new XDropWhile(f, xf);\n        });\n    }();\n\n    var _xfilter = function () {\n        function XFilter(f, xf) {\n            this.xf = xf;\n            this.f = f;\n        }\n        XFilter.prototype['@@transducer/init'] = _xfBase.init;\n        XFilter.prototype['@@transducer/result'] = _xfBase.result;\n        XFilter.prototype['@@transducer/step'] = function (result, input) {\n            return this.f(input) ? this.xf['@@transducer/step'](result, input) : result;\n        };\n        return _curry2(function _xfilter(f, xf) {\n            return new XFilter(f, xf);\n        });\n    }();\n\n    var _xfind = function () {\n        function XFind(f, xf) {\n            this.xf = xf;\n            this.f = f;\n            this.found = false;\n        }\n        XFind.prototype['@@transducer/init'] = _xfBase.init;\n        XFind.prototype['@@transducer/result'] = function (result) {\n            if (!this.found) {\n                result = this.xf['@@transducer/step'](result, void 0);\n            }\n            return this.xf['@@transducer/result'](result);\n        };\n        XFind.prototype['@@transducer/step'] = function (result, input) {\n            if (this.f(input)) {\n                this.found = true;\n                result = _reduced(this.xf['@@transducer/step'](result, input));\n            }\n            return result;\n        };\n        return _curry2(function _xfind(f, xf) {\n            return new XFind(f, xf);\n        });\n    }();\n\n    var _xfindIndex = function () {\n        function XFindIndex(f, xf) {\n            this.xf = xf;\n            this.f = f;\n            this.idx = -1;\n            this.found = false;\n        }\n        XFindIndex.prototype['@@transducer/init'] = _xfBase.init;\n        XFindIndex.prototype['@@transducer/result'] = function (result) {\n            if (!this.found) {\n                result = this.xf['@@transducer/step'](result, -1);\n            }\n            return this.xf['@@transducer/result'](result);\n        };\n        XFindIndex.prototype['@@transducer/step'] = function (result, input) {\n            this.idx += 1;\n            if (this.f(input)) {\n                this.found = true;\n                result = _reduced(this.xf['@@transducer/step'](result, this.idx));\n            }\n            return result;\n        };\n        return _curry2(function _xfindIndex(f, xf) {\n            return new XFindIndex(f, xf);\n        });\n    }();\n\n    var _xfindLast = function () {\n        function XFindLast(f, xf) {\n            this.xf = xf;\n            this.f = f;\n        }\n        XFindLast.prototype['@@transducer/init'] = _xfBase.init;\n        XFindLast.prototype['@@transducer/result'] = function (result) {\n            return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.last));\n        };\n        XFindLast.prototype['@@transducer/step'] = function (result, input) {\n            if (this.f(input)) {\n                this.last = input;\n            }\n            return result;\n        };\n        return _curry2(function _xfindLast(f, xf) {\n            return new XFindLast(f, xf);\n        });\n    }();\n\n    var _xfindLastIndex = function () {\n        function XFindLastIndex(f, xf) {\n            this.xf = xf;\n            this.f = f;\n            this.idx = -1;\n            this.lastIdx = -1;\n        }\n        XFindLastIndex.prototype['@@transducer/init'] = _xfBase.init;\n        XFindLastIndex.prototype['@@transducer/result'] = function (result) {\n            return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.lastIdx));\n        };\n        XFindLastIndex.prototype['@@transducer/step'] = function (result, input) {\n            this.idx += 1;\n            if (this.f(input)) {\n                this.lastIdx = this.idx;\n            }\n            return result;\n        };\n        return _curry2(function _xfindLastIndex(f, xf) {\n            return new XFindLastIndex(f, xf);\n        });\n    }();\n\n    var _xmap = function () {\n        function XMap(f, xf) {\n            this.xf = xf;\n            this.f = f;\n        }\n        XMap.prototype['@@transducer/init'] = _xfBase.init;\n        XMap.prototype['@@transducer/result'] = _xfBase.result;\n        XMap.prototype['@@transducer/step'] = function (result, input) {\n            return this.xf['@@transducer/step'](result, this.f(input));\n        };\n        return _curry2(function _xmap(f, xf) {\n            return new XMap(f, xf);\n        });\n    }();\n\n    var _xtake = function () {\n        function XTake(n, xf) {\n            this.xf = xf;\n            this.n = n;\n        }\n        XTake.prototype['@@transducer/init'] = _xfBase.init;\n        XTake.prototype['@@transducer/result'] = _xfBase.result;\n        XTake.prototype['@@transducer/step'] = function (result, input) {\n            if (this.n === 0) {\n                return _reduced(result);\n            } else {\n                this.n -= 1;\n                return this.xf['@@transducer/step'](result, input);\n            }\n        };\n        return _curry2(function _xtake(n, xf) {\n            return new XTake(n, xf);\n        });\n    }();\n\n    var _xtakeWhile = function () {\n        function XTakeWhile(f, xf) {\n            this.xf = xf;\n            this.f = f;\n        }\n        XTakeWhile.prototype['@@transducer/init'] = _xfBase.init;\n        XTakeWhile.prototype['@@transducer/result'] = _xfBase.result;\n        XTakeWhile.prototype['@@transducer/step'] = function (result, input) {\n            return this.f(input) ? this.xf['@@transducer/step'](result, input) : _reduced(result);\n        };\n        return _curry2(function _xtakeWhile(f, xf) {\n            return new XTakeWhile(f, xf);\n        });\n    }();\n\n    /**\n     * Adds two values.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Math\n     * @sig Number -> Number -> Number\n     * @param {Number} a\n     * @param {Number} b\n     * @return {Number}\n     * @see R.subtract\n     * @example\n     *\n     *      R.add(2, 3);       //=>  5\n     *      R.add(7)(10);      //=> 17\n     */\n    var add = _curry2(function add(a, b) {\n        return Number(a) + Number(b);\n    });\n\n    /**\n     * Applies a function to the value at the given index of an array, returning a\n     * new copy of the array with the element at the given index replaced with the\n     * result of the function application.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.14.0\n     * @category List\n     * @sig (a -> a) -> Number -> [a] -> [a]\n     * @param {Function} fn The function to apply.\n     * @param {Number} idx The index.\n     * @param {Array|Arguments} list An array-like object whose value\n     *        at the supplied index will be replaced.\n     * @return {Array} A copy of the supplied array-like object with\n     *         the element at index `idx` replaced with the value\n     *         returned by applying `fn` to the existing element.\n     * @see R.update\n     * @example\n     *\n     *      R.adjust(R.add(10), 1, [0, 1, 2]);     //=> [0, 11, 2]\n     *      R.adjust(R.add(10))(1)([0, 1, 2]);     //=> [0, 11, 2]\n     */\n    var adjust = _curry3(function adjust(fn, idx, list) {\n        if (idx >= list.length || idx < -list.length) {\n            return list;\n        }\n        var start = idx < 0 ? list.length : 0;\n        var _idx = start + idx;\n        var _list = _concat(list);\n        _list[_idx] = fn(list[_idx]);\n        return _list;\n    });\n\n    /**\n     * Returns `true` if all elements of the list match the predicate, `false` if\n     * there are any that don't.\n     *\n     * Dispatches to the `all` method of the second argument, if present.\n     *\n     * Acts as a transducer if a transformer is given in list position.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig (a -> Boolean) -> [a] -> Boolean\n     * @param {Function} fn The predicate function.\n     * @param {Array} list The array to consider.\n     * @return {Boolean} `true` if the predicate is satisfied by every element, `false`\n     *         otherwise.\n     * @see R.any, R.none, R.transduce\n     * @example\n     *\n     *      var lessThan2 = R.flip(R.lt)(2);\n     *      var lessThan3 = R.flip(R.lt)(3);\n     *      R.all(lessThan2)([1, 2]); //=> false\n     *      R.all(lessThan3)([1, 2]); //=> true\n     */\n    var all = _curry2(_dispatchable('all', _xall, function all(fn, list) {\n        var idx = 0;\n        while (idx < list.length) {\n            if (!fn(list[idx])) {\n                return false;\n            }\n            idx += 1;\n        }\n        return true;\n    }));\n\n    /**\n     * Returns a function that always returns the given value. Note that for\n     * non-primitives the value returned is a reference to the original value.\n     *\n     * This function is known as `const`, `constant`, or `K` (for K combinator) in\n     * other languages and libraries.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Function\n     * @sig a -> (* -> a)\n     * @param {*} val The value to wrap in a function\n     * @return {Function} A Function :: * -> val.\n     * @example\n     *\n     *      var t = R.always('Tee');\n     *      t(); //=> 'Tee'\n     */\n    var always = _curry1(function always(val) {\n        return function () {\n            return val;\n        };\n    });\n\n    /**\n     * Returns `true` if both arguments are `true`; `false` otherwise.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Logic\n     * @sig * -> * -> *\n     * @param {Boolean} a A boolean value\n     * @param {Boolean} b A boolean value\n     * @return {Boolean} `true` if both arguments are `true`, `false` otherwise\n     * @see R.both\n     * @example\n     *\n     *      R.and(true, true); //=> true\n     *      R.and(true, false); //=> false\n     *      R.and(false, true); //=> false\n     *      R.and(false, false); //=> false\n     */\n    var and = _curry2(function and(a, b) {\n        return a && b;\n    });\n\n    /**\n     * Returns `true` if at least one of elements of the list match the predicate,\n     * `false` otherwise.\n     *\n     * Dispatches to the `any` method of the second argument, if present.\n     *\n     * Acts as a transducer if a transformer is given in list position.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig (a -> Boolean) -> [a] -> Boolean\n     * @param {Function} fn The predicate function.\n     * @param {Array} list The array to consider.\n     * @return {Boolean} `true` if the predicate is satisfied by at least one element, `false`\n     *         otherwise.\n     * @see R.all, R.none, R.transduce\n     * @example\n     *\n     *      var lessThan0 = R.flip(R.lt)(0);\n     *      var lessThan2 = R.flip(R.lt)(2);\n     *      R.any(lessThan0)([1, 2]); //=> false\n     *      R.any(lessThan2)([1, 2]); //=> true\n     */\n    var any = _curry2(_dispatchable('any', _xany, function any(fn, list) {\n        var idx = 0;\n        while (idx < list.length) {\n            if (fn(list[idx])) {\n                return true;\n            }\n            idx += 1;\n        }\n        return false;\n    }));\n\n    /**\n     * Returns a new list, composed of n-tuples of consecutive elements If `n` is\n     * greater than the length of the list, an empty list is returned.\n     *\n     * Dispatches to the `aperture` method of the second argument, if present.\n     *\n     * Acts as a transducer if a transformer is given in list position.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.12.0\n     * @category List\n     * @sig Number -> [a] -> [[a]]\n     * @param {Number} n The size of the tuples to create\n     * @param {Array} list The list to split into `n`-tuples\n     * @return {Array} The new list.\n     * @see R.transduce\n     * @example\n     *\n     *      R.aperture(2, [1, 2, 3, 4, 5]); //=> [[1, 2], [2, 3], [3, 4], [4, 5]]\n     *      R.aperture(3, [1, 2, 3, 4, 5]); //=> [[1, 2, 3], [2, 3, 4], [3, 4, 5]]\n     *      R.aperture(7, [1, 2, 3, 4, 5]); //=> []\n     */\n    var aperture = _curry2(_dispatchable('aperture', _xaperture, _aperture));\n\n    /**\n     * Returns a new list containing the contents of the given list, followed by\n     * the given element.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig a -> [a] -> [a]\n     * @param {*} el The element to add to the end of the new list.\n     * @param {Array} list The list whose contents will be added to the beginning of the output\n     *        list.\n     * @return {Array} A new list containing the contents of the old list followed by `el`.\n     * @see R.prepend\n     * @example\n     *\n     *      R.append('tests', ['write', 'more']); //=> ['write', 'more', 'tests']\n     *      R.append('tests', []); //=> ['tests']\n     *      R.append(['tests'], ['write', 'more']); //=> ['write', 'more', ['tests']]\n     */\n    var append = _curry2(function append(el, list) {\n        return _concat(list, [el]);\n    });\n\n    /**\n     * Applies function `fn` to the argument list `args`. This is useful for\n     * creating a fixed-arity function from a variadic function. `fn` should be a\n     * bound function if context is significant.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.7.0\n     * @category Function\n     * @sig (*... -> a) -> [*] -> a\n     * @param {Function} fn\n     * @param {Array} args\n     * @return {*}\n     * @see R.call, R.unapply\n     * @example\n     *\n     *      var nums = [1, 2, 3, -99, 42, 6, 7];\n     *      R.apply(Math.max, nums); //=> 42\n     */\n    var apply = _curry2(function apply(fn, args) {\n        return fn.apply(this, args);\n    });\n\n    /**\n     * Makes a shallow clone of an object, setting or overriding the specified\n     * property with the given value. Note that this copies and flattens prototype\n     * properties onto the new object as well. All non-primitive properties are\n     * copied by reference.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.8.0\n     * @category Object\n     * @sig String -> a -> {k: v} -> {k: v}\n     * @param {String} prop the property name to set\n     * @param {*} val the new value\n     * @param {Object} obj the object to clone\n     * @return {Object} a new object similar to the original except for the specified property.\n     * @see R.dissoc\n     * @example\n     *\n     *      R.assoc('c', 3, {a: 1, b: 2}); //=> {a: 1, b: 2, c: 3}\n     */\n    var assoc = _curry3(function assoc(prop, val, obj) {\n        var result = {};\n        for (var p in obj) {\n            result[p] = obj[p];\n        }\n        result[prop] = val;\n        return result;\n    });\n\n    /**\n     * Makes a shallow clone of an object, setting or overriding the nodes required\n     * to create the given path, and placing the specific value at the tail end of\n     * that path. Note that this copies and flattens prototype properties onto the\n     * new object as well. All non-primitive properties are copied by reference.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.8.0\n     * @category Object\n     * @sig [String] -> a -> {k: v} -> {k: v}\n     * @param {Array} path the path to set\n     * @param {*} val the new value\n     * @param {Object} obj the object to clone\n     * @return {Object} a new object similar to the original except along the specified path.\n     * @see R.dissocPath\n     * @example\n     *\n     *      R.assocPath(['a', 'b', 'c'], 42, {a: {b: {c: 0}}}); //=> {a: {b: {c: 42}}}\n     */\n    var assocPath = _curry3(function assocPath(path, val, obj) {\n        switch (path.length) {\n        case 0:\n            return val;\n        case 1:\n            return assoc(path[0], val, obj);\n        default:\n            return assoc(path[0], assocPath(_slice(path, 1), val, Object(obj[path[0]])), obj);\n        }\n    });\n\n    /**\n     * Creates a function that is bound to a context.\n     * Note: `R.bind` does not provide the additional argument-binding capabilities of\n     * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).\n     *\n     * @func\n     * @memberOf R\n     * @since v0.6.0\n     * @category Function\n     * @category Object\n     * @sig (* -> *) -> {*} -> (* -> *)\n     * @param {Function} fn The function to bind to context\n     * @param {Object} thisObj The context to bind `fn` to\n     * @return {Function} A function that will execute in the context of `thisObj`.\n     * @see R.partial\n     */\n    var bind = _curry2(function bind(fn, thisObj) {\n        return _arity(fn.length, function () {\n            return fn.apply(thisObj, arguments);\n        });\n    });\n\n    /**\n     * Restricts a number to be within a range.\n     *\n     * Also works for other ordered types such as Strings and Dates.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.20.0\n     * @category Relation\n     * @sig Ord a => a -> a -> a -> a\n     * @param {Number} minimum number\n     * @param {Number} maximum number\n     * @param {Number} value to be clamped\n     * @return {Number} Returns the clamped value\n     * @example\n     *\n     *      R.clamp(1, 10, -1) // => 1\n     *      R.clamp(1, 10, 11) // => 10\n     *      R.clamp(1, 10, 4)  // => 4\n     */\n    var clamp = _curry3(function clamp(min, max, value) {\n        if (min > max) {\n            throw new Error('min must not be greater than max in clamp(min, max, value)');\n        }\n        return value < min ? min : value > max ? max : value;\n    });\n\n    /**\n     * Makes a comparator function out of a function that reports whether the first\n     * element is less than the second.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Function\n     * @sig (a, b -> Boolean) -> (a, b -> Number)\n     * @param {Function} pred A predicate function of arity two.\n     * @return {Function} A Function :: a -> b -> Int that returns `-1` if a < b, `1` if b < a, otherwise `0`.\n     * @example\n     *\n     *      var cmp = R.comparator((a, b) => a.age < b.age);\n     *      var people = [\n     *        // ...\n     *      ];\n     *      R.sort(cmp, people);\n     */\n    var comparator = _curry1(function comparator(pred) {\n        return function (a, b) {\n            return pred(a, b) ? -1 : pred(b, a) ? 1 : 0;\n        };\n    });\n\n    /**\n     * Returns a curried equivalent of the provided function, with the specified\n     * arity. The curried function has two unusual capabilities. First, its\n     * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the\n     * following are equivalent:\n     *\n     *   - `g(1)(2)(3)`\n     *   - `g(1)(2, 3)`\n     *   - `g(1, 2)(3)`\n     *   - `g(1, 2, 3)`\n     *\n     * Secondly, the special placeholder value `R.__` may be used to specify\n     * \"gaps\", allowing partial application of any combination of arguments,\n     * regardless of their positions. If `g` is as above and `_` is `R.__`, the\n     * following are equivalent:\n     *\n     *   - `g(1, 2, 3)`\n     *   - `g(_, 2, 3)(1)`\n     *   - `g(_, _, 3)(1)(2)`\n     *   - `g(_, _, 3)(1, 2)`\n     *   - `g(_, 2)(1)(3)`\n     *   - `g(_, 2)(1, 3)`\n     *   - `g(_, 2)(_, 3)(1)`\n     *\n     * @func\n     * @memberOf R\n     * @since v0.5.0\n     * @category Function\n     * @sig Number -> (* -> a) -> (* -> a)\n     * @param {Number} length The arity for the returned function.\n     * @param {Function} fn The function to curry.\n     * @return {Function} A new, curried function.\n     * @see R.curry\n     * @example\n     *\n     *      var sumArgs = (...args) => R.sum(args);\n     *\n     *      var curriedAddFourNumbers = R.curryN(4, sumArgs);\n     *      var f = curriedAddFourNumbers(1, 2);\n     *      var g = f(3);\n     *      g(4); //=> 10\n     */\n    var curryN = _curry2(function curryN(length, fn) {\n        if (length === 1) {\n            return _curry1(fn);\n        }\n        return _arity(length, _curryN(length, [], fn));\n    });\n\n    /**\n     * Decrements its argument.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.9.0\n     * @category Math\n     * @sig Number -> Number\n     * @param {Number} n\n     * @return {Number}\n     * @see R.inc\n     * @example\n     *\n     *      R.dec(42); //=> 41\n     */\n    var dec = add(-1);\n\n    /**\n     * Returns the second argument if it is not `null`, `undefined` or `NaN`\n     * otherwise the first argument is returned.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.10.0\n     * @category Logic\n     * @sig a -> b -> a | b\n     * @param {a} val The default value.\n     * @param {b} val The value to return if it is not null or undefined\n     * @return {*} The the second value or the default value\n     * @example\n     *\n     *      var defaultTo42 = R.defaultTo(42);\n     *\n     *      defaultTo42(null);  //=> 42\n     *      defaultTo42(undefined);  //=> 42\n     *      defaultTo42('Ramda');  //=> 'Ramda'\n     *      defaultTo42(parseInt('string')); //=> 42\n     */\n    var defaultTo = _curry2(function defaultTo(d, v) {\n        return v == null || v !== v ? d : v;\n    });\n\n    /**\n     * Finds the set (i.e. no duplicates) of all elements in the first list not\n     * contained in the second list. Duplication is determined according to the\n     * value returned by applying the supplied predicate to two list elements.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Relation\n     * @sig (a -> a -> Boolean) -> [*] -> [*] -> [*]\n     * @param {Function} pred A predicate used to test whether two items are equal.\n     * @param {Array} list1 The first list.\n     * @param {Array} list2 The second list.\n     * @return {Array} The elements in `list1` that are not in `list2`.\n     * @see R.difference\n     * @example\n     *\n     *      var cmp = (x, y) => x.a === y.a;\n     *      var l1 = [{a: 1}, {a: 2}, {a: 3}];\n     *      var l2 = [{a: 3}, {a: 4}];\n     *      R.differenceWith(cmp, l1, l2); //=> [{a: 1}, {a: 2}]\n     */\n    var differenceWith = _curry3(function differenceWith(pred, first, second) {\n        var out = [];\n        var idx = 0;\n        var firstLen = first.length;\n        while (idx < firstLen) {\n            if (!_containsWith(pred, first[idx], second) && !_containsWith(pred, first[idx], out)) {\n                out.push(first[idx]);\n            }\n            idx += 1;\n        }\n        return out;\n    });\n\n    /**\n     * Returns a new object that does not contain a `prop` property.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.10.0\n     * @category Object\n     * @sig String -> {k: v} -> {k: v}\n     * @param {String} prop the name of the property to dissociate\n     * @param {Object} obj the object to clone\n     * @return {Object} a new object similar to the original but without the specified property\n     * @see R.assoc\n     * @example\n     *\n     *      R.dissoc('b', {a: 1, b: 2, c: 3}); //=> {a: 1, c: 3}\n     */\n    var dissoc = _curry2(function dissoc(prop, obj) {\n        var result = {};\n        for (var p in obj) {\n            if (p !== prop) {\n                result[p] = obj[p];\n            }\n        }\n        return result;\n    });\n\n    /**\n     * Makes a shallow clone of an object, omitting the property at the given path.\n     * Note that this copies and flattens prototype properties onto the new object\n     * as well. All non-primitive properties are copied by reference.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.11.0\n     * @category Object\n     * @sig [String] -> {k: v} -> {k: v}\n     * @param {Array} path the path to set\n     * @param {Object} obj the object to clone\n     * @return {Object} a new object without the property at path\n     * @see R.assocPath\n     * @example\n     *\n     *      R.dissocPath(['a', 'b', 'c'], {a: {b: {c: 42}}}); //=> {a: {b: {}}}\n     */\n    var dissocPath = _curry2(function dissocPath(path, obj) {\n        switch (path.length) {\n        case 0:\n            return obj;\n        case 1:\n            return dissoc(path[0], obj);\n        default:\n            var head = path[0];\n            var tail = _slice(path, 1);\n            return obj[head] == null ? obj : assoc(head, dissocPath(tail, obj[head]), obj);\n        }\n    });\n\n    /**\n     * Divides two numbers. Equivalent to `a / b`.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Math\n     * @sig Number -> Number -> Number\n     * @param {Number} a The first value.\n     * @param {Number} b The second value.\n     * @return {Number} The result of `a / b`.\n     * @see R.multiply\n     * @example\n     *\n     *      R.divide(71, 100); //=> 0.71\n     *\n     *      var half = R.divide(R.__, 2);\n     *      half(42); //=> 21\n     *\n     *      var reciprocal = R.divide(1);\n     *      reciprocal(4);   //=> 0.25\n     */\n    var divide = _curry2(function divide(a, b) {\n        return a / b;\n    });\n\n    /**\n     * Returns a new list containing the last `n` elements of a given list, passing\n     * each value to the supplied predicate function, skipping elements while the\n     * predicate function returns `true`. The predicate function is passed one\n     * argument: *(value)*.\n     *\n     * Dispatches to the `dropWhile` method of the second argument, if present.\n     *\n     * Acts as a transducer if a transformer is given in list position.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.9.0\n     * @category List\n     * @sig (a -> Boolean) -> [a] -> [a]\n     * @param {Function} fn The function called per iteration.\n     * @param {Array} list The collection to iterate over.\n     * @return {Array} A new array.\n     * @see R.takeWhile, R.transduce, R.addIndex\n     * @example\n     *\n     *      var lteTwo = x => x <= 2;\n     *\n     *      R.dropWhile(lteTwo, [1, 2, 3, 4, 3, 2, 1]); //=> [3, 4, 3, 2, 1]\n     */\n    var dropWhile = _curry2(_dispatchable('dropWhile', _xdropWhile, function dropWhile(pred, list) {\n        var idx = 0;\n        var len = list.length;\n        while (idx < len && pred(list[idx])) {\n            idx += 1;\n        }\n        return _slice(list, idx);\n    }));\n\n    /**\n     * Returns the empty value of its argument's type. Ramda defines the empty\n     * value of Array (`[]`), Object (`{}`), String (`''`), and Arguments. Other\n     * types are supported if they define `<Type>.empty` and/or\n     * `<Type>.prototype.empty`.\n     *\n     * Dispatches to the `empty` method of the first argument, if present.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.3.0\n     * @category Function\n     * @sig a -> a\n     * @param {*} x\n     * @return {*}\n     * @example\n     *\n     *      R.empty(Just(42));      //=> Nothing()\n     *      R.empty([1, 2, 3]);     //=> []\n     *      R.empty('unicorns');    //=> ''\n     *      R.empty({x: 1, y: 2});  //=> {}\n     */\n    // else\n    var empty = _curry1(function empty(x) {\n        return x != null && typeof x.empty === 'function' ? x.empty() : x != null && x.constructor != null && typeof x.constructor.empty === 'function' ? x.constructor.empty() : _isArray(x) ? [] : _isString(x) ? '' : _isObject(x) ? {} : _isArguments(x) ? function () {\n            return arguments;\n        }() : // else\n        void 0;\n    });\n\n    /**\n     * Creates a new object by recursively evolving a shallow copy of `object`,\n     * according to the `transformation` functions. All non-primitive properties\n     * are copied by reference.\n     *\n     * A `transformation` function will not be invoked if its corresponding key\n     * does not exist in the evolved object.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.9.0\n     * @category Object\n     * @sig {k: (v -> v)} -> {k: v} -> {k: v}\n     * @param {Object} transformations The object specifying transformation functions to apply\n     *        to the object.\n     * @param {Object} object The object to be transformed.\n     * @return {Object} The transformed object.\n     * @example\n     *\n     *      var tomato  = {firstName: '  Tomato ', data: {elapsed: 100, remaining: 1400}, id:123};\n     *      var transformations = {\n     *        firstName: R.trim,\n     *        lastName: R.trim, // Will not get invoked.\n     *        data: {elapsed: R.add(1), remaining: R.add(-1)}\n     *      };\n     *      R.evolve(transformations, tomato); //=> {firstName: 'Tomato', data: {elapsed: 101, remaining: 1399}, id:123}\n     */\n    var evolve = _curry2(function evolve(transformations, object) {\n        var result = {};\n        var transformation, key, type;\n        for (key in object) {\n            transformation = transformations[key];\n            type = typeof transformation;\n            result[key] = type === 'function' ? transformation(object[key]) : type === 'object' ? evolve(transformations[key], object[key]) : object[key];\n        }\n        return result;\n    });\n\n    /**\n     * Returns the first element of the list which matches the predicate, or\n     * `undefined` if no element matches.\n     *\n     * Dispatches to the `find` method of the second argument, if present.\n     *\n     * Acts as a transducer if a transformer is given in list position.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig (a -> Boolean) -> [a] -> a | undefined\n     * @param {Function} fn The predicate function used to determine if the element is the\n     *        desired one.\n     * @param {Array} list The array to consider.\n     * @return {Object} The element found, or `undefined`.\n     * @see R.transduce\n     * @example\n     *\n     *      var xs = [{a: 1}, {a: 2}, {a: 3}];\n     *      R.find(R.propEq('a', 2))(xs); //=> {a: 2}\n     *      R.find(R.propEq('a', 4))(xs); //=> undefined\n     */\n    var find = _curry2(_dispatchable('find', _xfind, function find(fn, list) {\n        var idx = 0;\n        var len = list.length;\n        while (idx < len) {\n            if (fn(list[idx])) {\n                return list[idx];\n            }\n            idx += 1;\n        }\n    }));\n\n    /**\n     * Returns the index of the first element of the list which matches the\n     * predicate, or `-1` if no element matches.\n     *\n     * Dispatches to the `findIndex` method of the second argument, if present.\n     *\n     * Acts as a transducer if a transformer is given in list position.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.1\n     * @category List\n     * @sig (a -> Boolean) -> [a] -> Number\n     * @param {Function} fn The predicate function used to determine if the element is the\n     * desired one.\n     * @param {Array} list The array to consider.\n     * @return {Number} The index of the element found, or `-1`.\n     * @see R.transduce\n     * @example\n     *\n     *      var xs = [{a: 1}, {a: 2}, {a: 3}];\n     *      R.findIndex(R.propEq('a', 2))(xs); //=> 1\n     *      R.findIndex(R.propEq('a', 4))(xs); //=> -1\n     */\n    var findIndex = _curry2(_dispatchable('findIndex', _xfindIndex, function findIndex(fn, list) {\n        var idx = 0;\n        var len = list.length;\n        while (idx < len) {\n            if (fn(list[idx])) {\n                return idx;\n            }\n            idx += 1;\n        }\n        return -1;\n    }));\n\n    /**\n     * Returns the last element of the list which matches the predicate, or\n     * `undefined` if no element matches.\n     *\n     * Dispatches to the `findLast` method of the second argument, if present.\n     *\n     * Acts as a transducer if a transformer is given in list position.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.1\n     * @category List\n     * @sig (a -> Boolean) -> [a] -> a | undefined\n     * @param {Function} fn The predicate function used to determine if the element is the\n     * desired one.\n     * @param {Array} list The array to consider.\n     * @return {Object} The element found, or `undefined`.\n     * @see R.transduce\n     * @example\n     *\n     *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];\n     *      R.findLast(R.propEq('a', 1))(xs); //=> {a: 1, b: 1}\n     *      R.findLast(R.propEq('a', 4))(xs); //=> undefined\n     */\n    var findLast = _curry2(_dispatchable('findLast', _xfindLast, function findLast(fn, list) {\n        var idx = list.length - 1;\n        while (idx >= 0) {\n            if (fn(list[idx])) {\n                return list[idx];\n            }\n            idx -= 1;\n        }\n    }));\n\n    /**\n     * Returns the index of the last element of the list which matches the\n     * predicate, or `-1` if no element matches.\n     *\n     * Dispatches to the `findLastIndex` method of the second argument, if present.\n     *\n     * Acts as a transducer if a transformer is given in list position.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.1\n     * @category List\n     * @sig (a -> Boolean) -> [a] -> Number\n     * @param {Function} fn The predicate function used to determine if the element is the\n     * desired one.\n     * @param {Array} list The array to consider.\n     * @return {Number} The index of the element found, or `-1`.\n     * @see R.transduce\n     * @example\n     *\n     *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];\n     *      R.findLastIndex(R.propEq('a', 1))(xs); //=> 1\n     *      R.findLastIndex(R.propEq('a', 4))(xs); //=> -1\n     */\n    var findLastIndex = _curry2(_dispatchable('findLastIndex', _xfindLastIndex, function findLastIndex(fn, list) {\n        var idx = list.length - 1;\n        while (idx >= 0) {\n            if (fn(list[idx])) {\n                return idx;\n            }\n            idx -= 1;\n        }\n        return -1;\n    }));\n\n    /**\n     * Iterate over an input `list`, calling a provided function `fn` for each\n     * element in the list.\n     *\n     * `fn` receives one argument: *(value)*.\n     *\n     * Note: `R.forEach` does not skip deleted or unassigned indices (sparse\n     * arrays), unlike the native `Array.prototype.forEach` method. For more\n     * details on this behavior, see:\n     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Description\n     *\n     * Also note that, unlike `Array.prototype.forEach`, Ramda's `forEach` returns\n     * the original array. In some libraries this function is named `each`.\n     *\n     * Dispatches to the `forEach` method of the second argument, if present.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.1\n     * @category List\n     * @sig (a -> *) -> [a] -> [a]\n     * @param {Function} fn The function to invoke. Receives one argument, `value`.\n     * @param {Array} list The list to iterate over.\n     * @return {Array} The original list.\n     * @see R.addIndex\n     * @example\n     *\n     *      var printXPlusFive = x => console.log(x + 5);\n     *      R.forEach(printXPlusFive, [1, 2, 3]); //=> [1, 2, 3]\n     *      //-> 6\n     *      //-> 7\n     *      //-> 8\n     */\n    var forEach = _curry2(_checkForMethod('forEach', function forEach(fn, list) {\n        var len = list.length;\n        var idx = 0;\n        while (idx < len) {\n            fn(list[idx]);\n            idx += 1;\n        }\n        return list;\n    }));\n\n    /**\n     * Creates a new object out of a list key-value pairs.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.3.0\n     * @category List\n     * @sig [[k,v]] -> {k: v}\n     * @param {Array} pairs An array of two-element arrays that will be the keys and values of the output object.\n     * @return {Object} The object made by pairing up `keys` and `values`.\n     * @see R.toPairs, R.pair\n     * @example\n     *\n     *      R.fromPairs([['a', 1], ['b', 2],  ['c', 3]]); //=> {a: 1, b: 2, c: 3}\n     */\n    var fromPairs = _curry1(function fromPairs(pairs) {\n        var idx = 0;\n        var len = pairs.length;\n        var out = {};\n        while (idx < len) {\n            if (_isArray(pairs[idx]) && pairs[idx].length) {\n                out[pairs[idx][0]] = pairs[idx][1];\n            }\n            idx += 1;\n        }\n        return out;\n    });\n\n    /**\n     * Takes a list and returns a list of lists where each sublist's elements are\n     * all \"equal\" according to the provided equality function.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.21.0\n     * @category List\n     * @sig (a, a -> Boolean) -> [a] -> [[a]]\n     * @param {Function} fn Function for determining whether two given (adjacent)\n     *        elements should be in the same group\n     * @param {Array} list The array to group. Also accepts a string, which will be\n     *        treated as a list of characters.\n     * @return {List} A list that contains sublists of equal elements,\n     *         whose concatenations is equal to the original list.\n     * @example\n     *\n     *    groupWith(R.equals, [0, 1, 1, 2, 3, 5, 8, 13, 21])\n     *    // [[0], [1, 1], [2, 3, 5, 8, 13, 21]]\n     *\n     *    groupWith((a, b) => a % 2 === b % 2, [0, 1, 1, 2, 3, 5, 8, 13, 21])\n     *    // [[0], [1, 1], [2], [3, 5], [8], [13, 21]]\n     *\n     *    R.groupWith(R.eqBy(isVowel), 'aestiou')\n     *    // ['ae', 'st', 'iou']\n     */\n    var groupWith = _curry2(function (fn, list) {\n        var res = [];\n        var idx = 0;\n        var len = list.length;\n        while (idx < len) {\n            var nextidx = idx + 1;\n            while (nextidx < len && fn(list[idx], list[nextidx])) {\n                nextidx += 1;\n            }\n            res.push(list.slice(idx, nextidx));\n            idx = nextidx;\n        }\n        return res;\n    });\n\n    /**\n     * Returns `true` if the first argument is greater than the second; `false`\n     * otherwise.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Relation\n     * @sig Ord a => a -> a -> Boolean\n     * @param {*} a\n     * @param {*} b\n     * @return {Boolean}\n     * @see R.lt\n     * @example\n     *\n     *      R.gt(2, 1); //=> true\n     *      R.gt(2, 2); //=> false\n     *      R.gt(2, 3); //=> false\n     *      R.gt('a', 'z'); //=> false\n     *      R.gt('z', 'a'); //=> true\n     */\n    var gt = _curry2(function gt(a, b) {\n        return a > b;\n    });\n\n    /**\n     * Returns `true` if the first argument is greater than or equal to the second;\n     * `false` otherwise.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Relation\n     * @sig Ord a => a -> a -> Boolean\n     * @param {Number} a\n     * @param {Number} b\n     * @return {Boolean}\n     * @see R.lte\n     * @example\n     *\n     *      R.gte(2, 1); //=> true\n     *      R.gte(2, 2); //=> true\n     *      R.gte(2, 3); //=> false\n     *      R.gte('a', 'z'); //=> false\n     *      R.gte('z', 'a'); //=> true\n     */\n    var gte = _curry2(function gte(a, b) {\n        return a >= b;\n    });\n\n    /**\n     * Returns whether or not an object has an own property with the specified name\n     *\n     * @func\n     * @memberOf R\n     * @since v0.7.0\n     * @category Object\n     * @sig s -> {s: x} -> Boolean\n     * @param {String} prop The name of the property to check for.\n     * @param {Object} obj The object to query.\n     * @return {Boolean} Whether the property exists.\n     * @example\n     *\n     *      var hasName = R.has('name');\n     *      hasName({name: 'alice'});   //=> true\n     *      hasName({name: 'bob'});     //=> true\n     *      hasName({});                //=> false\n     *\n     *      var point = {x: 0, y: 0};\n     *      var pointHas = R.has(R.__, point);\n     *      pointHas('x');  //=> true\n     *      pointHas('y');  //=> true\n     *      pointHas('z');  //=> false\n     */\n    var has = _curry2(_has);\n\n    /**\n     * Returns whether or not an object or its prototype chain has a property with\n     * the specified name\n     *\n     * @func\n     * @memberOf R\n     * @since v0.7.0\n     * @category Object\n     * @sig s -> {s: x} -> Boolean\n     * @param {String} prop The name of the property to check for.\n     * @param {Object} obj The object to query.\n     * @return {Boolean} Whether the property exists.\n     * @example\n     *\n     *      function Rectangle(width, height) {\n     *        this.width = width;\n     *        this.height = height;\n     *      }\n     *      Rectangle.prototype.area = function() {\n     *        return this.width * this.height;\n     *      };\n     *\n     *      var square = new Rectangle(2, 2);\n     *      R.hasIn('width', square);  //=> true\n     *      R.hasIn('area', square);  //=> true\n     */\n    var hasIn = _curry2(function hasIn(prop, obj) {\n        return prop in obj;\n    });\n\n    /**\n     * Returns true if its arguments are identical, false otherwise. Values are\n     * identical if they reference the same memory. `NaN` is identical to `NaN`;\n     * `0` and `-0` are not identical.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.15.0\n     * @category Relation\n     * @sig a -> a -> Boolean\n     * @param {*} a\n     * @param {*} b\n     * @return {Boolean}\n     * @example\n     *\n     *      var o = {};\n     *      R.identical(o, o); //=> true\n     *      R.identical(1, 1); //=> true\n     *      R.identical(1, '1'); //=> false\n     *      R.identical([], []); //=> false\n     *      R.identical(0, -0); //=> false\n     *      R.identical(NaN, NaN); //=> true\n     */\n    // SameValue algorithm\n    // Steps 1-5, 7-10\n    // Steps 6.b-6.e: +0 != -0\n    // Step 6.a: NaN == NaN\n    var identical = _curry2(function identical(a, b) {\n        // SameValue algorithm\n        if (a === b) {\n            // Steps 1-5, 7-10\n            // Steps 6.b-6.e: +0 != -0\n            return a !== 0 || 1 / a === 1 / b;\n        } else {\n            // Step 6.a: NaN == NaN\n            return a !== a && b !== b;\n        }\n    });\n\n    /**\n     * A function that does nothing but return the parameter supplied to it. Good\n     * as a default or placeholder function.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Function\n     * @sig a -> a\n     * @param {*} x The value to return.\n     * @return {*} The input value, `x`.\n     * @example\n     *\n     *      R.identity(1); //=> 1\n     *\n     *      var obj = {};\n     *      R.identity(obj) === obj; //=> true\n     */\n    var identity = _curry1(_identity);\n\n    /**\n     * Creates a function that will process either the `onTrue` or the `onFalse`\n     * function depending upon the result of the `condition` predicate.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.8.0\n     * @category Logic\n     * @sig (*... -> Boolean) -> (*... -> *) -> (*... -> *) -> (*... -> *)\n     * @param {Function} condition A predicate function\n     * @param {Function} onTrue A function to invoke when the `condition` evaluates to a truthy value.\n     * @param {Function} onFalse A function to invoke when the `condition` evaluates to a falsy value.\n     * @return {Function} A new unary function that will process either the `onTrue` or the `onFalse`\n     *                    function depending upon the result of the `condition` predicate.\n     * @see R.unless, R.when\n     * @example\n     *\n     *      var incCount = R.ifElse(\n     *        R.has('count'),\n     *        R.over(R.lensProp('count'), R.inc),\n     *        R.assoc('count', 1)\n     *      );\n     *      incCount({});           //=> { count: 1 }\n     *      incCount({ count: 1 }); //=> { count: 2 }\n     */\n    var ifElse = _curry3(function ifElse(condition, onTrue, onFalse) {\n        return curryN(Math.max(condition.length, onTrue.length, onFalse.length), function _ifElse() {\n            return condition.apply(this, arguments) ? onTrue.apply(this, arguments) : onFalse.apply(this, arguments);\n        });\n    });\n\n    /**\n     * Increments its argument.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.9.0\n     * @category Math\n     * @sig Number -> Number\n     * @param {Number} n\n     * @return {Number}\n     * @see R.dec\n     * @example\n     *\n     *      R.inc(42); //=> 43\n     */\n    var inc = add(1);\n\n    /**\n     * Inserts the supplied element into the list, at index `index`. _Note that\n     * this is not destructive_: it returns a copy of the list with the changes.\n     * <small>No lists have been harmed in the application of this function.</small>\n     *\n     * @func\n     * @memberOf R\n     * @since v0.2.2\n     * @category List\n     * @sig Number -> a -> [a] -> [a]\n     * @param {Number} index The position to insert the element\n     * @param {*} elt The element to insert into the Array\n     * @param {Array} list The list to insert into\n     * @return {Array} A new Array with `elt` inserted at `index`.\n     * @example\n     *\n     *      R.insert(2, 'x', [1,2,3,4]); //=> [1,2,'x',3,4]\n     */\n    var insert = _curry3(function insert(idx, elt, list) {\n        idx = idx < list.length && idx >= 0 ? idx : list.length;\n        var result = _slice(list);\n        result.splice(idx, 0, elt);\n        return result;\n    });\n\n    /**\n     * Inserts the sub-list into the list, at index `index`. _Note that this is not\n     * destructive_: it returns a copy of the list with the changes.\n     * <small>No lists have been harmed in the application of this function.</small>\n     *\n     * @func\n     * @memberOf R\n     * @since v0.9.0\n     * @category List\n     * @sig Number -> [a] -> [a] -> [a]\n     * @param {Number} index The position to insert the sub-list\n     * @param {Array} elts The sub-list to insert into the Array\n     * @param {Array} list The list to insert the sub-list into\n     * @return {Array} A new Array with `elts` inserted starting at `index`.\n     * @example\n     *\n     *      R.insertAll(2, ['x','y','z'], [1,2,3,4]); //=> [1,2,'x','y','z',3,4]\n     */\n    var insertAll = _curry3(function insertAll(idx, elts, list) {\n        idx = idx < list.length && idx >= 0 ? idx : list.length;\n        return _concat(_concat(_slice(list, 0, idx), elts), _slice(list, idx));\n    });\n\n    /**\n     * Creates a new list with the separator interposed between elements.\n     *\n     * Dispatches to the `intersperse` method of the second argument, if present.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.14.0\n     * @category List\n     * @sig a -> [a] -> [a]\n     * @param {*} separator The element to add to the list.\n     * @param {Array} list The list to be interposed.\n     * @return {Array} The new list.\n     * @example\n     *\n     *      R.intersperse('n', ['ba', 'a', 'a']); //=> ['ba', 'n', 'a', 'n', 'a']\n     */\n    var intersperse = _curry2(_checkForMethod('intersperse', function intersperse(separator, list) {\n        var out = [];\n        var idx = 0;\n        var length = list.length;\n        while (idx < length) {\n            if (idx === length - 1) {\n                out.push(list[idx]);\n            } else {\n                out.push(list[idx], separator);\n            }\n            idx += 1;\n        }\n        return out;\n    }));\n\n    /**\n     * See if an object (`val`) is an instance of the supplied constructor. This\n     * function will check up the inheritance chain, if any.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.3.0\n     * @category Type\n     * @sig (* -> {*}) -> a -> Boolean\n     * @param {Object} ctor A constructor\n     * @param {*} val The value to test\n     * @return {Boolean}\n     * @example\n     *\n     *      R.is(Object, {}); //=> true\n     *      R.is(Number, 1); //=> true\n     *      R.is(Object, 1); //=> false\n     *      R.is(String, 's'); //=> true\n     *      R.is(String, new String('')); //=> true\n     *      R.is(Object, new String('')); //=> true\n     *      R.is(Object, 's'); //=> false\n     *      R.is(Number, {}); //=> false\n     */\n    var is = _curry2(function is(Ctor, val) {\n        return val != null && val.constructor === Ctor || val instanceof Ctor;\n    });\n\n    /**\n     * Tests whether or not an object is similar to an array.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.5.0\n     * @category Type\n     * @category List\n     * @sig * -> Boolean\n     * @param {*} x The object to test.\n     * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.\n     * @example\n     *\n     *      R.isArrayLike([]); //=> true\n     *      R.isArrayLike(true); //=> false\n     *      R.isArrayLike({}); //=> false\n     *      R.isArrayLike({length: 10}); //=> false\n     *      R.isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true\n     */\n    var isArrayLike = _curry1(function isArrayLike(x) {\n        if (_isArray(x)) {\n            return true;\n        }\n        if (!x) {\n            return false;\n        }\n        if (typeof x !== 'object') {\n            return false;\n        }\n        if (x instanceof String) {\n            return false;\n        }\n        if (x.nodeType === 1) {\n            return !!x.length;\n        }\n        if (x.length === 0) {\n            return true;\n        }\n        if (x.length > 0) {\n            return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);\n        }\n        return false;\n    });\n\n    /**\n     * Checks if the input value is `null` or `undefined`.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.9.0\n     * @category Type\n     * @sig * -> Boolean\n     * @param {*} x The value to test.\n     * @return {Boolean} `true` if `x` is `undefined` or `null`, otherwise `false`.\n     * @example\n     *\n     *      R.isNil(null); //=> true\n     *      R.isNil(undefined); //=> true\n     *      R.isNil(0); //=> false\n     *      R.isNil([]); //=> false\n     */\n    var isNil = _curry1(function isNil(x) {\n        return x == null;\n    });\n\n    /**\n     * Returns a list containing the names of all the enumerable own properties of\n     * the supplied object.\n     * Note that the order of the output array is not guaranteed to be consistent\n     * across different JS platforms.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Object\n     * @sig {k: v} -> [k]\n     * @param {Object} obj The object to extract properties from\n     * @return {Array} An array of the object's own properties.\n     * @example\n     *\n     *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']\n     */\n    // cover IE < 9 keys issues\n    // Safari bug\n    var keys = function () {\n        // cover IE < 9 keys issues\n        var hasEnumBug = !{ toString: null }.propertyIsEnumerable('toString');\n        var nonEnumerableProps = [\n            'constructor',\n            'valueOf',\n            'isPrototypeOf',\n            'toString',\n            'propertyIsEnumerable',\n            'hasOwnProperty',\n            'toLocaleString'\n        ];\n        // Safari bug\n        var hasArgsEnumBug = function () {\n            'use strict';\n            return arguments.propertyIsEnumerable('length');\n        }();\n        var contains = function contains(list, item) {\n            var idx = 0;\n            while (idx < list.length) {\n                if (list[idx] === item) {\n                    return true;\n                }\n                idx += 1;\n            }\n            return false;\n        };\n        return typeof Object.keys === 'function' && !hasArgsEnumBug ? _curry1(function keys(obj) {\n            return Object(obj) !== obj ? [] : Object.keys(obj);\n        }) : _curry1(function keys(obj) {\n            if (Object(obj) !== obj) {\n                return [];\n            }\n            var prop, nIdx;\n            var ks = [];\n            var checkArgsLength = hasArgsEnumBug && _isArguments(obj);\n            for (prop in obj) {\n                if (_has(prop, obj) && (!checkArgsLength || prop !== 'length')) {\n                    ks[ks.length] = prop;\n                }\n            }\n            if (hasEnumBug) {\n                nIdx = nonEnumerableProps.length - 1;\n                while (nIdx >= 0) {\n                    prop = nonEnumerableProps[nIdx];\n                    if (_has(prop, obj) && !contains(ks, prop)) {\n                        ks[ks.length] = prop;\n                    }\n                    nIdx -= 1;\n                }\n            }\n            return ks;\n        });\n    }();\n\n    /**\n     * Returns a list containing the names of all the properties of the supplied\n     * object, including prototype properties.\n     * Note that the order of the output array is not guaranteed to be consistent\n     * across different JS platforms.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.2.0\n     * @category Object\n     * @sig {k: v} -> [k]\n     * @param {Object} obj The object to extract properties from\n     * @return {Array} An array of the object's own and prototype properties.\n     * @example\n     *\n     *      var F = function() { this.x = 'X'; };\n     *      F.prototype.y = 'Y';\n     *      var f = new F();\n     *      R.keysIn(f); //=> ['x', 'y']\n     */\n    var keysIn = _curry1(function keysIn(obj) {\n        var prop;\n        var ks = [];\n        for (prop in obj) {\n            ks[ks.length] = prop;\n        }\n        return ks;\n    });\n\n    /**\n     * Returns the number of elements in the array by returning `list.length`.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.3.0\n     * @category List\n     * @sig [a] -> Number\n     * @param {Array} list The array to inspect.\n     * @return {Number} The length of the array.\n     * @example\n     *\n     *      R.length([]); //=> 0\n     *      R.length([1, 2, 3]); //=> 3\n     */\n    var length = _curry1(function length(list) {\n        return list != null && is(Number, list.length) ? list.length : NaN;\n    });\n\n    /**\n     * Returns `true` if the first argument is less than the second; `false`\n     * otherwise.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Relation\n     * @sig Ord a => a -> a -> Boolean\n     * @param {*} a\n     * @param {*} b\n     * @return {Boolean}\n     * @see R.gt\n     * @example\n     *\n     *      R.lt(2, 1); //=> false\n     *      R.lt(2, 2); //=> false\n     *      R.lt(2, 3); //=> true\n     *      R.lt('a', 'z'); //=> true\n     *      R.lt('z', 'a'); //=> false\n     */\n    var lt = _curry2(function lt(a, b) {\n        return a < b;\n    });\n\n    /**\n     * Returns `true` if the first argument is less than or equal to the second;\n     * `false` otherwise.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Relation\n     * @sig Ord a => a -> a -> Boolean\n     * @param {Number} a\n     * @param {Number} b\n     * @return {Boolean}\n     * @see R.gte\n     * @example\n     *\n     *      R.lte(2, 1); //=> false\n     *      R.lte(2, 2); //=> true\n     *      R.lte(2, 3); //=> true\n     *      R.lte('a', 'z'); //=> true\n     *      R.lte('z', 'a'); //=> false\n     */\n    var lte = _curry2(function lte(a, b) {\n        return a <= b;\n    });\n\n    /**\n     * The mapAccum function behaves like a combination of map and reduce; it\n     * applies a function to each element of a list, passing an accumulating\n     * parameter from left to right, and returning a final value of this\n     * accumulator together with the new list.\n     *\n     * The iterator function receives two arguments, *acc* and *value*, and should\n     * return a tuple *[acc, value]*.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.10.0\n     * @category List\n     * @sig (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])\n     * @param {Function} fn The function to be called on every element of the input `list`.\n     * @param {*} acc The accumulator value.\n     * @param {Array} list The list to iterate over.\n     * @return {*} The final, accumulated value.\n     * @see R.addIndex\n     * @example\n     *\n     *      var digits = ['1', '2', '3', '4'];\n     *      var appender = (a, b) => [a + b, a + b];\n     *\n     *      R.mapAccum(appender, 0, digits); //=> ['01234', ['01', '012', '0123', '01234']]\n     */\n    var mapAccum = _curry3(function mapAccum(fn, acc, list) {\n        var idx = 0;\n        var len = list.length;\n        var result = [];\n        var tuple = [acc];\n        while (idx < len) {\n            tuple = fn(tuple[0], list[idx]);\n            result[idx] = tuple[1];\n            idx += 1;\n        }\n        return [\n            tuple[0],\n            result\n        ];\n    });\n\n    /**\n     * The mapAccumRight function behaves like a combination of map and reduce; it\n     * applies a function to each element of a list, passing an accumulating\n     * parameter from right to left, and returning a final value of this\n     * accumulator together with the new list.\n     *\n     * Similar to `mapAccum`, except moves through the input list from the right to\n     * the left.\n     *\n     * The iterator function receives two arguments, *acc* and *value*, and should\n     * return a tuple *[acc, value]*.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.10.0\n     * @category List\n     * @sig (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])\n     * @param {Function} fn The function to be called on every element of the input `list`.\n     * @param {*} acc The accumulator value.\n     * @param {Array} list The list to iterate over.\n     * @return {*} The final, accumulated value.\n     * @see R.addIndex\n     * @example\n     *\n     *      var digits = ['1', '2', '3', '4'];\n     *      var append = (a, b) => [a + b, a + b];\n     *\n     *      R.mapAccumRight(append, 0, digits); //=> ['04321', ['04321', '0432', '043', '04']]\n     */\n    var mapAccumRight = _curry3(function mapAccumRight(fn, acc, list) {\n        var idx = list.length - 1;\n        var result = [];\n        var tuple = [acc];\n        while (idx >= 0) {\n            tuple = fn(tuple[0], list[idx]);\n            result[idx] = tuple[1];\n            idx -= 1;\n        }\n        return [\n            tuple[0],\n            result\n        ];\n    });\n\n    /**\n     * Tests a regular expression against a String. Note that this function will\n     * return an empty array when there are no matches. This differs from\n     * [`String.prototype.match`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match)\n     * which returns `null` when there are no matches.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category String\n     * @sig RegExp -> String -> [String | Undefined]\n     * @param {RegExp} rx A regular expression.\n     * @param {String} str The string to match against\n     * @return {Array} The list of matches or empty array.\n     * @see R.test\n     * @example\n     *\n     *      R.match(/([a-z]a)/g, 'bananas'); //=> ['ba', 'na', 'na']\n     *      R.match(/a/, 'b'); //=> []\n     *      R.match(/a/, null); //=> TypeError: null does not have a method named \"match\"\n     */\n    var match = _curry2(function match(rx, str) {\n        return str.match(rx) || [];\n    });\n\n    /**\n     * mathMod behaves like the modulo operator should mathematically, unlike the\n     * `%` operator (and by extension, R.modulo). So while \"-17 % 5\" is -2,\n     * mathMod(-17, 5) is 3. mathMod requires Integer arguments, and returns NaN\n     * when the modulus is zero or negative.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.3.0\n     * @category Math\n     * @sig Number -> Number -> Number\n     * @param {Number} m The dividend.\n     * @param {Number} p the modulus.\n     * @return {Number} The result of `b mod a`.\n     * @example\n     *\n     *      R.mathMod(-17, 5);  //=> 3\n     *      R.mathMod(17, 5);   //=> 2\n     *      R.mathMod(17, -5);  //=> NaN\n     *      R.mathMod(17, 0);   //=> NaN\n     *      R.mathMod(17.2, 5); //=> NaN\n     *      R.mathMod(17, 5.3); //=> NaN\n     *\n     *      var clock = R.mathMod(R.__, 12);\n     *      clock(15); //=> 3\n     *      clock(24); //=> 0\n     *\n     *      var seventeenMod = R.mathMod(17);\n     *      seventeenMod(3);  //=> 2\n     *      seventeenMod(4);  //=> 1\n     *      seventeenMod(10); //=> 7\n     */\n    var mathMod = _curry2(function mathMod(m, p) {\n        if (!_isInteger(m)) {\n            return NaN;\n        }\n        if (!_isInteger(p) || p < 1) {\n            return NaN;\n        }\n        return (m % p + p) % p;\n    });\n\n    /**\n     * Returns the larger of its two arguments.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Relation\n     * @sig Ord a => a -> a -> a\n     * @param {*} a\n     * @param {*} b\n     * @return {*}\n     * @see R.maxBy, R.min\n     * @example\n     *\n     *      R.max(789, 123); //=> 789\n     *      R.max('a', 'b'); //=> 'b'\n     */\n    var max = _curry2(function max(a, b) {\n        return b > a ? b : a;\n    });\n\n    /**\n     * Takes a function and two values, and returns whichever value produces the\n     * larger result when passed to the provided function.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.8.0\n     * @category Relation\n     * @sig Ord b => (a -> b) -> a -> a -> a\n     * @param {Function} f\n     * @param {*} a\n     * @param {*} b\n     * @return {*}\n     * @see R.max, R.minBy\n     * @example\n     *\n     *      //  square :: Number -> Number\n     *      var square = n => n * n;\n     *\n     *      R.maxBy(square, -3, 2); //=> -3\n     *\n     *      R.reduce(R.maxBy(square), 0, [3, -5, 4, 1, -2]); //=> -5\n     *      R.reduce(R.maxBy(square), 0, []); //=> 0\n     */\n    var maxBy = _curry3(function maxBy(f, a, b) {\n        return f(b) > f(a) ? b : a;\n    });\n\n    /**\n     * Create a new object with the own properties of the first object merged with\n     * the own properties of the second object. If a key exists in both objects,\n     * the value from the second object will be used.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Object\n     * @sig {k: v} -> {k: v} -> {k: v}\n     * @param {Object} l\n     * @param {Object} r\n     * @return {Object}\n     * @see R.mergeWith, R.mergeWithKey\n     * @example\n     *\n     *      R.merge({ 'name': 'fred', 'age': 10 }, { 'age': 40 });\n     *      //=> { 'name': 'fred', 'age': 40 }\n     *\n     *      var resetToDefault = R.merge(R.__, {x: 0});\n     *      resetToDefault({x: 5, y: 2}); //=> {x: 0, y: 2}\n     */\n    var merge = _curry2(function merge(l, r) {\n        return _assign({}, l, r);\n    });\n\n    /**\n     * Merges a list of objects together into one object.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.10.0\n     * @category List\n     * @sig [{k: v}] -> {k: v}\n     * @param {Array} list An array of objects\n     * @return {Object} A merged object.\n     * @see R.reduce\n     * @example\n     *\n     *      R.mergeAll([{foo:1},{bar:2},{baz:3}]); //=> {foo:1,bar:2,baz:3}\n     *      R.mergeAll([{foo:1},{foo:2},{bar:2}]); //=> {foo:2,bar:2}\n     */\n    var mergeAll = _curry1(function mergeAll(list) {\n        return _assign.apply(null, [{}].concat(list));\n    });\n\n    /**\n     * Creates a new object with the own properties of the two provided objects. If\n     * a key exists in both objects, the provided function is applied to the key\n     * and the values associated with the key in each object, with the result being\n     * used as the value associated with the key in the returned object. The key\n     * will be excluded from the returned object if the resulting value is\n     * `undefined`.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.19.0\n     * @category Object\n     * @sig (String -> a -> a -> a) -> {a} -> {a} -> {a}\n     * @param {Function} fn\n     * @param {Object} l\n     * @param {Object} r\n     * @return {Object}\n     * @see R.merge, R.mergeWith\n     * @example\n     *\n     *      let concatValues = (k, l, r) => k == 'values' ? R.concat(l, r) : r\n     *      R.mergeWithKey(concatValues,\n     *                     { a: true, thing: 'foo', values: [10, 20] },\n     *                     { b: true, thing: 'bar', values: [15, 35] });\n     *      //=> { a: true, b: true, thing: 'bar', values: [10, 20, 15, 35] }\n     */\n    var mergeWithKey = _curry3(function mergeWithKey(fn, l, r) {\n        var result = {};\n        var k;\n        for (k in l) {\n            if (_has(k, l)) {\n                result[k] = _has(k, r) ? fn(k, l[k], r[k]) : l[k];\n            }\n        }\n        for (k in r) {\n            if (_has(k, r) && !_has(k, result)) {\n                result[k] = r[k];\n            }\n        }\n        return result;\n    });\n\n    /**\n     * Returns the smaller of its two arguments.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Relation\n     * @sig Ord a => a -> a -> a\n     * @param {*} a\n     * @param {*} b\n     * @return {*}\n     * @see R.minBy, R.max\n     * @example\n     *\n     *      R.min(789, 123); //=> 123\n     *      R.min('a', 'b'); //=> 'a'\n     */\n    var min = _curry2(function min(a, b) {\n        return b < a ? b : a;\n    });\n\n    /**\n     * Takes a function and two values, and returns whichever value produces the\n     * smaller result when passed to the provided function.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.8.0\n     * @category Relation\n     * @sig Ord b => (a -> b) -> a -> a -> a\n     * @param {Function} f\n     * @param {*} a\n     * @param {*} b\n     * @return {*}\n     * @see R.min, R.maxBy\n     * @example\n     *\n     *      //  square :: Number -> Number\n     *      var square = n => n * n;\n     *\n     *      R.minBy(square, -3, 2); //=> 2\n     *\n     *      R.reduce(R.minBy(square), Infinity, [3, -5, 4, 1, -2]); //=> 1\n     *      R.reduce(R.minBy(square), Infinity, []); //=> Infinity\n     */\n    var minBy = _curry3(function minBy(f, a, b) {\n        return f(b) < f(a) ? b : a;\n    });\n\n    /**\n     * Divides the second parameter by the first and returns the remainder. Note\n     * that this function preserves the JavaScript-style behavior for modulo. For\n     * mathematical modulo see `mathMod`.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.1\n     * @category Math\n     * @sig Number -> Number -> Number\n     * @param {Number} a The value to the divide.\n     * @param {Number} b The pseudo-modulus\n     * @return {Number} The result of `b % a`.\n     * @see R.mathMod\n     * @example\n     *\n     *      R.modulo(17, 3); //=> 2\n     *      // JS behavior:\n     *      R.modulo(-17, 3); //=> -2\n     *      R.modulo(17, -3); //=> 2\n     *\n     *      var isOdd = R.modulo(R.__, 2);\n     *      isOdd(42); //=> 0\n     *      isOdd(21); //=> 1\n     */\n    var modulo = _curry2(function modulo(a, b) {\n        return a % b;\n    });\n\n    /**\n     * Multiplies two numbers. Equivalent to `a * b` but curried.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Math\n     * @sig Number -> Number -> Number\n     * @param {Number} a The first value.\n     * @param {Number} b The second value.\n     * @return {Number} The result of `a * b`.\n     * @see R.divide\n     * @example\n     *\n     *      var double = R.multiply(2);\n     *      var triple = R.multiply(3);\n     *      double(3);       //=>  6\n     *      triple(4);       //=> 12\n     *      R.multiply(2, 5);  //=> 10\n     */\n    var multiply = _curry2(function multiply(a, b) {\n        return a * b;\n    });\n\n    /**\n     * Wraps a function of any arity (including nullary) in a function that accepts\n     * exactly `n` parameters. Any extraneous parameters will not be passed to the\n     * supplied function.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Function\n     * @sig Number -> (* -> a) -> (* -> a)\n     * @param {Number} n The desired arity of the new function.\n     * @param {Function} fn The function to wrap.\n     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of\n     *         arity `n`.\n     * @example\n     *\n     *      var takesTwoArgs = (a, b) => [a, b];\n     *\n     *      takesTwoArgs.length; //=> 2\n     *      takesTwoArgs(1, 2); //=> [1, 2]\n     *\n     *      var takesOneArg = R.nAry(1, takesTwoArgs);\n     *      takesOneArg.length; //=> 1\n     *      // Only `n` arguments are passed to the wrapped function\n     *      takesOneArg(1, 2); //=> [1, undefined]\n     */\n    var nAry = _curry2(function nAry(n, fn) {\n        switch (n) {\n        case 0:\n            return function () {\n                return fn.call(this);\n            };\n        case 1:\n            return function (a0) {\n                return fn.call(this, a0);\n            };\n        case 2:\n            return function (a0, a1) {\n                return fn.call(this, a0, a1);\n            };\n        case 3:\n            return function (a0, a1, a2) {\n                return fn.call(this, a0, a1, a2);\n            };\n        case 4:\n            return function (a0, a1, a2, a3) {\n                return fn.call(this, a0, a1, a2, a3);\n            };\n        case 5:\n            return function (a0, a1, a2, a3, a4) {\n                return fn.call(this, a0, a1, a2, a3, a4);\n            };\n        case 6:\n            return function (a0, a1, a2, a3, a4, a5) {\n                return fn.call(this, a0, a1, a2, a3, a4, a5);\n            };\n        case 7:\n            return function (a0, a1, a2, a3, a4, a5, a6) {\n                return fn.call(this, a0, a1, a2, a3, a4, a5, a6);\n            };\n        case 8:\n            return function (a0, a1, a2, a3, a4, a5, a6, a7) {\n                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7);\n            };\n        case 9:\n            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {\n                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8);\n            };\n        case 10:\n            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {\n                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);\n            };\n        default:\n            throw new Error('First argument to nAry must be a non-negative integer no greater than ten');\n        }\n    });\n\n    /**\n     * Negates its argument.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.9.0\n     * @category Math\n     * @sig Number -> Number\n     * @param {Number} n\n     * @return {Number}\n     * @example\n     *\n     *      R.negate(42); //=> -42\n     */\n    var negate = _curry1(function negate(n) {\n        return -n;\n    });\n\n    /**\n     * Returns `true` if no elements of the list match the predicate, `false`\n     * otherwise.\n     *\n     * Dispatches to the `any` method of the second argument, if present.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.12.0\n     * @category List\n     * @sig (a -> Boolean) -> [a] -> Boolean\n     * @param {Function} fn The predicate function.\n     * @param {Array} list The array to consider.\n     * @return {Boolean} `true` if the predicate is not satisfied by every element, `false` otherwise.\n     * @see R.all, R.any\n     * @example\n     *\n     *      var isEven = n => n % 2 === 0;\n     *\n     *      R.none(isEven, [1, 3, 5, 7, 9, 11]); //=> true\n     *      R.none(isEven, [1, 3, 5, 7, 8, 11]); //=> false\n     */\n    var none = _curry2(_complement(_dispatchable('any', _xany, any)));\n\n    /**\n     * A function that returns the `!` of its argument. It will return `true` when\n     * passed false-y value, and `false` when passed a truth-y one.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Logic\n     * @sig * -> Boolean\n     * @param {*} a any value\n     * @return {Boolean} the logical inverse of passed argument.\n     * @see R.complement\n     * @example\n     *\n     *      R.not(true); //=> false\n     *      R.not(false); //=> true\n     *      R.not(0); => true\n     *      R.not(1); => false\n     */\n    var not = _curry1(function not(a) {\n        return !a;\n    });\n\n    /**\n     * Returns the nth element of the given list or string. If n is negative the\n     * element at index length + n is returned.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig Number -> [a] -> a | Undefined\n     * @sig Number -> String -> String\n     * @param {Number} offset\n     * @param {*} list\n     * @return {*}\n     * @example\n     *\n     *      var list = ['foo', 'bar', 'baz', 'quux'];\n     *      R.nth(1, list); //=> 'bar'\n     *      R.nth(-1, list); //=> 'quux'\n     *      R.nth(-99, list); //=> undefined\n     *\n     *      R.nth(2, 'abc'); //=> 'c'\n     *      R.nth(3, 'abc'); //=> ''\n     */\n    var nth = _curry2(function nth(offset, list) {\n        var idx = offset < 0 ? list.length + offset : offset;\n        return _isString(list) ? list.charAt(idx) : list[idx];\n    });\n\n    /**\n     * Returns a function which returns its nth argument.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.9.0\n     * @category Function\n     * @sig Number -> *... -> *\n     * @param {Number} n\n     * @return {Function}\n     * @example\n     *\n     *      R.nthArg(1)('a', 'b', 'c'); //=> 'b'\n     *      R.nthArg(-1)('a', 'b', 'c'); //=> 'c'\n     */\n    var nthArg = _curry1(function nthArg(n) {\n        return function () {\n            return nth(n, arguments);\n        };\n    });\n\n    /**\n     * Creates an object containing a single key:value pair.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.18.0\n     * @category Object\n     * @sig String -> a -> {String:a}\n     * @param {String} key\n     * @param {*} val\n     * @return {Object}\n     * @see R.pair\n     * @example\n     *\n     *      var matchPhrases = R.compose(\n     *        R.objOf('must'),\n     *        R.map(R.objOf('match_phrase'))\n     *      );\n     *      matchPhrases(['foo', 'bar', 'baz']); //=> {must: [{match_phrase: 'foo'}, {match_phrase: 'bar'}, {match_phrase: 'baz'}]}\n     */\n    var objOf = _curry2(function objOf(key, val) {\n        var obj = {};\n        obj[key] = val;\n        return obj;\n    });\n\n    /**\n     * Returns a singleton array containing the value provided.\n     *\n     * Note this `of` is different from the ES6 `of`; See\n     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of\n     *\n     * @func\n     * @memberOf R\n     * @since v0.3.0\n     * @category Function\n     * @sig a -> [a]\n     * @param {*} x any value\n     * @return {Array} An array wrapping `x`.\n     * @example\n     *\n     *      R.of(null); //=> [null]\n     *      R.of([42]); //=> [[42]]\n     */\n    var of = _curry1(_of);\n\n    /**\n     * Accepts a function `fn` and returns a function that guards invocation of\n     * `fn` such that `fn` can only ever be called once, no matter how many times\n     * the returned function is invoked. The first value calculated is returned in\n     * subsequent invocations.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Function\n     * @sig (a... -> b) -> (a... -> b)\n     * @param {Function} fn The function to wrap in a call-only-once wrapper.\n     * @return {Function} The wrapped function.\n     * @example\n     *\n     *      var addOneOnce = R.once(x => x + 1);\n     *      addOneOnce(10); //=> 11\n     *      addOneOnce(addOneOnce(50)); //=> 11\n     */\n    var once = _curry1(function once(fn) {\n        var called = false;\n        var result;\n        return _arity(fn.length, function () {\n            if (called) {\n                return result;\n            }\n            called = true;\n            result = fn.apply(this, arguments);\n            return result;\n        });\n    });\n\n    /**\n     * Returns `true` if one or both of its arguments are `true`. Returns `false`\n     * if both arguments are `false`.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Logic\n     * @sig * -> * -> *\n     * @param {Boolean} a A boolean value\n     * @param {Boolean} b A boolean value\n     * @return {Boolean} `true` if one or both arguments are `true`, `false` otherwise\n     * @see R.either\n     * @example\n     *\n     *      R.or(true, true); //=> true\n     *      R.or(true, false); //=> true\n     *      R.or(false, true); //=> true\n     *      R.or(false, false); //=> false\n     */\n    var or = _curry2(function or(a, b) {\n        return a || b;\n    });\n\n    /**\n     * Returns the result of \"setting\" the portion of the given data structure\n     * focused by the given lens to the result of applying the given function to\n     * the focused value.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.16.0\n     * @category Object\n     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s\n     * @sig Lens s a -> (a -> a) -> s -> s\n     * @param {Lens} lens\n     * @param {*} v\n     * @param {*} x\n     * @return {*}\n     * @see R.prop, R.lensIndex, R.lensProp\n     * @example\n     *\n     *      var headLens = R.lensIndex(0);\n     *\n     *      R.over(headLens, R.toUpper, ['foo', 'bar', 'baz']); //=> ['FOO', 'bar', 'baz']\n     */\n    // `Identity` is a functor that holds a single value, where `map` simply\n    // transforms the held value with the provided function.\n    // The value returned by the getter function is first transformed with `f`,\n    // then set as the value of an `Identity`. This is then mapped over with the\n    // setter function of the lens.\n    var over = function () {\n        // `Identity` is a functor that holds a single value, where `map` simply\n        // transforms the held value with the provided function.\n        var Identity = function (x) {\n            return {\n                value: x,\n                map: function (f) {\n                    return Identity(f(x));\n                }\n            };\n        };\n        return _curry3(function over(lens, f, x) {\n            // The value returned by the getter function is first transformed with `f`,\n            // then set as the value of an `Identity`. This is then mapped over with the\n            // setter function of the lens.\n            return lens(function (y) {\n                return Identity(f(y));\n            })(x).value;\n        });\n    }();\n\n    /**\n     * Takes two arguments, `fst` and `snd`, and returns `[fst, snd]`.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.18.0\n     * @category List\n     * @sig a -> b -> (a,b)\n     * @param {*} fst\n     * @param {*} snd\n     * @return {Array}\n     * @see R.objOf, R.of\n     * @example\n     *\n     *      R.pair('foo', 'bar'); //=> ['foo', 'bar']\n     */\n    var pair = _curry2(function pair(fst, snd) {\n        return [\n            fst,\n            snd\n        ];\n    });\n\n    /**\n     * Retrieve the value at a given path.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.2.0\n     * @category Object\n     * @sig [String] -> {k: v} -> v | Undefined\n     * @param {Array} path The path to use.\n     * @param {Object} obj The object to retrieve the nested property from.\n     * @return {*} The data at `path`.\n     * @example\n     *\n     *      R.path(['a', 'b'], {a: {b: 2}}); //=> 2\n     *      R.path(['a', 'b'], {c: {b: 2}}); //=> undefined\n     */\n    var path = _curry2(function path(paths, obj) {\n        var val = obj;\n        var idx = 0;\n        while (idx < paths.length) {\n            if (val == null) {\n                return;\n            }\n            val = val[paths[idx]];\n            idx += 1;\n        }\n        return val;\n    });\n\n    /**\n     * If the given, non-null object has a value at the given path, returns the\n     * value at that path. Otherwise returns the provided default value.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.18.0\n     * @category Object\n     * @sig a -> [String] -> Object -> a\n     * @param {*} d The default value.\n     * @param {Array} p The path to use.\n     * @param {Object} obj The object to retrieve the nested property from.\n     * @return {*} The data at `path` of the supplied object or the default value.\n     * @example\n     *\n     *      R.pathOr('N/A', ['a', 'b'], {a: {b: 2}}); //=> 2\n     *      R.pathOr('N/A', ['a', 'b'], {c: {b: 2}}); //=> \"N/A\"\n     */\n    var pathOr = _curry3(function pathOr(d, p, obj) {\n        return defaultTo(d, path(p, obj));\n    });\n\n    /**\n     * Returns `true` if the specified object property at given path satisfies the\n     * given predicate; `false` otherwise.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.19.0\n     * @category Logic\n     * @sig (a -> Boolean) -> [String] -> Object -> Boolean\n     * @param {Function} pred\n     * @param {Array} propPath\n     * @param {*} obj\n     * @return {Boolean}\n     * @see R.propSatisfies, R.path\n     * @example\n     *\n     *      R.pathSatisfies(y => y > 0, ['x', 'y'], {x: {y: 2}}); //=> true\n     */\n    var pathSatisfies = _curry3(function pathSatisfies(pred, propPath, obj) {\n        return propPath.length > 0 && pred(path(propPath, obj));\n    });\n\n    /**\n     * Returns a partial copy of an object containing only the keys specified. If\n     * the key does not exist, the property is ignored.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Object\n     * @sig [k] -> {k: v} -> {k: v}\n     * @param {Array} names an array of String property names to copy onto a new object\n     * @param {Object} obj The object to copy from\n     * @return {Object} A new object with only properties from `names` on it.\n     * @see R.omit, R.props\n     * @example\n     *\n     *      R.pick(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}\n     *      R.pick(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1}\n     */\n    var pick = _curry2(function pick(names, obj) {\n        var result = {};\n        var idx = 0;\n        while (idx < names.length) {\n            if (names[idx] in obj) {\n                result[names[idx]] = obj[names[idx]];\n            }\n            idx += 1;\n        }\n        return result;\n    });\n\n    /**\n     * Similar to `pick` except that this one includes a `key: undefined` pair for\n     * properties that don't exist.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Object\n     * @sig [k] -> {k: v} -> {k: v}\n     * @param {Array} names an array of String property names to copy onto a new object\n     * @param {Object} obj The object to copy from\n     * @return {Object} A new object with only properties from `names` on it.\n     * @see R.pick\n     * @example\n     *\n     *      R.pickAll(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}\n     *      R.pickAll(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, e: undefined, f: undefined}\n     */\n    var pickAll = _curry2(function pickAll(names, obj) {\n        var result = {};\n        var idx = 0;\n        var len = names.length;\n        while (idx < len) {\n            var name = names[idx];\n            result[name] = obj[name];\n            idx += 1;\n        }\n        return result;\n    });\n\n    /**\n     * Returns a partial copy of an object containing only the keys that satisfy\n     * the supplied predicate.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.8.0\n     * @category Object\n     * @sig (v, k -> Boolean) -> {k: v} -> {k: v}\n     * @param {Function} pred A predicate to determine whether or not a key\n     *        should be included on the output object.\n     * @param {Object} obj The object to copy from\n     * @return {Object} A new object with only properties that satisfy `pred`\n     *         on it.\n     * @see R.pick, R.filter\n     * @example\n     *\n     *      var isUpperCase = (val, key) => key.toUpperCase() === key;\n     *      R.pickBy(isUpperCase, {a: 1, b: 2, A: 3, B: 4}); //=> {A: 3, B: 4}\n     */\n    var pickBy = _curry2(function pickBy(test, obj) {\n        var result = {};\n        for (var prop in obj) {\n            if (test(obj[prop], prop, obj)) {\n                result[prop] = obj[prop];\n            }\n        }\n        return result;\n    });\n\n    /**\n     * Returns a new list with the given element at the front, followed by the\n     * contents of the list.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig a -> [a] -> [a]\n     * @param {*} el The item to add to the head of the output list.\n     * @param {Array} list The array to add to the tail of the output list.\n     * @return {Array} A new array.\n     * @see R.append\n     * @example\n     *\n     *      R.prepend('fee', ['fi', 'fo', 'fum']); //=> ['fee', 'fi', 'fo', 'fum']\n     */\n    var prepend = _curry2(function prepend(el, list) {\n        return _concat([el], list);\n    });\n\n    /**\n     * Returns a function that when supplied an object returns the indicated\n     * property of that object, if it exists.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Object\n     * @sig s -> {s: a} -> a | Undefined\n     * @param {String} p The property name\n     * @param {Object} obj The object to query\n     * @return {*} The value at `obj.p`.\n     * @example\n     *\n     *      R.prop('x', {x: 100}); //=> 100\n     *      R.prop('x', {}); //=> undefined\n     */\n    var prop = _curry2(function prop(p, obj) {\n        return obj[p];\n    });\n\n    /**\n     * If the given, non-null object has an own property with the specified name,\n     * returns the value of that property. Otherwise returns the provided default\n     * value.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.6.0\n     * @category Object\n     * @sig a -> String -> Object -> a\n     * @param {*} val The default value.\n     * @param {String} p The name of the property to return.\n     * @param {Object} obj The object to query.\n     * @return {*} The value of given property of the supplied object or the default value.\n     * @example\n     *\n     *      var alice = {\n     *        name: 'ALICE',\n     *        age: 101\n     *      };\n     *      var favorite = R.prop('favoriteLibrary');\n     *      var favoriteWithDefault = R.propOr('Ramda', 'favoriteLibrary');\n     *\n     *      favorite(alice);  //=> undefined\n     *      favoriteWithDefault(alice);  //=> 'Ramda'\n     */\n    var propOr = _curry3(function propOr(val, p, obj) {\n        return obj != null && _has(p, obj) ? obj[p] : val;\n    });\n\n    /**\n     * Returns `true` if the specified object property satisfies the given\n     * predicate; `false` otherwise.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.16.0\n     * @category Logic\n     * @sig (a -> Boolean) -> String -> {String: a} -> Boolean\n     * @param {Function} pred\n     * @param {String} name\n     * @param {*} obj\n     * @return {Boolean}\n     * @see R.propEq, R.propIs\n     * @example\n     *\n     *      R.propSatisfies(x => x > 0, 'x', {x: 1, y: 2}); //=> true\n     */\n    var propSatisfies = _curry3(function propSatisfies(pred, name, obj) {\n        return pred(obj[name]);\n    });\n\n    /**\n     * Acts as multiple `prop`: array of keys in, array of values out. Preserves\n     * order.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Object\n     * @sig [k] -> {k: v} -> [v]\n     * @param {Array} ps The property names to fetch\n     * @param {Object} obj The object to query\n     * @return {Array} The corresponding values or partially applied function.\n     * @example\n     *\n     *      R.props(['x', 'y'], {x: 1, y: 2}); //=> [1, 2]\n     *      R.props(['c', 'a', 'b'], {b: 2, a: 1}); //=> [undefined, 1, 2]\n     *\n     *      var fullName = R.compose(R.join(' '), R.props(['first', 'last']));\n     *      fullName({last: 'Bullet-Tooth', age: 33, first: 'Tony'}); //=> 'Tony Bullet-Tooth'\n     */\n    var props = _curry2(function props(ps, obj) {\n        var len = ps.length;\n        var out = [];\n        var idx = 0;\n        while (idx < len) {\n            out[idx] = obj[ps[idx]];\n            idx += 1;\n        }\n        return out;\n    });\n\n    /**\n     * Returns a list of numbers from `from` (inclusive) to `to` (exclusive).\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig Number -> Number -> [Number]\n     * @param {Number} from The first number in the list.\n     * @param {Number} to One more than the last number in the list.\n     * @return {Array} The list of numbers in tthe set `[a, b)`.\n     * @example\n     *\n     *      R.range(1, 5);    //=> [1, 2, 3, 4]\n     *      R.range(50, 53);  //=> [50, 51, 52]\n     */\n    var range = _curry2(function range(from, to) {\n        if (!(_isNumber(from) && _isNumber(to))) {\n            throw new TypeError('Both arguments to range must be numbers');\n        }\n        var result = [];\n        var n = from;\n        while (n < to) {\n            result.push(n);\n            n += 1;\n        }\n        return result;\n    });\n\n    /**\n     * Returns a single item by iterating through the list, successively calling\n     * the iterator function and passing it an accumulator value and the current\n     * value from the array, and then passing the result to the next call.\n     *\n     * Similar to `reduce`, except moves through the input list from the right to\n     * the left.\n     *\n     * The iterator function receives two values: *(acc, value)*\n     *\n     * Note: `R.reduceRight` does not skip deleted or unassigned indices (sparse\n     * arrays), unlike the native `Array.prototype.reduce` method. For more details\n     * on this behavior, see:\n     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight#Description\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig (a,b -> a) -> a -> [b] -> a\n     * @param {Function} fn The iterator function. Receives two values, the accumulator and the\n     *        current element from the array.\n     * @param {*} acc The accumulator value.\n     * @param {Array} list The list to iterate over.\n     * @return {*} The final, accumulated value.\n     * @see R.addIndex\n     * @example\n     *\n     *      var pairs = [ ['a', 1], ['b', 2], ['c', 3] ];\n     *      var flattenPairs = (acc, pair) => acc.concat(pair);\n     *\n     *      R.reduceRight(flattenPairs, [], pairs); //=> [ 'c', 3, 'b', 2, 'a', 1 ]\n     */\n    var reduceRight = _curry3(function reduceRight(fn, acc, list) {\n        var idx = list.length - 1;\n        while (idx >= 0) {\n            acc = fn(acc, list[idx]);\n            idx -= 1;\n        }\n        return acc;\n    });\n\n    /**\n     * Returns a value wrapped to indicate that it is the final value of the reduce\n     * and transduce functions. The returned value should be considered a black\n     * box: the internal structure is not guaranteed to be stable.\n     *\n     * Note: this optimization is unavailable to functions not explicitly listed\n     * above. For instance, it is not currently supported by reduceRight.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.15.0\n     * @category List\n     * @sig a -> *\n     * @param {*} x The final value of the reduce.\n     * @return {*} The wrapped value.\n     * @see R.reduce, R.transduce\n     * @example\n     *\n     *      R.reduce(\n     *        R.pipe(R.add, R.when(R.gte(R.__, 10), R.reduced)),\n     *        0,\n     *        [1, 2, 3, 4, 5]) // 10\n     */\n    var reduced = _curry1(_reduced);\n\n    /**\n     * Removes the sub-list of `list` starting at index `start` and containing\n     * `count` elements. _Note that this is not destructive_: it returns a copy of\n     * the list with the changes.\n     * <small>No lists have been harmed in the application of this function.</small>\n     *\n     * @func\n     * @memberOf R\n     * @since v0.2.2\n     * @category List\n     * @sig Number -> Number -> [a] -> [a]\n     * @param {Number} start The position to start removing elements\n     * @param {Number} count The number of elements to remove\n     * @param {Array} list The list to remove from\n     * @return {Array} A new Array with `count` elements from `start` removed.\n     * @example\n     *\n     *      R.remove(2, 3, [1,2,3,4,5,6,7,8]); //=> [1,2,6,7,8]\n     */\n    var remove = _curry3(function remove(start, count, list) {\n        return _concat(_slice(list, 0, Math.min(start, list.length)), _slice(list, Math.min(list.length, start + count)));\n    });\n\n    /**\n     * Replace a substring or regex match in a string with a replacement.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.7.0\n     * @category String\n     * @sig RegExp|String -> String -> String -> String\n     * @param {RegExp|String} pattern A regular expression or a substring to match.\n     * @param {String} replacement The string to replace the matches with.\n     * @param {String} str The String to do the search and replacement in.\n     * @return {String} The result.\n     * @example\n     *\n     *      R.replace('foo', 'bar', 'foo foo foo'); //=> 'bar foo foo'\n     *      R.replace(/foo/, 'bar', 'foo foo foo'); //=> 'bar foo foo'\n     *\n     *      // Use the \"g\" (global) flag to replace all occurrences:\n     *      R.replace(/foo/g, 'bar', 'foo foo foo'); //=> 'bar bar bar'\n     */\n    var replace = _curry3(function replace(regex, replacement, str) {\n        return str.replace(regex, replacement);\n    });\n\n    /**\n     * Returns a new list or string with the elements or characters in reverse\n     * order.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig [a] -> [a]\n     * @sig String -> String\n     * @param {Array|String} list\n     * @return {Array|String}\n     * @example\n     *\n     *      R.reverse([1, 2, 3]);  //=> [3, 2, 1]\n     *      R.reverse([1, 2]);     //=> [2, 1]\n     *      R.reverse([1]);        //=> [1]\n     *      R.reverse([]);         //=> []\n     *\n     *      R.reverse('abc');      //=> 'cba'\n     *      R.reverse('ab');       //=> 'ba'\n     *      R.reverse('a');        //=> 'a'\n     *      R.reverse('');         //=> ''\n     */\n    var reverse = _curry1(function reverse(list) {\n        return _isString(list) ? list.split('').reverse().join('') : _slice(list).reverse();\n    });\n\n    /**\n     * Scan is similar to reduce, but returns a list of successively reduced values\n     * from the left\n     *\n     * @func\n     * @memberOf R\n     * @since v0.10.0\n     * @category List\n     * @sig (a,b -> a) -> a -> [b] -> [a]\n     * @param {Function} fn The iterator function. Receives two values, the accumulator and the\n     *        current element from the array\n     * @param {*} acc The accumulator value.\n     * @param {Array} list The list to iterate over.\n     * @return {Array} A list of all intermediately reduced values.\n     * @example\n     *\n     *      var numbers = [1, 2, 3, 4];\n     *      var factorials = R.scan(R.multiply, 1, numbers); //=> [1, 1, 2, 6, 24]\n     */\n    var scan = _curry3(function scan(fn, acc, list) {\n        var idx = 0;\n        var len = list.length;\n        var result = [acc];\n        while (idx < len) {\n            acc = fn(acc, list[idx]);\n            result[idx + 1] = acc;\n            idx += 1;\n        }\n        return result;\n    });\n\n    /**\n     * Returns the result of \"setting\" the portion of the given data structure\n     * focused by the given lens to the given value.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.16.0\n     * @category Object\n     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s\n     * @sig Lens s a -> a -> s -> s\n     * @param {Lens} lens\n     * @param {*} v\n     * @param {*} x\n     * @return {*}\n     * @see R.prop, R.lensIndex, R.lensProp\n     * @example\n     *\n     *      var xLens = R.lensProp('x');\n     *\n     *      R.set(xLens, 4, {x: 1, y: 2});  //=> {x: 4, y: 2}\n     *      R.set(xLens, 8, {x: 1, y: 2});  //=> {x: 8, y: 2}\n     */\n    var set = _curry3(function set(lens, v, x) {\n        return over(lens, always(v), x);\n    });\n\n    /**\n     * Returns the elements of the given list or string (or object with a `slice`\n     * method) from `fromIndex` (inclusive) to `toIndex` (exclusive).\n     *\n     * Dispatches to the `slice` method of the third argument, if present.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.4\n     * @category List\n     * @sig Number -> Number -> [a] -> [a]\n     * @sig Number -> Number -> String -> String\n     * @param {Number} fromIndex The start index (inclusive).\n     * @param {Number} toIndex The end index (exclusive).\n     * @param {*} list\n     * @return {*}\n     * @example\n     *\n     *      R.slice(1, 3, ['a', 'b', 'c', 'd']);        //=> ['b', 'c']\n     *      R.slice(1, Infinity, ['a', 'b', 'c', 'd']); //=> ['b', 'c', 'd']\n     *      R.slice(0, -1, ['a', 'b', 'c', 'd']);       //=> ['a', 'b', 'c']\n     *      R.slice(-3, -1, ['a', 'b', 'c', 'd']);      //=> ['b', 'c']\n     *      R.slice(0, 3, 'ramda');                     //=> 'ram'\n     */\n    var slice = _curry3(_checkForMethod('slice', function slice(fromIndex, toIndex, list) {\n        return Array.prototype.slice.call(list, fromIndex, toIndex);\n    }));\n\n    /**\n     * Returns a copy of the list, sorted according to the comparator function,\n     * which should accept two values at a time and return a negative number if the\n     * first value is smaller, a positive number if it's larger, and zero if they\n     * are equal. Please note that this is a **copy** of the list. It does not\n     * modify the original.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig (a,a -> Number) -> [a] -> [a]\n     * @param {Function} comparator A sorting function :: a -> b -> Int\n     * @param {Array} list The list to sort\n     * @return {Array} a new array with its elements sorted by the comparator function.\n     * @example\n     *\n     *      var diff = function(a, b) { return a - b; };\n     *      R.sort(diff, [4,2,7,5]); //=> [2, 4, 5, 7]\n     */\n    var sort = _curry2(function sort(comparator, list) {\n        return _slice(list).sort(comparator);\n    });\n\n    /**\n     * Sorts the list according to the supplied function.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Relation\n     * @sig Ord b => (a -> b) -> [a] -> [a]\n     * @param {Function} fn\n     * @param {Array} list The list to sort.\n     * @return {Array} A new list sorted by the keys generated by `fn`.\n     * @example\n     *\n     *      var sortByFirstItem = R.sortBy(R.prop(0));\n     *      var sortByNameCaseInsensitive = R.sortBy(R.compose(R.toLower, R.prop('name')));\n     *      var pairs = [[-1, 1], [-2, 2], [-3, 3]];\n     *      sortByFirstItem(pairs); //=> [[-3, 3], [-2, 2], [-1, 1]]\n     *      var alice = {\n     *        name: 'ALICE',\n     *        age: 101\n     *      };\n     *      var bob = {\n     *        name: 'Bob',\n     *        age: -10\n     *      };\n     *      var clara = {\n     *        name: 'clara',\n     *        age: 314.159\n     *      };\n     *      var people = [clara, bob, alice];\n     *      sortByNameCaseInsensitive(people); //=> [alice, bob, clara]\n     */\n    var sortBy = _curry2(function sortBy(fn, list) {\n        return _slice(list).sort(function (a, b) {\n            var aa = fn(a);\n            var bb = fn(b);\n            return aa < bb ? -1 : aa > bb ? 1 : 0;\n        });\n    });\n\n    /**\n     * Splits a given list or string at a given index.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.19.0\n     * @category List\n     * @sig Number -> [a] -> [[a], [a]]\n     * @sig Number -> String -> [String, String]\n     * @param {Number} index The index where the array/string is split.\n     * @param {Array|String} array The array/string to be split.\n     * @return {Array}\n     * @example\n     *\n     *      R.splitAt(1, [1, 2, 3]);          //=> [[1], [2, 3]]\n     *      R.splitAt(5, 'hello world');      //=> ['hello', ' world']\n     *      R.splitAt(-1, 'foobar');          //=> ['fooba', 'r']\n     */\n    var splitAt = _curry2(function splitAt(index, array) {\n        return [\n            slice(0, index, array),\n            slice(index, length(array), array)\n        ];\n    });\n\n    /**\n     * Splits a collection into slices of the specified length.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.16.0\n     * @category List\n     * @sig Number -> [a] -> [[a]]\n     * @sig Number -> String -> [String]\n     * @param {Number} n\n     * @param {Array} list\n     * @return {Array}\n     * @example\n     *\n     *      R.splitEvery(3, [1, 2, 3, 4, 5, 6, 7]); //=> [[1, 2, 3], [4, 5, 6], [7]]\n     *      R.splitEvery(3, 'foobarbaz'); //=> ['foo', 'bar', 'baz']\n     */\n    var splitEvery = _curry2(function splitEvery(n, list) {\n        if (n <= 0) {\n            throw new Error('First argument to splitEvery must be a positive integer');\n        }\n        var result = [];\n        var idx = 0;\n        while (idx < list.length) {\n            result.push(slice(idx, idx += n, list));\n        }\n        return result;\n    });\n\n    /**\n     * Takes a list and a predicate and returns a pair of lists with the following properties:\n     *\n     *  - the result of concatenating the two output lists is equivalent to the input list;\n     *  - none of the elements of the first output list satisfies the predicate; and\n     *  - if the second output list is non-empty, its first element satisfies the predicate.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.19.0\n     * @category List\n     * @sig (a -> Boolean) -> [a] -> [[a], [a]]\n     * @param {Function} pred The predicate that determines where the array is split.\n     * @param {Array} list The array to be split.\n     * @return {Array}\n     * @example\n     *\n     *      R.splitWhen(R.equals(2), [1, 2, 3, 1, 2, 3]);   //=> [[1], [2, 3, 1, 2, 3]]\n     */\n    var splitWhen = _curry2(function splitWhen(pred, list) {\n        var idx = 0;\n        var len = list.length;\n        var prefix = [];\n        while (idx < len && !pred(list[idx])) {\n            prefix.push(list[idx]);\n            idx += 1;\n        }\n        return [\n            prefix,\n            _slice(list, idx)\n        ];\n    });\n\n    /**\n     * Subtracts its second argument from its first argument.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Math\n     * @sig Number -> Number -> Number\n     * @param {Number} a The first value.\n     * @param {Number} b The second value.\n     * @return {Number} The result of `a - b`.\n     * @see R.add\n     * @example\n     *\n     *      R.subtract(10, 8); //=> 2\n     *\n     *      var minus5 = R.subtract(R.__, 5);\n     *      minus5(17); //=> 12\n     *\n     *      var complementaryAngle = R.subtract(90);\n     *      complementaryAngle(30); //=> 60\n     *      complementaryAngle(72); //=> 18\n     */\n    var subtract = _curry2(function subtract(a, b) {\n        return Number(a) - Number(b);\n    });\n\n    /**\n     * Returns all but the first element of the given list or string (or object\n     * with a `tail` method).\n     *\n     * Dispatches to the `slice` method of the first argument, if present.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig [a] -> [a]\n     * @sig String -> String\n     * @param {*} list\n     * @return {*}\n     * @see R.head, R.init, R.last\n     * @example\n     *\n     *      R.tail([1, 2, 3]);  //=> [2, 3]\n     *      R.tail([1, 2]);     //=> [2]\n     *      R.tail([1]);        //=> []\n     *      R.tail([]);         //=> []\n     *\n     *      R.tail('abc');  //=> 'bc'\n     *      R.tail('ab');   //=> 'b'\n     *      R.tail('a');    //=> ''\n     *      R.tail('');     //=> ''\n     */\n    var tail = _checkForMethod('tail', slice(1, Infinity));\n\n    /**\n     * Returns the first `n` elements of the given list, string, or\n     * transducer/transformer (or object with a `take` method).\n     *\n     * Dispatches to the `take` method of the second argument, if present.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig Number -> [a] -> [a]\n     * @sig Number -> String -> String\n     * @param {Number} n\n     * @param {*} list\n     * @return {*}\n     * @see R.drop\n     * @example\n     *\n     *      R.take(1, ['foo', 'bar', 'baz']); //=> ['foo']\n     *      R.take(2, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']\n     *      R.take(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']\n     *      R.take(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']\n     *      R.take(3, 'ramda');               //=> 'ram'\n     *\n     *      var personnel = [\n     *        'Dave Brubeck',\n     *        'Paul Desmond',\n     *        'Eugene Wright',\n     *        'Joe Morello',\n     *        'Gerry Mulligan',\n     *        'Bob Bates',\n     *        'Joe Dodge',\n     *        'Ron Crotty'\n     *      ];\n     *\n     *      var takeFive = R.take(5);\n     *      takeFive(personnel);\n     *      //=> ['Dave Brubeck', 'Paul Desmond', 'Eugene Wright', 'Joe Morello', 'Gerry Mulligan']\n     */\n    var take = _curry2(_dispatchable('take', _xtake, function take(n, xs) {\n        return slice(0, n < 0 ? Infinity : n, xs);\n    }));\n\n    /**\n     * Returns a new list containing the last `n` elements of a given list, passing\n     * each value to the supplied predicate function, and terminating when the\n     * predicate function returns `false`. Excludes the element that caused the\n     * predicate function to fail. The predicate function is passed one argument:\n     * *(value)*.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.16.0\n     * @category List\n     * @sig (a -> Boolean) -> [a] -> [a]\n     * @param {Function} fn The function called per iteration.\n     * @param {Array} list The collection to iterate over.\n     * @return {Array} A new array.\n     * @see R.dropLastWhile, R.addIndex\n     * @example\n     *\n     *      var isNotOne = x => x !== 1;\n     *\n     *      R.takeLastWhile(isNotOne, [1, 2, 3, 4]); //=> [2, 3, 4]\n     */\n    var takeLastWhile = _curry2(function takeLastWhile(fn, list) {\n        var idx = list.length - 1;\n        while (idx >= 0 && fn(list[idx])) {\n            idx -= 1;\n        }\n        return _slice(list, idx + 1, Infinity);\n    });\n\n    /**\n     * Returns a new list containing the first `n` elements of a given list,\n     * passing each value to the supplied predicate function, and terminating when\n     * the predicate function returns `false`. Excludes the element that caused the\n     * predicate function to fail. The predicate function is passed one argument:\n     * *(value)*.\n     *\n     * Dispatches to the `takeWhile` method of the second argument, if present.\n     *\n     * Acts as a transducer if a transformer is given in list position.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig (a -> Boolean) -> [a] -> [a]\n     * @param {Function} fn The function called per iteration.\n     * @param {Array} list The collection to iterate over.\n     * @return {Array} A new array.\n     * @see R.dropWhile, R.transduce, R.addIndex\n     * @example\n     *\n     *      var isNotFour = x => x !== 4;\n     *\n     *      R.takeWhile(isNotFour, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2, 3]\n     */\n    var takeWhile = _curry2(_dispatchable('takeWhile', _xtakeWhile, function takeWhile(fn, list) {\n        var idx = 0;\n        var len = list.length;\n        while (idx < len && fn(list[idx])) {\n            idx += 1;\n        }\n        return _slice(list, 0, idx);\n    }));\n\n    /**\n     * Runs the given function with the supplied object, then returns the object.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Function\n     * @sig (a -> *) -> a -> a\n     * @param {Function} fn The function to call with `x`. The return value of `fn` will be thrown away.\n     * @param {*} x\n     * @return {*} `x`.\n     * @example\n     *\n     *      var sayX = x => console.log('x is ' + x);\n     *      R.tap(sayX, 100); //=> 100\n     *      //-> 'x is 100'\n     */\n    var tap = _curry2(function tap(fn, x) {\n        fn(x);\n        return x;\n    });\n\n    /**\n     * Calls an input function `n` times, returning an array containing the results\n     * of those function calls.\n     *\n     * `fn` is passed one argument: The current value of `n`, which begins at `0`\n     * and is gradually incremented to `n - 1`.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.2.3\n     * @category List\n     * @sig (Number -> a) -> Number -> [a]\n     * @param {Function} fn The function to invoke. Passed one argument, the current value of `n`.\n     * @param {Number} n A value between `0` and `n - 1`. Increments after each function call.\n     * @return {Array} An array containing the return values of all calls to `fn`.\n     * @example\n     *\n     *      R.times(R.identity, 5); //=> [0, 1, 2, 3, 4]\n     */\n    var times = _curry2(function times(fn, n) {\n        var len = Number(n);\n        var idx = 0;\n        var list;\n        if (len < 0 || isNaN(len)) {\n            throw new RangeError('n must be a non-negative number');\n        }\n        list = new Array(len);\n        while (idx < len) {\n            list[idx] = fn(idx);\n            idx += 1;\n        }\n        return list;\n    });\n\n    /**\n     * Converts an object into an array of key, value arrays. Only the object's\n     * own properties are used.\n     * Note that the order of the output array is not guaranteed to be consistent\n     * across different JS platforms.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.4.0\n     * @category Object\n     * @sig {String: *} -> [[String,*]]\n     * @param {Object} obj The object to extract from\n     * @return {Array} An array of key, value arrays from the object's own properties.\n     * @see R.fromPairs\n     * @example\n     *\n     *      R.toPairs({a: 1, b: 2, c: 3}); //=> [['a', 1], ['b', 2], ['c', 3]]\n     */\n    var toPairs = _curry1(function toPairs(obj) {\n        var pairs = [];\n        for (var prop in obj) {\n            if (_has(prop, obj)) {\n                pairs[pairs.length] = [\n                    prop,\n                    obj[prop]\n                ];\n            }\n        }\n        return pairs;\n    });\n\n    /**\n     * Converts an object into an array of key, value arrays. The object's own\n     * properties and prototype properties are used. Note that the order of the\n     * output array is not guaranteed to be consistent across different JS\n     * platforms.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.4.0\n     * @category Object\n     * @sig {String: *} -> [[String,*]]\n     * @param {Object} obj The object to extract from\n     * @return {Array} An array of key, value arrays from the object's own\n     *         and prototype properties.\n     * @example\n     *\n     *      var F = function() { this.x = 'X'; };\n     *      F.prototype.y = 'Y';\n     *      var f = new F();\n     *      R.toPairsIn(f); //=> [['x','X'], ['y','Y']]\n     */\n    var toPairsIn = _curry1(function toPairsIn(obj) {\n        var pairs = [];\n        for (var prop in obj) {\n            pairs[pairs.length] = [\n                prop,\n                obj[prop]\n            ];\n        }\n        return pairs;\n    });\n\n    /**\n     * Transposes the rows and columns of a 2D list.\n     * When passed a list of `n` lists of length `x`,\n     * returns a list of `x` lists of length `n`.\n     *\n     *\n     * @func\n     * @memberOf R\n     * @since v0.19.0\n     * @category List\n     * @sig [[a]] -> [[a]]\n     * @param {Array} list A 2D list\n     * @return {Array} A 2D list\n     * @example\n     *\n     *      R.transpose([[1, 'a'], [2, 'b'], [3, 'c']]) //=> [[1, 2, 3], ['a', 'b', 'c']]\n     *      R.transpose([[1, 2, 3], ['a', 'b', 'c']]) //=> [[1, 'a'], [2, 'b'], [3, 'c']]\n     *\n     * If some of the rows are shorter than the following rows, their elements are skipped:\n     *\n     *      R.transpose([[10, 11], [20], [], [30, 31, 32]]) //=> [[10, 20, 30], [11, 31], [32]]\n     */\n    var transpose = _curry1(function transpose(outerlist) {\n        var i = 0;\n        var result = [];\n        while (i < outerlist.length) {\n            var innerlist = outerlist[i];\n            var j = 0;\n            while (j < innerlist.length) {\n                if (typeof result[j] === 'undefined') {\n                    result[j] = [];\n                }\n                result[j].push(innerlist[j]);\n                j += 1;\n            }\n            i += 1;\n        }\n        return result;\n    });\n\n    /**\n     * Removes (strips) whitespace from both ends of the string.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.6.0\n     * @category String\n     * @sig String -> String\n     * @param {String} str The string to trim.\n     * @return {String} Trimmed version of `str`.\n     * @example\n     *\n     *      R.trim('   xyz  '); //=> 'xyz'\n     *      R.map(R.trim, R.split(',', 'x, y, z')); //=> ['x', 'y', 'z']\n     */\n    var trim = function () {\n        var ws = '\\t\\n\\x0B\\f\\r \\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003' + '\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028' + '\\u2029\\uFEFF';\n        var zeroWidth = '\\u200B';\n        var hasProtoTrim = typeof String.prototype.trim === 'function';\n        if (!hasProtoTrim || (ws.trim() || !zeroWidth.trim())) {\n            return _curry1(function trim(str) {\n                var beginRx = new RegExp('^[' + ws + '][' + ws + ']*');\n                var endRx = new RegExp('[' + ws + '][' + ws + ']*$');\n                return str.replace(beginRx, '').replace(endRx, '');\n            });\n        } else {\n            return _curry1(function trim(str) {\n                return str.trim();\n            });\n        }\n    }();\n\n    /**\n     * `tryCatch` takes two functions, a `tryer` and a `catcher`. The returned\n     * function evaluates the `tryer`; if it does not throw, it simply returns the\n     * result. If the `tryer` *does* throw, the returned function evaluates the\n     * `catcher` function and returns its result. Note that for effective\n     * composition with this function, both the `tryer` and `catcher` functions\n     * must return the same type of results.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.20.0\n     * @category Function\n     * @sig (...x -> a) -> ((e, ...x) -> a) -> (...x -> a)\n     * @param {Function} tryer The function that may throw.\n     * @param {Function} catcher The function that will be evaluated if `tryer` throws.\n     * @return {Function} A new function that will catch exceptions and send then to the catcher.\n     * @example\n     *\n     *      R.tryCatch(R.prop('x'), R.F, {x: true}); //=> true\n     *      R.tryCatch(R.prop('x'), R.F, null);      //=> false\n     */\n    var tryCatch = _curry2(function _tryCatch(tryer, catcher) {\n        return _arity(tryer.length, function () {\n            try {\n                return tryer.apply(this, arguments);\n            } catch (e) {\n                return catcher.apply(this, _concat([e], arguments));\n            }\n        });\n    });\n\n    /**\n     * Gives a single-word string description of the (native) type of a value,\n     * returning such answers as 'Object', 'Number', 'Array', or 'Null'. Does not\n     * attempt to distinguish user Object types any further, reporting them all as\n     * 'Object'.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.8.0\n     * @category Type\n     * @sig (* -> {*}) -> String\n     * @param {*} val The value to test\n     * @return {String}\n     * @example\n     *\n     *      R.type({}); //=> \"Object\"\n     *      R.type(1); //=> \"Number\"\n     *      R.type(false); //=> \"Boolean\"\n     *      R.type('s'); //=> \"String\"\n     *      R.type(null); //=> \"Null\"\n     *      R.type([]); //=> \"Array\"\n     *      R.type(/[A-z]/); //=> \"RegExp\"\n     */\n    var type = _curry1(function type(val) {\n        return val === null ? 'Null' : val === undefined ? 'Undefined' : Object.prototype.toString.call(val).slice(8, -1);\n    });\n\n    /**\n     * Takes a function `fn`, which takes a single array argument, and returns a\n     * function which:\n     *\n     *   - takes any number of positional arguments;\n     *   - passes these arguments to `fn` as an array; and\n     *   - returns the result.\n     *\n     * In other words, R.unapply derives a variadic function from a function which\n     * takes an array. R.unapply is the inverse of R.apply.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.8.0\n     * @category Function\n     * @sig ([*...] -> a) -> (*... -> a)\n     * @param {Function} fn\n     * @return {Function}\n     * @see R.apply\n     * @example\n     *\n     *      R.unapply(JSON.stringify)(1, 2, 3); //=> '[1,2,3]'\n     */\n    var unapply = _curry1(function unapply(fn) {\n        return function () {\n            return fn(_slice(arguments));\n        };\n    });\n\n    /**\n     * Wraps a function of any arity (including nullary) in a function that accepts\n     * exactly 1 parameter. Any extraneous parameters will not be passed to the\n     * supplied function.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.2.0\n     * @category Function\n     * @sig (* -> b) -> (a -> b)\n     * @param {Function} fn The function to wrap.\n     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of\n     *         arity 1.\n     * @example\n     *\n     *      var takesTwoArgs = function(a, b) {\n     *        return [a, b];\n     *      };\n     *      takesTwoArgs.length; //=> 2\n     *      takesTwoArgs(1, 2); //=> [1, 2]\n     *\n     *      var takesOneArg = R.unary(takesTwoArgs);\n     *      takesOneArg.length; //=> 1\n     *      // Only 1 argument is passed to the wrapped function\n     *      takesOneArg(1, 2); //=> [1, undefined]\n     */\n    var unary = _curry1(function unary(fn) {\n        return nAry(1, fn);\n    });\n\n    /**\n     * Returns a function of arity `n` from a (manually) curried function.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.14.0\n     * @category Function\n     * @sig Number -> (a -> b) -> (a -> c)\n     * @param {Number} length The arity for the returned function.\n     * @param {Function} fn The function to uncurry.\n     * @return {Function} A new function.\n     * @see R.curry\n     * @example\n     *\n     *      var addFour = a => b => c => d => a + b + c + d;\n     *\n     *      var uncurriedAddFour = R.uncurryN(4, addFour);\n     *      uncurriedAddFour(1, 2, 3, 4); //=> 10\n     */\n    var uncurryN = _curry2(function uncurryN(depth, fn) {\n        return curryN(depth, function () {\n            var currentDepth = 1;\n            var value = fn;\n            var idx = 0;\n            var endIdx;\n            while (currentDepth <= depth && typeof value === 'function') {\n                endIdx = currentDepth === depth ? arguments.length : idx + value.length;\n                value = value.apply(this, _slice(arguments, idx, endIdx));\n                currentDepth += 1;\n                idx = endIdx;\n            }\n            return value;\n        });\n    });\n\n    /**\n     * Builds a list from a seed value. Accepts an iterator function, which returns\n     * either false to stop iteration or an array of length 2 containing the value\n     * to add to the resulting list and the seed to be used in the next call to the\n     * iterator function.\n     *\n     * The iterator function receives one argument: *(seed)*.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.10.0\n     * @category List\n     * @sig (a -> [b]) -> * -> [b]\n     * @param {Function} fn The iterator function. receives one argument, `seed`, and returns\n     *        either false to quit iteration or an array of length two to proceed. The element\n     *        at index 0 of this array will be added to the resulting array, and the element\n     *        at index 1 will be passed to the next call to `fn`.\n     * @param {*} seed The seed value.\n     * @return {Array} The final list.\n     * @example\n     *\n     *      var f = n => n > 50 ? false : [-n, n + 10];\n     *      R.unfold(f, 10); //=> [-10, -20, -30, -40, -50]\n     */\n    var unfold = _curry2(function unfold(fn, seed) {\n        var pair = fn(seed);\n        var result = [];\n        while (pair && pair.length) {\n            result[result.length] = pair[0];\n            pair = fn(pair[1]);\n        }\n        return result;\n    });\n\n    /**\n     * Returns a new list containing only one copy of each element in the original\n     * list, based upon the value returned by applying the supplied predicate to\n     * two list elements. Prefers the first item if two items compare equal based\n     * on the predicate.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.2.0\n     * @category List\n     * @sig (a, a -> Boolean) -> [a] -> [a]\n     * @param {Function} pred A predicate used to test whether two items are equal.\n     * @param {Array} list The array to consider.\n     * @return {Array} The list of unique items.\n     * @example\n     *\n     *      var strEq = R.eqBy(String);\n     *      R.uniqWith(strEq)([1, '1', 2, 1]); //=> [1, 2]\n     *      R.uniqWith(strEq)([{}, {}]);       //=> [{}]\n     *      R.uniqWith(strEq)([1, '1', 1]);    //=> [1]\n     *      R.uniqWith(strEq)(['1', 1, 1]);    //=> ['1']\n     */\n    var uniqWith = _curry2(function uniqWith(pred, list) {\n        var idx = 0;\n        var len = list.length;\n        var result = [];\n        var item;\n        while (idx < len) {\n            item = list[idx];\n            if (!_containsWith(pred, item, result)) {\n                result[result.length] = item;\n            }\n            idx += 1;\n        }\n        return result;\n    });\n\n    /**\n     * Tests the final argument by passing it to the given predicate function. If\n     * the predicate is not satisfied, the function will return the result of\n     * calling the `whenFalseFn` function with the same argument. If the predicate\n     * is satisfied, the argument is returned as is.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.18.0\n     * @category Logic\n     * @sig (a -> Boolean) -> (a -> a) -> a -> a\n     * @param {Function} pred        A predicate function\n     * @param {Function} whenFalseFn A function to invoke when the `pred` evaluates\n     *                               to a falsy value.\n     * @param {*}        x           An object to test with the `pred` function and\n     *                               pass to `whenFalseFn` if necessary.\n     * @return {*} Either `x` or the result of applying `x` to `whenFalseFn`.\n     * @see R.ifElse, R.when\n     * @example\n     *\n     *      // coerceArray :: (a|[a]) -> [a]\n     *      var coerceArray = R.unless(R.isArrayLike, R.of);\n     *      coerceArray([1, 2, 3]); //=> [1, 2, 3]\n     *      coerceArray(1);         //=> [1]\n     */\n    var unless = _curry3(function unless(pred, whenFalseFn, x) {\n        return pred(x) ? x : whenFalseFn(x);\n    });\n\n    /**\n     * Takes a predicate, a transformation function, and an initial value,\n     * and returns a value of the same type as the initial value.\n     * It does so by applying the transformation until the predicate is satisfied,\n     * at which point it returns the satisfactory value.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.20.0\n     * @category Logic\n     * @sig (a -> Boolean) -> (a -> a) -> a -> a\n     * @param {Function} pred A predicate function\n     * @param {Function} fn The iterator function\n     * @param {*} init Initial value\n     * @return {*} Final value that satisfies predicate\n     * @example\n     *\n     *      R.until(R.gt(R.__, 100), R.multiply(2))(1) // => 128\n     */\n    var until = _curry3(function until(pred, fn, init) {\n        var val = init;\n        while (!pred(val)) {\n            val = fn(val);\n        }\n        return val;\n    });\n\n    /**\n     * Returns a new copy of the array with the element at the provided index\n     * replaced with the given value.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.14.0\n     * @category List\n     * @sig Number -> a -> [a] -> [a]\n     * @param {Number} idx The index to update.\n     * @param {*} x The value to exist at the given index of the returned array.\n     * @param {Array|Arguments} list The source array-like object to be updated.\n     * @return {Array} A copy of `list` with the value at index `idx` replaced with `x`.\n     * @see R.adjust\n     * @example\n     *\n     *      R.update(1, 11, [0, 1, 2]);     //=> [0, 11, 2]\n     *      R.update(1)(11)([0, 1, 2]);     //=> [0, 11, 2]\n     */\n    var update = _curry3(function update(idx, x, list) {\n        return adjust(always(x), idx, list);\n    });\n\n    /**\n     * Accepts a function `fn` and a list of transformer functions and returns a\n     * new curried function. When the new function is invoked, it calls the\n     * function `fn` with parameters consisting of the result of calling each\n     * supplied handler on successive arguments to the new function.\n     *\n     * If more arguments are passed to the returned function than transformer\n     * functions, those arguments are passed directly to `fn` as additional\n     * parameters. If you expect additional arguments that don't need to be\n     * transformed, although you can ignore them, it's best to pass an identity\n     * function so that the new function reports the correct arity.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Function\n     * @sig (x1 -> x2 -> ... -> z) -> [(a -> x1), (b -> x2), ...] -> (a -> b -> ... -> z)\n     * @param {Function} fn The function to wrap.\n     * @param {Array} transformers A list of transformer functions\n     * @return {Function} The wrapped function.\n     * @example\n     *\n     *      R.useWith(Math.pow, [R.identity, R.identity])(3, 4); //=> 81\n     *      R.useWith(Math.pow, [R.identity, R.identity])(3)(4); //=> 81\n     *      R.useWith(Math.pow, [R.dec, R.inc])(3, 4); //=> 32\n     *      R.useWith(Math.pow, [R.dec, R.inc])(3)(4); //=> 32\n     */\n    var useWith = _curry2(function useWith(fn, transformers) {\n        return curryN(transformers.length, function () {\n            var args = [];\n            var idx = 0;\n            while (idx < transformers.length) {\n                args.push(transformers[idx].call(this, arguments[idx]));\n                idx += 1;\n            }\n            return fn.apply(this, args.concat(_slice(arguments, transformers.length)));\n        });\n    });\n\n    /**\n     * Returns a list of all the enumerable own properties of the supplied object.\n     * Note that the order of the output array is not guaranteed across different\n     * JS platforms.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Object\n     * @sig {k: v} -> [v]\n     * @param {Object} obj The object to extract values from\n     * @return {Array} An array of the values of the object's own properties.\n     * @example\n     *\n     *      R.values({a: 1, b: 2, c: 3}); //=> [1, 2, 3]\n     */\n    var values = _curry1(function values(obj) {\n        var props = keys(obj);\n        var len = props.length;\n        var vals = [];\n        var idx = 0;\n        while (idx < len) {\n            vals[idx] = obj[props[idx]];\n            idx += 1;\n        }\n        return vals;\n    });\n\n    /**\n     * Returns a list of all the properties, including prototype properties, of the\n     * supplied object.\n     * Note that the order of the output array is not guaranteed to be consistent\n     * across different JS platforms.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.2.0\n     * @category Object\n     * @sig {k: v} -> [v]\n     * @param {Object} obj The object to extract values from\n     * @return {Array} An array of the values of the object's own and prototype properties.\n     * @example\n     *\n     *      var F = function() { this.x = 'X'; };\n     *      F.prototype.y = 'Y';\n     *      var f = new F();\n     *      R.valuesIn(f); //=> ['X', 'Y']\n     */\n    var valuesIn = _curry1(function valuesIn(obj) {\n        var prop;\n        var vs = [];\n        for (prop in obj) {\n            vs[vs.length] = obj[prop];\n        }\n        return vs;\n    });\n\n    /**\n     * Returns a \"view\" of the given data structure, determined by the given lens.\n     * The lens's focus determines which portion of the data structure is visible.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.16.0\n     * @category Object\n     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s\n     * @sig Lens s a -> s -> a\n     * @param {Lens} lens\n     * @param {*} x\n     * @return {*}\n     * @see R.prop, R.lensIndex, R.lensProp\n     * @example\n     *\n     *      var xLens = R.lensProp('x');\n     *\n     *      R.view(xLens, {x: 1, y: 2});  //=> 1\n     *      R.view(xLens, {x: 4, y: 2});  //=> 4\n     */\n    // `Const` is a functor that effectively ignores the function given to `map`.\n    // Using `Const` effectively ignores the setter function of the `lens`,\n    // leaving the value returned by the getter function unmodified.\n    var view = function () {\n        // `Const` is a functor that effectively ignores the function given to `map`.\n        var Const = function (x) {\n            return {\n                value: x,\n                map: function () {\n                    return this;\n                }\n            };\n        };\n        return _curry2(function view(lens, x) {\n            // Using `Const` effectively ignores the setter function of the `lens`,\n            // leaving the value returned by the getter function unmodified.\n            return lens(Const)(x).value;\n        });\n    }();\n\n    /**\n     * Tests the final argument by passing it to the given predicate function. If\n     * the predicate is satisfied, the function will return the result of calling\n     * the `whenTrueFn` function with the same argument. If the predicate is not\n     * satisfied, the argument is returned as is.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.18.0\n     * @category Logic\n     * @sig (a -> Boolean) -> (a -> a) -> a -> a\n     * @param {Function} pred       A predicate function\n     * @param {Function} whenTrueFn A function to invoke when the `condition`\n     *                              evaluates to a truthy value.\n     * @param {*}        x          An object to test with the `pred` function and\n     *                              pass to `whenTrueFn` if necessary.\n     * @return {*} Either `x` or the result of applying `x` to `whenTrueFn`.\n     * @see R.ifElse, R.unless\n     * @example\n     *\n     *      // truncate :: String -> String\n     *      var truncate = R.when(\n     *        R.propSatisfies(R.gt(R.__, 10), 'length'),\n     *        R.pipe(R.take(10), R.append(''), R.join(''))\n     *      );\n     *      truncate('12345');         //=> '12345'\n     *      truncate('0123456789ABC'); //=> '0123456789'\n     */\n    var when = _curry3(function when(pred, whenTrueFn, x) {\n        return pred(x) ? whenTrueFn(x) : x;\n    });\n\n    /**\n     * Takes a spec object and a test object; returns true if the test satisfies\n     * the spec. Each of the spec's own properties must be a predicate function.\n     * Each predicate is applied to the value of the corresponding property of the\n     * test object. `where` returns true if all the predicates return true, false\n     * otherwise.\n     *\n     * `where` is well suited to declaratively expressing constraints for other\n     * functions such as `filter` and `find`.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.1\n     * @category Object\n     * @sig {String: (* -> Boolean)} -> {String: *} -> Boolean\n     * @param {Object} spec\n     * @param {Object} testObj\n     * @return {Boolean}\n     * @example\n     *\n     *      // pred :: Object -> Boolean\n     *      var pred = R.where({\n     *        a: R.equals('foo'),\n     *        b: R.complement(R.equals('bar')),\n     *        x: R.gt(_, 10),\n     *        y: R.lt(_, 20)\n     *      });\n     *\n     *      pred({a: 'foo', b: 'xxx', x: 11, y: 19}); //=> true\n     *      pred({a: 'xxx', b: 'xxx', x: 11, y: 19}); //=> false\n     *      pred({a: 'foo', b: 'bar', x: 11, y: 19}); //=> false\n     *      pred({a: 'foo', b: 'xxx', x: 10, y: 19}); //=> false\n     *      pred({a: 'foo', b: 'xxx', x: 11, y: 20}); //=> false\n     */\n    var where = _curry2(function where(spec, testObj) {\n        for (var prop in spec) {\n            if (_has(prop, spec) && !spec[prop](testObj[prop])) {\n                return false;\n            }\n        }\n        return true;\n    });\n\n    /**\n     * Wrap a function inside another to allow you to make adjustments to the\n     * parameters, or do other processing either before the internal function is\n     * called or with its results.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Function\n     * @sig (a... -> b) -> ((a... -> b) -> a... -> c) -> (a... -> c)\n     * @param {Function} fn The function to wrap.\n     * @param {Function} wrapper The wrapper function.\n     * @return {Function} The wrapped function.\n     * @example\n     *\n     *      var greet = name => 'Hello ' + name;\n     *\n     *      var shoutedGreet = R.wrap(greet, (gr, name) => gr(name).toUpperCase());\n     *\n     *      shoutedGreet(\"Kathy\"); //=> \"HELLO KATHY\"\n     *\n     *      var shortenedGreet = R.wrap(greet, function(gr, name) {\n     *        return gr(name.substring(0, 3));\n     *      });\n     *      shortenedGreet(\"Robert\"); //=> \"Hello Rob\"\n     */\n    var wrap = _curry2(function wrap(fn, wrapper) {\n        return curryN(fn.length, function () {\n            return wrapper.apply(this, _concat([fn], arguments));\n        });\n    });\n\n    /**\n     * Creates a new list out of the two supplied by creating each possible pair\n     * from the lists.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig [a] -> [b] -> [[a,b]]\n     * @param {Array} as The first list.\n     * @param {Array} bs The second list.\n     * @return {Array} The list made by combining each possible pair from\n     *         `as` and `bs` into pairs (`[a, b]`).\n     * @example\n     *\n     *      R.xprod([1, 2], ['a', 'b']); //=> [[1, 'a'], [1, 'b'], [2, 'a'], [2, 'b']]\n     */\n    // = xprodWith(prepend); (takes about 3 times as long...)\n    var xprod = _curry2(function xprod(a, b) {\n        // = xprodWith(prepend); (takes about 3 times as long...)\n        var idx = 0;\n        var ilen = a.length;\n        var j;\n        var jlen = b.length;\n        var result = [];\n        while (idx < ilen) {\n            j = 0;\n            while (j < jlen) {\n                result[result.length] = [\n                    a[idx],\n                    b[j]\n                ];\n                j += 1;\n            }\n            idx += 1;\n        }\n        return result;\n    });\n\n    /**\n     * Creates a new list out of the two supplied by pairing up equally-positioned\n     * items from both lists. The returned list is truncated to the length of the\n     * shorter of the two input lists.\n     * Note: `zip` is equivalent to `zipWith(function(a, b) { return [a, b] })`.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig [a] -> [b] -> [[a,b]]\n     * @param {Array} list1 The first array to consider.\n     * @param {Array} list2 The second array to consider.\n     * @return {Array} The list made by pairing up same-indexed elements of `list1` and `list2`.\n     * @example\n     *\n     *      R.zip([1, 2, 3], ['a', 'b', 'c']); //=> [[1, 'a'], [2, 'b'], [3, 'c']]\n     */\n    var zip = _curry2(function zip(a, b) {\n        var rv = [];\n        var idx = 0;\n        var len = Math.min(a.length, b.length);\n        while (idx < len) {\n            rv[idx] = [\n                a[idx],\n                b[idx]\n            ];\n            idx += 1;\n        }\n        return rv;\n    });\n\n    /**\n     * Creates a new object out of a list of keys and a list of values.\n     * Key/value pairing is truncated to the length of the shorter of the two lists.\n     * Note: `zipObj` is equivalent to `pipe(zipWith(pair), fromPairs)`.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.3.0\n     * @category List\n     * @sig [String] -> [*] -> {String: *}\n     * @param {Array} keys The array that will be properties on the output object.\n     * @param {Array} values The list of values on the output object.\n     * @return {Object} The object made by pairing up same-indexed elements of `keys` and `values`.\n     * @example\n     *\n     *      R.zipObj(['a', 'b', 'c'], [1, 2, 3]); //=> {a: 1, b: 2, c: 3}\n     */\n    var zipObj = _curry2(function zipObj(keys, values) {\n        var idx = 0;\n        var len = Math.min(keys.length, values.length);\n        var out = {};\n        while (idx < len) {\n            out[keys[idx]] = values[idx];\n            idx += 1;\n        }\n        return out;\n    });\n\n    /**\n     * Creates a new list out of the two supplied by applying the function to each\n     * equally-positioned pair in the lists. The returned list is truncated to the\n     * length of the shorter of the two input lists.\n     *\n     * @function\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig (a,b -> c) -> [a] -> [b] -> [c]\n     * @param {Function} fn The function used to combine the two elements into one value.\n     * @param {Array} list1 The first array to consider.\n     * @param {Array} list2 The second array to consider.\n     * @return {Array} The list made by combining same-indexed elements of `list1` and `list2`\n     *         using `fn`.\n     * @example\n     *\n     *      var f = (x, y) => {\n     *        // ...\n     *      };\n     *      R.zipWith(f, [1, 2, 3], ['a', 'b', 'c']);\n     *      //=> [f(1, 'a'), f(2, 'b'), f(3, 'c')]\n     */\n    var zipWith = _curry3(function zipWith(fn, a, b) {\n        var rv = [];\n        var idx = 0;\n        var len = Math.min(a.length, b.length);\n        while (idx < len) {\n            rv[idx] = fn(a[idx], b[idx]);\n            idx += 1;\n        }\n        return rv;\n    });\n\n    /**\n     * A function that always returns `false`. Any passed in parameters are ignored.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.9.0\n     * @category Function\n     * @sig * -> Boolean\n     * @param {*}\n     * @return {Boolean}\n     * @see R.always, R.T\n     * @example\n     *\n     *      R.F(); //=> false\n     */\n    var F = always(false);\n\n    /**\n     * A function that always returns `true`. Any passed in parameters are ignored.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.9.0\n     * @category Function\n     * @sig * -> Boolean\n     * @param {*}\n     * @return {Boolean}\n     * @see R.always, R.F\n     * @example\n     *\n     *      R.T(); //=> true\n     */\n    var T = always(true);\n\n    /**\n     * Copies an object.\n     *\n     * @private\n     * @param {*} value The value to be copied\n     * @param {Array} refFrom Array containing the source references\n     * @param {Array} refTo Array containing the copied source references\n     * @param {Boolean} deep Whether or not to perform deep cloning.\n     * @return {*} The copied value.\n     */\n    var _clone = function _clone(value, refFrom, refTo, deep) {\n        var copy = function copy(copiedValue) {\n            var len = refFrom.length;\n            var idx = 0;\n            while (idx < len) {\n                if (value === refFrom[idx]) {\n                    return refTo[idx];\n                }\n                idx += 1;\n            }\n            refFrom[idx + 1] = value;\n            refTo[idx + 1] = copiedValue;\n            for (var key in value) {\n                copiedValue[key] = deep ? _clone(value[key], refFrom, refTo, true) : value[key];\n            }\n            return copiedValue;\n        };\n        switch (type(value)) {\n        case 'Object':\n            return copy({});\n        case 'Array':\n            return copy([]);\n        case 'Date':\n            return new Date(value.valueOf());\n        case 'RegExp':\n            return _cloneRegExp(value);\n        default:\n            return value;\n        }\n    };\n\n    var _createPartialApplicator = function _createPartialApplicator(concat) {\n        return _curry2(function (fn, args) {\n            return _arity(Math.max(0, fn.length - args.length), function () {\n                return fn.apply(this, concat(args, arguments));\n            });\n        });\n    };\n\n    var _dropLast = function dropLast(n, xs) {\n        return take(n < xs.length ? xs.length - n : 0, xs);\n    };\n\n    // Values of other types are only equal if identical.\n    var _equals = function _equals(a, b, stackA, stackB) {\n        if (identical(a, b)) {\n            return true;\n        }\n        if (type(a) !== type(b)) {\n            return false;\n        }\n        if (a == null || b == null) {\n            return false;\n        }\n        if (typeof a.equals === 'function' || typeof b.equals === 'function') {\n            return typeof a.equals === 'function' && a.equals(b) && typeof b.equals === 'function' && b.equals(a);\n        }\n        switch (type(a)) {\n        case 'Arguments':\n        case 'Array':\n        case 'Object':\n            if (typeof a.constructor === 'function' && _functionName(a.constructor) === 'Promise') {\n                return a === b;\n            }\n            break;\n        case 'Boolean':\n        case 'Number':\n        case 'String':\n            if (!(typeof a === typeof b && identical(a.valueOf(), b.valueOf()))) {\n                return false;\n            }\n            break;\n        case 'Date':\n            if (!identical(a.valueOf(), b.valueOf())) {\n                return false;\n            }\n            break;\n        case 'Error':\n            return a.name === b.name && a.message === b.message;\n        case 'RegExp':\n            if (!(a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode)) {\n                return false;\n            }\n            break;\n        case 'Map':\n        case 'Set':\n            if (!_equals(_arrayFromIterator(a.entries()), _arrayFromIterator(b.entries()), stackA, stackB)) {\n                return false;\n            }\n            break;\n        case 'Int8Array':\n        case 'Uint8Array':\n        case 'Uint8ClampedArray':\n        case 'Int16Array':\n        case 'Uint16Array':\n        case 'Int32Array':\n        case 'Uint32Array':\n        case 'Float32Array':\n        case 'Float64Array':\n            break;\n        case 'ArrayBuffer':\n            break;\n        default:\n            // Values of other types are only equal if identical.\n            return false;\n        }\n        var keysA = keys(a);\n        if (keysA.length !== keys(b).length) {\n            return false;\n        }\n        var idx = stackA.length - 1;\n        while (idx >= 0) {\n            if (stackA[idx] === a) {\n                return stackB[idx] === b;\n            }\n            idx -= 1;\n        }\n        stackA.push(a);\n        stackB.push(b);\n        idx = keysA.length - 1;\n        while (idx >= 0) {\n            var key = keysA[idx];\n            if (!(_has(key, b) && _equals(b[key], a[key], stackA, stackB))) {\n                return false;\n            }\n            idx -= 1;\n        }\n        stackA.pop();\n        stackB.pop();\n        return true;\n    };\n\n    /**\n     * `_makeFlat` is a helper function that returns a one-level or fully recursive\n     * function based on the flag passed in.\n     *\n     * @private\n     */\n    var _makeFlat = function _makeFlat(recursive) {\n        return function flatt(list) {\n            var value, jlen, j;\n            var result = [];\n            var idx = 0;\n            var ilen = list.length;\n            while (idx < ilen) {\n                if (isArrayLike(list[idx])) {\n                    value = recursive ? flatt(list[idx]) : list[idx];\n                    j = 0;\n                    jlen = value.length;\n                    while (j < jlen) {\n                        result[result.length] = value[j];\n                        j += 1;\n                    }\n                } else {\n                    result[result.length] = list[idx];\n                }\n                idx += 1;\n            }\n            return result;\n        };\n    };\n\n    var _reduce = function () {\n        function _arrayReduce(xf, acc, list) {\n            var idx = 0;\n            var len = list.length;\n            while (idx < len) {\n                acc = xf['@@transducer/step'](acc, list[idx]);\n                if (acc && acc['@@transducer/reduced']) {\n                    acc = acc['@@transducer/value'];\n                    break;\n                }\n                idx += 1;\n            }\n            return xf['@@transducer/result'](acc);\n        }\n        function _iterableReduce(xf, acc, iter) {\n            var step = iter.next();\n            while (!step.done) {\n                acc = xf['@@transducer/step'](acc, step.value);\n                if (acc && acc['@@transducer/reduced']) {\n                    acc = acc['@@transducer/value'];\n                    break;\n                }\n                step = iter.next();\n            }\n            return xf['@@transducer/result'](acc);\n        }\n        function _methodReduce(xf, acc, obj) {\n            return xf['@@transducer/result'](obj.reduce(bind(xf['@@transducer/step'], xf), acc));\n        }\n        var symIterator = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';\n        return function _reduce(fn, acc, list) {\n            if (typeof fn === 'function') {\n                fn = _xwrap(fn);\n            }\n            if (isArrayLike(list)) {\n                return _arrayReduce(fn, acc, list);\n            }\n            if (typeof list.reduce === 'function') {\n                return _methodReduce(fn, acc, list);\n            }\n            if (list[symIterator] != null) {\n                return _iterableReduce(fn, acc, list[symIterator]());\n            }\n            if (typeof list.next === 'function') {\n                return _iterableReduce(fn, acc, list);\n            }\n            throw new TypeError('reduce: list must be array or iterable');\n        };\n    }();\n\n    var _stepCat = function () {\n        var _stepCatArray = {\n            '@@transducer/init': Array,\n            '@@transducer/step': function (xs, x) {\n                xs.push(x);\n                return xs;\n            },\n            '@@transducer/result': _identity\n        };\n        var _stepCatString = {\n            '@@transducer/init': String,\n            '@@transducer/step': function (a, b) {\n                return a + b;\n            },\n            '@@transducer/result': _identity\n        };\n        var _stepCatObject = {\n            '@@transducer/init': Object,\n            '@@transducer/step': function (result, input) {\n                return _assign(result, isArrayLike(input) ? objOf(input[0], input[1]) : input);\n            },\n            '@@transducer/result': _identity\n        };\n        return function _stepCat(obj) {\n            if (_isTransformer(obj)) {\n                return obj;\n            }\n            if (isArrayLike(obj)) {\n                return _stepCatArray;\n            }\n            if (typeof obj === 'string') {\n                return _stepCatString;\n            }\n            if (typeof obj === 'object') {\n                return _stepCatObject;\n            }\n            throw new Error('Cannot create transformer for ' + obj);\n        };\n    }();\n\n    var _xdropLastWhile = function () {\n        function XDropLastWhile(fn, xf) {\n            this.f = fn;\n            this.retained = [];\n            this.xf = xf;\n        }\n        XDropLastWhile.prototype['@@transducer/init'] = _xfBase.init;\n        XDropLastWhile.prototype['@@transducer/result'] = function (result) {\n            this.retained = null;\n            return this.xf['@@transducer/result'](result);\n        };\n        XDropLastWhile.prototype['@@transducer/step'] = function (result, input) {\n            return this.f(input) ? this.retain(result, input) : this.flush(result, input);\n        };\n        XDropLastWhile.prototype.flush = function (result, input) {\n            result = _reduce(this.xf['@@transducer/step'], result, this.retained);\n            this.retained = [];\n            return this.xf['@@transducer/step'](result, input);\n        };\n        XDropLastWhile.prototype.retain = function (result, input) {\n            this.retained.push(input);\n            return result;\n        };\n        return _curry2(function _xdropLastWhile(fn, xf) {\n            return new XDropLastWhile(fn, xf);\n        });\n    }();\n\n    var _xgroupBy = function () {\n        function XGroupBy(f, xf) {\n            this.xf = xf;\n            this.f = f;\n            this.inputs = {};\n        }\n        XGroupBy.prototype['@@transducer/init'] = _xfBase.init;\n        XGroupBy.prototype['@@transducer/result'] = function (result) {\n            var key;\n            for (key in this.inputs) {\n                if (_has(key, this.inputs)) {\n                    result = this.xf['@@transducer/step'](result, this.inputs[key]);\n                    if (result['@@transducer/reduced']) {\n                        result = result['@@transducer/value'];\n                        break;\n                    }\n                }\n            }\n            this.inputs = null;\n            return this.xf['@@transducer/result'](result);\n        };\n        XGroupBy.prototype['@@transducer/step'] = function (result, input) {\n            var key = this.f(input);\n            this.inputs[key] = this.inputs[key] || [\n                key,\n                []\n            ];\n            this.inputs[key][1] = append(input, this.inputs[key][1]);\n            return result;\n        };\n        return _curry2(function _xgroupBy(f, xf) {\n            return new XGroupBy(f, xf);\n        });\n    }();\n\n    /**\n     * Creates a new list iteration function from an existing one by adding two new\n     * parameters to its callback function: the current index, and the entire list.\n     *\n     * This would turn, for instance, Ramda's simple `map` function into one that\n     * more closely resembles `Array.prototype.map`. Note that this will only work\n     * for functions in which the iteration callback function is the first\n     * parameter, and where the list is the last parameter. (This latter might be\n     * unimportant if the list parameter is not used.)\n     *\n     * @func\n     * @memberOf R\n     * @since v0.15.0\n     * @category Function\n     * @category List\n     * @sig ((a ... -> b) ... -> [a] -> *) -> (a ..., Int, [a] -> b) ... -> [a] -> *)\n     * @param {Function} fn A list iteration function that does not pass index or list to its callback\n     * @return {Function} An altered list iteration function that passes (item, index, list) to its callback\n     * @example\n     *\n     *      var mapIndexed = R.addIndex(R.map);\n     *      mapIndexed((val, idx) => idx + '-' + val, ['f', 'o', 'o', 'b', 'a', 'r']);\n     *      //=> ['0-f', '1-o', '2-o', '3-b', '4-a', '5-r']\n     */\n    var addIndex = _curry1(function addIndex(fn) {\n        return curryN(fn.length, function () {\n            var idx = 0;\n            var origFn = arguments[0];\n            var list = arguments[arguments.length - 1];\n            var args = _slice(arguments);\n            args[0] = function () {\n                var result = origFn.apply(this, _concat(arguments, [\n                    idx,\n                    list\n                ]));\n                idx += 1;\n                return result;\n            };\n            return fn.apply(this, args);\n        });\n    });\n\n    /**\n     * Wraps a function of any arity (including nullary) in a function that accepts\n     * exactly 2 parameters. Any extraneous parameters will not be passed to the\n     * supplied function.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.2.0\n     * @category Function\n     * @sig (* -> c) -> (a, b -> c)\n     * @param {Function} fn The function to wrap.\n     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of\n     *         arity 2.\n     * @example\n     *\n     *      var takesThreeArgs = function(a, b, c) {\n     *        return [a, b, c];\n     *      };\n     *      takesThreeArgs.length; //=> 3\n     *      takesThreeArgs(1, 2, 3); //=> [1, 2, 3]\n     *\n     *      var takesTwoArgs = R.binary(takesThreeArgs);\n     *      takesTwoArgs.length; //=> 2\n     *      // Only 2 arguments are passed to the wrapped function\n     *      takesTwoArgs(1, 2, 3); //=> [1, 2, undefined]\n     */\n    var binary = _curry1(function binary(fn) {\n        return nAry(2, fn);\n    });\n\n    /**\n     * Creates a deep copy of the value which may contain (nested) `Array`s and\n     * `Object`s, `Number`s, `String`s, `Boolean`s and `Date`s. `Function`s are not\n     * copied, but assigned by their reference.\n     *\n     * Dispatches to a `clone` method if present.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Object\n     * @sig {*} -> {*}\n     * @param {*} value The object or array to clone\n     * @return {*} A new object or array.\n     * @example\n     *\n     *      var objects = [{}, {}, {}];\n     *      var objectsClone = R.clone(objects);\n     *      objects[0] === objectsClone[0]; //=> false\n     */\n    var clone = _curry1(function clone(value) {\n        return value != null && typeof value.clone === 'function' ? value.clone() : _clone(value, [], [], true);\n    });\n\n    /**\n     * Returns a curried equivalent of the provided function. The curried function\n     * has two unusual capabilities. First, its arguments needn't be provided one\n     * at a time. If `f` is a ternary function and `g` is `R.curry(f)`, the\n     * following are equivalent:\n     *\n     *   - `g(1)(2)(3)`\n     *   - `g(1)(2, 3)`\n     *   - `g(1, 2)(3)`\n     *   - `g(1, 2, 3)`\n     *\n     * Secondly, the special placeholder value `R.__` may be used to specify\n     * \"gaps\", allowing partial application of any combination of arguments,\n     * regardless of their positions. If `g` is as above and `_` is `R.__`, the\n     * following are equivalent:\n     *\n     *   - `g(1, 2, 3)`\n     *   - `g(_, 2, 3)(1)`\n     *   - `g(_, _, 3)(1)(2)`\n     *   - `g(_, _, 3)(1, 2)`\n     *   - `g(_, 2)(1)(3)`\n     *   - `g(_, 2)(1, 3)`\n     *   - `g(_, 2)(_, 3)(1)`\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Function\n     * @sig (* -> a) -> (* -> a)\n     * @param {Function} fn The function to curry.\n     * @return {Function} A new, curried function.\n     * @see R.curryN\n     * @example\n     *\n     *      var addFourNumbers = (a, b, c, d) => a + b + c + d;\n     *\n     *      var curriedAddFourNumbers = R.curry(addFourNumbers);\n     *      var f = curriedAddFourNumbers(1, 2);\n     *      var g = f(3);\n     *      g(4); //=> 10\n     */\n    var curry = _curry1(function curry(fn) {\n        return curryN(fn.length, fn);\n    });\n\n    /**\n     * Returns all but the first `n` elements of the given list, string, or\n     * transducer/transformer (or object with a `drop` method).\n     *\n     * Dispatches to the `drop` method of the second argument, if present.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig Number -> [a] -> [a]\n     * @sig Number -> String -> String\n     * @param {Number} n\n     * @param {*} list\n     * @return {*}\n     * @see R.take, R.transduce\n     * @example\n     *\n     *      R.drop(1, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']\n     *      R.drop(2, ['foo', 'bar', 'baz']); //=> ['baz']\n     *      R.drop(3, ['foo', 'bar', 'baz']); //=> []\n     *      R.drop(4, ['foo', 'bar', 'baz']); //=> []\n     *      R.drop(3, 'ramda');               //=> 'da'\n     */\n    var drop = _curry2(_dispatchable('drop', _xdrop, function drop(n, xs) {\n        return slice(Math.max(0, n), Infinity, xs);\n    }));\n\n    /**\n     * Returns a list containing all but the last `n` elements of the given `list`.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.16.0\n     * @category List\n     * @sig Number -> [a] -> [a]\n     * @sig Number -> String -> String\n     * @param {Number} n The number of elements of `xs` to skip.\n     * @param {Array} xs The collection to consider.\n     * @return {Array}\n     * @see R.takeLast\n     * @example\n     *\n     *      R.dropLast(1, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']\n     *      R.dropLast(2, ['foo', 'bar', 'baz']); //=> ['foo']\n     *      R.dropLast(3, ['foo', 'bar', 'baz']); //=> []\n     *      R.dropLast(4, ['foo', 'bar', 'baz']); //=> []\n     *      R.dropLast(3, 'ramda');               //=> 'ra'\n     */\n    var dropLast = _curry2(_dispatchable('dropLast', _xdropLast, _dropLast));\n\n    /**\n     * Returns a new list containing all but last the`n` elements of a given list,\n     * passing each value from the right to the supplied predicate function,\n     * skipping elements while the predicate function returns `true`. The predicate\n     * function is passed one argument: (value)*.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.16.0\n     * @category List\n     * @sig (a -> Boolean) -> [a] -> [a]\n     * @param {Function} fn The function called per iteration.\n     * @param {Array} list The collection to iterate over.\n     * @return {Array} A new array.\n     * @see R.takeLastWhile, R.addIndex\n     * @example\n     *\n     *      var lteThree = x => x <= 3;\n     *\n     *      R.dropLastWhile(lteThree, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2, 3, 4]\n     */\n    var dropLastWhile = _curry2(_dispatchable('dropLastWhile', _xdropLastWhile, _dropLastWhile));\n\n    /**\n     * Returns `true` if its arguments are equivalent, `false` otherwise. Handles\n     * cyclical data structures.\n     *\n     * Dispatches symmetrically to the `equals` methods of both arguments, if\n     * present.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.15.0\n     * @category Relation\n     * @sig a -> b -> Boolean\n     * @param {*} a\n     * @param {*} b\n     * @return {Boolean}\n     * @example\n     *\n     *      R.equals(1, 1); //=> true\n     *      R.equals(1, '1'); //=> false\n     *      R.equals([1, 2, 3], [1, 2, 3]); //=> true\n     *\n     *      var a = {}; a.v = a;\n     *      var b = {}; b.v = b;\n     *      R.equals(a, b); //=> true\n     */\n    var equals = _curry2(function equals(a, b) {\n        return _equals(a, b, [], []);\n    });\n\n    /**\n     * Takes a predicate and a \"filterable\", and returns a new filterable of the\n     * same type containing the members of the given filterable which satisfy the\n     * given predicate.\n     *\n     * Dispatches to the `filter` method of the second argument, if present.\n     *\n     * Acts as a transducer if a transformer is given in list position.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig Filterable f => (a -> Boolean) -> f a -> f a\n     * @param {Function} pred\n     * @param {Array} filterable\n     * @return {Array}\n     * @see R.reject, R.transduce, R.addIndex\n     * @example\n     *\n     *      var isEven = n => n % 2 === 0;\n     *\n     *      R.filter(isEven, [1, 2, 3, 4]); //=> [2, 4]\n     *\n     *      R.filter(isEven, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}\n     */\n    // else\n    var filter = _curry2(_dispatchable('filter', _xfilter, function (pred, filterable) {\n        return _isObject(filterable) ? _reduce(function (acc, key) {\n            if (pred(filterable[key])) {\n                acc[key] = filterable[key];\n            }\n            return acc;\n        }, {}, keys(filterable)) : // else\n        _filter(pred, filterable);\n    }));\n\n    /**\n     * Returns a new list by pulling every item out of it (and all its sub-arrays)\n     * and putting them in a new array, depth-first.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig [a] -> [b]\n     * @param {Array} list The array to consider.\n     * @return {Array} The flattened list.\n     * @see R.unnest\n     * @example\n     *\n     *      R.flatten([1, 2, [3, 4], 5, [6, [7, 8, [9, [10, 11], 12]]]]);\n     *      //=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n     */\n    var flatten = _curry1(_makeFlat(true));\n\n    /**\n     * Returns a new function much like the supplied one, except that the first two\n     * arguments' order is reversed.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Function\n     * @sig (a -> b -> c -> ... -> z) -> (b -> a -> c -> ... -> z)\n     * @param {Function} fn The function to invoke with its first two parameters reversed.\n     * @return {*} The result of invoking `fn` with its first two parameters' order reversed.\n     * @example\n     *\n     *      var mergeThree = (a, b, c) => [].concat(a, b, c);\n     *\n     *      mergeThree(1, 2, 3); //=> [1, 2, 3]\n     *\n     *      R.flip(mergeThree)(1, 2, 3); //=> [2, 1, 3]\n     */\n    var flip = _curry1(function flip(fn) {\n        return curry(function (a, b) {\n            var args = _slice(arguments);\n            args[0] = b;\n            args[1] = a;\n            return fn.apply(this, args);\n        });\n    });\n\n    /**\n     * Returns the first element of the given list or string. In some libraries\n     * this function is named `first`.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig [a] -> a | Undefined\n     * @sig String -> String\n     * @param {Array|String} list\n     * @return {*}\n     * @see R.tail, R.init, R.last\n     * @example\n     *\n     *      R.head(['fi', 'fo', 'fum']); //=> 'fi'\n     *      R.head([]); //=> undefined\n     *\n     *      R.head('abc'); //=> 'a'\n     *      R.head(''); //=> ''\n     */\n    var head = nth(0);\n\n    /**\n     * Returns all but the last element of the given list or string.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.9.0\n     * @category List\n     * @sig [a] -> [a]\n     * @sig String -> String\n     * @param {*} list\n     * @return {*}\n     * @see R.last, R.head, R.tail\n     * @example\n     *\n     *      R.init([1, 2, 3]);  //=> [1, 2]\n     *      R.init([1, 2]);     //=> [1]\n     *      R.init([1]);        //=> []\n     *      R.init([]);         //=> []\n     *\n     *      R.init('abc');  //=> 'ab'\n     *      R.init('ab');   //=> 'a'\n     *      R.init('a');    //=> ''\n     *      R.init('');     //=> ''\n     */\n    var init = slice(0, -1);\n\n    /**\n     * Combines two lists into a set (i.e. no duplicates) composed of those\n     * elements common to both lists. Duplication is determined according to the\n     * value returned by applying the supplied predicate to two list elements.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Relation\n     * @sig (a -> a -> Boolean) -> [*] -> [*] -> [*]\n     * @param {Function} pred A predicate function that determines whether\n     *        the two supplied elements are equal.\n     * @param {Array} list1 One list of items to compare\n     * @param {Array} list2 A second list of items to compare\n     * @return {Array} A new list containing those elements common to both lists.\n     * @see R.intersection\n     * @example\n     *\n     *      var buffaloSpringfield = [\n     *        {id: 824, name: 'Richie Furay'},\n     *        {id: 956, name: 'Dewey Martin'},\n     *        {id: 313, name: 'Bruce Palmer'},\n     *        {id: 456, name: 'Stephen Stills'},\n     *        {id: 177, name: 'Neil Young'}\n     *      ];\n     *      var csny = [\n     *        {id: 204, name: 'David Crosby'},\n     *        {id: 456, name: 'Stephen Stills'},\n     *        {id: 539, name: 'Graham Nash'},\n     *        {id: 177, name: 'Neil Young'}\n     *      ];\n     *\n     *      R.intersectionWith(R.eqBy(R.prop('id')), buffaloSpringfield, csny);\n     *      //=> [{id: 456, name: 'Stephen Stills'}, {id: 177, name: 'Neil Young'}]\n     */\n    var intersectionWith = _curry3(function intersectionWith(pred, list1, list2) {\n        var lookupList, filteredList;\n        if (list1.length > list2.length) {\n            lookupList = list1;\n            filteredList = list2;\n        } else {\n            lookupList = list2;\n            filteredList = list1;\n        }\n        var results = [];\n        var idx = 0;\n        while (idx < filteredList.length) {\n            if (_containsWith(pred, filteredList[idx], lookupList)) {\n                results[results.length] = filteredList[idx];\n            }\n            idx += 1;\n        }\n        return uniqWith(pred, results);\n    });\n\n    /**\n     * Transforms the items of the list with the transducer and appends the\n     * transformed items to the accumulator using an appropriate iterator function\n     * based on the accumulator type.\n     *\n     * The accumulator can be an array, string, object or a transformer. Iterated\n     * items will be appended to arrays and concatenated to strings. Objects will\n     * be merged directly or 2-item arrays will be merged as key, value pairs.\n     *\n     * The accumulator can also be a transformer object that provides a 2-arity\n     * reducing iterator function, step, 0-arity initial value function, init, and\n     * 1-arity result extraction function result. The step function is used as the\n     * iterator function in reduce. The result function is used to convert the\n     * final accumulator into the return type and in most cases is R.identity. The\n     * init function is used to provide the initial accumulator.\n     *\n     * The iteration is performed with R.reduce after initializing the transducer.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.12.0\n     * @category List\n     * @sig a -> (b -> b) -> [c] -> a\n     * @param {*} acc The initial accumulator value.\n     * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.\n     * @param {Array} list The list to iterate over.\n     * @return {*} The final, accumulated value.\n     * @example\n     *\n     *      var numbers = [1, 2, 3, 4];\n     *      var transducer = R.compose(R.map(R.add(1)), R.take(2));\n     *\n     *      R.into([], transducer, numbers); //=> [2, 3]\n     *\n     *      var intoArray = R.into([]);\n     *      intoArray(transducer, numbers); //=> [2, 3]\n     */\n    var into = _curry3(function into(acc, xf, list) {\n        return _isTransformer(acc) ? _reduce(xf(acc), acc['@@transducer/init'](), list) : _reduce(xf(_stepCat(acc)), _clone(acc, [], [], false), list);\n    });\n\n    /**\n     * Same as R.invertObj, however this accounts for objects with duplicate values\n     * by putting the values into an array.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.9.0\n     * @category Object\n     * @sig {s: x} -> {x: [ s, ... ]}\n     * @param {Object} obj The object or array to invert\n     * @return {Object} out A new object with keys\n     * in an array.\n     * @example\n     *\n     *      var raceResultsByFirstName = {\n     *        first: 'alice',\n     *        second: 'jake',\n     *        third: 'alice',\n     *      };\n     *      R.invert(raceResultsByFirstName);\n     *      //=> { 'alice': ['first', 'third'], 'jake':['second'] }\n     */\n    var invert = _curry1(function invert(obj) {\n        var props = keys(obj);\n        var len = props.length;\n        var idx = 0;\n        var out = {};\n        while (idx < len) {\n            var key = props[idx];\n            var val = obj[key];\n            var list = _has(val, out) ? out[val] : out[val] = [];\n            list[list.length] = key;\n            idx += 1;\n        }\n        return out;\n    });\n\n    /**\n     * Returns a new object with the keys of the given object as values, and the\n     * values of the given object, which are coerced to strings, as keys. Note\n     * that the last key found is preferred when handling the same value.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.9.0\n     * @category Object\n     * @sig {s: x} -> {x: s}\n     * @param {Object} obj The object or array to invert\n     * @return {Object} out A new object\n     * @example\n     *\n     *      var raceResults = {\n     *        first: 'alice',\n     *        second: 'jake'\n     *      };\n     *      R.invertObj(raceResults);\n     *      //=> { 'alice': 'first', 'jake':'second' }\n     *\n     *      // Alternatively:\n     *      var raceResults = ['alice', 'jake'];\n     *      R.invertObj(raceResults);\n     *      //=> { 'alice': '0', 'jake':'1' }\n     */\n    var invertObj = _curry1(function invertObj(obj) {\n        var props = keys(obj);\n        var len = props.length;\n        var idx = 0;\n        var out = {};\n        while (idx < len) {\n            var key = props[idx];\n            out[obj[key]] = key;\n            idx += 1;\n        }\n        return out;\n    });\n\n    /**\n     * Returns `true` if the given value is its type's empty value; `false`\n     * otherwise.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Logic\n     * @sig a -> Boolean\n     * @param {*} x\n     * @return {Boolean}\n     * @see R.empty\n     * @example\n     *\n     *      R.isEmpty([1, 2, 3]);   //=> false\n     *      R.isEmpty([]);          //=> true\n     *      R.isEmpty('');          //=> true\n     *      R.isEmpty(null);        //=> false\n     *      R.isEmpty({});          //=> true\n     *      R.isEmpty({length: 0}); //=> false\n     */\n    var isEmpty = _curry1(function isEmpty(x) {\n        return x != null && equals(x, empty(x));\n    });\n\n    /**\n     * Returns the last element of the given list or string.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.4\n     * @category List\n     * @sig [a] -> a | Undefined\n     * @sig String -> String\n     * @param {*} list\n     * @return {*}\n     * @see R.init, R.head, R.tail\n     * @example\n     *\n     *      R.last(['fi', 'fo', 'fum']); //=> 'fum'\n     *      R.last([]); //=> undefined\n     *\n     *      R.last('abc'); //=> 'c'\n     *      R.last(''); //=> ''\n     */\n    var last = nth(-1);\n\n    /**\n     * Returns the position of the last occurrence of an item in an array, or -1 if\n     * the item is not included in the array. `R.equals` is used to determine\n     * equality.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig a -> [a] -> Number\n     * @param {*} target The item to find.\n     * @param {Array} xs The array to search in.\n     * @return {Number} the index of the target, or -1 if the target is not found.\n     * @see R.indexOf\n     * @example\n     *\n     *      R.lastIndexOf(3, [-1,3,3,0,1,2,3,4]); //=> 6\n     *      R.lastIndexOf(10, [1,2,3,4]); //=> -1\n     */\n    var lastIndexOf = _curry2(function lastIndexOf(target, xs) {\n        if (typeof xs.lastIndexOf === 'function' && !_isArray(xs)) {\n            return xs.lastIndexOf(target);\n        } else {\n            var idx = xs.length - 1;\n            while (idx >= 0) {\n                if (equals(xs[idx], target)) {\n                    return idx;\n                }\n                idx -= 1;\n            }\n            return -1;\n        }\n    });\n\n    /**\n     * Takes a function and\n     * a [functor](https://github.com/fantasyland/fantasy-land#functor),\n     * applies the function to each of the functor's values, and returns\n     * a functor of the same shape.\n     *\n     * Ramda provides suitable `map` implementations for `Array` and `Object`,\n     * so this function may be applied to `[1, 2, 3]` or `{x: 1, y: 2, z: 3}`.\n     *\n     * Dispatches to the `map` method of the second argument, if present.\n     *\n     * Acts as a transducer if a transformer is given in list position.\n     *\n     * Also treats functions as functors and will compose them together.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig Functor f => (a -> b) -> f a -> f b\n     * @param {Function} fn The function to be called on every element of the input `list`.\n     * @param {Array} list The list to be iterated over.\n     * @return {Array} The new list.\n     * @see R.transduce, R.addIndex\n     * @example\n     *\n     *      var double = x => x * 2;\n     *\n     *      R.map(double, [1, 2, 3]); //=> [2, 4, 6]\n     *\n     *      R.map(double, {x: 1, y: 2, z: 3}); //=> {x: 2, y: 4, z: 6}\n     */\n    var map = _curry2(_dispatchable('map', _xmap, function map(fn, functor) {\n        switch (Object.prototype.toString.call(functor)) {\n        case '[object Function]':\n            return curryN(functor.length, function () {\n                return fn.call(this, functor.apply(this, arguments));\n            });\n        case '[object Object]':\n            return _reduce(function (acc, key) {\n                acc[key] = fn(functor[key]);\n                return acc;\n            }, {}, keys(functor));\n        default:\n            return _map(fn, functor);\n        }\n    }));\n\n    /**\n     * An Object-specific version of `map`. The function is applied to three\n     * arguments: *(value, key, obj)*. If only the value is significant, use\n     * `map` instead.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.9.0\n     * @category Object\n     * @sig ((*, String, Object) -> *) -> Object -> Object\n     * @param {Function} fn\n     * @param {Object} obj\n     * @return {Object}\n     * @see R.map\n     * @example\n     *\n     *      var values = { x: 1, y: 2, z: 3 };\n     *      var prependKeyAndDouble = (num, key, obj) => key + (num * 2);\n     *\n     *      R.mapObjIndexed(prependKeyAndDouble, values); //=> { x: 'x2', y: 'y4', z: 'z6' }\n     */\n    var mapObjIndexed = _curry2(function mapObjIndexed(fn, obj) {\n        return _reduce(function (acc, key) {\n            acc[key] = fn(obj[key], key, obj);\n            return acc;\n        }, {}, keys(obj));\n    });\n\n    /**\n     * Creates a new object with the own properties of the two provided objects. If\n     * a key exists in both objects, the provided function is applied to the values\n     * associated with the key in each object, with the result being used as the\n     * value associated with the key in the returned object. The key will be\n     * excluded from the returned object if the resulting value is `undefined`.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.19.0\n     * @category Object\n     * @sig (a -> a -> a) -> {a} -> {a} -> {a}\n     * @param {Function} fn\n     * @param {Object} l\n     * @param {Object} r\n     * @return {Object}\n     * @see R.merge, R.mergeWithKey\n     * @example\n     *\n     *      R.mergeWith(R.concat,\n     *                  { a: true, values: [10, 20] },\n     *                  { b: true, values: [15, 35] });\n     *      //=> { a: true, b: true, values: [10, 20, 15, 35] }\n     */\n    var mergeWith = _curry3(function mergeWith(fn, l, r) {\n        return mergeWithKey(function (_, _l, _r) {\n            return fn(_l, _r);\n        }, l, r);\n    });\n\n    /**\n     * Takes a function `f` and a list of arguments, and returns a function `g`.\n     * When applied, `g` returns the result of applying `f` to the arguments\n     * provided initially followed by the arguments provided to `g`.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.10.0\n     * @category Function\n     * @sig ((a, b, c, ..., n) -> x) -> [a, b, c, ...] -> ((d, e, f, ..., n) -> x)\n     * @param {Function} f\n     * @param {Array} args\n     * @return {Function}\n     * @see R.partialRight\n     * @example\n     *\n     *      var multiply = (a, b) => a * b;\n     *      var double = R.partial(multiply, [2]);\n     *      double(2); //=> 4\n     *\n     *      var greet = (salutation, title, firstName, lastName) =>\n     *        salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';\n     *\n     *      var sayHello = R.partial(greet, ['Hello']);\n     *      var sayHelloToMs = R.partial(sayHello, ['Ms.']);\n     *      sayHelloToMs('Jane', 'Jones'); //=> 'Hello, Ms. Jane Jones!'\n     */\n    var partial = _createPartialApplicator(_concat);\n\n    /**\n     * Takes a function `f` and a list of arguments, and returns a function `g`.\n     * When applied, `g` returns the result of applying `f` to the arguments\n     * provided to `g` followed by the arguments provided initially.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.10.0\n     * @category Function\n     * @sig ((a, b, c, ..., n) -> x) -> [d, e, f, ..., n] -> ((a, b, c, ...) -> x)\n     * @param {Function} f\n     * @param {Array} args\n     * @return {Function}\n     * @see R.partial\n     * @example\n     *\n     *      var greet = (salutation, title, firstName, lastName) =>\n     *        salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';\n     *\n     *      var greetMsJaneJones = R.partialRight(greet, ['Ms.', 'Jane', 'Jones']);\n     *\n     *      greetMsJaneJones('Hello'); //=> 'Hello, Ms. Jane Jones!'\n     */\n    var partialRight = _createPartialApplicator(flip(_concat));\n\n    /**\n     * Determines whether a nested path on an object has a specific value, in\n     * `R.equals` terms. Most likely used to filter a list.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.7.0\n     * @category Relation\n     * @sig [String] -> * -> {String: *} -> Boolean\n     * @param {Array} path The path of the nested property to use\n     * @param {*} val The value to compare the nested property with\n     * @param {Object} obj The object to check the nested property in\n     * @return {Boolean} `true` if the value equals the nested object property,\n     *         `false` otherwise.\n     * @example\n     *\n     *      var user1 = { address: { zipCode: 90210 } };\n     *      var user2 = { address: { zipCode: 55555 } };\n     *      var user3 = { name: 'Bob' };\n     *      var users = [ user1, user2, user3 ];\n     *      var isFamous = R.pathEq(['address', 'zipCode'], 90210);\n     *      R.filter(isFamous, users); //=> [ user1 ]\n     */\n    var pathEq = _curry3(function pathEq(_path, val, obj) {\n        return equals(path(_path, obj), val);\n    });\n\n    /**\n     * Returns a new list by plucking the same named property off all objects in\n     * the list supplied.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig k -> [{k: v}] -> [v]\n     * @param {Number|String} key The key name to pluck off of each object.\n     * @param {Array} list The array to consider.\n     * @return {Array} The list of values for the given key.\n     * @see R.props\n     * @example\n     *\n     *      R.pluck('a')([{a: 1}, {a: 2}]); //=> [1, 2]\n     *      R.pluck(0)([[1, 2], [3, 4]]);   //=> [1, 3]\n     */\n    var pluck = _curry2(function pluck(p, list) {\n        return map(prop(p), list);\n    });\n\n    /**\n     * Reasonable analog to SQL `select` statement.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Object\n     * @category Relation\n     * @sig [k] -> [{k: v}] -> [{k: v}]\n     * @param {Array} props The property names to project\n     * @param {Array} objs The objects to query\n     * @return {Array} An array of objects with just the `props` properties.\n     * @example\n     *\n     *      var abby = {name: 'Abby', age: 7, hair: 'blond', grade: 2};\n     *      var fred = {name: 'Fred', age: 12, hair: 'brown', grade: 7};\n     *      var kids = [abby, fred];\n     *      R.project(['name', 'grade'], kids); //=> [{name: 'Abby', grade: 2}, {name: 'Fred', grade: 7}]\n     */\n    // passing `identity` gives correct arity\n    var project = useWith(_map, [\n        pickAll,\n        identity\n    ]);\n\n    /**\n     * Returns `true` if the specified object property is equal, in `R.equals`\n     * terms, to the given value; `false` otherwise.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Relation\n     * @sig String -> a -> Object -> Boolean\n     * @param {String} name\n     * @param {*} val\n     * @param {*} obj\n     * @return {Boolean}\n     * @see R.equals, R.propSatisfies\n     * @example\n     *\n     *      var abby = {name: 'Abby', age: 7, hair: 'blond'};\n     *      var fred = {name: 'Fred', age: 12, hair: 'brown'};\n     *      var rusty = {name: 'Rusty', age: 10, hair: 'brown'};\n     *      var alois = {name: 'Alois', age: 15, disposition: 'surly'};\n     *      var kids = [abby, fred, rusty, alois];\n     *      var hasBrownHair = R.propEq('hair', 'brown');\n     *      R.filter(hasBrownHair, kids); //=> [fred, rusty]\n     */\n    var propEq = _curry3(function propEq(name, val, obj) {\n        return propSatisfies(equals(val), name, obj);\n    });\n\n    /**\n     * Returns `true` if the specified object property is of the given type;\n     * `false` otherwise.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.16.0\n     * @category Type\n     * @sig Type -> String -> Object -> Boolean\n     * @param {Function} type\n     * @param {String} name\n     * @param {*} obj\n     * @return {Boolean}\n     * @see R.is, R.propSatisfies\n     * @example\n     *\n     *      R.propIs(Number, 'x', {x: 1, y: 2});  //=> true\n     *      R.propIs(Number, 'x', {x: 'foo'});    //=> false\n     *      R.propIs(Number, 'x', {});            //=> false\n     */\n    var propIs = _curry3(function propIs(type, name, obj) {\n        return propSatisfies(is(type), name, obj);\n    });\n\n    /**\n     * Returns a single item by iterating through the list, successively calling\n     * the iterator function and passing it an accumulator value and the current\n     * value from the array, and then passing the result to the next call.\n     *\n     * The iterator function receives two values: *(acc, value)*. It may use\n     * `R.reduced` to shortcut the iteration.\n     *\n     * Note: `R.reduce` does not skip deleted or unassigned indices (sparse\n     * arrays), unlike the native `Array.prototype.reduce` method. For more details\n     * on this behavior, see:\n     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description\n     *\n     * Dispatches to the `reduce` method of the third argument, if present.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig ((a, b) -> a) -> a -> [b] -> a\n     * @param {Function} fn The iterator function. Receives two values, the accumulator and the\n     *        current element from the array.\n     * @param {*} acc The accumulator value.\n     * @param {Array} list The list to iterate over.\n     * @return {*} The final, accumulated value.\n     * @see R.reduced, R.addIndex\n     * @example\n     *\n     *      var numbers = [1, 2, 3];\n     *      var add = (a, b) => a + b;\n     *\n     *      R.reduce(add, 10, numbers); //=> 16\n     */\n    var reduce = _curry3(_reduce);\n\n    /**\n     * Groups the elements of the list according to the result of calling\n     * the String-returning function `keyFn` on each element and reduces the elements\n     * of each group to a single value via the reducer function `valueFn`.\n     *\n     * This function is basically a more general `groupBy` function.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.20.0\n     * @category List\n     * @sig ((a, b) -> a) -> a -> (b -> String) -> [b] -> {String: a}\n     * @param {Function} valueFn The function that reduces the elements of each group to a single\n     *        value. Receives two values, accumulator for a particular group and the current element.\n     * @param {*} acc The (initial) accumulator value for each group.\n     * @param {Function} keyFn The function that maps the list's element into a key.\n     * @param {Array} list The array to group.\n     * @return {Object} An object with the output of `keyFn` for keys, mapped to the output of\n     *         `valueFn` for elements which produced that key when passed to `keyFn`.\n     * @see R.groupBy, R.reduce\n     * @example\n     *\n     *      var reduceToNamesBy = R.reduceBy((acc, student) => acc.concat(student.name), []);\n     *      var namesByGrade = reduceToNamesBy(function(student) {\n     *        var score = student.score;\n     *        return score < 65 ? 'F' :\n     *               score < 70 ? 'D' :\n     *               score < 80 ? 'C' :\n     *               score < 90 ? 'B' : 'A';\n     *      });\n     *      var students = [{name: 'Lucy', score: 92},\n     *                      {name: 'Drew', score: 85},\n     *                      // ...\n     *                      {name: 'Bart', score: 62}];\n     *      namesByGrade(students);\n     *      // {\n     *      //   'A': ['Lucy'],\n     *      //   'B': ['Drew']\n     *      //   // ...,\n     *      //   'F': ['Bart']\n     *      // }\n     */\n    var reduceBy = _curryN(4, [], function reduceBy(valueFn, valueAcc, keyFn, list) {\n        return _reduce(function (acc, elt) {\n            var key = keyFn(elt);\n            acc[key] = valueFn(_has(key, acc) ? acc[key] : valueAcc, elt);\n            return acc;\n        }, {}, list);\n    });\n\n    /**\n     * The complement of `filter`.\n     *\n     * Acts as a transducer if a transformer is given in list position.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig Filterable f => (a -> Boolean) -> f a -> f a\n     * @param {Function} pred\n     * @param {Array} filterable\n     * @return {Array}\n     * @see R.filter, R.transduce, R.addIndex\n     * @example\n     *\n     *      var isOdd = (n) => n % 2 === 1;\n     *\n     *      R.reject(isOdd, [1, 2, 3, 4]); //=> [2, 4]\n     *\n     *      R.reject(isOdd, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}\n     */\n    var reject = _curry2(function reject(pred, filterable) {\n        return filter(_complement(pred), filterable);\n    });\n\n    /**\n     * Returns a fixed list of size `n` containing a specified identical value.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.1\n     * @category List\n     * @sig a -> n -> [a]\n     * @param {*} value The value to repeat.\n     * @param {Number} n The desired size of the output list.\n     * @return {Array} A new array containing `n` `value`s.\n     * @example\n     *\n     *      R.repeat('hi', 5); //=> ['hi', 'hi', 'hi', 'hi', 'hi']\n     *\n     *      var obj = {};\n     *      var repeatedObjs = R.repeat(obj, 5); //=> [{}, {}, {}, {}, {}]\n     *      repeatedObjs[0] === repeatedObjs[1]; //=> true\n     */\n    var repeat = _curry2(function repeat(value, n) {\n        return times(always(value), n);\n    });\n\n    /**\n     * Adds together all the elements of a list.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Math\n     * @sig [Number] -> Number\n     * @param {Array} list An array of numbers\n     * @return {Number} The sum of all the numbers in the list.\n     * @see R.reduce\n     * @example\n     *\n     *      R.sum([2,4,6,8,100,1]); //=> 121\n     */\n    var sum = reduce(add, 0);\n\n    /**\n     * Returns a new list containing the last `n` elements of the given list.\n     * If `n > list.length`, returns a list of `list.length` elements.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.16.0\n     * @category List\n     * @sig Number -> [a] -> [a]\n     * @sig Number -> String -> String\n     * @param {Number} n The number of elements to return.\n     * @param {Array} xs The collection to consider.\n     * @return {Array}\n     * @see R.dropLast\n     * @example\n     *\n     *      R.takeLast(1, ['foo', 'bar', 'baz']); //=> ['baz']\n     *      R.takeLast(2, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']\n     *      R.takeLast(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']\n     *      R.takeLast(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']\n     *      R.takeLast(3, 'ramda');               //=> 'mda'\n     */\n    var takeLast = _curry2(function takeLast(n, xs) {\n        return drop(n >= 0 ? xs.length - n : 0, xs);\n    });\n\n    /**\n     * Initializes a transducer using supplied iterator function. Returns a single\n     * item by iterating through the list, successively calling the transformed\n     * iterator function and passing it an accumulator value and the current value\n     * from the array, and then passing the result to the next call.\n     *\n     * The iterator function receives two values: *(acc, value)*. It will be\n     * wrapped as a transformer to initialize the transducer. A transformer can be\n     * passed directly in place of an iterator function. In both cases, iteration\n     * may be stopped early with the `R.reduced` function.\n     *\n     * A transducer is a function that accepts a transformer and returns a\n     * transformer and can be composed directly.\n     *\n     * A transformer is an an object that provides a 2-arity reducing iterator\n     * function, step, 0-arity initial value function, init, and 1-arity result\n     * extraction function, result. The step function is used as the iterator\n     * function in reduce. The result function is used to convert the final\n     * accumulator into the return type and in most cases is R.identity. The init\n     * function can be used to provide an initial accumulator, but is ignored by\n     * transduce.\n     *\n     * The iteration is performed with R.reduce after initializing the transducer.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.12.0\n     * @category List\n     * @sig (c -> c) -> (a,b -> a) -> a -> [b] -> a\n     * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.\n     * @param {Function} fn The iterator function. Receives two values, the accumulator and the\n     *        current element from the array. Wrapped as transformer, if necessary, and used to\n     *        initialize the transducer\n     * @param {*} acc The initial accumulator value.\n     * @param {Array} list The list to iterate over.\n     * @return {*} The final, accumulated value.\n     * @see R.reduce, R.reduced, R.into\n     * @example\n     *\n     *      var numbers = [1, 2, 3, 4];\n     *      var transducer = R.compose(R.map(R.add(1)), R.take(2));\n     *\n     *      R.transduce(transducer, R.flip(R.append), [], numbers); //=> [2, 3]\n     */\n    var transduce = curryN(4, function transduce(xf, fn, acc, list) {\n        return _reduce(xf(typeof fn === 'function' ? _xwrap(fn) : fn), acc, list);\n    });\n\n    /**\n     * Combines two lists into a set (i.e. no duplicates) composed of the elements\n     * of each list. Duplication is determined according to the value returned by\n     * applying the supplied predicate to two list elements.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Relation\n     * @sig (a -> a -> Boolean) -> [*] -> [*] -> [*]\n     * @param {Function} pred A predicate used to test whether two items are equal.\n     * @param {Array} list1 The first list.\n     * @param {Array} list2 The second list.\n     * @return {Array} The first and second lists concatenated, with\n     *         duplicates removed.\n     * @see R.union\n     * @example\n     *\n     *      var l1 = [{a: 1}, {a: 2}];\n     *      var l2 = [{a: 1}, {a: 4}];\n     *      R.unionWith(R.eqBy(R.prop('a')), l1, l2); //=> [{a: 1}, {a: 2}, {a: 4}]\n     */\n    var unionWith = _curry3(function unionWith(pred, list1, list2) {\n        return uniqWith(pred, _concat(list1, list2));\n    });\n\n    /**\n     * Takes a spec object and a test object; returns true if the test satisfies\n     * the spec, false otherwise. An object satisfies the spec if, for each of the\n     * spec's own properties, accessing that property of the object gives the same\n     * value (in `R.equals` terms) as accessing that property of the spec.\n     *\n     * `whereEq` is a specialization of [`where`](#where).\n     *\n     * @func\n     * @memberOf R\n     * @since v0.14.0\n     * @category Object\n     * @sig {String: *} -> {String: *} -> Boolean\n     * @param {Object} spec\n     * @param {Object} testObj\n     * @return {Boolean}\n     * @see R.where\n     * @example\n     *\n     *      // pred :: Object -> Boolean\n     *      var pred = R.whereEq({a: 1, b: 2});\n     *\n     *      pred({a: 1});              //=> false\n     *      pred({a: 1, b: 2});        //=> true\n     *      pred({a: 1, b: 2, c: 3});  //=> true\n     *      pred({a: 1, b: 1});        //=> false\n     */\n    var whereEq = _curry2(function whereEq(spec, testObj) {\n        return where(map(equals, spec), testObj);\n    });\n\n    var _flatCat = function () {\n        var preservingReduced = function (xf) {\n            return {\n                '@@transducer/init': _xfBase.init,\n                '@@transducer/result': function (result) {\n                    return xf['@@transducer/result'](result);\n                },\n                '@@transducer/step': function (result, input) {\n                    var ret = xf['@@transducer/step'](result, input);\n                    return ret['@@transducer/reduced'] ? _forceReduced(ret) : ret;\n                }\n            };\n        };\n        return function _xcat(xf) {\n            var rxf = preservingReduced(xf);\n            return {\n                '@@transducer/init': _xfBase.init,\n                '@@transducer/result': function (result) {\n                    return rxf['@@transducer/result'](result);\n                },\n                '@@transducer/step': function (result, input) {\n                    return !isArrayLike(input) ? _reduce(rxf, result, [input]) : _reduce(rxf, result, input);\n                }\n            };\n        };\n    }();\n\n    // Array.prototype.indexOf doesn't exist below IE9\n    // manually crawl the list to distinguish between +0 and -0\n    // NaN\n    // non-zero numbers can utilise Set\n    // all these types can utilise Set\n    // null can utilise Set\n    // anything else not covered above, defer to R.equals\n    var _indexOf = function _indexOf(list, a, idx) {\n        var inf, item;\n        // Array.prototype.indexOf doesn't exist below IE9\n        if (typeof list.indexOf === 'function') {\n            switch (typeof a) {\n            case 'number':\n                if (a === 0) {\n                    // manually crawl the list to distinguish between +0 and -0\n                    inf = 1 / a;\n                    while (idx < list.length) {\n                        item = list[idx];\n                        if (item === 0 && 1 / item === inf) {\n                            return idx;\n                        }\n                        idx += 1;\n                    }\n                    return -1;\n                } else if (a !== a) {\n                    // NaN\n                    while (idx < list.length) {\n                        item = list[idx];\n                        if (typeof item === 'number' && item !== item) {\n                            return idx;\n                        }\n                        idx += 1;\n                    }\n                    return -1;\n                }\n                // non-zero numbers can utilise Set\n                return list.indexOf(a, idx);\n            // all these types can utilise Set\n            case 'string':\n            case 'boolean':\n            case 'function':\n            case 'undefined':\n                return list.indexOf(a, idx);\n            case 'object':\n                if (a === null) {\n                    // null can utilise Set\n                    return list.indexOf(a, idx);\n                }\n            }\n        }\n        // anything else not covered above, defer to R.equals\n        while (idx < list.length) {\n            if (equals(list[idx], a)) {\n                return idx;\n            }\n            idx += 1;\n        }\n        return -1;\n    };\n\n    var _xchain = _curry2(function _xchain(f, xf) {\n        return map(f, _flatCat(xf));\n    });\n\n    /**\n     * Takes a list of predicates and returns a predicate that returns true for a\n     * given list of arguments if every one of the provided predicates is satisfied\n     * by those arguments.\n     *\n     * The function returned is a curried function whose arity matches that of the\n     * highest-arity predicate.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.9.0\n     * @category Logic\n     * @sig [(*... -> Boolean)] -> (*... -> Boolean)\n     * @param {Array} preds\n     * @return {Function}\n     * @see R.anyPass\n     * @example\n     *\n     *      var isQueen = R.propEq('rank', 'Q');\n     *      var isSpade = R.propEq('suit', '');\n     *      var isQueenOfSpades = R.allPass([isQueen, isSpade]);\n     *\n     *      isQueenOfSpades({rank: 'Q', suit: ''}); //=> false\n     *      isQueenOfSpades({rank: 'Q', suit: ''}); //=> true\n     */\n    var allPass = _curry1(function allPass(preds) {\n        return curryN(reduce(max, 0, pluck('length', preds)), function () {\n            var idx = 0;\n            var len = preds.length;\n            while (idx < len) {\n                if (!preds[idx].apply(this, arguments)) {\n                    return false;\n                }\n                idx += 1;\n            }\n            return true;\n        });\n    });\n\n    /**\n     * Returns `true` if all elements are unique, in `R.equals` terms, otherwise\n     * `false`.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.18.0\n     * @category List\n     * @sig [a] -> Boolean\n     * @param {Array} list The array to consider.\n     * @return {Boolean} `true` if all elements are unique, else `false`.\n     * @deprecated since v0.20.0\n     * @example\n     *\n     *      R.allUniq(['1', 1]); //=> true\n     *      R.allUniq([1, 1]);   //=> false\n     *      R.allUniq([[42], [42]]); //=> false\n     */\n    var allUniq = _curry1(function allUniq(list) {\n        var len = list.length;\n        var idx = 0;\n        while (idx < len) {\n            if (_indexOf(list, list[idx], idx + 1) >= 0) {\n                return false;\n            }\n            idx += 1;\n        }\n        return true;\n    });\n\n    /**\n     * Takes a list of predicates and returns a predicate that returns true for a\n     * given list of arguments if at least one of the provided predicates is\n     * satisfied by those arguments.\n     *\n     * The function returned is a curried function whose arity matches that of the\n     * highest-arity predicate.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.9.0\n     * @category Logic\n     * @sig [(*... -> Boolean)] -> (*... -> Boolean)\n     * @param {Array} preds\n     * @return {Function}\n     * @see R.allPass\n     * @example\n     *\n     *      var gte = R.anyPass([R.gt, R.equals]);\n     *\n     *      gte(3, 2); //=> true\n     *      gte(2, 2); //=> true\n     *      gte(2, 3); //=> false\n     */\n    var anyPass = _curry1(function anyPass(preds) {\n        return curryN(reduce(max, 0, pluck('length', preds)), function () {\n            var idx = 0;\n            var len = preds.length;\n            while (idx < len) {\n                if (preds[idx].apply(this, arguments)) {\n                    return true;\n                }\n                idx += 1;\n            }\n            return false;\n        });\n    });\n\n    /**\n     * ap applies a list of functions to a list of values.\n     *\n     * Dispatches to the `ap` method of the second argument, if present. Also\n     * treats functions as applicatives.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.3.0\n     * @category Function\n     * @sig [f] -> [a] -> [f a]\n     * @param {Array} fns An array of functions\n     * @param {Array} vs An array of values\n     * @return {Array} An array of results of applying each of `fns` to all of `vs` in turn.\n     * @example\n     *\n     *      R.ap([R.multiply(2), R.add(3)], [1,2,3]); //=> [2, 4, 6, 4, 5, 6]\n     */\n    // else\n    var ap = _curry2(function ap(applicative, fn) {\n        return typeof applicative.ap === 'function' ? applicative.ap(fn) : typeof applicative === 'function' ? curryN(Math.max(applicative.length, fn.length), function () {\n            return applicative.apply(this, arguments)(fn.apply(this, arguments));\n        }) : // else\n        _reduce(function (acc, f) {\n            return _concat(acc, map(f, fn));\n        }, [], applicative);\n    });\n\n    /**\n     * Given a spec object recursively mapping properties to functions, creates a\n     * function producing an object of the same structure, by mapping each property\n     * to the result of calling its associated function with the supplied arguments.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.20.0\n     * @category Function\n     * @sig {k: ((a, b, ..., m) -> v)} -> ((a, b, ..., m) -> {k: v})\n     * @param {Object} spec an object recursively mapping properties to functions for\n     *        producing the values for these properties.\n     * @return {Function} A function that returns an object of the same structure\n     * as `spec', with each property set to the value returned by calling its\n     * associated function with the supplied arguments.\n     * @see R.juxt\n     * @example\n     *\n     *      var getMetrics = R.applySpec({\n     *                                      sum: R.add,\n     *                                      nested: { mul: R.multiply }\n     *                                   });\n     *      getMetrics(2, 4); // => { sum: 6, nested: { mul: 8 } }\n     */\n    var applySpec = _curry1(function applySpec(spec) {\n        spec = map(function (v) {\n            return typeof v == 'function' ? v : applySpec(v);\n        }, spec);\n        return curryN(reduce(max, 0, pluck('length', values(spec))), function () {\n            var args = arguments;\n            return map(function (f) {\n                return apply(f, args);\n            }, spec);\n        });\n    });\n\n    /**\n     * Returns the result of calling its first argument with the remaining\n     * arguments. This is occasionally useful as a converging function for\n     * `R.converge`: the left branch can produce a function while the right branch\n     * produces a value to be passed to that function as an argument.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.9.0\n     * @category Function\n     * @sig (*... -> a),*... -> a\n     * @param {Function} fn The function to apply to the remaining arguments.\n     * @param {...*} args Any number of positional arguments.\n     * @return {*}\n     * @see R.apply\n     * @example\n     *\n     *      var indentN = R.pipe(R.times(R.always(' ')),\n     *                           R.join(''),\n     *                           R.replace(/^(?!$)/gm));\n     *\n     *      var format = R.converge(R.call, [\n     *                                  R.pipe(R.prop('indent'), indentN),\n     *                                  R.prop('value')\n     *                              ]);\n     *\n     *      format({indent: 2, value: 'foo\\nbar\\nbaz\\n'}); //=> '  foo\\n  bar\\n  baz\\n'\n     */\n    var call = curry(function call(fn) {\n        return fn.apply(this, _slice(arguments, 1));\n    });\n\n    /**\n     * `chain` maps a function over a list and concatenates the results. `chain`\n     * is also known as `flatMap` in some libraries\n     *\n     * Dispatches to the `chain` method of the second argument, if present.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.3.0\n     * @category List\n     * @sig (a -> [b]) -> [a] -> [b]\n     * @param {Function} fn\n     * @param {Array} list\n     * @return {Array}\n     * @example\n     *\n     *      var duplicate = n => [n, n];\n     *      R.chain(duplicate, [1, 2, 3]); //=> [1, 1, 2, 2, 3, 3]\n     */\n    var chain = _curry2(_dispatchable('chain', _xchain, function chain(fn, monad) {\n        if (typeof monad === 'function') {\n            return function () {\n                return monad.call(this, fn.apply(this, arguments)).apply(this, arguments);\n            };\n        }\n        return _makeFlat(false)(map(fn, monad));\n    }));\n\n    /**\n     * Returns a function, `fn`, which encapsulates if/else-if/else logic.\n     * `R.cond` takes a list of [predicate, transform] pairs. All of the arguments\n     * to `fn` are applied to each of the predicates in turn until one returns a\n     * \"truthy\" value, at which point `fn` returns the result of applying its\n     * arguments to the corresponding transformer. If none of the predicates\n     * matches, `fn` returns undefined.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.6.0\n     * @category Logic\n     * @sig [[(*... -> Boolean),(*... -> *)]] -> (*... -> *)\n     * @param {Array} pairs\n     * @return {Function}\n     * @example\n     *\n     *      var fn = R.cond([\n     *        [R.equals(0),   R.always('water freezes at 0C')],\n     *        [R.equals(100), R.always('water boils at 100C')],\n     *        [R.T,           temp => 'nothing special happens at ' + temp + 'C']\n     *      ]);\n     *      fn(0); //=> 'water freezes at 0C'\n     *      fn(50); //=> 'nothing special happens at 50C'\n     *      fn(100); //=> 'water boils at 100C'\n     */\n    var cond = _curry1(function cond(pairs) {\n        var arity = reduce(max, 0, map(function (pair) {\n            return pair[0].length;\n        }, pairs));\n        return _arity(arity, function () {\n            var idx = 0;\n            while (idx < pairs.length) {\n                if (pairs[idx][0].apply(this, arguments)) {\n                    return pairs[idx][1].apply(this, arguments);\n                }\n                idx += 1;\n            }\n        });\n    });\n\n    /**\n     * Wraps a constructor function inside a curried function that can be called\n     * with the same arguments and returns the same type. The arity of the function\n     * returned is specified to allow using variadic constructor functions.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.4.0\n     * @category Function\n     * @sig Number -> (* -> {*}) -> (* -> {*})\n     * @param {Number} n The arity of the constructor function.\n     * @param {Function} Fn The constructor function to wrap.\n     * @return {Function} A wrapped, curried constructor function.\n     * @example\n     *\n     *      // Variadic constructor function\n     *      var Widget = () => {\n     *        this.children = Array.prototype.slice.call(arguments);\n     *        // ...\n     *      };\n     *      Widget.prototype = {\n     *        // ...\n     *      };\n     *      var allConfigs = [\n     *        // ...\n     *      ];\n     *      R.map(R.constructN(1, Widget), allConfigs); // a list of Widgets\n     */\n    var constructN = _curry2(function constructN(n, Fn) {\n        if (n > 10) {\n            throw new Error('Constructor with greater than ten arguments');\n        }\n        if (n === 0) {\n            return function () {\n                return new Fn();\n            };\n        }\n        return curry(nAry(n, function ($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {\n            switch (arguments.length) {\n            case 1:\n                return new Fn($0);\n            case 2:\n                return new Fn($0, $1);\n            case 3:\n                return new Fn($0, $1, $2);\n            case 4:\n                return new Fn($0, $1, $2, $3);\n            case 5:\n                return new Fn($0, $1, $2, $3, $4);\n            case 6:\n                return new Fn($0, $1, $2, $3, $4, $5);\n            case 7:\n                return new Fn($0, $1, $2, $3, $4, $5, $6);\n            case 8:\n                return new Fn($0, $1, $2, $3, $4, $5, $6, $7);\n            case 9:\n                return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8);\n            case 10:\n                return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8, $9);\n            }\n        }));\n    });\n\n    /**\n     * Accepts a converging function and a list of branching functions and returns\n     * a new function. When invoked, this new function is applied to some\n     * arguments, each branching function is applied to those same arguments. The\n     * results of each branching function are passed as arguments to the converging\n     * function to produce the return value.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.4.2\n     * @category Function\n     * @sig (x1 -> x2 -> ... -> z) -> [(a -> b -> ... -> x1), (a -> b -> ... -> x2), ...] -> (a -> b -> ... -> z)\n     * @param {Function} after A function. `after` will be invoked with the return values of\n     *        `fn1` and `fn2` as its arguments.\n     * @param {Array} functions A list of functions.\n     * @return {Function} A new function.\n     * @example\n     *\n     *      var add = (a, b) => a + b;\n     *      var multiply = (a, b) => a * b;\n     *      var subtract = (a, b) => a - b;\n     *\n     *      // multiply( add(1, 2), subtract(1, 2) );\n     *      R.converge(multiply, [add, subtract])(1, 2); //=> -3\n     *\n     *      var add3 = (a, b, c) => a + b + c;\n     *      R.converge(add3, [multiply, add, subtract])(1, 2); //=> 4\n     */\n    var converge = _curry2(function converge(after, fns) {\n        return curryN(reduce(max, 0, pluck('length', fns)), function () {\n            var args = arguments;\n            var context = this;\n            return after.apply(context, _map(function (fn) {\n                return fn.apply(context, args);\n            }, fns));\n        });\n    });\n\n    /**\n     * Counts the elements of a list according to how many match each value of a\n     * key generated by the supplied function. Returns an object mapping the keys\n     * produced by `fn` to the number of occurrences in the list. Note that all\n     * keys are coerced to strings because of how JavaScript objects work.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Relation\n     * @sig (a -> String) -> [a] -> {*}\n     * @param {Function} fn The function used to map values to keys.\n     * @param {Array} list The list to count elements from.\n     * @return {Object} An object mapping keys to number of occurrences in the list.\n     * @example\n     *\n     *      var numbers = [1.0, 1.1, 1.2, 2.0, 3.0, 2.2];\n     *      var letters = R.split('', 'abcABCaaaBBc');\n     *      R.countBy(Math.floor)(numbers);    //=> {'1': 3, '2': 2, '3': 1}\n     *      R.countBy(R.toLower)(letters);   //=> {'a': 5, 'b': 4, 'c': 3}\n     */\n    var countBy = reduceBy(function (acc, elem) {\n        return acc + 1;\n    }, 0);\n\n    /**\n     * Returns a new list without any consecutively repeating elements. Equality is\n     * determined by applying the supplied predicate two consecutive elements. The\n     * first element in a series of equal element is the one being preserved.\n     *\n     * Dispatches to the `dropRepeatsWith` method of the second argument, if present.\n     *\n     * Acts as a transducer if a transformer is given in list position.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.14.0\n     * @category List\n     * @sig (a, a -> Boolean) -> [a] -> [a]\n     * @param {Function} pred A predicate used to test whether two items are equal.\n     * @param {Array} list The array to consider.\n     * @return {Array} `list` without repeating elements.\n     * @see R.transduce\n     * @example\n     *\n     *      var l = [1, -1, 1, 3, 4, -4, -4, -5, 5, 3, 3];\n     *      R.dropRepeatsWith(R.eqBy(Math.abs), l); //=> [1, 3, 4, -5, 3]\n     */\n    var dropRepeatsWith = _curry2(_dispatchable('dropRepeatsWith', _xdropRepeatsWith, function dropRepeatsWith(pred, list) {\n        var result = [];\n        var idx = 1;\n        var len = list.length;\n        if (len !== 0) {\n            result[0] = list[0];\n            while (idx < len) {\n                if (!pred(last(result), list[idx])) {\n                    result[result.length] = list[idx];\n                }\n                idx += 1;\n            }\n        }\n        return result;\n    }));\n\n    /**\n     * Takes a function and two values in its domain and returns `true` if the\n     * values map to the same value in the codomain; `false` otherwise.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.18.0\n     * @category Relation\n     * @sig (a -> b) -> a -> a -> Boolean\n     * @param {Function} f\n     * @param {*} x\n     * @param {*} y\n     * @return {Boolean}\n     * @example\n     *\n     *      R.eqBy(Math.abs, 5, -5); //=> true\n     */\n    var eqBy = _curry3(function eqBy(f, x, y) {\n        return equals(f(x), f(y));\n    });\n\n    /**\n     * Reports whether two objects have the same value, in `R.equals` terms, for\n     * the specified property. Useful as a curried predicate.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Object\n     * @sig k -> {k: v} -> {k: v} -> Boolean\n     * @param {String} prop The name of the property to compare\n     * @param {Object} obj1\n     * @param {Object} obj2\n     * @return {Boolean}\n     *\n     * @example\n     *\n     *      var o1 = { a: 1, b: 2, c: 3, d: 4 };\n     *      var o2 = { a: 10, b: 20, c: 3, d: 40 };\n     *      R.eqProps('a', o1, o2); //=> false\n     *      R.eqProps('c', o1, o2); //=> true\n     */\n    var eqProps = _curry3(function eqProps(prop, obj1, obj2) {\n        return equals(obj1[prop], obj2[prop]);\n    });\n\n    /**\n     * Splits a list into sub-lists stored in an object, based on the result of\n     * calling a String-returning function on each element, and grouping the\n     * results according to values returned.\n     *\n     * Dispatches to the `groupBy` method of the second argument, if present.\n     *\n     * Acts as a transducer if a transformer is given in list position.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig (a -> String) -> [a] -> {String: [a]}\n     * @param {Function} fn Function :: a -> String\n     * @param {Array} list The array to group\n     * @return {Object} An object with the output of `fn` for keys, mapped to arrays of elements\n     *         that produced that key when passed to `fn`.\n     * @see R.transduce\n     * @example\n     *\n     *      var byGrade = R.groupBy(function(student) {\n     *        var score = student.score;\n     *        return score < 65 ? 'F' :\n     *               score < 70 ? 'D' :\n     *               score < 80 ? 'C' :\n     *               score < 90 ? 'B' : 'A';\n     *      });\n     *      var students = [{name: 'Abby', score: 84},\n     *                      {name: 'Eddy', score: 58},\n     *                      // ...\n     *                      {name: 'Jack', score: 69}];\n     *      byGrade(students);\n     *      // {\n     *      //   'A': [{name: 'Dianne', score: 99}],\n     *      //   'B': [{name: 'Abby', score: 84}]\n     *      //   // ...,\n     *      //   'F': [{name: 'Eddy', score: 58}]\n     *      // }\n     */\n    var groupBy = _curry2(_dispatchable('groupBy', _xgroupBy, reduceBy(function (acc, item) {\n        if (acc == null) {\n            acc = [];\n        }\n        acc.push(item);\n        return acc;\n    }, null)));\n\n    /**\n     * Given a function that generates a key, turns a list of objects into an\n     * object indexing the objects by the given key. Note that if multiple\n     * objects generate the same value for the indexing key only the last value\n     * will be included in the generated object.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.19.0\n     * @category List\n     * @sig (a -> String) -> [{k: v}] -> {k: {k: v}}\n     * @param {Function} fn Function :: a -> String\n     * @param {Array} array The array of objects to index\n     * @return {Object} An object indexing each array element by the given property.\n     * @example\n     *\n     *      var list = [{id: 'xyz', title: 'A'}, {id: 'abc', title: 'B'}];\n     *      R.indexBy(R.prop('id'), list);\n     *      //=> {abc: {id: 'abc', title: 'B'}, xyz: {id: 'xyz', title: 'A'}}\n     */\n    var indexBy = reduceBy(function (acc, elem) {\n        return elem;\n    }, null);\n\n    /**\n     * Returns the position of the first occurrence of an item in an array, or -1\n     * if the item is not included in the array. `R.equals` is used to determine\n     * equality.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig a -> [a] -> Number\n     * @param {*} target The item to find.\n     * @param {Array} xs The array to search in.\n     * @return {Number} the index of the target, or -1 if the target is not found.\n     * @see R.lastIndexOf\n     * @example\n     *\n     *      R.indexOf(3, [1,2,3,4]); //=> 2\n     *      R.indexOf(10, [1,2,3,4]); //=> -1\n     */\n    var indexOf = _curry2(function indexOf(target, xs) {\n        return typeof xs.indexOf === 'function' && !_isArray(xs) ? xs.indexOf(target) : _indexOf(xs, target, 0);\n    });\n\n    /**\n     * juxt applies a list of functions to a list of values.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.19.0\n     * @category Function\n     * @sig [(a, b, ..., m) -> n] -> ((a, b, ..., m) -> [n])\n     * @param {Array} fns An array of functions\n     * @return {Function} A function that returns a list of values after applying each of the original `fns` to its parameters.\n     * @see R.applySpec\n     * @example\n     *\n     *      var range = R.juxt([Math.min, Math.max]);\n     *      range(3, 4, 9, -3); //=> [-3, 9]\n     */\n    var juxt = _curry1(function juxt(fns) {\n        return converge(_arrayOf, fns);\n    });\n\n    /**\n     * Returns a lens for the given getter and setter functions. The getter \"gets\"\n     * the value of the focus; the setter \"sets\" the value of the focus. The setter\n     * should not mutate the data structure.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.8.0\n     * @category Object\n     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s\n     * @sig (s -> a) -> ((a, s) -> s) -> Lens s a\n     * @param {Function} getter\n     * @param {Function} setter\n     * @return {Lens}\n     * @see R.view, R.set, R.over, R.lensIndex, R.lensProp\n     * @example\n     *\n     *      var xLens = R.lens(R.prop('x'), R.assoc('x'));\n     *\n     *      R.view(xLens, {x: 1, y: 2});            //=> 1\n     *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}\n     *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}\n     */\n    var lens = _curry2(function lens(getter, setter) {\n        return function (toFunctorFn) {\n            return function (target) {\n                return map(function (focus) {\n                    return setter(focus, target);\n                }, toFunctorFn(getter(target)));\n            };\n        };\n    });\n\n    /**\n     * Returns a lens whose focus is the specified index.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.14.0\n     * @category Object\n     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s\n     * @sig Number -> Lens s a\n     * @param {Number} n\n     * @return {Lens}\n     * @see R.view, R.set, R.over\n     * @example\n     *\n     *      var headLens = R.lensIndex(0);\n     *\n     *      R.view(headLens, ['a', 'b', 'c']);            //=> 'a'\n     *      R.set(headLens, 'x', ['a', 'b', 'c']);        //=> ['x', 'b', 'c']\n     *      R.over(headLens, R.toUpper, ['a', 'b', 'c']); //=> ['A', 'b', 'c']\n     */\n    var lensIndex = _curry1(function lensIndex(n) {\n        return lens(nth(n), update(n));\n    });\n\n    /**\n     * Returns a lens whose focus is the specified path.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.19.0\n     * @category Object\n     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s\n     * @sig [String] -> Lens s a\n     * @param {Array} path The path to use.\n     * @return {Lens}\n     * @see R.view, R.set, R.over\n     * @example\n     *\n     *      var xyLens = R.lensPath(['x', 'y']);\n     *\n     *      R.view(xyLens, {x: {y: 2, z: 3}});            //=> 2\n     *      R.set(xyLens, 4, {x: {y: 2, z: 3}});          //=> {x: {y: 4, z: 3}}\n     *      R.over(xyLens, R.negate, {x: {y: 2, z: 3}});  //=> {x: {y: -2, z: 3}}\n     */\n    var lensPath = _curry1(function lensPath(p) {\n        return lens(path(p), assocPath(p));\n    });\n\n    /**\n     * Returns a lens whose focus is the specified property.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.14.0\n     * @category Object\n     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s\n     * @sig String -> Lens s a\n     * @param {String} k\n     * @return {Lens}\n     * @see R.view, R.set, R.over\n     * @example\n     *\n     *      var xLens = R.lensProp('x');\n     *\n     *      R.view(xLens, {x: 1, y: 2});            //=> 1\n     *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}\n     *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}\n     */\n    var lensProp = _curry1(function lensProp(k) {\n        return lens(prop(k), assoc(k));\n    });\n\n    /**\n     * \"lifts\" a function to be the specified arity, so that it may \"map over\" that\n     * many lists, Functions or other objects that satisfy the [FantasyLand Apply spec](https://github.com/fantasyland/fantasy-land#apply).\n     *\n     * @func\n     * @memberOf R\n     * @since v0.7.0\n     * @category Function\n     * @sig Number -> (*... -> *) -> ([*]... -> [*])\n     * @param {Function} fn The function to lift into higher context\n     * @return {Function} The lifted function.\n     * @see R.lift, R.ap\n     * @example\n     *\n     *      var madd3 = R.liftN(3, R.curryN(3, (...args) => R.sum(args)));\n     *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]\n     */\n    var liftN = _curry2(function liftN(arity, fn) {\n        var lifted = curryN(arity, fn);\n        return curryN(arity, function () {\n            return _reduce(ap, map(lifted, arguments[0]), _slice(arguments, 1));\n        });\n    });\n\n    /**\n     * Returns the mean of the given list of numbers.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.14.0\n     * @category Math\n     * @sig [Number] -> Number\n     * @param {Array} list\n     * @return {Number}\n     * @example\n     *\n     *      R.mean([2, 7, 9]); //=> 6\n     *      R.mean([]); //=> NaN\n     */\n    var mean = _curry1(function mean(list) {\n        return sum(list) / list.length;\n    });\n\n    /**\n     * Returns the median of the given list of numbers.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.14.0\n     * @category Math\n     * @sig [Number] -> Number\n     * @param {Array} list\n     * @return {Number}\n     * @example\n     *\n     *      R.median([2, 9, 7]); //=> 7\n     *      R.median([7, 2, 10, 9]); //=> 8\n     *      R.median([]); //=> NaN\n     */\n    var median = _curry1(function median(list) {\n        var len = list.length;\n        if (len === 0) {\n            return NaN;\n        }\n        var width = 2 - len % 2;\n        var idx = (len - width) / 2;\n        return mean(_slice(list).sort(function (a, b) {\n            return a < b ? -1 : a > b ? 1 : 0;\n        }).slice(idx, idx + width));\n    });\n\n    /**\n     * Takes a predicate and a list or other \"filterable\" object and returns the\n     * pair of filterable objects of the same type of elements which do and do not\n     * satisfy, the predicate, respectively.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.4\n     * @category List\n     * @sig Filterable f => (a -> Boolean) -> f a -> [f a, f a]\n     * @param {Function} pred A predicate to determine which side the element belongs to.\n     * @param {Array} filterable the list (or other filterable) to partition.\n     * @return {Array} An array, containing first the subset of elements that satisfy the\n     *         predicate, and second the subset of elements that do not satisfy.\n     * @see R.filter, R.reject\n     * @example\n     *\n     *      R.partition(R.contains('s'), ['sss', 'ttt', 'foo', 'bars']);\n     *      // => [ [ 'sss', 'bars' ],  [ 'ttt', 'foo' ] ]\n     *\n     *      R.partition(R.contains('s'), { a: 'sss', b: 'ttt', foo: 'bars' });\n     *      // => [ { a: 'sss', foo: 'bars' }, { b: 'ttt' }  ]\n     */\n    var partition = juxt([\n        filter,\n        reject\n    ]);\n\n    /**\n     * Performs left-to-right function composition. The leftmost function may have\n     * any arity; the remaining functions must be unary.\n     *\n     * In some libraries this function is named `sequence`.\n     *\n     * **Note:** The result of pipe is not automatically curried.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Function\n     * @sig (((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)) -> ((a, b, ..., n) -> z)\n     * @param {...Function} functions\n     * @return {Function}\n     * @see R.compose\n     * @example\n     *\n     *      var f = R.pipe(Math.pow, R.negate, R.inc);\n     *\n     *      f(3, 4); // -(3^4) + 1\n     */\n    var pipe = function pipe() {\n        if (arguments.length === 0) {\n            throw new Error('pipe requires at least one argument');\n        }\n        return _arity(arguments[0].length, reduce(_pipe, arguments[0], tail(arguments)));\n    };\n\n    /**\n     * Performs left-to-right composition of one or more Promise-returning\n     * functions. The leftmost function may have any arity; the remaining functions\n     * must be unary.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.10.0\n     * @category Function\n     * @sig ((a -> Promise b), (b -> Promise c), ..., (y -> Promise z)) -> (a -> Promise z)\n     * @param {...Function} functions\n     * @return {Function}\n     * @see R.composeP\n     * @example\n     *\n     *      //  followersForUser :: String -> Promise [User]\n     *      var followersForUser = R.pipeP(db.getUserById, db.getFollowers);\n     */\n    var pipeP = function pipeP() {\n        if (arguments.length === 0) {\n            throw new Error('pipeP requires at least one argument');\n        }\n        return _arity(arguments[0].length, reduce(_pipeP, arguments[0], tail(arguments)));\n    };\n\n    /**\n     * Multiplies together all the elements of a list.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Math\n     * @sig [Number] -> Number\n     * @param {Array} list An array of numbers\n     * @return {Number} The product of all the numbers in the list.\n     * @see R.reduce\n     * @example\n     *\n     *      R.product([2,4,6,8,100,1]); //=> 38400\n     */\n    var product = reduce(multiply, 1);\n\n    /**\n     * Transforms a [Traversable](https://github.com/fantasyland/fantasy-land#traversable)\n     * of [Applicative](https://github.com/fantasyland/fantasy-land#applicative) into an\n     * Applicative of Traversable.\n     *\n     * Dispatches to the `sequence` method of the second argument, if present.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.19.0\n     * @category List\n     * @sig (Applicative f, Traversable t) => (a -> f a) -> t (f a) -> f (t a)\n     * @param {Function} of\n     * @param {*} traversable\n     * @return {*}\n     * @see R.traverse\n     * @example\n     *\n     *      R.sequence(Maybe.of, [Just(1), Just(2), Just(3)]);   //=> Just([1, 2, 3])\n     *      R.sequence(Maybe.of, [Just(1), Just(2), Nothing()]); //=> Nothing()\n     *\n     *      R.sequence(R.of, Just([1, 2, 3])); //=> [Just(1), Just(2), Just(3)]\n     *      R.sequence(R.of, Nothing());       //=> [Nothing()]\n     */\n    var sequence = _curry2(function sequence(of, traversable) {\n        return typeof traversable.sequence === 'function' ? traversable.sequence(of) : reduceRight(function (acc, x) {\n            return ap(map(prepend, x), acc);\n        }, of([]), traversable);\n    });\n\n    /**\n     * Maps an [Applicative](https://github.com/fantasyland/fantasy-land#applicative)-returning\n     * function over a [Traversable](https://github.com/fantasyland/fantasy-land#traversable),\n     * then uses [`sequence`](#sequence) to transform the resulting Traversable of Applicative\n     * into an Applicative of Traversable.\n     *\n     * Dispatches to the `sequence` method of the third argument, if present.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.19.0\n     * @category List\n     * @sig (Applicative f, Traversable t) => (a -> f a) -> (a -> f b) -> t a -> f (t b)\n     * @param {Function} of\n     * @param {Function} f\n     * @param {*} traversable\n     * @return {*}\n     * @see R.sequence\n     * @example\n     *\n     *      // Returns `Nothing` if the given divisor is `0`\n     *      safeDiv = n => d => d === 0 ? Nothing() : Just(n / d)\n     *\n     *      R.traverse(Maybe.of, safeDiv(10), [2, 4, 5]); //=> Just([5, 2.5, 2])\n     *      R.traverse(Maybe.of, safeDiv(10), [2, 0, 5]); //=> Nothing\n     */\n    var traverse = _curry3(function traverse(of, f, traversable) {\n        return sequence(of, map(f, traversable));\n    });\n\n    /**\n     * Shorthand for `R.chain(R.identity)`, which removes one level of nesting from\n     * any [Chain](https://github.com/fantasyland/fantasy-land#chain).\n     *\n     * @func\n     * @memberOf R\n     * @since v0.3.0\n     * @category List\n     * @sig Chain c => c (c a) -> c a\n     * @param {*} list\n     * @return {*}\n     * @see R.flatten, R.chain\n     * @example\n     *\n     *      R.unnest([1, [2], [[3]]]); //=> [1, 2, [3]]\n     *      R.unnest([[1, 2], [3, 4], [5, 6]]); //=> [1, 2, 3, 4, 5, 6]\n     */\n    var unnest = chain(_identity);\n\n    var _contains = function _contains(a, list) {\n        return _indexOf(list, a, 0) >= 0;\n    };\n\n    //  mapPairs :: (Object, [String]) -> [String]\n    var _toString = function _toString(x, seen) {\n        var recur = function recur(y) {\n            var xs = seen.concat([x]);\n            return _contains(y, xs) ? '<Circular>' : _toString(y, xs);\n        };\n        //  mapPairs :: (Object, [String]) -> [String]\n        var mapPairs = function (obj, keys) {\n            return _map(function (k) {\n                return _quote(k) + ': ' + recur(obj[k]);\n            }, keys.slice().sort());\n        };\n        switch (Object.prototype.toString.call(x)) {\n        case '[object Arguments]':\n            return '(function() { return arguments; }(' + _map(recur, x).join(', ') + '))';\n        case '[object Array]':\n            return '[' + _map(recur, x).concat(mapPairs(x, reject(function (k) {\n                return /^\\d+$/.test(k);\n            }, keys(x)))).join(', ') + ']';\n        case '[object Boolean]':\n            return typeof x === 'object' ? 'new Boolean(' + recur(x.valueOf()) + ')' : x.toString();\n        case '[object Date]':\n            return 'new Date(' + (isNaN(x.valueOf()) ? recur(NaN) : _quote(_toISOString(x))) + ')';\n        case '[object Null]':\n            return 'null';\n        case '[object Number]':\n            return typeof x === 'object' ? 'new Number(' + recur(x.valueOf()) + ')' : 1 / x === -Infinity ? '-0' : x.toString(10);\n        case '[object String]':\n            return typeof x === 'object' ? 'new String(' + recur(x.valueOf()) + ')' : _quote(x);\n        case '[object Undefined]':\n            return 'undefined';\n        default:\n            if (typeof x.toString === 'function') {\n                var repr = x.toString();\n                if (repr !== '[object Object]') {\n                    return repr;\n                }\n            }\n            return '{' + mapPairs(x, keys(x)).join(', ') + '}';\n        }\n    };\n\n    /**\n     * Performs right-to-left function composition. The rightmost function may have\n     * any arity; the remaining functions must be unary.\n     *\n     * **Note:** The result of compose is not automatically curried.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Function\n     * @sig ((y -> z), (x -> y), ..., (o -> p), ((a, b, ..., n) -> o)) -> ((a, b, ..., n) -> z)\n     * @param {...Function} functions\n     * @return {Function}\n     * @see R.pipe\n     * @example\n     *\n     *      var f = R.compose(R.inc, R.negate, Math.pow);\n     *\n     *      f(3, 4); // -(3^4) + 1\n     */\n    var compose = function compose() {\n        if (arguments.length === 0) {\n            throw new Error('compose requires at least one argument');\n        }\n        return pipe.apply(this, reverse(arguments));\n    };\n\n    /**\n     * Returns the right-to-left Kleisli composition of the provided functions,\n     * each of which must return a value of a type supported by [`chain`](#chain).\n     *\n     * `R.composeK(h, g, f)` is equivalent to `R.compose(R.chain(h), R.chain(g), R.chain(f))`.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.16.0\n     * @category Function\n     * @sig Chain m => ((y -> m z), (x -> m y), ..., (a -> m b)) -> (m a -> m z)\n     * @param {...Function}\n     * @return {Function}\n     * @see R.pipeK\n     * @example\n     *\n     *      //  parseJson :: String -> Maybe *\n     *      //  get :: String -> Object -> Maybe *\n     *\n     *      //  getStateCode :: Maybe String -> Maybe String\n     *      var getStateCode = R.composeK(\n     *        R.compose(Maybe.of, R.toUpper),\n     *        get('state'),\n     *        get('address'),\n     *        get('user'),\n     *        parseJson\n     *      );\n     *\n     *      getStateCode(Maybe.of('{\"user\":{\"address\":{\"state\":\"ny\"}}}'));\n     *      //=> Just('NY')\n     *      getStateCode(Maybe.of('[Invalid JSON]'));\n     *      //=> Nothing()\n     */\n    var composeK = function composeK() {\n        return compose.apply(this, prepend(identity, map(chain, arguments)));\n    };\n\n    /**\n     * Performs right-to-left composition of one or more Promise-returning\n     * functions. The rightmost function may have any arity; the remaining\n     * functions must be unary.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.10.0\n     * @category Function\n     * @sig ((y -> Promise z), (x -> Promise y), ..., (a -> Promise b)) -> (a -> Promise z)\n     * @param {...Function} functions\n     * @return {Function}\n     * @see R.pipeP\n     * @example\n     *\n     *      //  followersForUser :: String -> Promise [User]\n     *      var followersForUser = R.composeP(db.getFollowers, db.getUserById);\n     */\n    var composeP = function composeP() {\n        if (arguments.length === 0) {\n            throw new Error('composeP requires at least one argument');\n        }\n        return pipeP.apply(this, reverse(arguments));\n    };\n\n    /**\n     * Wraps a constructor function inside a curried function that can be called\n     * with the same arguments and returns the same type.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Function\n     * @sig (* -> {*}) -> (* -> {*})\n     * @param {Function} Fn The constructor function to wrap.\n     * @return {Function} A wrapped, curried constructor function.\n     * @example\n     *\n     *      // Constructor function\n     *      var Widget = config => {\n     *        // ...\n     *      };\n     *      Widget.prototype = {\n     *        // ...\n     *      };\n     *      var allConfigs = [\n     *        // ...\n     *      ];\n     *      R.map(R.construct(Widget), allConfigs); // a list of Widgets\n     */\n    var construct = _curry1(function construct(Fn) {\n        return constructN(Fn.length, Fn);\n    });\n\n    /**\n     * Returns `true` if the specified value is equal, in `R.equals` terms, to at\n     * least one element of the given list; `false` otherwise.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig a -> [a] -> Boolean\n     * @param {Object} a The item to compare against.\n     * @param {Array} list The array to consider.\n     * @return {Boolean} `true` if the item is in the list, `false` otherwise.\n     * @see R.any\n     * @example\n     *\n     *      R.contains(3, [1, 2, 3]); //=> true\n     *      R.contains(4, [1, 2, 3]); //=> false\n     *      R.contains([42], [[42]]); //=> true\n     */\n    var contains = _curry2(_contains);\n\n    /**\n     * Finds the set (i.e. no duplicates) of all elements in the first list not\n     * contained in the second list.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Relation\n     * @sig [*] -> [*] -> [*]\n     * @param {Array} list1 The first list.\n     * @param {Array} list2 The second list.\n     * @return {Array} The elements in `list1` that are not in `list2`.\n     * @see R.differenceWith\n     * @example\n     *\n     *      R.difference([1,2,3,4], [7,6,5,4,3]); //=> [1,2]\n     *      R.difference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5]\n     */\n    var difference = _curry2(function difference(first, second) {\n        var out = [];\n        var idx = 0;\n        var firstLen = first.length;\n        while (idx < firstLen) {\n            if (!_contains(first[idx], second) && !_contains(first[idx], out)) {\n                out[out.length] = first[idx];\n            }\n            idx += 1;\n        }\n        return out;\n    });\n\n    /**\n     * Returns a new list without any consecutively repeating elements. `R.equals`\n     * is used to determine equality.\n     *\n     * Dispatches to the `dropRepeats` method of the first argument, if present.\n     *\n     * Acts as a transducer if a transformer is given in list position.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.14.0\n     * @category List\n     * @sig [a] -> [a]\n     * @param {Array} list The array to consider.\n     * @return {Array} `list` without repeating elements.\n     * @see R.transduce\n     * @example\n     *\n     *     R.dropRepeats([1, 1, 1, 2, 3, 4, 4, 2, 2]); //=> [1, 2, 3, 4, 2]\n     */\n    var dropRepeats = _curry1(_dispatchable('dropRepeats', _xdropRepeatsWith(equals), dropRepeatsWith(equals)));\n\n    /**\n     * \"lifts\" a function of arity > 1 so that it may \"map over\" a list, Function or other\n     * object that satisfies the [FantasyLand Apply spec](https://github.com/fantasyland/fantasy-land#apply).\n     *\n     * @func\n     * @memberOf R\n     * @since v0.7.0\n     * @category Function\n     * @sig (*... -> *) -> ([*]... -> [*])\n     * @param {Function} fn The function to lift into higher context\n     * @return {Function} The lifted function.\n     * @see R.liftN\n     * @example\n     *\n     *      var madd3 = R.lift(R.curry((a, b, c) => a + b + c));\n     *\n     *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]\n     *\n     *      var madd5 = R.lift(R.curry((a, b, c, d, e) => a + b + c + d + e));\n     *\n     *      madd5([1,2], [3], [4, 5], [6], [7, 8]); //=> [21, 22, 22, 23, 22, 23, 23, 24]\n     */\n    var lift = _curry1(function lift(fn) {\n        return liftN(fn.length, fn);\n    });\n\n    /**\n     * Returns a partial copy of an object omitting the keys specified.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Object\n     * @sig [String] -> {String: *} -> {String: *}\n     * @param {Array} names an array of String property names to omit from the new object\n     * @param {Object} obj The object to copy from\n     * @return {Object} A new object with properties from `names` not on it.\n     * @see R.pick\n     * @example\n     *\n     *      R.omit(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, c: 3}\n     */\n    var omit = _curry2(function omit(names, obj) {\n        var result = {};\n        for (var prop in obj) {\n            if (!_contains(prop, names)) {\n                result[prop] = obj[prop];\n            }\n        }\n        return result;\n    });\n\n    /**\n     * Returns the left-to-right Kleisli composition of the provided functions,\n     * each of which must return a value of a type supported by [`chain`](#chain).\n     *\n     * `R.pipeK(f, g, h)` is equivalent to `R.pipe(R.chain(f), R.chain(g), R.chain(h))`.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.16.0\n     * @category Function\n     * @sig Chain m => ((a -> m b), (b -> m c), ..., (y -> m z)) -> (m a -> m z)\n     * @param {...Function}\n     * @return {Function}\n     * @see R.composeK\n     * @example\n     *\n     *      //  parseJson :: String -> Maybe *\n     *      //  get :: String -> Object -> Maybe *\n     *\n     *      //  getStateCode :: Maybe String -> Maybe String\n     *      var getStateCode = R.pipeK(\n     *        parseJson,\n     *        get('user'),\n     *        get('address'),\n     *        get('state'),\n     *        R.compose(Maybe.of, R.toUpper)\n     *      );\n     *\n     *      getStateCode(Maybe.of('{\"user\":{\"address\":{\"state\":\"ny\"}}}'));\n     *      //=> Just('NY')\n     *      getStateCode(Maybe.of('[Invalid JSON]'));\n     *      //=> Nothing()\n     */\n    var pipeK = function pipeK() {\n        return composeK.apply(this, reverse(arguments));\n    };\n\n    /**\n     * Returns the string representation of the given value. `eval`'ing the output\n     * should result in a value equivalent to the input value. Many of the built-in\n     * `toString` methods do not satisfy this requirement.\n     *\n     * If the given value is an `[object Object]` with a `toString` method other\n     * than `Object.prototype.toString`, this method is invoked with no arguments\n     * to produce the return value. This means user-defined constructor functions\n     * can provide a suitable `toString` method. For example:\n     *\n     *     function Point(x, y) {\n     *       this.x = x;\n     *       this.y = y;\n     *     }\n     *\n     *     Point.prototype.toString = function() {\n     *       return 'new Point(' + this.x + ', ' + this.y + ')';\n     *     };\n     *\n     *     R.toString(new Point(1, 2)); //=> 'new Point(1, 2)'\n     *\n     * @func\n     * @memberOf R\n     * @since v0.14.0\n     * @category String\n     * @sig * -> String\n     * @param {*} val\n     * @return {String}\n     * @example\n     *\n     *      R.toString(42); //=> '42'\n     *      R.toString('abc'); //=> '\"abc\"'\n     *      R.toString([1, 2, 3]); //=> '[1, 2, 3]'\n     *      R.toString({foo: 1, bar: 2, baz: 3}); //=> '{\"bar\": 2, \"baz\": 3, \"foo\": 1}'\n     *      R.toString(new Date('2001-02-03T04:05:06Z')); //=> 'new Date(\"2001-02-03T04:05:06.000Z\")'\n     */\n    var toString = _curry1(function toString(val) {\n        return _toString(val, []);\n    });\n\n    /**\n     * Returns a new list without values in the first argument.\n     * `R.equals` is used to determine equality.\n     *\n     * Acts as a transducer if a transformer is given in list position.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.19.0\n     * @category List\n     * @sig [a] -> [a] -> [a]\n     * @param {Array} list1 The values to be removed from `list2`.\n     * @param {Array} list2 The array to remove values from.\n     * @return {Array} The new array without values in `list1`.\n     * @see R.transduce\n     * @example\n     *\n     *      R.without([1, 2], [1, 2, 1, 3, 4]); //=> [3, 4]\n     */\n    var without = _curry2(function (xs, list) {\n        return reject(flip(_contains)(xs), list);\n    });\n\n    // A simple Set type that honours R.equals semantics\n    /* globals Set */\n    /**\n       * Combines the logic for checking whether an item is a member of the set and\n       * for adding a new item to the set.\n       *\n       * @param item       The item to check or add to the Set instance.\n       * @param shouldAdd  If true, the item will be added to the set if it doesn't\n       *                   already exist.\n       * @param set        The set instance to check or add to.\n       * @return {boolean} When shouldAdd is true, this will return true when a new\n       *                   item was added otherwise false. When shouldAdd is false,\n       *                   this will return true if the item already exists, otherwise\n       *                   false.\n       */\n    // distinguish between +0 and -0\n    // these types can all utilise Set\n    // set._items['boolean'] holds a two element array\n    // representing [ falseExists, trueExists ]\n    // compare functions for reference equality\n    /* falls through */\n    // reduce the search size of heterogeneous sets by creating buckets\n    // for each type.\n    // scan through all previously applied items\n    var _Set = function () {\n        function _Set() {\n            /* globals Set */\n            this._nativeSet = typeof Set === 'function' ? new Set() : null;\n            this._items = {};\n        }\n        _Set.prototype.add = function (item) {\n            return hasOrAdd(item, true, this);\n        };\n        _Set.prototype.has = function (item) {\n            return hasOrAdd(item, false, this);\n        };\n        /**\n       * Combines the logic for checking whether an item is a member of the set and\n       * for adding a new item to the set.\n       *\n       * @param item       The item to check or add to the Set instance.\n       * @param shouldAdd  If true, the item will be added to the set if it doesn't\n       *                   already exist.\n       * @param set        The set instance to check or add to.\n       * @return {boolean} When shouldAdd is true, this will return true when a new\n       *                   item was added otherwise false. When shouldAdd is false,\n       *                   this will return true if the item already exists, otherwise\n       *                   false.\n       */\n        function hasOrAdd(item, shouldAdd, set) {\n            var type = typeof item;\n            var prevSize, newSize;\n            switch (type) {\n            case 'string':\n            case 'number':\n                // distinguish between +0 and -0\n                if (item === 0 && !set._items['-0'] && 1 / item === -Infinity) {\n                    if (shouldAdd) {\n                        set._items['-0'] = true;\n                    }\n                    return shouldAdd;\n                }\n                // these types can all utilise Set\n                if (set._nativeSet !== null) {\n                    if (shouldAdd) {\n                        prevSize = set._nativeSet.size;\n                        set._nativeSet.add(item);\n                        newSize = set._nativeSet.size;\n                        return newSize > prevSize;\n                    } else {\n                        return set._nativeSet.has(item);\n                    }\n                } else {\n                    if (!(type in set._items)) {\n                        if (shouldAdd) {\n                            set._items[type] = {};\n                            set._items[type][item] = true;\n                        }\n                        return shouldAdd;\n                    } else if (item in set._items[type]) {\n                        return !shouldAdd;\n                    } else {\n                        if (shouldAdd) {\n                            set._items[type][item] = true;\n                        }\n                        return shouldAdd;\n                    }\n                }\n            case 'boolean':\n                // set._items['boolean'] holds a two element array\n                // representing [ falseExists, trueExists ]\n                if (type in set._items) {\n                    var bIdx = item ? 1 : 0;\n                    if (set._items[type][bIdx]) {\n                        return !shouldAdd;\n                    } else {\n                        if (shouldAdd) {\n                            set._items[type][bIdx] = true;\n                        }\n                        return shouldAdd;\n                    }\n                } else {\n                    if (shouldAdd) {\n                        set._items[type] = item ? [\n                            false,\n                            true\n                        ] : [\n                            true,\n                            false\n                        ];\n                    }\n                    return shouldAdd;\n                }\n            case 'function':\n                // compare functions for reference equality\n                if (set._nativeSet !== null) {\n                    if (shouldAdd) {\n                        prevSize = set._nativeSet.size;\n                        set._nativeSet.add(item);\n                        newSize = set._nativeSet.size;\n                        return newSize > prevSize;\n                    } else {\n                        return set._nativeSet.has(item);\n                    }\n                } else {\n                    if (!(type in set._items)) {\n                        if (shouldAdd) {\n                            set._items[type] = [item];\n                        }\n                        return shouldAdd;\n                    }\n                    if (!_contains(item, set._items[type])) {\n                        if (shouldAdd) {\n                            set._items[type].push(item);\n                        }\n                        return shouldAdd;\n                    }\n                }\n                return !shouldAdd;\n            case 'undefined':\n                if (set._items[type]) {\n                    return !shouldAdd;\n                } else {\n                    if (shouldAdd) {\n                        set._items[type] = true;\n                    }\n                    return shouldAdd;\n                }\n            case 'object':\n                if (item === null) {\n                    if (!set._items['null']) {\n                        if (shouldAdd) {\n                            set._items['null'] = true;\n                        }\n                        return shouldAdd;\n                    }\n                    return !shouldAdd;\n                }\n            /* falls through */\n            default:\n                // reduce the search size of heterogeneous sets by creating buckets\n                // for each type.\n                type = Object.prototype.toString.call(item);\n                if (!(type in set._items)) {\n                    if (shouldAdd) {\n                        set._items[type] = [item];\n                    }\n                    return shouldAdd;\n                }\n                // scan through all previously applied items\n                if (!_contains(item, set._items[type])) {\n                    if (shouldAdd) {\n                        set._items[type].push(item);\n                    }\n                    return shouldAdd;\n                }\n                return !shouldAdd;\n            }\n        }\n        return _Set;\n    }();\n\n    /**\n     * A function wrapping calls to the two functions in an `&&` operation,\n     * returning the result of the first function if it is false-y and the result\n     * of the second function otherwise. Note that this is short-circuited,\n     * meaning that the second function will not be invoked if the first returns a\n     * false-y value.\n     *\n     * In addition to functions, `R.both` also accepts any fantasy-land compatible\n     * applicative functor.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.12.0\n     * @category Logic\n     * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)\n     * @param {Function} f a predicate\n     * @param {Function} g another predicate\n     * @return {Function} a function that applies its arguments to `f` and `g` and `&&`s their outputs together.\n     * @see R.and\n     * @example\n     *\n     *      var gt10 = x => x > 10;\n     *      var even = x => x % 2 === 0;\n     *      var f = R.both(gt10, even);\n     *      f(100); //=> true\n     *      f(101); //=> false\n     */\n    var both = _curry2(function both(f, g) {\n        return _isFunction(f) ? function _both() {\n            return f.apply(this, arguments) && g.apply(this, arguments);\n        } : lift(and)(f, g);\n    });\n\n    /**\n     * Takes a function `f` and returns a function `g` such that:\n     *\n     *   - applying `g` to zero or more arguments will give __true__ if applying\n     *     the same arguments to `f` gives a logical __false__ value; and\n     *\n     *   - applying `g` to zero or more arguments will give __false__ if applying\n     *     the same arguments to `f` gives a logical __true__ value.\n     *\n     * `R.complement` will work on all other functors as well.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.12.0\n     * @category Logic\n     * @sig (*... -> *) -> (*... -> Boolean)\n     * @param {Function} f\n     * @return {Function}\n     * @see R.not\n     * @example\n     *\n     *      var isEven = n => n % 2 === 0;\n     *      var isOdd = R.complement(isEven);\n     *      isOdd(21); //=> true\n     *      isOdd(42); //=> false\n     */\n    var complement = lift(not);\n\n    /**\n     * A function wrapping calls to the two functions in an `||` operation,\n     * returning the result of the first function if it is truth-y and the result\n     * of the second function otherwise. Note that this is short-circuited,\n     * meaning that the second function will not be invoked if the first returns a\n     * truth-y value.\n     *\n     * In addition to functions, `R.either` also accepts any fantasy-land compatible\n     * applicative functor.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.12.0\n     * @category Logic\n     * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)\n     * @param {Function} f a predicate\n     * @param {Function} g another predicate\n     * @return {Function} a function that applies its arguments to `f` and `g` and `||`s their outputs together.\n     * @see R.or\n     * @example\n     *\n     *      var gt10 = x => x > 10;\n     *      var even = x => x % 2 === 0;\n     *      var f = R.either(gt10, even);\n     *      f(101); //=> true\n     *      f(8); //=> true\n     */\n    var either = _curry2(function either(f, g) {\n        return _isFunction(f) ? function _either() {\n            return f.apply(this, arguments) || g.apply(this, arguments);\n        } : lift(or)(f, g);\n    });\n\n    /**\n     * Turns a named method with a specified arity into a function that can be\n     * called directly supplied with arguments and a target object.\n     *\n     * The returned function is curried and accepts `arity + 1` parameters where\n     * the final parameter is the target object.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Function\n     * @sig Number -> String -> (a -> b -> ... -> n -> Object -> *)\n     * @param {Number} arity Number of arguments the returned function should take\n     *        before the target object.\n     * @param {String} method Name of the method to call.\n     * @return {Function} A new curried function.\n     * @example\n     *\n     *      var sliceFrom = R.invoker(1, 'slice');\n     *      sliceFrom(6, 'abcdefghijklm'); //=> 'ghijklm'\n     *      var sliceFrom6 = R.invoker(2, 'slice')(6);\n     *      sliceFrom6(8, 'abcdefghijklm'); //=> 'gh'\n     */\n    var invoker = _curry2(function invoker(arity, method) {\n        return curryN(arity + 1, function () {\n            var target = arguments[arity];\n            if (target != null && is(Function, target[method])) {\n                return target[method].apply(target, _slice(arguments, 0, arity));\n            }\n            throw new TypeError(toString(target) + ' does not have a method named \"' + method + '\"');\n        });\n    });\n\n    /**\n     * Returns a string made by inserting the `separator` between each element and\n     * concatenating all the elements into a single string.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig String -> [a] -> String\n     * @param {Number|String} separator The string used to separate the elements.\n     * @param {Array} xs The elements to join into a string.\n     * @return {String} str The string made by concatenating `xs` with `separator`.\n     * @see R.split\n     * @example\n     *\n     *      var spacer = R.join(' ');\n     *      spacer(['a', 2, 3.4]);   //=> 'a 2 3.4'\n     *      R.join('|', [1, 2, 3]);    //=> '1|2|3'\n     */\n    var join = invoker(1, 'join');\n\n    /**\n     * Creates a new function that, when invoked, caches the result of calling `fn`\n     * for a given argument set and returns the result. Subsequent calls to the\n     * memoized `fn` with the same argument set will not result in an additional\n     * call to `fn`; instead, the cached result for that set of arguments will be\n     * returned.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Function\n     * @sig (*... -> a) -> (*... -> a)\n     * @param {Function} fn The function to memoize.\n     * @return {Function} Memoized version of `fn`.\n     * @example\n     *\n     *      var count = 0;\n     *      var factorial = R.memoize(n => {\n     *        count += 1;\n     *        return R.product(R.range(1, n + 1));\n     *      });\n     *      factorial(5); //=> 120\n     *      factorial(5); //=> 120\n     *      factorial(5); //=> 120\n     *      count; //=> 1\n     */\n    var memoize = _curry1(function memoize(fn) {\n        var cache = {};\n        return _arity(fn.length, function () {\n            var key = toString(arguments);\n            if (!_has(key, cache)) {\n                cache[key] = fn.apply(this, arguments);\n            }\n            return cache[key];\n        });\n    });\n\n    /**\n     * Splits a string into an array of strings based on the given\n     * separator.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category String\n     * @sig (String | RegExp) -> String -> [String]\n     * @param {String|RegExp} sep The pattern.\n     * @param {String} str The string to separate into an array.\n     * @return {Array} The array of strings from `str` separated by `str`.\n     * @see R.join\n     * @example\n     *\n     *      var pathComponents = R.split('/');\n     *      R.tail(pathComponents('/usr/local/bin/node')); //=> ['usr', 'local', 'bin', 'node']\n     *\n     *      R.split('.', 'a.b.c.xyz.d'); //=> ['a', 'b', 'c', 'xyz', 'd']\n     */\n    var split = invoker(1, 'split');\n\n    /**\n     * Determines whether a given string matches a given regular expression.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.12.0\n     * @category String\n     * @sig RegExp -> String -> Boolean\n     * @param {RegExp} pattern\n     * @param {String} str\n     * @return {Boolean}\n     * @see R.match\n     * @example\n     *\n     *      R.test(/^x/, 'xyz'); //=> true\n     *      R.test(/^y/, 'xyz'); //=> false\n     */\n    var test = _curry2(function test(pattern, str) {\n        if (!_isRegExp(pattern)) {\n            throw new TypeError('\\u2018test\\u2019 requires a value of type RegExp as its first argument; received ' + toString(pattern));\n        }\n        return _cloneRegExp(pattern).test(str);\n    });\n\n    /**\n     * The lower case version of a string.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.9.0\n     * @category String\n     * @sig String -> String\n     * @param {String} str The string to lower case.\n     * @return {String} The lower case version of `str`.\n     * @see R.toUpper\n     * @example\n     *\n     *      R.toLower('XYZ'); //=> 'xyz'\n     */\n    var toLower = invoker(0, 'toLowerCase');\n\n    /**\n     * The upper case version of a string.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.9.0\n     * @category String\n     * @sig String -> String\n     * @param {String} str The string to upper case.\n     * @return {String} The upper case version of `str`.\n     * @see R.toLower\n     * @example\n     *\n     *      R.toUpper('abc'); //=> 'ABC'\n     */\n    var toUpper = invoker(0, 'toUpperCase');\n\n    /**\n     * Returns a new list containing only one copy of each element in the original\n     * list, based upon the value returned by applying the supplied function to\n     * each list element. Prefers the first item if the supplied function produces\n     * the same value on two items. `R.equals` is used for comparison.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.16.0\n     * @category List\n     * @sig (a -> b) -> [a] -> [a]\n     * @param {Function} fn A function used to produce a value to use during comparisons.\n     * @param {Array} list The array to consider.\n     * @return {Array} The list of unique items.\n     * @example\n     *\n     *      R.uniqBy(Math.abs, [-1, -5, 2, 10, 1, 2]); //=> [-1, -5, 2, 10]\n     */\n    var uniqBy = _curry2(function uniqBy(fn, list) {\n        var set = new _Set();\n        var result = [];\n        var idx = 0;\n        var appliedItem, item;\n        while (idx < list.length) {\n            item = list[idx];\n            appliedItem = fn(item);\n            if (set.add(appliedItem)) {\n                result.push(item);\n            }\n            idx += 1;\n        }\n        return result;\n    });\n\n    /**\n     * Returns the result of concatenating the given lists or strings.\n     *\n     * Dispatches to the `concat` method of the first argument, if present.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig [a] -> [a] -> [a]\n     * @sig String -> String -> String\n     * @param {Array|String} a\n     * @param {Array|String} b\n     * @return {Array|String}\n     *\n     * @example\n     *\n     *      R.concat([], []); //=> []\n     *      R.concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]\n     *      R.concat('ABC', 'DEF'); // 'ABCDEF'\n     */\n    var concat = flip(invoker(1, 'concat'));\n\n    /**\n     * Finds the set (i.e. no duplicates) of all elements contained in the first or\n     * second list, but not both.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.19.0\n     * @category Relation\n     * @sig [*] -> [*] -> [*]\n     * @param {Array} list1 The first list.\n     * @param {Array} list2 The second list.\n     * @return {Array} The elements in `list1` or `list2`, but not both.\n     * @see R.symmetricDifferenceWith\n     * @example\n     *\n     *      R.symmetricDifference([1,2,3,4], [7,6,5,4,3]); //=> [1,2,7,6,5]\n     *      R.symmetricDifference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5,1,2]\n     */\n    var symmetricDifference = _curry2(function symmetricDifference(list1, list2) {\n        return concat(difference(list1, list2), difference(list2, list1));\n    });\n\n    /**\n     * Finds the set (i.e. no duplicates) of all elements contained in the first or\n     * second list, but not both. Duplication is determined according to the value\n     * returned by applying the supplied predicate to two list elements.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.19.0\n     * @category Relation\n     * @sig (a -> a -> Boolean) -> [a] -> [a] -> [a]\n     * @param {Function} pred A predicate used to test whether two items are equal.\n     * @param {Array} list1 The first list.\n     * @param {Array} list2 The second list.\n     * @return {Array} The elements in `list1` or `list2`, but not both.\n     * @see R.symmetricDifference\n     * @example\n     *\n     *      var eqA = R.eqBy(R.prop('a'));\n     *      var l1 = [{a: 1}, {a: 2}, {a: 3}, {a: 4}];\n     *      var l2 = [{a: 3}, {a: 4}, {a: 5}, {a: 6}];\n     *      R.symmetricDifferenceWith(eqA, l1, l2); //=> [{a: 1}, {a: 2}, {a: 5}, {a: 6}]\n     */\n    var symmetricDifferenceWith = _curry3(function symmetricDifferenceWith(pred, list1, list2) {\n        return concat(differenceWith(pred, list1, list2), differenceWith(pred, list2, list1));\n    });\n\n    /**\n     * Returns a new list containing only one copy of each element in the original\n     * list. `R.equals` is used to determine equality.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig [a] -> [a]\n     * @param {Array} list The array to consider.\n     * @return {Array} The list of unique items.\n     * @example\n     *\n     *      R.uniq([1, 1, 2, 1]); //=> [1, 2]\n     *      R.uniq([1, '1']);     //=> [1, '1']\n     *      R.uniq([[42], [42]]); //=> [[42]]\n     */\n    var uniq = uniqBy(identity);\n\n    /**\n     * Combines two lists into a set (i.e. no duplicates) composed of those\n     * elements common to both lists.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Relation\n     * @sig [*] -> [*] -> [*]\n     * @param {Array} list1 The first list.\n     * @param {Array} list2 The second list.\n     * @return {Array} The list of elements found in both `list1` and `list2`.\n     * @see R.intersectionWith\n     * @example\n     *\n     *      R.intersection([1,2,3,4], [7,6,5,4,3]); //=> [4, 3]\n     */\n    var intersection = _curry2(function intersection(list1, list2) {\n        var lookupList, filteredList;\n        if (list1.length > list2.length) {\n            lookupList = list1;\n            filteredList = list2;\n        } else {\n            lookupList = list2;\n            filteredList = list1;\n        }\n        return uniq(_filter(flip(_contains)(lookupList), filteredList));\n    });\n\n    /**\n     * Combines two lists into a set (i.e. no duplicates) composed of the elements\n     * of each list.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Relation\n     * @sig [*] -> [*] -> [*]\n     * @param {Array} as The first list.\n     * @param {Array} bs The second list.\n     * @return {Array} The first and second lists concatenated, with\n     *         duplicates removed.\n     * @example\n     *\n     *      R.union([1, 2, 3], [2, 3, 4]); //=> [1, 2, 3, 4]\n     */\n    var union = _curry2(compose(uniq, _concat));\n\n    var R = {\n        F: F,\n        T: T,\n        __: __,\n        add: add,\n        addIndex: addIndex,\n        adjust: adjust,\n        all: all,\n        allPass: allPass,\n        allUniq: allUniq,\n        always: always,\n        and: and,\n        any: any,\n        anyPass: anyPass,\n        ap: ap,\n        aperture: aperture,\n        append: append,\n        apply: apply,\n        applySpec: applySpec,\n        assoc: assoc,\n        assocPath: assocPath,\n        binary: binary,\n        bind: bind,\n        both: both,\n        call: call,\n        chain: chain,\n        clamp: clamp,\n        clone: clone,\n        comparator: comparator,\n        complement: complement,\n        compose: compose,\n        composeK: composeK,\n        composeP: composeP,\n        concat: concat,\n        cond: cond,\n        construct: construct,\n        constructN: constructN,\n        contains: contains,\n        converge: converge,\n        countBy: countBy,\n        curry: curry,\n        curryN: curryN,\n        dec: dec,\n        defaultTo: defaultTo,\n        difference: difference,\n        differenceWith: differenceWith,\n        dissoc: dissoc,\n        dissocPath: dissocPath,\n        divide: divide,\n        drop: drop,\n        dropLast: dropLast,\n        dropLastWhile: dropLastWhile,\n        dropRepeats: dropRepeats,\n        dropRepeatsWith: dropRepeatsWith,\n        dropWhile: dropWhile,\n        either: either,\n        empty: empty,\n        eqBy: eqBy,\n        eqProps: eqProps,\n        equals: equals,\n        evolve: evolve,\n        filter: filter,\n        find: find,\n        findIndex: findIndex,\n        findLast: findLast,\n        findLastIndex: findLastIndex,\n        flatten: flatten,\n        flip: flip,\n        forEach: forEach,\n        fromPairs: fromPairs,\n        groupBy: groupBy,\n        groupWith: groupWith,\n        gt: gt,\n        gte: gte,\n        has: has,\n        hasIn: hasIn,\n        head: head,\n        identical: identical,\n        identity: identity,\n        ifElse: ifElse,\n        inc: inc,\n        indexBy: indexBy,\n        indexOf: indexOf,\n        init: init,\n        insert: insert,\n        insertAll: insertAll,\n        intersection: intersection,\n        intersectionWith: intersectionWith,\n        intersperse: intersperse,\n        into: into,\n        invert: invert,\n        invertObj: invertObj,\n        invoker: invoker,\n        is: is,\n        isArrayLike: isArrayLike,\n        isEmpty: isEmpty,\n        isNil: isNil,\n        join: join,\n        juxt: juxt,\n        keys: keys,\n        keysIn: keysIn,\n        last: last,\n        lastIndexOf: lastIndexOf,\n        length: length,\n        lens: lens,\n        lensIndex: lensIndex,\n        lensPath: lensPath,\n        lensProp: lensProp,\n        lift: lift,\n        liftN: liftN,\n        lt: lt,\n        lte: lte,\n        map: map,\n        mapAccum: mapAccum,\n        mapAccumRight: mapAccumRight,\n        mapObjIndexed: mapObjIndexed,\n        match: match,\n        mathMod: mathMod,\n        max: max,\n        maxBy: maxBy,\n        mean: mean,\n        median: median,\n        memoize: memoize,\n        merge: merge,\n        mergeAll: mergeAll,\n        mergeWith: mergeWith,\n        mergeWithKey: mergeWithKey,\n        min: min,\n        minBy: minBy,\n        modulo: modulo,\n        multiply: multiply,\n        nAry: nAry,\n        negate: negate,\n        none: none,\n        not: not,\n        nth: nth,\n        nthArg: nthArg,\n        objOf: objOf,\n        of: of,\n        omit: omit,\n        once: once,\n        or: or,\n        over: over,\n        pair: pair,\n        partial: partial,\n        partialRight: partialRight,\n        partition: partition,\n        path: path,\n        pathEq: pathEq,\n        pathOr: pathOr,\n        pathSatisfies: pathSatisfies,\n        pick: pick,\n        pickAll: pickAll,\n        pickBy: pickBy,\n        pipe: pipe,\n        pipeK: pipeK,\n        pipeP: pipeP,\n        pluck: pluck,\n        prepend: prepend,\n        product: product,\n        project: project,\n        prop: prop,\n        propEq: propEq,\n        propIs: propIs,\n        propOr: propOr,\n        propSatisfies: propSatisfies,\n        props: props,\n        range: range,\n        reduce: reduce,\n        reduceBy: reduceBy,\n        reduceRight: reduceRight,\n        reduced: reduced,\n        reject: reject,\n        remove: remove,\n        repeat: repeat,\n        replace: replace,\n        reverse: reverse,\n        scan: scan,\n        sequence: sequence,\n        set: set,\n        slice: slice,\n        sort: sort,\n        sortBy: sortBy,\n        split: split,\n        splitAt: splitAt,\n        splitEvery: splitEvery,\n        splitWhen: splitWhen,\n        subtract: subtract,\n        sum: sum,\n        symmetricDifference: symmetricDifference,\n        symmetricDifferenceWith: symmetricDifferenceWith,\n        tail: tail,\n        take: take,\n        takeLast: takeLast,\n        takeLastWhile: takeLastWhile,\n        takeWhile: takeWhile,\n        tap: tap,\n        test: test,\n        times: times,\n        toLower: toLower,\n        toPairs: toPairs,\n        toPairsIn: toPairsIn,\n        toString: toString,\n        toUpper: toUpper,\n        transduce: transduce,\n        transpose: transpose,\n        traverse: traverse,\n        trim: trim,\n        tryCatch: tryCatch,\n        type: type,\n        unapply: unapply,\n        unary: unary,\n        uncurryN: uncurryN,\n        unfold: unfold,\n        union: union,\n        unionWith: unionWith,\n        uniq: uniq,\n        uniqBy: uniqBy,\n        uniqWith: uniqWith,\n        unless: unless,\n        unnest: unnest,\n        until: until,\n        update: update,\n        useWith: useWith,\n        values: values,\n        valuesIn: valuesIn,\n        view: view,\n        when: when,\n        where: where,\n        whereEq: whereEq,\n        without: without,\n        wrap: wrap,\n        xprod: xprod,\n        zip: zip,\n        zipObj: zipObj,\n        zipWith: zipWith\n    };\n  /* eslint-env amd */\n\n  /* TEST_ENTRY_POINT */\n\n  if (true) {\n    module.exports = R;\n  } else if (typeof define === 'function' && define.amd) {\n    define(function() { return R; });\n  } else {\n    this.R = R;\n  }\n\n}.call(this));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3JhbWRhL2Rpc3QvcmFtZGEuanM/YWEwOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsS0FBSyxrQkFBa0IsS0FBSztBQUNoRSwyQkFBMkI7QUFDM0I7QUFDQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0IsZUFBZSxnQkFBZ0I7QUFDL0IsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSx3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QUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsTUFBTTtBQUNyQixlQUFlLE1BQU07QUFDckIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixFQUFFO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxFQUFFLEtBQUs7QUFDcEIsZUFBZSxFQUFFO0FBQ2pCLGdCQUFnQixFQUFFO0FBQ2xCO0FBQ0E7QUFDQSw2QkFBNkIsSUFBSSxJQUFJO0FBQ3JDO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsRUFBRTtBQUNqQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDLDZDQUE2QztBQUM3Qyw2Q0FBNkM7QUFDN0MsNkNBQTZDO0FBQzdDLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE1BQU07QUFDckIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxpREFBaUQ7QUFDakQsaURBQWlEO0FBQ2pELGlEQUFpRDtBQUNqRCxtQ0FBbUM7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsTUFBTTtBQUNyQixnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsRUFBRTtBQUNqQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiw2QkFBNkI7QUFDN0IsMkNBQTJDO0FBQzNDO0FBQ0EsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2QiwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsTUFBTTtBQUNyQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBLDhCQUE4Qix1QkFBdUIsRUFBRSxPQUFPO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixnQkFBZ0IsRUFBRTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsdUJBQXVCO0FBQ3ZCO0FBQ0EsMEJBQTBCO0FBQzFCLHVCQUF1QjtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLDJCQUEyQjtBQUMzQix3QkFBd0I7QUFDeEIsdUJBQXVCO0FBQ3ZCO0FBQ0EsMEJBQTBCO0FBQzFCLHlCQUF5QjtBQUN6Qix3QkFBd0I7QUFDeEIsdUJBQXVCO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxNQUFNO0FBQ3JCLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4QkFBOEI7QUFDN0MsZUFBZSw4QkFBOEI7QUFDN0MsZUFBZSw4QkFBOEI7QUFDN0MsZUFBZSxnQ0FBZ0M7QUFDL0MsZUFBZTtBQUNmO0FBQ0E7QUFDQSxlQUFlLDhCQUE4QjtBQUM3QyxlQUFlLGdDQUFnQztBQUMvQyxlQUFlLDZCQUE2QjtBQUM1QyxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdDQUFnQyxHQUFHLDRCQUE0QjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsU0FBUztBQUN4QixlQUFlLE1BQU07QUFDckIsZ0JBQWdCLEVBQUU7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSyxLQUFLO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLLEtBQUs7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQywwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLDRCQUE0QjtBQUM1Qix3QkFBd0IsRUFBRTtBQUMxQix1QkFBdUIsVUFBVSxFQUFFO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsdUJBQXVCO0FBQ3ZCO0FBQ0EsMEJBQTBCO0FBQzFCLHVCQUF1QjtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsTUFBTTtBQUNyQixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsaUJBQWlCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLE1BQU07QUFDckIsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBLDJCQUEyQixpQkFBaUIsRUFBRSxPQUFPO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsSUFBSTtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSx5REFBeUQsT0FBTztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2IsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLEVBQUUsS0FBSyxFQUFFLEtBQUs7QUFDNUMsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDRCQUE0QjtBQUNyRCx5QkFBeUIsNEJBQTRCO0FBQ3JELGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsTUFBTTtBQUNyQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLE1BQU07QUFDckIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFVBQVU7QUFDeEMsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsRUFBRTtBQUNqQixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFdBQVcsaUJBQWlCO0FBQ3JELHlCQUF5QixXQUFXLGlCQUFpQjtBQUNyRCx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsS0FBSztBQUN4QixlQUFlLGNBQWM7QUFDN0IsZUFBZSxNQUFNO0FBQ3JCLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixLQUFLLEdBQUcsS0FBSyxHQUFHO0FBQzNDLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsS0FBSyxPQUFPLEtBQUs7QUFDdEMsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsTUFBTTtBQUNyQixnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4QjtBQUNBLCtDQUErQyxRQUFRLHVCQUF1QixHQUFHLHVCQUF1QjtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsRUFBRTtBQUNqQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4Qix5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsRUFBRTtBQUNqQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFdBQVcsRUFBRTtBQUNoRCxtQ0FBbUMsU0FBUyxFQUFFO0FBQzlDLG9DQUFvQyxFQUFFO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBLGVBQWUsRUFBRTtBQUNqQixlQUFlLE1BQU07QUFDckIsZ0JBQWdCLEVBQUU7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCxlQUFlLFNBQVM7QUFDeEI7QUFDQSxlQUFlLEVBQUU7QUFDakIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsTUFBTTtBQUNyQixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLDZCQUE2Qix3QkFBd0I7QUFDckQsNkJBQTZCLHdCQUF3QjtBQUNyRDtBQUNBLDZCQUE2Qix3QkFBd0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYixLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsTUFBTTtBQUNyQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBLDZCQUE2Qix1QkFBdUIsRUFBRSxPQUFPO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsZ0RBQWdELFNBQVMsSUFBSSxJQUFJLElBQUksSUFBSTtBQUN6RSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsTUFBTTtBQUNyQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELGlEQUFpRDtBQUNqRCxpREFBaUQ7QUFDakQsaURBQWlEO0FBQ2pELG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZUFBZSxNQUFNO0FBQ3JCLGdCQUFnQixFQUFFO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsTUFBTTtBQUNyQixlQUFlLE1BQU07QUFDckIsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsS0FBSyxHQUFHLEtBQUs7QUFDcEMsdUJBQXVCLEtBQUssR0FBRyxLQUFLO0FBQ3BDLHFEQUFxRCxRQUFRLEtBQUssR0FBRyxLQUFLLEdBQUcsS0FBSztBQUNsRjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVLEtBQUssVUFBVTtBQUN0QyxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxXQUFXO0FBQzdDO0FBQ0Esa0JBQWtCLEtBQUssRUFBRTtBQUN6QixrQkFBa0IsV0FBVyxFQUFFO0FBQy9CLGtCQUFrQixpQkFBaUIsRUFBRTtBQUNyQyxrQkFBa0IsV0FBVyxFQUFFO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNCQUFzQixFQUFFO0FBQ3JELDZCQUE2QixzQkFBc0IsRUFBRTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLDhCQUE4QjtBQUM5QixvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsTUFBTTtBQUNyQixnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEseUJBQXlCLHdCQUF3QixLQUFLO0FBQ25FLGVBQWUsT0FBTztBQUN0QjtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JELDBDQUEwQztBQUMxQyw2QkFBNkIsUUFBUSxrQkFBa0IsU0FBUztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsS0FBSztBQUNwQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9DQUFvQyxFQUFFO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLE1BQU07QUFDckIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsbUJBQW1CO0FBQ25CLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLEVBQUUsWUFBWSxFQUFFO0FBQzdDLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsTUFBTTtBQUNyQixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxVQUFVO0FBQ3JELDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLE1BQU07QUFDckIsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLEVBQUU7QUFDakIsZUFBZSxFQUFFO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixLQUFLLEtBQUssS0FBSztBQUNqQyxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QixtQ0FBbUM7QUFDbkMsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsTUFBTTtBQUNyQixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYiw2QkFBNkIsd0JBQXdCO0FBQ3JELDZCQUE2Qix3QkFBd0I7QUFDckQ7QUFDQSw2QkFBNkIsd0JBQXdCO0FBQ3JEO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xELHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUssTUFBTSxJQUFJO0FBQzlDLGVBQWUsU0FBUztBQUN4QixlQUFlLE1BQU07QUFDckIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBLHlCQUF5QixzQkFBc0IsR0FBRyxzQkFBc0I7QUFDeEU7QUFDQSxrQkFBa0IsTUFBTSxzQkFBc0IsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsTUFBTTtBQUNyQixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsV0FBVyxFQUFFO0FBQ3hDLDZCQUE2QixXQUFXLEVBQUUsZ0JBQWdCO0FBQzFELHFDQUFxQyxXQUFXLEVBQUUsUUFBUTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDLGtEQUFrRDtBQUNsRCx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsSUFBSSxZQUFZLEVBQUU7QUFDOUMsOEJBQThCLElBQUksWUFBWSxFQUFFLGdCQUFnQixJQUFJO0FBQ3BFLHNDQUFzQyxJQUFJLFlBQVksRUFBRSxRQUFRLElBQUk7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsV0FBVyxFQUFFO0FBQ3hDLDZCQUE2QixXQUFXLEVBQUUsZ0JBQWdCO0FBQzFELHFDQUFxQyxXQUFXLEVBQUUsUUFBUTtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLDhCQUE4QjtBQUM5Qix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLG9DQUFvQztBQUNwQyx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLE1BQU07QUFDckIsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsa0NBQWtDO0FBQzVFLHFCQUFxQix3QkFBd0IsR0FBRyxXQUFXO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxFQUFFO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQsZ0VBQWdFO0FBQ2hFO0FBQ0EsOENBQThDO0FBQzlDLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLEVBQUU7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RCx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QywrQ0FBK0M7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtCQUFrQixFQUFFO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix3Q0FBd0M7QUFDN0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVEsV0FBVyxlQUFlO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEVBQUUsWUFBWSxFQUFFO0FBQ25DLGVBQWUsU0FBUztBQUN4QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE1BQU07QUFDckIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLHFDQUFxQztBQUNyQyxxQ0FBcUM7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxNQUFNO0FBQ3JCLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixVQUFVLEtBQUs7QUFDeEMsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsdUJBQXVCLEVBQUUsT0FBTztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRLFdBQVcsZUFBZTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsOEJBQThCO0FBQzlCLGtDQUFrQztBQUNsQyx3QkFBd0IsdUJBQXVCLEVBQUUsUUFBUSw2QkFBNkI7QUFDdEYseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLE1BQU07QUFDckIsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsTUFBTTtBQUNyQixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxtQ0FBbUM7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSx3R0FBd0c7QUFDeEc7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxNQUFNO0FBQ3JCLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLDJDQUEyQztBQUMzQyxtQ0FBbUM7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxNQUFNO0FBQ3JCLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRCwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLE1BQU07QUFDckIsZUFBZSxNQUFNO0FBQ3JCLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLEtBQUssR0FBRyxLQUFLLEdBQUcsS0FBSyxHQUFHLEtBQUs7QUFDcEQsdUJBQXVCLEtBQUssR0FBRyxLQUFLLEdBQUcsS0FBSyxHQUFHLEtBQUs7QUFDcEQsbURBQW1ELFFBQVEsS0FBSyxHQUFHLEtBQUssR0FBRyxLQUFLLEdBQUcsS0FBSztBQUN4RjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLDZCQUE2QjtBQUM3QixpQ0FBaUM7QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxNQUFNO0FBQ3JCLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLE1BQU07QUFDckIsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCx1QkFBdUIsVUFBVSxFQUFFO0FBQ25DLEdBQUc7QUFDSDtBQUNBOztBQUVBLENBQUMiLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vICBSYW1kYSB2MC4yMS4wXG4vLyAgaHR0cHM6Ly9naXRodWIuY29tL3JhbWRhL3JhbWRhXG4vLyAgKGMpIDIwMTMtMjAxNiBTY290dCBTYXV5ZXQsIE1pY2hhZWwgSHVybGV5LCBhbmQgRGF2aWQgQ2hhbWJlcnNcbi8vICBSYW1kYSBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuOyhmdW5jdGlvbigpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAgICogQSBzcGVjaWFsIHBsYWNlaG9sZGVyIHZhbHVlIHVzZWQgdG8gc3BlY2lmeSBcImdhcHNcIiB3aXRoaW4gY3VycmllZCBmdW5jdGlvbnMsXG4gICAgICogYWxsb3dpbmcgcGFydGlhbCBhcHBsaWNhdGlvbiBvZiBhbnkgY29tYmluYXRpb24gb2YgYXJndW1lbnRzLCByZWdhcmRsZXNzIG9mXG4gICAgICogdGhlaXIgcG9zaXRpb25zLlxuICAgICAqXG4gICAgICogSWYgYGdgIGlzIGEgY3VycmllZCB0ZXJuYXJ5IGZ1bmN0aW9uIGFuZCBgX2AgaXMgYFIuX19gLCB0aGUgZm9sbG93aW5nIGFyZVxuICAgICAqIGVxdWl2YWxlbnQ6XG4gICAgICpcbiAgICAgKiAgIC0gYGcoMSwgMiwgMylgXG4gICAgICogICAtIGBnKF8sIDIsIDMpKDEpYFxuICAgICAqICAgLSBgZyhfLCBfLCAzKSgxKSgyKWBcbiAgICAgKiAgIC0gYGcoXywgXywgMykoMSwgMilgXG4gICAgICogICAtIGBnKF8sIDIsIF8pKDEsIDMpYFxuICAgICAqICAgLSBgZyhfLCAyKSgxKSgzKWBcbiAgICAgKiAgIC0gYGcoXywgMikoMSwgMylgXG4gICAgICogICAtIGBnKF8sIDIpKF8sIDMpKDEpYFxuICAgICAqXG4gICAgICogQGNvbnN0YW50XG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuNi4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGdyZWV0ID0gUi5yZXBsYWNlKCd7bmFtZX0nLCBSLl9fLCAnSGVsbG8sIHtuYW1lfSEnKTtcbiAgICAgKiAgICAgIGdyZWV0KCdBbGljZScpOyAvLz0+ICdIZWxsbywgQWxpY2UhJ1xuICAgICAqL1xuICAgIHZhciBfXyA9IHsgJ0BAZnVuY3Rpb25hbC9wbGFjZWhvbGRlcic6IHRydWUgfTtcblxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4gICAgdmFyIF9hcml0eSA9IGZ1bmN0aW9uIF9hcml0eShuLCBmbikge1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuICAgICAgICBzd2l0Y2ggKG4pIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTAsIGExKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSwgYTIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTAsIGExLCBhMiwgYTMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTAsIGExLCBhMiwgYTMsIGE0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgsIGE5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCB0byBfYXJpdHkgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyIG5vIGdyZWF0ZXIgdGhhbiB0ZW4nKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgX2FycmF5RnJvbUl0ZXJhdG9yID0gZnVuY3Rpb24gX2FycmF5RnJvbUl0ZXJhdG9yKGl0ZXIpIHtcbiAgICAgICAgdmFyIGxpc3QgPSBbXTtcbiAgICAgICAgdmFyIG5leHQ7XG4gICAgICAgIHdoaWxlICghKG5leHQgPSBpdGVyLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgbGlzdC5wdXNoKG5leHQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgIH07XG5cbiAgICB2YXIgX2FycmF5T2YgPSBmdW5jdGlvbiBfYXJyYXlPZigpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIHZhciBfY2xvbmVSZWdFeHAgPSBmdW5jdGlvbiBfY2xvbmVSZWdFeHAocGF0dGVybikge1xuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChwYXR0ZXJuLnNvdXJjZSwgKHBhdHRlcm4uZ2xvYmFsID8gJ2cnIDogJycpICsgKHBhdHRlcm4uaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSArIChwYXR0ZXJuLm11bHRpbGluZSA/ICdtJyA6ICcnKSArIChwYXR0ZXJuLnN0aWNreSA/ICd5JyA6ICcnKSArIChwYXR0ZXJuLnVuaWNvZGUgPyAndScgOiAnJykpO1xuICAgIH07XG5cbiAgICB2YXIgX2NvbXBsZW1lbnQgPSBmdW5jdGlvbiBfY29tcGxlbWVudChmKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gIWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBgY29uY2F0YCBmdW5jdGlvbiB0byBtZXJnZSB0d28gYXJyYXktbGlrZSBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fEFyZ3VtZW50c30gW3NldDE9W11dIEFuIGFycmF5LWxpa2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8QXJndW1lbnRzfSBbc2V0Mj1bXV0gQW4gYXJyYXktbGlrZSBvYmplY3QuXG4gICAgICogQHJldHVybiB7QXJyYXl9IEEgbmV3LCBtZXJnZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgX2NvbmNhdChbNCwgNSwgNl0sIFsxLCAyLCAzXSk7IC8vPT4gWzQsIDUsIDYsIDEsIDIsIDNdXG4gICAgICovXG4gICAgdmFyIF9jb25jYXQgPSBmdW5jdGlvbiBfY29uY2F0KHNldDEsIHNldDIpIHtcbiAgICAgICAgc2V0MSA9IHNldDEgfHwgW107XG4gICAgICAgIHNldDIgPSBzZXQyIHx8IFtdO1xuICAgICAgICB2YXIgaWR4O1xuICAgICAgICB2YXIgbGVuMSA9IHNldDEubGVuZ3RoO1xuICAgICAgICB2YXIgbGVuMiA9IHNldDIubGVuZ3RoO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGlkeCA9IDA7XG4gICAgICAgIHdoaWxlIChpZHggPCBsZW4xKSB7XG4gICAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSBzZXQxW2lkeF07XG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZHggPSAwO1xuICAgICAgICB3aGlsZSAoaWR4IDwgbGVuMikge1xuICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gc2V0MltpZHhdO1xuICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgdmFyIF9jb250YWluc1dpdGggPSBmdW5jdGlvbiBfY29udGFpbnNXaXRoKHByZWQsIHgsIGxpc3QpIHtcbiAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKHByZWQoeCwgbGlzdFtpZHhdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICB2YXIgX2ZpbHRlciA9IGZ1bmN0aW9uIF9maWx0ZXIoZm4sIGxpc3QpIHtcbiAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoZm4obGlzdFtpZHhdKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IGxpc3RbaWR4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIHZhciBfZm9yY2VSZWR1Y2VkID0gZnVuY3Rpb24gX2ZvcmNlUmVkdWNlZCh4KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnQEB0cmFuc2R1Y2VyL3ZhbHVlJzogeCxcbiAgICAgICAgICAgICdAQHRyYW5zZHVjZXIvcmVkdWNlZCc6IHRydWVcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gU3RyaW5nKHggPT4geCkgZXZhbHVhdGVzIHRvIFwieCA9PiB4XCIsIHNvIHRoZSBwYXR0ZXJuIG1heSBub3QgbWF0Y2guXG4gICAgdmFyIF9mdW5jdGlvbk5hbWUgPSBmdW5jdGlvbiBfZnVuY3Rpb25OYW1lKGYpIHtcbiAgICAgICAgLy8gU3RyaW5nKHggPT4geCkgZXZhbHVhdGVzIHRvIFwieCA9PiB4XCIsIHNvIHRoZSBwYXR0ZXJuIG1heSBub3QgbWF0Y2guXG4gICAgICAgIHZhciBtYXRjaCA9IFN0cmluZyhmKS5tYXRjaCgvXmZ1bmN0aW9uIChcXHcqKS8pO1xuICAgICAgICByZXR1cm4gbWF0Y2ggPT0gbnVsbCA/ICcnIDogbWF0Y2hbMV07XG4gICAgfTtcblxuICAgIHZhciBfaGFzID0gZnVuY3Rpb24gX2hhcyhwcm9wLCBvYmopIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xuICAgIH07XG5cbiAgICB2YXIgX2lkZW50aXR5ID0gZnVuY3Rpb24gX2lkZW50aXR5KHgpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfTtcblxuICAgIHZhciBfaXNBcmd1bWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG4gICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKGFyZ3VtZW50cykgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nID8gZnVuY3Rpb24gX2lzQXJndW1lbnRzKHgpIHtcbiAgICAgICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBBcmd1bWVudHNdJztcbiAgICAgICAgfSA6IGZ1bmN0aW9uIF9pc0FyZ3VtZW50cyh4KSB7XG4gICAgICAgICAgICByZXR1cm4gX2hhcygnY2FsbGVlJywgeCk7XG4gICAgICAgIH07XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogVGVzdHMgd2hldGhlciBvciBub3QgYW4gb2JqZWN0IGlzIGFuIGFycmF5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbCBUaGUgb2JqZWN0IHRvIHRlc3QuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIGB2YWxgIGlzIGFuIGFycmF5LCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBfaXNBcnJheShbXSk7IC8vPT4gdHJ1ZVxuICAgICAqICAgICAgX2lzQXJyYXkobnVsbCk7IC8vPT4gZmFsc2VcbiAgICAgKiAgICAgIF9pc0FycmF5KHt9KTsgLy89PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gX2lzQXJyYXkodmFsKSB7XG4gICAgICAgIHJldHVybiB2YWwgIT0gbnVsbCAmJiB2YWwubGVuZ3RoID49IDAgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfTtcblxuICAgIHZhciBfaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIF9pc051bWJlcih4KSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSBpZiB0aGUgcGFzc2VkIGFyZ3VtZW50IGlzIGFuIGludGVnZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gblxuICAgICAqIEBjYXRlZ29yeSBUeXBlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB2YXIgX2lzSW50ZWdlciA9IE51bWJlci5pc0ludGVnZXIgfHwgZnVuY3Rpb24gX2lzSW50ZWdlcihuKSB7XG4gICAgICAgIHJldHVybiBuIDw8IDAgPT09IG47XG4gICAgfTtcblxuICAgIHZhciBfaXNOdW1iZXIgPSBmdW5jdGlvbiBfaXNOdW1iZXIoeCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBOdW1iZXJdJztcbiAgICB9O1xuXG4gICAgdmFyIF9pc09iamVjdCA9IGZ1bmN0aW9uIF9pc09iamVjdCh4KSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xuICAgIH07XG5cbiAgICB2YXIgX2lzUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiBfaXNQbGFjZWhvbGRlcihhKSB7XG4gICAgICAgIHJldHVybiBhICE9IG51bGwgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnICYmIGFbJ0BAZnVuY3Rpb25hbC9wbGFjZWhvbGRlciddID09PSB0cnVlO1xuICAgIH07XG5cbiAgICB2YXIgX2lzUmVnRXhwID0gZnVuY3Rpb24gX2lzUmVnRXhwKHgpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG4gICAgfTtcblxuICAgIHZhciBfaXNTdHJpbmcgPSBmdW5jdGlvbiBfaXNTdHJpbmcoeCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBTdHJpbmddJztcbiAgICB9O1xuXG4gICAgdmFyIF9pc1RyYW5zZm9ybWVyID0gZnVuY3Rpb24gX2lzVHJhbnNmb3JtZXIob2JqKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygb2JqWydAQHRyYW5zZHVjZXIvc3RlcCddID09PSAnZnVuY3Rpb24nO1xuICAgIH07XG5cbiAgICB2YXIgX21hcCA9IGZ1bmN0aW9uIF9tYXAoZm4sIGZ1bmN0b3IpIHtcbiAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgIHZhciBsZW4gPSBmdW5jdG9yLmxlbmd0aDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbik7XG4gICAgICAgIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICAgICAgICAgIHJlc3VsdFtpZHhdID0gZm4oZnVuY3RvcltpZHhdKTtcbiAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8vIEJhc2VkIG9uIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9hc3NpZ25cbiAgICB2YXIgX29iamVjdEFzc2lnbiA9IGZ1bmN0aW9uIF9vYmplY3RBc3NpZ24odGFyZ2V0KSB7XG4gICAgICAgIGlmICh0YXJnZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG91dHB1dCA9IE9iamVjdCh0YXJnZXQpO1xuICAgICAgICB2YXIgaWR4ID0gMTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpZHggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaWR4XTtcbiAgICAgICAgICAgIGlmIChzb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG5leHRLZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfaGFzKG5leHRLZXksIHNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtuZXh0S2V5XSA9IHNvdXJjZVtuZXh0S2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcblxuICAgIHZhciBfb2YgPSBmdW5jdGlvbiBfb2YoeCkge1xuICAgICAgICByZXR1cm4gW3hdO1xuICAgIH07XG5cbiAgICB2YXIgX3BpcGUgPSBmdW5jdGlvbiBfcGlwZShmLCBnKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZy5jYWxsKHRoaXMsIGYuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBfcGlwZVAgPSBmdW5jdGlvbiBfcGlwZVAoZiwgZykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gZi5hcHBseShjdHgsIGFyZ3VtZW50cykudGhlbihmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnLmNhbGwoY3R4LCB4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBcXGIgbWF0Y2hlcyB3b3JkIGJvdW5kYXJ5OyBbXFxiXSBtYXRjaGVzIGJhY2tzcGFjZVxuICAgIHZhciBfcXVvdGUgPSBmdW5jdGlvbiBfcXVvdGUocykge1xuICAgICAgICB2YXIgZXNjYXBlZCA9IHMucmVwbGFjZSgvXFxcXC9nLCAnXFxcXFxcXFwnKS5yZXBsYWNlKC9bXFxiXS9nLCAnXFxcXGInKSAgICAvLyBcXGIgbWF0Y2hlcyB3b3JkIGJvdW5kYXJ5OyBbXFxiXSBtYXRjaGVzIGJhY2tzcGFjZVxuICAgIC5yZXBsYWNlKC9cXGYvZywgJ1xcXFxmJykucmVwbGFjZSgvXFxuL2csICdcXFxcbicpLnJlcGxhY2UoL1xcci9nLCAnXFxcXHInKS5yZXBsYWNlKC9cXHQvZywgJ1xcXFx0JykucmVwbGFjZSgvXFx2L2csICdcXFxcdicpLnJlcGxhY2UoL1xcMC9nLCAnXFxcXDAnKTtcbiAgICAgICAgcmV0dXJuICdcIicgKyBlc2NhcGVkLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKSArICdcIic7XG4gICAgfTtcblxuICAgIHZhciBfcmVkdWNlZCA9IGZ1bmN0aW9uIF9yZWR1Y2VkKHgpIHtcbiAgICAgICAgcmV0dXJuIHggJiYgeFsnQEB0cmFuc2R1Y2VyL3JlZHVjZWQnXSA/IHggOiB7XG4gICAgICAgICAgICAnQEB0cmFuc2R1Y2VyL3ZhbHVlJzogeCxcbiAgICAgICAgICAgICdAQHRyYW5zZHVjZXIvcmVkdWNlZCc6IHRydWVcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQW4gb3B0aW1pemVkLCBwcml2YXRlIGFycmF5IGBzbGljZWAgaW1wbGVtZW50YXRpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJndW1lbnRzfEFycmF5fSBhcmdzIFRoZSBhcnJheSBvciBhcmd1bWVudHMgb2JqZWN0IHRvIGNvbnNpZGVyLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZnJvbT0wXSBUaGUgYXJyYXkgaW5kZXggdG8gc2xpY2UgZnJvbSwgaW5jbHVzaXZlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbdG89YXJncy5sZW5ndGhdIFRoZSBhcnJheSBpbmRleCB0byBzbGljZSB0bywgZXhjbHVzaXZlLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBBIG5ldywgc2xpY2VkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIF9zbGljZShbMSwgMiwgMywgNCwgNV0sIDEsIDMpOyAvLz0+IFsyLCAzXVxuICAgICAqXG4gICAgICogICAgICB2YXIgZmlyc3RUaHJlZUFyZ3MgPSBmdW5jdGlvbihhLCBiLCBjLCBkKSB7XG4gICAgICogICAgICAgIHJldHVybiBfc2xpY2UoYXJndW1lbnRzLCAwLCAzKTtcbiAgICAgKiAgICAgIH07XG4gICAgICogICAgICBmaXJzdFRocmVlQXJncygxLCAyLCAzLCA0KTsgLy89PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICB2YXIgX3NsaWNlID0gZnVuY3Rpb24gX3NsaWNlKGFyZ3MsIGZyb20sIHRvKSB7XG4gICAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gX3NsaWNlKGFyZ3MsIDAsIGFyZ3MubGVuZ3RoKTtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuIF9zbGljZShhcmdzLCBmcm9tLCBhcmdzLmxlbmd0aCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB2YXIgbGlzdCA9IFtdO1xuICAgICAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgICAgICB2YXIgbGVuID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oYXJncy5sZW5ndGgsIHRvKSAtIGZyb20pO1xuICAgICAgICAgICAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgICAgICAgICAgICAgIGxpc3RbaWR4XSA9IGFyZ3NbZnJvbSArIGlkeF07XG4gICAgICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGlzdDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQb2x5ZmlsbCBmcm9tIDxodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlL3RvSVNPU3RyaW5nPi5cbiAgICAgKi9cbiAgICB2YXIgX3RvSVNPU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGFkID0gZnVuY3Rpb24gcGFkKG4pIHtcbiAgICAgICAgICAgIHJldHVybiAobiA8IDEwID8gJzAnIDogJycpICsgbjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZyA9PT0gJ2Z1bmN0aW9uJyA/IGZ1bmN0aW9uIF90b0lTT1N0cmluZyhkKSB7XG4gICAgICAgICAgICByZXR1cm4gZC50b0lTT1N0cmluZygpO1xuICAgICAgICB9IDogZnVuY3Rpb24gX3RvSVNPU3RyaW5nKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkLmdldFVUQ0Z1bGxZZWFyKCkgKyAnLScgKyBwYWQoZC5nZXRVVENNb250aCgpICsgMSkgKyAnLScgKyBwYWQoZC5nZXRVVENEYXRlKCkpICsgJ1QnICsgcGFkKGQuZ2V0VVRDSG91cnMoKSkgKyAnOicgKyBwYWQoZC5nZXRVVENNaW51dGVzKCkpICsgJzonICsgcGFkKGQuZ2V0VVRDU2Vjb25kcygpKSArICcuJyArIChkLmdldFVUQ01pbGxpc2Vjb25kcygpIC8gMTAwMCkudG9GaXhlZCgzKS5zbGljZSgyLCA1KSArICdaJztcbiAgICAgICAgfTtcbiAgICB9KCk7XG5cbiAgICB2YXIgX3hmQmFzZSA9IHtcbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMueGZbJ0BAdHJhbnNkdWNlci9pbml0J10oKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzdWx0OiBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIF94d3JhcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gWFdyYXAoZm4pIHtcbiAgICAgICAgICAgIHRoaXMuZiA9IGZuO1xuICAgICAgICB9XG4gICAgICAgIFhXcmFwLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW5pdCBub3QgaW1wbGVtZW50ZWQgb24gWFdyYXAnKTtcbiAgICAgICAgfTtcbiAgICAgICAgWFdyYXAucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBmdW5jdGlvbiAoYWNjKSB7XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9O1xuICAgICAgICBYV3JhcC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbiAoYWNjLCB4KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mKGFjYywgeCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBfeHdyYXAoZm4pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgWFdyYXAoZm4pO1xuICAgICAgICB9O1xuICAgIH0oKTtcblxuICAgIHZhciBfYXBlcnR1cmUgPSBmdW5jdGlvbiBfYXBlcnR1cmUobiwgbGlzdCkge1xuICAgICAgICB2YXIgaWR4ID0gMDtcbiAgICAgICAgdmFyIGxpbWl0ID0gbGlzdC5sZW5ndGggLSAobiAtIDEpO1xuICAgICAgICB2YXIgYWNjID0gbmV3IEFycmF5KGxpbWl0ID49IDAgPyBsaW1pdCA6IDApO1xuICAgICAgICB3aGlsZSAoaWR4IDwgbGltaXQpIHtcbiAgICAgICAgICAgIGFjY1tpZHhdID0gX3NsaWNlKGxpc3QsIGlkeCwgaWR4ICsgbik7XG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH07XG5cbiAgICB2YXIgX2Fzc2lnbiA9IHR5cGVvZiBPYmplY3QuYXNzaWduID09PSAnZnVuY3Rpb24nID8gT2JqZWN0LmFzc2lnbiA6IF9vYmplY3RBc3NpZ247XG5cbiAgICAvKipcbiAgICAgKiBTaW1pbGFyIHRvIGhhc01ldGhvZCwgdGhpcyBjaGVja3Mgd2hldGhlciBhIGZ1bmN0aW9uIGhhcyBhIFttZXRob2RuYW1lXVxuICAgICAqIGZ1bmN0aW9uLiBJZiBpdCBpc24ndCBhbiBhcnJheSBpdCB3aWxsIGV4ZWN1dGUgdGhhdCBmdW5jdGlvbiBvdGhlcndpc2UgaXRcbiAgICAgKiB3aWxsIGRlZmF1bHQgdG8gdGhlIHJhbWRhIGltcGxlbWVudGF0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiByYW1kYSBpbXBsZW10YXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kbmFtZSBwcm9wZXJ0eSB0byBjaGVjayBmb3IgYSBjdXN0b20gaW1wbGVtZW50YXRpb25cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFdoYXRldmVyIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIG1ldGhvZCBpcy5cbiAgICAgKi9cbiAgICB2YXIgX2NoZWNrRm9yTWV0aG9kID0gZnVuY3Rpb24gX2NoZWNrRm9yTWV0aG9kKG1ldGhvZG5hbWUsIGZuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBvYmogPSBhcmd1bWVudHNbbGVuZ3RoIC0gMV07XG4gICAgICAgICAgICByZXR1cm4gX2lzQXJyYXkob2JqKSB8fCB0eXBlb2Ygb2JqW21ldGhvZG5hbWVdICE9PSAnZnVuY3Rpb24nID8gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IG9ialttZXRob2RuYW1lXS5hcHBseShvYmosIF9zbGljZShhcmd1bWVudHMsIDAsIGxlbmd0aCAtIDEpKTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogT3B0aW1pemVkIGludGVybmFsIG9uZS1hcml0eSBjdXJyeSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICB2YXIgX2N1cnJ5MSA9IGZ1bmN0aW9uIF9jdXJyeTEoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGYxKGEpIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwIHx8IF9pc1BsYWNlaG9sZGVyKGEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGYxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogT3B0aW1pemVkIGludGVybmFsIHR3by1hcml0eSBjdXJyeSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICB2YXIgX2N1cnJ5MiA9IGZ1bmN0aW9uIF9jdXJyeTIoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGYyKGEsIGIpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldHVybiBmMjtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2lzUGxhY2Vob2xkZXIoYSkgPyBmMiA6IF9jdXJyeTEoZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbihhLCBfYik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBfaXNQbGFjZWhvbGRlcihhKSAmJiBfaXNQbGFjZWhvbGRlcihiKSA/IGYyIDogX2lzUGxhY2Vob2xkZXIoYSkgPyBfY3VycnkxKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm4oX2EsIGIpO1xuICAgICAgICAgICAgICAgIH0pIDogX2lzUGxhY2Vob2xkZXIoYikgPyBfY3VycnkxKGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm4oYSwgX2IpO1xuICAgICAgICAgICAgICAgIH0pIDogZm4oYSwgYik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE9wdGltaXplZCBpbnRlcm5hbCB0aHJlZS1hcml0eSBjdXJyeSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICB2YXIgX2N1cnJ5MyA9IGZ1bmN0aW9uIF9jdXJyeTMoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGYzKGEsIGIsIGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldHVybiBmMztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2lzUGxhY2Vob2xkZXIoYSkgPyBmMyA6IF9jdXJyeTIoZnVuY3Rpb24gKF9iLCBfYykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm4oYSwgX2IsIF9jKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2lzUGxhY2Vob2xkZXIoYSkgJiYgX2lzUGxhY2Vob2xkZXIoYikgPyBmMyA6IF9pc1BsYWNlaG9sZGVyKGEpID8gX2N1cnJ5MihmdW5jdGlvbiAoX2EsIF9jKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbihfYSwgYiwgX2MpO1xuICAgICAgICAgICAgICAgIH0pIDogX2lzUGxhY2Vob2xkZXIoYikgPyBfY3VycnkyKGZ1bmN0aW9uIChfYiwgX2MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuKGEsIF9iLCBfYyk7XG4gICAgICAgICAgICAgICAgfSkgOiBfY3VycnkxKGZ1bmN0aW9uIChfYykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm4oYSwgYiwgX2MpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2lzUGxhY2Vob2xkZXIoYSkgJiYgX2lzUGxhY2Vob2xkZXIoYikgJiYgX2lzUGxhY2Vob2xkZXIoYykgPyBmMyA6IF9pc1BsYWNlaG9sZGVyKGEpICYmIF9pc1BsYWNlaG9sZGVyKGIpID8gX2N1cnJ5MihmdW5jdGlvbiAoX2EsIF9iKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbihfYSwgX2IsIGMpO1xuICAgICAgICAgICAgICAgIH0pIDogX2lzUGxhY2Vob2xkZXIoYSkgJiYgX2lzUGxhY2Vob2xkZXIoYykgPyBfY3VycnkyKGZ1bmN0aW9uIChfYSwgX2MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuKF9hLCBiLCBfYyk7XG4gICAgICAgICAgICAgICAgfSkgOiBfaXNQbGFjZWhvbGRlcihiKSAmJiBfaXNQbGFjZWhvbGRlcihjKSA/IF9jdXJyeTIoZnVuY3Rpb24gKF9iLCBfYykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm4oYSwgX2IsIF9jKTtcbiAgICAgICAgICAgICAgICB9KSA6IF9pc1BsYWNlaG9sZGVyKGEpID8gX2N1cnJ5MShmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuKF9hLCBiLCBjKTtcbiAgICAgICAgICAgICAgICB9KSA6IF9pc1BsYWNlaG9sZGVyKGIpID8gX2N1cnJ5MShmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuKGEsIF9iLCBjKTtcbiAgICAgICAgICAgICAgICB9KSA6IF9pc1BsYWNlaG9sZGVyKGMpID8gX2N1cnJ5MShmdW5jdGlvbiAoX2MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuKGEsIGIsIF9jKTtcbiAgICAgICAgICAgICAgICB9KSA6IGZuKGEsIGIsIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBjdXJyeU4gZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggVGhlIGFyaXR5IG9mIHRoZSBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHJlY2VpdmVkIEFuIGFycmF5IG9mIGFyZ3VtZW50cyByZWNlaXZlZCB0aHVzIGZhci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHZhciBfY3VycnlOID0gZnVuY3Rpb24gX2N1cnJ5TihsZW5ndGgsIHJlY2VpdmVkLCBmbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNvbWJpbmVkID0gW107XG4gICAgICAgICAgICB2YXIgYXJnc0lkeCA9IDA7XG4gICAgICAgICAgICB2YXIgbGVmdCA9IGxlbmd0aDtcbiAgICAgICAgICAgIHZhciBjb21iaW5lZElkeCA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoY29tYmluZWRJZHggPCByZWNlaXZlZC5sZW5ndGggfHwgYXJnc0lkeCA8IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChjb21iaW5lZElkeCA8IHJlY2VpdmVkLmxlbmd0aCAmJiAoIV9pc1BsYWNlaG9sZGVyKHJlY2VpdmVkW2NvbWJpbmVkSWR4XSkgfHwgYXJnc0lkeCA+PSBhcmd1bWVudHMubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZWNlaXZlZFtjb21iaW5lZElkeF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gYXJndW1lbnRzW2FyZ3NJZHhdO1xuICAgICAgICAgICAgICAgICAgICBhcmdzSWR4ICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbWJpbmVkW2NvbWJpbmVkSWR4XSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoIV9pc1BsYWNlaG9sZGVyKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCAtPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb21iaW5lZElkeCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxlZnQgPD0gMCA/IGZuLmFwcGx5KHRoaXMsIGNvbWJpbmVkKSA6IF9hcml0eShsZWZ0LCBfY3VycnlOKGxlbmd0aCwgY29tYmluZWQsIGZuKSk7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGRpc3BhdGNoZXMgd2l0aCBkaWZmZXJlbnQgc3RyYXRlZ2llcyBiYXNlZCBvbiB0aGVcbiAgICAgKiBvYmplY3QgaW4gbGlzdCBwb3NpdGlvbiAobGFzdCBhcmd1bWVudCkuIElmIGl0IGlzIGFuIGFycmF5LCBleGVjdXRlcyBbZm5dLlxuICAgICAqIE90aGVyd2lzZSwgaWYgaXQgaGFzIGEgZnVuY3Rpb24gd2l0aCBbbWV0aG9kbmFtZV0sIGl0IHdpbGwgZXhlY3V0ZSB0aGF0XG4gICAgICogZnVuY3Rpb24gKGZ1bmN0b3IgY2FzZSkuIE90aGVyd2lzZSwgaWYgaXQgaXMgYSB0cmFuc2Zvcm1lciwgdXNlcyB0cmFuc2R1Y2VyXG4gICAgICogW3hmXSB0byByZXR1cm4gYSBuZXcgdHJhbnNmb3JtZXIgKHRyYW5zZHVjZXIgY2FzZSkuIE90aGVyd2lzZSwgaXQgd2lsbFxuICAgICAqIGRlZmF1bHQgdG8gZXhlY3V0aW5nIFtmbl0uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RuYW1lIHByb3BlcnR5IHRvIGNoZWNrIGZvciBhIGN1c3RvbSBpbXBsZW1lbnRhdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHhmIHRyYW5zZHVjZXIgdG8gaW5pdGlhbGl6ZSBpZiBvYmplY3QgaXMgdHJhbnNmb3JtZXJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBkZWZhdWx0IHJhbWRhIGltcGxlbWVudGF0aW9uXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdGhhdCBkaXNwYXRjaGVzIG9uIG9iamVjdCBpbiBsaXN0IHBvc2l0aW9uXG4gICAgICovXG4gICAgdmFyIF9kaXNwYXRjaGFibGUgPSBmdW5jdGlvbiBfZGlzcGF0Y2hhYmxlKG1ldGhvZG5hbWUsIHhmLCBmbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb2JqID0gYXJndW1lbnRzW2xlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKCFfaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBfc2xpY2UoYXJndW1lbnRzLCAwLCBsZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9ialttZXRob2RuYW1lXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqW21ldGhvZG5hbWVdLmFwcGx5KG9iaiwgYXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfaXNUcmFuc2Zvcm1lcihvYmopKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFuc2R1Y2VyID0geGYuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc2R1Y2VyKG9iaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBfZHJvcExhc3RXaGlsZSA9IGZ1bmN0aW9uIGRyb3BMYXN0V2hpbGUocHJlZCwgbGlzdCkge1xuICAgICAgICB2YXIgaWR4ID0gbGlzdC5sZW5ndGggLSAxO1xuICAgICAgICB3aGlsZSAoaWR4ID49IDAgJiYgcHJlZChsaXN0W2lkeF0pKSB7XG4gICAgICAgICAgICBpZHggLT0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3NsaWNlKGxpc3QsIDAsIGlkeCArIDEpO1xuICAgIH07XG5cbiAgICB2YXIgX3hhbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFhBbGwoZiwgeGYpIHtcbiAgICAgICAgICAgIHRoaXMueGYgPSB4ZjtcbiAgICAgICAgICAgIHRoaXMuZiA9IGY7XG4gICAgICAgICAgICB0aGlzLmFsbCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgWEFsbC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBfeGZCYXNlLmluaXQ7XG4gICAgICAgIFhBbGwucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hbGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKHJlc3VsdCk7XG4gICAgICAgIH07XG4gICAgICAgIFhBbGwucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24gKHJlc3VsdCwgaW5wdXQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5mKGlucHV0KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWxsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gX3JlZHVjZWQodGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIGZhbHNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX2N1cnJ5MihmdW5jdGlvbiBfeGFsbChmLCB4Zikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBYQWxsKGYsIHhmKTtcbiAgICAgICAgfSk7XG4gICAgfSgpO1xuXG4gICAgdmFyIF94YW55ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBYQW55KGYsIHhmKSB7XG4gICAgICAgICAgICB0aGlzLnhmID0geGY7XG4gICAgICAgICAgICB0aGlzLmYgPSBmO1xuICAgICAgICAgICAgdGhpcy5hbnkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBYQW55LnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IF94ZkJhc2UuaW5pdDtcbiAgICAgICAgWEFueS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5hbnkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueGZbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXShyZXN1bHQpO1xuICAgICAgICB9O1xuICAgICAgICBYQW55LnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uIChyZXN1bHQsIGlucHV0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5mKGlucHV0KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYW55ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBfcmVkdWNlZCh0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgdHJ1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF9jdXJyeTIoZnVuY3Rpb24gX3hhbnkoZiwgeGYpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgWEFueShmLCB4Zik7XG4gICAgICAgIH0pO1xuICAgIH0oKTtcblxuICAgIHZhciBfeGFwZXJ0dXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBYQXBlcnR1cmUobiwgeGYpIHtcbiAgICAgICAgICAgIHRoaXMueGYgPSB4ZjtcbiAgICAgICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgICAgIHRoaXMuZnVsbCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5hY2MgPSBuZXcgQXJyYXkobik7XG4gICAgICAgIH1cbiAgICAgICAgWEFwZXJ0dXJlLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IF94ZkJhc2UuaW5pdDtcbiAgICAgICAgWEFwZXJ0dXJlLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgdGhpcy5hY2MgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMueGZbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXShyZXN1bHQpO1xuICAgICAgICB9O1xuICAgICAgICBYQXBlcnR1cmUucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24gKHJlc3VsdCwgaW5wdXQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmUoaW5wdXQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnVsbCA/IHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCB0aGlzLmdldENvcHkoKSkgOiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICAgIFhBcGVydHVyZS5wcm90b3R5cGUuc3RvcmUgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICAgIHRoaXMuYWNjW3RoaXMucG9zXSA9IGlucHV0O1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gdGhpcy5hY2MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuZnVsbCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFhBcGVydHVyZS5wcm90b3R5cGUuZ2V0Q29weSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfY29uY2F0KF9zbGljZSh0aGlzLmFjYywgdGhpcy5wb3MpLCBfc2xpY2UodGhpcy5hY2MsIDAsIHRoaXMucG9zKSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfY3VycnkyKGZ1bmN0aW9uIF94YXBlcnR1cmUobiwgeGYpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgWEFwZXJ0dXJlKG4sIHhmKTtcbiAgICAgICAgfSk7XG4gICAgfSgpO1xuXG4gICAgdmFyIF94ZHJvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gWERyb3AobiwgeGYpIHtcbiAgICAgICAgICAgIHRoaXMueGYgPSB4ZjtcbiAgICAgICAgICAgIHRoaXMubiA9IG47XG4gICAgICAgIH1cbiAgICAgICAgWERyb3AucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gX3hmQmFzZS5pbml0O1xuICAgICAgICBYRHJvcC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IF94ZkJhc2UucmVzdWx0O1xuICAgICAgICBYRHJvcC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbiAocmVzdWx0LCBpbnB1dCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubiA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm4gLT0gMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCBpbnB1dCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfY3VycnkyKGZ1bmN0aW9uIF94ZHJvcChuLCB4Zikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBYRHJvcChuLCB4Zik7XG4gICAgICAgIH0pO1xuICAgIH0oKTtcblxuICAgIHZhciBfeGRyb3BMYXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBYRHJvcExhc3QobiwgeGYpIHtcbiAgICAgICAgICAgIHRoaXMueGYgPSB4ZjtcbiAgICAgICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgICAgIHRoaXMuZnVsbCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5hY2MgPSBuZXcgQXJyYXkobik7XG4gICAgICAgIH1cbiAgICAgICAgWERyb3BMYXN0LnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IF94ZkJhc2UuaW5pdDtcbiAgICAgICAgWERyb3BMYXN0LnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgdGhpcy5hY2MgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMueGZbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXShyZXN1bHQpO1xuICAgICAgICB9O1xuICAgICAgICBYRHJvcExhc3QucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24gKHJlc3VsdCwgaW5wdXQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZ1bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgdGhpcy5hY2NbdGhpcy5wb3NdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RvcmUoaW5wdXQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgWERyb3BMYXN0LnByb3RvdHlwZS5zdG9yZSA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgdGhpcy5hY2NbdGhpcy5wb3NdID0gaW5wdXQ7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSB0aGlzLmFjYy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5mdWxsID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF9jdXJyeTIoZnVuY3Rpb24gX3hkcm9wTGFzdChuLCB4Zikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBYRHJvcExhc3QobiwgeGYpO1xuICAgICAgICB9KTtcbiAgICB9KCk7XG5cbiAgICB2YXIgX3hkcm9wUmVwZWF0c1dpdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFhEcm9wUmVwZWF0c1dpdGgocHJlZCwgeGYpIHtcbiAgICAgICAgICAgIHRoaXMueGYgPSB4ZjtcbiAgICAgICAgICAgIHRoaXMucHJlZCA9IHByZWQ7XG4gICAgICAgICAgICB0aGlzLmxhc3RWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuc2VlbkZpcnN0VmFsdWUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBYRHJvcFJlcGVhdHNXaXRoLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnhmWydAQHRyYW5zZHVjZXIvaW5pdCddKCk7XG4gICAgICAgIH07XG4gICAgICAgIFhEcm9wUmVwZWF0c1dpdGgucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKHJlc3VsdCk7XG4gICAgICAgIH07XG4gICAgICAgIFhEcm9wUmVwZWF0c1dpdGgucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24gKHJlc3VsdCwgaW5wdXQpIHtcbiAgICAgICAgICAgIHZhciBzYW1lQXNMYXN0ID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2VlbkZpcnN0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlZW5GaXJzdFZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmVkKHRoaXMubGFzdFZhbHVlLCBpbnB1dCkpIHtcbiAgICAgICAgICAgICAgICBzYW1lQXNMYXN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubGFzdFZhbHVlID0gaW5wdXQ7XG4gICAgICAgICAgICByZXR1cm4gc2FtZUFzTGFzdCA/IHJlc3VsdCA6IHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCBpbnB1dCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfY3VycnkyKGZ1bmN0aW9uIF94ZHJvcFJlcGVhdHNXaXRoKHByZWQsIHhmKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFhEcm9wUmVwZWF0c1dpdGgocHJlZCwgeGYpO1xuICAgICAgICB9KTtcbiAgICB9KCk7XG5cbiAgICB2YXIgX3hkcm9wV2hpbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFhEcm9wV2hpbGUoZiwgeGYpIHtcbiAgICAgICAgICAgIHRoaXMueGYgPSB4ZjtcbiAgICAgICAgICAgIHRoaXMuZiA9IGY7XG4gICAgICAgIH1cbiAgICAgICAgWERyb3BXaGlsZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBfeGZCYXNlLmluaXQ7XG4gICAgICAgIFhEcm9wV2hpbGUucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBfeGZCYXNlLnJlc3VsdDtcbiAgICAgICAgWERyb3BXaGlsZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbiAocmVzdWx0LCBpbnB1dCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmYoaW5wdXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIGlucHV0KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF9jdXJyeTIoZnVuY3Rpb24gX3hkcm9wV2hpbGUoZiwgeGYpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgWERyb3BXaGlsZShmLCB4Zik7XG4gICAgICAgIH0pO1xuICAgIH0oKTtcblxuICAgIHZhciBfeGZpbHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gWEZpbHRlcihmLCB4Zikge1xuICAgICAgICAgICAgdGhpcy54ZiA9IHhmO1xuICAgICAgICAgICAgdGhpcy5mID0gZjtcbiAgICAgICAgfVxuICAgICAgICBYRmlsdGVyLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IF94ZkJhc2UuaW5pdDtcbiAgICAgICAgWEZpbHRlci5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IF94ZkJhc2UucmVzdWx0O1xuICAgICAgICBYRmlsdGVyLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uIChyZXN1bHQsIGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mKGlucHV0KSA/IHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCBpbnB1dCkgOiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfY3VycnkyKGZ1bmN0aW9uIF94ZmlsdGVyKGYsIHhmKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFhGaWx0ZXIoZiwgeGYpO1xuICAgICAgICB9KTtcbiAgICB9KCk7XG5cbiAgICB2YXIgX3hmaW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBYRmluZChmLCB4Zikge1xuICAgICAgICAgICAgdGhpcy54ZiA9IHhmO1xuICAgICAgICAgICAgdGhpcy5mID0gZjtcbiAgICAgICAgICAgIHRoaXMuZm91bmQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBYRmluZC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBfeGZCYXNlLmluaXQ7XG4gICAgICAgIFhGaW5kLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZvdW5kKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIHZvaWQgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKHJlc3VsdCk7XG4gICAgICAgIH07XG4gICAgICAgIFhGaW5kLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uIChyZXN1bHQsIGlucHV0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5mKGlucHV0KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9yZWR1Y2VkKHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCBpbnB1dCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF9jdXJyeTIoZnVuY3Rpb24gX3hmaW5kKGYsIHhmKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFhGaW5kKGYsIHhmKTtcbiAgICAgICAgfSk7XG4gICAgfSgpO1xuXG4gICAgdmFyIF94ZmluZEluZGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBYRmluZEluZGV4KGYsIHhmKSB7XG4gICAgICAgICAgICB0aGlzLnhmID0geGY7XG4gICAgICAgICAgICB0aGlzLmYgPSBmO1xuICAgICAgICAgICAgdGhpcy5pZHggPSAtMTtcbiAgICAgICAgICAgIHRoaXMuZm91bmQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBYRmluZEluZGV4LnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IF94ZkJhc2UuaW5pdDtcbiAgICAgICAgWEZpbmRJbmRleC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5mb3VuZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCAtMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKHJlc3VsdCk7XG4gICAgICAgIH07XG4gICAgICAgIFhGaW5kSW5kZXgucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24gKHJlc3VsdCwgaW5wdXQpIHtcbiAgICAgICAgICAgIHRoaXMuaWR4ICs9IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5mKGlucHV0KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9yZWR1Y2VkKHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCB0aGlzLmlkeCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF9jdXJyeTIoZnVuY3Rpb24gX3hmaW5kSW5kZXgoZiwgeGYpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgWEZpbmRJbmRleChmLCB4Zik7XG4gICAgICAgIH0pO1xuICAgIH0oKTtcblxuICAgIHZhciBfeGZpbmRMYXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBYRmluZExhc3QoZiwgeGYpIHtcbiAgICAgICAgICAgIHRoaXMueGYgPSB4ZjtcbiAgICAgICAgICAgIHRoaXMuZiA9IGY7XG4gICAgICAgIH1cbiAgICAgICAgWEZpbmRMYXN0LnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IF94ZkJhc2UuaW5pdDtcbiAgICAgICAgWEZpbmRMYXN0LnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMueGZbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSh0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgdGhpcy5sYXN0KSk7XG4gICAgICAgIH07XG4gICAgICAgIFhGaW5kTGFzdC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbiAocmVzdWx0LCBpbnB1dCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZihpbnB1dCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3QgPSBpbnB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfY3VycnkyKGZ1bmN0aW9uIF94ZmluZExhc3QoZiwgeGYpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgWEZpbmRMYXN0KGYsIHhmKTtcbiAgICAgICAgfSk7XG4gICAgfSgpO1xuXG4gICAgdmFyIF94ZmluZExhc3RJbmRleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gWEZpbmRMYXN0SW5kZXgoZiwgeGYpIHtcbiAgICAgICAgICAgIHRoaXMueGYgPSB4ZjtcbiAgICAgICAgICAgIHRoaXMuZiA9IGY7XG4gICAgICAgICAgICB0aGlzLmlkeCA9IC0xO1xuICAgICAgICAgICAgdGhpcy5sYXN0SWR4ID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgWEZpbmRMYXN0SW5kZXgucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gX3hmQmFzZS5pbml0O1xuICAgICAgICBYRmluZExhc3RJbmRleC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnhmWydAQHRyYW5zZHVjZXIvcmVzdWx0J10odGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIHRoaXMubGFzdElkeCkpO1xuICAgICAgICB9O1xuICAgICAgICBYRmluZExhc3RJbmRleC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbiAocmVzdWx0LCBpbnB1dCkge1xuICAgICAgICAgICAgdGhpcy5pZHggKz0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLmYoaW5wdXQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0SWR4ID0gdGhpcy5pZHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX2N1cnJ5MihmdW5jdGlvbiBfeGZpbmRMYXN0SW5kZXgoZiwgeGYpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgWEZpbmRMYXN0SW5kZXgoZiwgeGYpO1xuICAgICAgICB9KTtcbiAgICB9KCk7XG5cbiAgICB2YXIgX3htYXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFhNYXAoZiwgeGYpIHtcbiAgICAgICAgICAgIHRoaXMueGYgPSB4ZjtcbiAgICAgICAgICAgIHRoaXMuZiA9IGY7XG4gICAgICAgIH1cbiAgICAgICAgWE1hcC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBfeGZCYXNlLmluaXQ7XG4gICAgICAgIFhNYXAucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBfeGZCYXNlLnJlc3VsdDtcbiAgICAgICAgWE1hcC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbiAocmVzdWx0LCBpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCB0aGlzLmYoaW5wdXQpKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF9jdXJyeTIoZnVuY3Rpb24gX3htYXAoZiwgeGYpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgWE1hcChmLCB4Zik7XG4gICAgICAgIH0pO1xuICAgIH0oKTtcblxuICAgIHZhciBfeHRha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFhUYWtlKG4sIHhmKSB7XG4gICAgICAgICAgICB0aGlzLnhmID0geGY7XG4gICAgICAgICAgICB0aGlzLm4gPSBuO1xuICAgICAgICB9XG4gICAgICAgIFhUYWtlLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IF94ZkJhc2UuaW5pdDtcbiAgICAgICAgWFRha2UucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBfeGZCYXNlLnJlc3VsdDtcbiAgICAgICAgWFRha2UucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24gKHJlc3VsdCwgaW5wdXQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm4gPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3JlZHVjZWQocmVzdWx0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uIC09IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCBpbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfY3VycnkyKGZ1bmN0aW9uIF94dGFrZShuLCB4Zikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBYVGFrZShuLCB4Zik7XG4gICAgICAgIH0pO1xuICAgIH0oKTtcblxuICAgIHZhciBfeHRha2VXaGlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gWFRha2VXaGlsZShmLCB4Zikge1xuICAgICAgICAgICAgdGhpcy54ZiA9IHhmO1xuICAgICAgICAgICAgdGhpcy5mID0gZjtcbiAgICAgICAgfVxuICAgICAgICBYVGFrZVdoaWxlLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IF94ZkJhc2UuaW5pdDtcbiAgICAgICAgWFRha2VXaGlsZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IF94ZkJhc2UucmVzdWx0O1xuICAgICAgICBYVGFrZVdoaWxlLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uIChyZXN1bHQsIGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mKGlucHV0KSA/IHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCBpbnB1dCkgOiBfcmVkdWNlZChyZXN1bHQpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX2N1cnJ5MihmdW5jdGlvbiBfeHRha2VXaGlsZShmLCB4Zikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBYVGFrZVdoaWxlKGYsIHhmKTtcbiAgICAgICAgfSk7XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogQWRkcyB0d28gdmFsdWVzLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBzaWcgTnVtYmVyIC0+IE51bWJlciAtPiBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBiXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqIEBzZWUgUi5zdWJ0cmFjdFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuYWRkKDIsIDMpOyAgICAgICAvLz0+ICA1XG4gICAgICogICAgICBSLmFkZCg3KSgxMCk7ICAgICAgLy89PiAxN1xuICAgICAqL1xuICAgIHZhciBhZGQgPSBfY3VycnkyKGZ1bmN0aW9uIGFkZChhLCBiKSB7XG4gICAgICAgIHJldHVybiBOdW1iZXIoYSkgKyBOdW1iZXIoYik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGEgZnVuY3Rpb24gdG8gdGhlIHZhbHVlIGF0IHRoZSBnaXZlbiBpbmRleCBvZiBhbiBhcnJheSwgcmV0dXJuaW5nIGFcbiAgICAgKiBuZXcgY29weSBvZiB0aGUgYXJyYXkgd2l0aCB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXggcmVwbGFjZWQgd2l0aCB0aGVcbiAgICAgKiByZXN1bHQgb2YgdGhlIGZ1bmN0aW9uIGFwcGxpY2F0aW9uLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xNC4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIChhIC0+IGEpIC0+IE51bWJlciAtPiBbYV0gLT4gW2FdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGFwcGx5LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpZHggVGhlIGluZGV4LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8QXJndW1lbnRzfSBsaXN0IEFuIGFycmF5LWxpa2Ugb2JqZWN0IHdob3NlIHZhbHVlXG4gICAgICogICAgICAgIGF0IHRoZSBzdXBwbGllZCBpbmRleCB3aWxsIGJlIHJlcGxhY2VkLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBBIGNvcHkgb2YgdGhlIHN1cHBsaWVkIGFycmF5LWxpa2Ugb2JqZWN0IHdpdGhcbiAgICAgKiAgICAgICAgIHRoZSBlbGVtZW50IGF0IGluZGV4IGBpZHhgIHJlcGxhY2VkIHdpdGggdGhlIHZhbHVlXG4gICAgICogICAgICAgICByZXR1cm5lZCBieSBhcHBseWluZyBgZm5gIHRvIHRoZSBleGlzdGluZyBlbGVtZW50LlxuICAgICAqIEBzZWUgUi51cGRhdGVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLmFkanVzdChSLmFkZCgxMCksIDEsIFswLCAxLCAyXSk7ICAgICAvLz0+IFswLCAxMSwgMl1cbiAgICAgKiAgICAgIFIuYWRqdXN0KFIuYWRkKDEwKSkoMSkoWzAsIDEsIDJdKTsgICAgIC8vPT4gWzAsIDExLCAyXVxuICAgICAqL1xuICAgIHZhciBhZGp1c3QgPSBfY3VycnkzKGZ1bmN0aW9uIGFkanVzdChmbiwgaWR4LCBsaXN0KSB7XG4gICAgICAgIGlmIChpZHggPj0gbGlzdC5sZW5ndGggfHwgaWR4IDwgLWxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbGlzdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhcnQgPSBpZHggPCAwID8gbGlzdC5sZW5ndGggOiAwO1xuICAgICAgICB2YXIgX2lkeCA9IHN0YXJ0ICsgaWR4O1xuICAgICAgICB2YXIgX2xpc3QgPSBfY29uY2F0KGxpc3QpO1xuICAgICAgICBfbGlzdFtfaWR4XSA9IGZuKGxpc3RbX2lkeF0pO1xuICAgICAgICByZXR1cm4gX2xpc3Q7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBhbGwgZWxlbWVudHMgb2YgdGhlIGxpc3QgbWF0Y2ggdGhlIHByZWRpY2F0ZSwgYGZhbHNlYCBpZlxuICAgICAqIHRoZXJlIGFyZSBhbnkgdGhhdCBkb24ndC5cbiAgICAgKlxuICAgICAqIERpc3BhdGNoZXMgdG8gdGhlIGBhbGxgIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICAgICAqXG4gICAgICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gW2FdIC0+IEJvb2xlYW5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgcHJlZGljYXRlIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGNvbnNpZGVyLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgcHJlZGljYXRlIGlzIHNhdGlzZmllZCBieSBldmVyeSBlbGVtZW50LCBgZmFsc2VgXG4gICAgICogICAgICAgICBvdGhlcndpc2UuXG4gICAgICogQHNlZSBSLmFueSwgUi5ub25lLCBSLnRyYW5zZHVjZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBsZXNzVGhhbjIgPSBSLmZsaXAoUi5sdCkoMik7XG4gICAgICogICAgICB2YXIgbGVzc1RoYW4zID0gUi5mbGlwKFIubHQpKDMpO1xuICAgICAqICAgICAgUi5hbGwobGVzc1RoYW4yKShbMSwgMl0pOyAvLz0+IGZhbHNlXG4gICAgICogICAgICBSLmFsbChsZXNzVGhhbjMpKFsxLCAyXSk7IC8vPT4gdHJ1ZVxuICAgICAqL1xuICAgIHZhciBhbGwgPSBfY3VycnkyKF9kaXNwYXRjaGFibGUoJ2FsbCcsIF94YWxsLCBmdW5jdGlvbiBhbGwoZm4sIGxpc3QpIHtcbiAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgIHdoaWxlIChpZHggPCBsaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCFmbihsaXN0W2lkeF0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSkpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgYWx3YXlzIHJldHVybnMgdGhlIGdpdmVuIHZhbHVlLiBOb3RlIHRoYXQgZm9yXG4gICAgICogbm9uLXByaW1pdGl2ZXMgdGhlIHZhbHVlIHJldHVybmVkIGlzIGEgcmVmZXJlbmNlIHRvIHRoZSBvcmlnaW5hbCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMga25vd24gYXMgYGNvbnN0YCwgYGNvbnN0YW50YCwgb3IgYEtgIChmb3IgSyBjb21iaW5hdG9yKSBpblxuICAgICAqIG90aGVyIGxhbmd1YWdlcyBhbmQgbGlicmFyaWVzLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAc2lnIGEgLT4gKCogLT4gYSlcbiAgICAgKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gd3JhcCBpbiBhIGZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IEEgRnVuY3Rpb24gOjogKiAtPiB2YWwuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIHQgPSBSLmFsd2F5cygnVGVlJyk7XG4gICAgICogICAgICB0KCk7IC8vPT4gJ1RlZSdcbiAgICAgKi9cbiAgICB2YXIgYWx3YXlzID0gX2N1cnJ5MShmdW5jdGlvbiBhbHdheXModmFsKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgYm90aCBhcmd1bWVudHMgYXJlIGB0cnVlYDsgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMb2dpY1xuICAgICAqIEBzaWcgKiAtPiAqIC0+ICpcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGEgQSBib29sZWFuIHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBiIEEgYm9vbGVhbiB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiBib3RoIGFyZ3VtZW50cyBhcmUgYHRydWVgLCBgZmFsc2VgIG90aGVyd2lzZVxuICAgICAqIEBzZWUgUi5ib3RoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5hbmQodHJ1ZSwgdHJ1ZSk7IC8vPT4gdHJ1ZVxuICAgICAqICAgICAgUi5hbmQodHJ1ZSwgZmFsc2UpOyAvLz0+IGZhbHNlXG4gICAgICogICAgICBSLmFuZChmYWxzZSwgdHJ1ZSk7IC8vPT4gZmFsc2VcbiAgICAgKiAgICAgIFIuYW5kKGZhbHNlLCBmYWxzZSk7IC8vPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgYW5kID0gX2N1cnJ5MihmdW5jdGlvbiBhbmQoYSwgYikge1xuICAgICAgICByZXR1cm4gYSAmJiBiO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgYXQgbGVhc3Qgb25lIG9mIGVsZW1lbnRzIG9mIHRoZSBsaXN0IG1hdGNoIHRoZSBwcmVkaWNhdGUsXG4gICAgICogYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBEaXNwYXRjaGVzIHRvIHRoZSBgYW55YCBtZXRob2Qgb2YgdGhlIHNlY29uZCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIEFjdHMgYXMgYSB0cmFuc2R1Y2VyIGlmIGEgdHJhbnNmb3JtZXIgaXMgZ2l2ZW4gaW4gbGlzdCBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IFthXSAtPiBCb29sZWFuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIHByZWRpY2F0ZSBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBjb25zaWRlci5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIHByZWRpY2F0ZSBpcyBzYXRpc2ZpZWQgYnkgYXQgbGVhc3Qgb25lIGVsZW1lbnQsIGBmYWxzZWBcbiAgICAgKiAgICAgICAgIG90aGVyd2lzZS5cbiAgICAgKiBAc2VlIFIuYWxsLCBSLm5vbmUsIFIudHJhbnNkdWNlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGxlc3NUaGFuMCA9IFIuZmxpcChSLmx0KSgwKTtcbiAgICAgKiAgICAgIHZhciBsZXNzVGhhbjIgPSBSLmZsaXAoUi5sdCkoMik7XG4gICAgICogICAgICBSLmFueShsZXNzVGhhbjApKFsxLCAyXSk7IC8vPT4gZmFsc2VcbiAgICAgKiAgICAgIFIuYW55KGxlc3NUaGFuMikoWzEsIDJdKTsgLy89PiB0cnVlXG4gICAgICovXG4gICAgdmFyIGFueSA9IF9jdXJyeTIoX2Rpc3BhdGNoYWJsZSgnYW55JywgX3hhbnksIGZ1bmN0aW9uIGFueShmbiwgbGlzdCkge1xuICAgICAgICB2YXIgaWR4ID0gMDtcbiAgICAgICAgd2hpbGUgKGlkeCA8IGxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoZm4obGlzdFtpZHhdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgbGlzdCwgY29tcG9zZWQgb2Ygbi10dXBsZXMgb2YgY29uc2VjdXRpdmUgZWxlbWVudHMgSWYgYG5gIGlzXG4gICAgICogZ3JlYXRlciB0aGFuIHRoZSBsZW5ndGggb2YgdGhlIGxpc3QsIGFuIGVtcHR5IGxpc3QgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBEaXNwYXRjaGVzIHRvIHRoZSBgYXBlcnR1cmVgIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICAgICAqXG4gICAgICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xMi4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIE51bWJlciAtPiBbYV0gLT4gW1thXV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbiBUaGUgc2l6ZSBvZiB0aGUgdHVwbGVzIHRvIGNyZWF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3QgdG8gc3BsaXQgaW50byBgbmAtdHVwbGVzXG4gICAgICogQHJldHVybiB7QXJyYXl9IFRoZSBuZXcgbGlzdC5cbiAgICAgKiBAc2VlIFIudHJhbnNkdWNlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5hcGVydHVyZSgyLCBbMSwgMiwgMywgNCwgNV0pOyAvLz0+IFtbMSwgMl0sIFsyLCAzXSwgWzMsIDRdLCBbNCwgNV1dXG4gICAgICogICAgICBSLmFwZXJ0dXJlKDMsIFsxLCAyLCAzLCA0LCA1XSk7IC8vPT4gW1sxLCAyLCAzXSwgWzIsIDMsIDRdLCBbMywgNCwgNV1dXG4gICAgICogICAgICBSLmFwZXJ0dXJlKDcsIFsxLCAyLCAzLCA0LCA1XSk7IC8vPT4gW11cbiAgICAgKi9cbiAgICB2YXIgYXBlcnR1cmUgPSBfY3VycnkyKF9kaXNwYXRjaGFibGUoJ2FwZXJ0dXJlJywgX3hhcGVydHVyZSwgX2FwZXJ0dXJlKSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IGxpc3QgY29udGFpbmluZyB0aGUgY29udGVudHMgb2YgdGhlIGdpdmVuIGxpc3QsIGZvbGxvd2VkIGJ5XG4gICAgICogdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyBhIC0+IFthXSAtPiBbYV1cbiAgICAgKiBAcGFyYW0geyp9IGVsIFRoZSBlbGVtZW50IHRvIGFkZCB0byB0aGUgZW5kIG9mIHRoZSBuZXcgbGlzdC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHdob3NlIGNvbnRlbnRzIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgb3V0cHV0XG4gICAgICogICAgICAgIGxpc3QuXG4gICAgICogQHJldHVybiB7QXJyYXl9IEEgbmV3IGxpc3QgY29udGFpbmluZyB0aGUgY29udGVudHMgb2YgdGhlIG9sZCBsaXN0IGZvbGxvd2VkIGJ5IGBlbGAuXG4gICAgICogQHNlZSBSLnByZXBlbmRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLmFwcGVuZCgndGVzdHMnLCBbJ3dyaXRlJywgJ21vcmUnXSk7IC8vPT4gWyd3cml0ZScsICdtb3JlJywgJ3Rlc3RzJ11cbiAgICAgKiAgICAgIFIuYXBwZW5kKCd0ZXN0cycsIFtdKTsgLy89PiBbJ3Rlc3RzJ11cbiAgICAgKiAgICAgIFIuYXBwZW5kKFsndGVzdHMnXSwgWyd3cml0ZScsICdtb3JlJ10pOyAvLz0+IFsnd3JpdGUnLCAnbW9yZScsIFsndGVzdHMnXV1cbiAgICAgKi9cbiAgICB2YXIgYXBwZW5kID0gX2N1cnJ5MihmdW5jdGlvbiBhcHBlbmQoZWwsIGxpc3QpIHtcbiAgICAgICAgcmV0dXJuIF9jb25jYXQobGlzdCwgW2VsXSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGZ1bmN0aW9uIGBmbmAgdG8gdGhlIGFyZ3VtZW50IGxpc3QgYGFyZ3NgLiBUaGlzIGlzIHVzZWZ1bCBmb3JcbiAgICAgKiBjcmVhdGluZyBhIGZpeGVkLWFyaXR5IGZ1bmN0aW9uIGZyb20gYSB2YXJpYWRpYyBmdW5jdGlvbi4gYGZuYCBzaG91bGQgYmUgYVxuICAgICAqIGJvdW5kIGZ1bmN0aW9uIGlmIGNvbnRleHQgaXMgc2lnbmlmaWNhbnQuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjcuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBzaWcgKCouLi4gLT4gYSkgLT4gWypdIC0+IGFcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3NcbiAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAqIEBzZWUgUi5jYWxsLCBSLnVuYXBwbHlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgbnVtcyA9IFsxLCAyLCAzLCAtOTksIDQyLCA2LCA3XTtcbiAgICAgKiAgICAgIFIuYXBwbHkoTWF0aC5tYXgsIG51bXMpOyAvLz0+IDQyXG4gICAgICovXG4gICAgdmFyIGFwcGx5ID0gX2N1cnJ5MihmdW5jdGlvbiBhcHBseShmbiwgYXJncykge1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBNYWtlcyBhIHNoYWxsb3cgY2xvbmUgb2YgYW4gb2JqZWN0LCBzZXR0aW5nIG9yIG92ZXJyaWRpbmcgdGhlIHNwZWNpZmllZFxuICAgICAqIHByb3BlcnR5IHdpdGggdGhlIGdpdmVuIHZhbHVlLiBOb3RlIHRoYXQgdGhpcyBjb3BpZXMgYW5kIGZsYXR0ZW5zIHByb3RvdHlwZVxuICAgICAqIHByb3BlcnRpZXMgb250byB0aGUgbmV3IG9iamVjdCBhcyB3ZWxsLiBBbGwgbm9uLXByaW1pdGl2ZSBwcm9wZXJ0aWVzIGFyZVxuICAgICAqIGNvcGllZCBieSByZWZlcmVuY2UuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjguMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAc2lnIFN0cmluZyAtPiBhIC0+IHtrOiB2fSAtPiB7azogdn1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcCB0aGUgcHJvcGVydHkgbmFtZSB0byBzZXRcbiAgICAgKiBAcGFyYW0geyp9IHZhbCB0aGUgbmV3IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiB0aGUgb2JqZWN0IHRvIGNsb25lXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBhIG5ldyBvYmplY3Qgc2ltaWxhciB0byB0aGUgb3JpZ2luYWwgZXhjZXB0IGZvciB0aGUgc3BlY2lmaWVkIHByb3BlcnR5LlxuICAgICAqIEBzZWUgUi5kaXNzb2NcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLmFzc29jKCdjJywgMywge2E6IDEsIGI6IDJ9KTsgLy89PiB7YTogMSwgYjogMiwgYzogM31cbiAgICAgKi9cbiAgICB2YXIgYXNzb2MgPSBfY3VycnkzKGZ1bmN0aW9uIGFzc29jKHByb3AsIHZhbCwgb2JqKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBvYmopIHtcbiAgICAgICAgICAgIHJlc3VsdFtwXSA9IG9ialtwXTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbcHJvcF0gPSB2YWw7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBNYWtlcyBhIHNoYWxsb3cgY2xvbmUgb2YgYW4gb2JqZWN0LCBzZXR0aW5nIG9yIG92ZXJyaWRpbmcgdGhlIG5vZGVzIHJlcXVpcmVkXG4gICAgICogdG8gY3JlYXRlIHRoZSBnaXZlbiBwYXRoLCBhbmQgcGxhY2luZyB0aGUgc3BlY2lmaWMgdmFsdWUgYXQgdGhlIHRhaWwgZW5kIG9mXG4gICAgICogdGhhdCBwYXRoLiBOb3RlIHRoYXQgdGhpcyBjb3BpZXMgYW5kIGZsYXR0ZW5zIHByb3RvdHlwZSBwcm9wZXJ0aWVzIG9udG8gdGhlXG4gICAgICogbmV3IG9iamVjdCBhcyB3ZWxsLiBBbGwgbm9uLXByaW1pdGl2ZSBwcm9wZXJ0aWVzIGFyZSBjb3BpZWQgYnkgcmVmZXJlbmNlLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC44LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHNpZyBbU3RyaW5nXSAtPiBhIC0+IHtrOiB2fSAtPiB7azogdn1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoIHRoZSBwYXRoIHRvIHNldFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsIHRoZSBuZXcgdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIHRoZSBvYmplY3QgdG8gY2xvbmVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGEgbmV3IG9iamVjdCBzaW1pbGFyIHRvIHRoZSBvcmlnaW5hbCBleGNlcHQgYWxvbmcgdGhlIHNwZWNpZmllZCBwYXRoLlxuICAgICAqIEBzZWUgUi5kaXNzb2NQYXRoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5hc3NvY1BhdGgoWydhJywgJ2InLCAnYyddLCA0Miwge2E6IHtiOiB7YzogMH19fSk7IC8vPT4ge2E6IHtiOiB7YzogNDJ9fX1cbiAgICAgKi9cbiAgICB2YXIgYXNzb2NQYXRoID0gX2N1cnJ5MyhmdW5jdGlvbiBhc3NvY1BhdGgocGF0aCwgdmFsLCBvYmopIHtcbiAgICAgICAgc3dpdGNoIChwYXRoLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gYXNzb2MocGF0aFswXSwgdmFsLCBvYmopO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGFzc29jKHBhdGhbMF0sIGFzc29jUGF0aChfc2xpY2UocGF0aCwgMSksIHZhbCwgT2JqZWN0KG9ialtwYXRoWzBdXSkpLCBvYmopO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpcyBib3VuZCB0byBhIGNvbnRleHQuXG4gICAgICogTm90ZTogYFIuYmluZGAgZG9lcyBub3QgcHJvdmlkZSB0aGUgYWRkaXRpb25hbCBhcmd1bWVudC1iaW5kaW5nIGNhcGFiaWxpdGllcyBvZlxuICAgICAqIFtGdW5jdGlvbi5wcm90b3R5cGUuYmluZF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vYmluZCkuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjYuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAc2lnICgqIC0+ICopIC0+IHsqfSAtPiAoKiAtPiAqKVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBiaW5kIHRvIGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGhpc09iaiBUaGUgY29udGV4dCB0byBiaW5kIGBmbmAgdG9cbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0aGF0IHdpbGwgZXhlY3V0ZSBpbiB0aGUgY29udGV4dCBvZiBgdGhpc09iamAuXG4gICAgICogQHNlZSBSLnBhcnRpYWxcbiAgICAgKi9cbiAgICB2YXIgYmluZCA9IF9jdXJyeTIoZnVuY3Rpb24gYmluZChmbiwgdGhpc09iaikge1xuICAgICAgICByZXR1cm4gX2FyaXR5KGZuLmxlbmd0aCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNPYmosIGFyZ3VtZW50cyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmVzdHJpY3RzIGEgbnVtYmVyIHRvIGJlIHdpdGhpbiBhIHJhbmdlLlxuICAgICAqXG4gICAgICogQWxzbyB3b3JrcyBmb3Igb3RoZXIgb3JkZXJlZCB0eXBlcyBzdWNoIGFzIFN0cmluZ3MgYW5kIERhdGVzLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4yMC4wXG4gICAgICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gICAgICogQHNpZyBPcmQgYSA9PiBhIC0+IGEgLT4gYSAtPiBhXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1pbmltdW0gbnVtYmVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1heGltdW0gbnVtYmVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIHRvIGJlIGNsYW1wZWRcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFJldHVybnMgdGhlIGNsYW1wZWQgdmFsdWVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLmNsYW1wKDEsIDEwLCAtMSkgLy8gPT4gMVxuICAgICAqICAgICAgUi5jbGFtcCgxLCAxMCwgMTEpIC8vID0+IDEwXG4gICAgICogICAgICBSLmNsYW1wKDEsIDEwLCA0KSAgLy8gPT4gNFxuICAgICAqL1xuICAgIHZhciBjbGFtcCA9IF9jdXJyeTMoZnVuY3Rpb24gY2xhbXAobWluLCBtYXgsIHZhbHVlKSB7XG4gICAgICAgIGlmIChtaW4gPiBtYXgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWluIG11c3Qgbm90IGJlIGdyZWF0ZXIgdGhhbiBtYXggaW4gY2xhbXAobWluLCBtYXgsIHZhbHVlKScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZSA8IG1pbiA/IG1pbiA6IHZhbHVlID4gbWF4ID8gbWF4IDogdmFsdWU7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBNYWtlcyBhIGNvbXBhcmF0b3IgZnVuY3Rpb24gb3V0IG9mIGEgZnVuY3Rpb24gdGhhdCByZXBvcnRzIHdoZXRoZXIgdGhlIGZpcnN0XG4gICAgICogZWxlbWVudCBpcyBsZXNzIHRoYW4gdGhlIHNlY29uZC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHNpZyAoYSwgYiAtPiBCb29sZWFuKSAtPiAoYSwgYiAtPiBOdW1iZXIpXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZCBBIHByZWRpY2F0ZSBmdW5jdGlvbiBvZiBhcml0eSB0d28uXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IEEgRnVuY3Rpb24gOjogYSAtPiBiIC0+IEludCB0aGF0IHJldHVybnMgYC0xYCBpZiBhIDwgYiwgYDFgIGlmIGIgPCBhLCBvdGhlcndpc2UgYDBgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBjbXAgPSBSLmNvbXBhcmF0b3IoKGEsIGIpID0+IGEuYWdlIDwgYi5hZ2UpO1xuICAgICAqICAgICAgdmFyIHBlb3BsZSA9IFtcbiAgICAgKiAgICAgICAgLy8gLi4uXG4gICAgICogICAgICBdO1xuICAgICAqICAgICAgUi5zb3J0KGNtcCwgcGVvcGxlKTtcbiAgICAgKi9cbiAgICB2YXIgY29tcGFyYXRvciA9IF9jdXJyeTEoZnVuY3Rpb24gY29tcGFyYXRvcihwcmVkKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIHByZWQoYSwgYikgPyAtMSA6IHByZWQoYiwgYSkgPyAxIDogMDtcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjdXJyaWVkIGVxdWl2YWxlbnQgb2YgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLCB3aXRoIHRoZSBzcGVjaWZpZWRcbiAgICAgKiBhcml0eS4gVGhlIGN1cnJpZWQgZnVuY3Rpb24gaGFzIHR3byB1bnVzdWFsIGNhcGFiaWxpdGllcy4gRmlyc3QsIGl0c1xuICAgICAqIGFyZ3VtZW50cyBuZWVkbid0IGJlIHByb3ZpZGVkIG9uZSBhdCBhIHRpbWUuIElmIGBnYCBpcyBgUi5jdXJyeU4oMywgZilgLCB0aGVcbiAgICAgKiBmb2xsb3dpbmcgYXJlIGVxdWl2YWxlbnQ6XG4gICAgICpcbiAgICAgKiAgIC0gYGcoMSkoMikoMylgXG4gICAgICogICAtIGBnKDEpKDIsIDMpYFxuICAgICAqICAgLSBgZygxLCAyKSgzKWBcbiAgICAgKiAgIC0gYGcoMSwgMiwgMylgXG4gICAgICpcbiAgICAgKiBTZWNvbmRseSwgdGhlIHNwZWNpYWwgcGxhY2Vob2xkZXIgdmFsdWUgYFIuX19gIG1heSBiZSB1c2VkIHRvIHNwZWNpZnlcbiAgICAgKiBcImdhcHNcIiwgYWxsb3dpbmcgcGFydGlhbCBhcHBsaWNhdGlvbiBvZiBhbnkgY29tYmluYXRpb24gb2YgYXJndW1lbnRzLFxuICAgICAqIHJlZ2FyZGxlc3Mgb2YgdGhlaXIgcG9zaXRpb25zLiBJZiBgZ2AgaXMgYXMgYWJvdmUgYW5kIGBfYCBpcyBgUi5fX2AsIHRoZVxuICAgICAqIGZvbGxvd2luZyBhcmUgZXF1aXZhbGVudDpcbiAgICAgKlxuICAgICAqICAgLSBgZygxLCAyLCAzKWBcbiAgICAgKiAgIC0gYGcoXywgMiwgMykoMSlgXG4gICAgICogICAtIGBnKF8sIF8sIDMpKDEpKDIpYFxuICAgICAqICAgLSBgZyhfLCBfLCAzKSgxLCAyKWBcbiAgICAgKiAgIC0gYGcoXywgMikoMSkoMylgXG4gICAgICogICAtIGBnKF8sIDIpKDEsIDMpYFxuICAgICAqICAgLSBgZyhfLCAyKShfLCAzKSgxKWBcbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuNS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHNpZyBOdW1iZXIgLT4gKCogLT4gYSkgLT4gKCogLT4gYSlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIFRoZSBhcml0eSBmb3IgdGhlIHJldHVybmVkIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjdXJyeS5cbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBuZXcsIGN1cnJpZWQgZnVuY3Rpb24uXG4gICAgICogQHNlZSBSLmN1cnJ5XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIHN1bUFyZ3MgPSAoLi4uYXJncykgPT4gUi5zdW0oYXJncyk7XG4gICAgICpcbiAgICAgKiAgICAgIHZhciBjdXJyaWVkQWRkRm91ck51bWJlcnMgPSBSLmN1cnJ5Tig0LCBzdW1BcmdzKTtcbiAgICAgKiAgICAgIHZhciBmID0gY3VycmllZEFkZEZvdXJOdW1iZXJzKDEsIDIpO1xuICAgICAqICAgICAgdmFyIGcgPSBmKDMpO1xuICAgICAqICAgICAgZyg0KTsgLy89PiAxMFxuICAgICAqL1xuICAgIHZhciBjdXJyeU4gPSBfY3VycnkyKGZ1bmN0aW9uIGN1cnJ5TihsZW5ndGgsIGZuKSB7XG4gICAgICAgIGlmIChsZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBfY3VycnkxKGZuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2FyaXR5KGxlbmd0aCwgX2N1cnJ5TihsZW5ndGgsIFtdLCBmbikpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogRGVjcmVtZW50cyBpdHMgYXJndW1lbnQuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjkuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHNpZyBOdW1iZXIgLT4gTnVtYmVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICogQHNlZSBSLmluY1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuZGVjKDQyKTsgLy89PiA0MVxuICAgICAqL1xuICAgIHZhciBkZWMgPSBhZGQoLTEpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc2Vjb25kIGFyZ3VtZW50IGlmIGl0IGlzIG5vdCBgbnVsbGAsIGB1bmRlZmluZWRgIG9yIGBOYU5gXG4gICAgICogb3RoZXJ3aXNlIHRoZSBmaXJzdCBhcmd1bWVudCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBMb2dpY1xuICAgICAqIEBzaWcgYSAtPiBiIC0+IGEgfCBiXG4gICAgICogQHBhcmFtIHthfSB2YWwgVGhlIGRlZmF1bHQgdmFsdWUuXG4gICAgICogQHBhcmFtIHtifSB2YWwgVGhlIHZhbHVlIHRvIHJldHVybiBpZiBpdCBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgKiBAcmV0dXJuIHsqfSBUaGUgdGhlIHNlY29uZCB2YWx1ZSBvciB0aGUgZGVmYXVsdCB2YWx1ZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBkZWZhdWx0VG80MiA9IFIuZGVmYXVsdFRvKDQyKTtcbiAgICAgKlxuICAgICAqICAgICAgZGVmYXVsdFRvNDIobnVsbCk7ICAvLz0+IDQyXG4gICAgICogICAgICBkZWZhdWx0VG80Mih1bmRlZmluZWQpOyAgLy89PiA0MlxuICAgICAqICAgICAgZGVmYXVsdFRvNDIoJ1JhbWRhJyk7ICAvLz0+ICdSYW1kYSdcbiAgICAgKiAgICAgIGRlZmF1bHRUbzQyKHBhcnNlSW50KCdzdHJpbmcnKSk7IC8vPT4gNDJcbiAgICAgKi9cbiAgICB2YXIgZGVmYXVsdFRvID0gX2N1cnJ5MihmdW5jdGlvbiBkZWZhdWx0VG8oZCwgdikge1xuICAgICAgICByZXR1cm4gdiA9PSBudWxsIHx8IHYgIT09IHYgPyBkIDogdjtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBzZXQgKGkuZS4gbm8gZHVwbGljYXRlcykgb2YgYWxsIGVsZW1lbnRzIGluIHRoZSBmaXJzdCBsaXN0IG5vdFxuICAgICAqIGNvbnRhaW5lZCBpbiB0aGUgc2Vjb25kIGxpc3QuIER1cGxpY2F0aW9uIGlzIGRldGVybWluZWQgYWNjb3JkaW5nIHRvIHRoZVxuICAgICAqIHZhbHVlIHJldHVybmVkIGJ5IGFwcGx5aW5nIHRoZSBzdXBwbGllZCBwcmVkaWNhdGUgdG8gdHdvIGxpc3QgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICAgICAqIEBzaWcgKGEgLT4gYSAtPiBCb29sZWFuKSAtPiBbKl0gLT4gWypdIC0+IFsqXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWQgQSBwcmVkaWNhdGUgdXNlZCB0byB0ZXN0IHdoZXRoZXIgdHdvIGl0ZW1zIGFyZSBlcXVhbC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0MSBUaGUgZmlyc3QgbGlzdC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0MiBUaGUgc2Vjb25kIGxpc3QuXG4gICAgICogQHJldHVybiB7QXJyYXl9IFRoZSBlbGVtZW50cyBpbiBgbGlzdDFgIHRoYXQgYXJlIG5vdCBpbiBgbGlzdDJgLlxuICAgICAqIEBzZWUgUi5kaWZmZXJlbmNlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGNtcCA9ICh4LCB5KSA9PiB4LmEgPT09IHkuYTtcbiAgICAgKiAgICAgIHZhciBsMSA9IFt7YTogMX0sIHthOiAyfSwge2E6IDN9XTtcbiAgICAgKiAgICAgIHZhciBsMiA9IFt7YTogM30sIHthOiA0fV07XG4gICAgICogICAgICBSLmRpZmZlcmVuY2VXaXRoKGNtcCwgbDEsIGwyKTsgLy89PiBbe2E6IDF9LCB7YTogMn1dXG4gICAgICovXG4gICAgdmFyIGRpZmZlcmVuY2VXaXRoID0gX2N1cnJ5MyhmdW5jdGlvbiBkaWZmZXJlbmNlV2l0aChwcmVkLCBmaXJzdCwgc2Vjb25kKSB7XG4gICAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgIHZhciBmaXJzdExlbiA9IGZpcnN0Lmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGlkeCA8IGZpcnN0TGVuKSB7XG4gICAgICAgICAgICBpZiAoIV9jb250YWluc1dpdGgocHJlZCwgZmlyc3RbaWR4XSwgc2Vjb25kKSAmJiAhX2NvbnRhaW5zV2l0aChwcmVkLCBmaXJzdFtpZHhdLCBvdXQpKSB7XG4gICAgICAgICAgICAgICAgb3V0LnB1c2goZmlyc3RbaWR4XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBvYmplY3QgdGhhdCBkb2VzIG5vdCBjb250YWluIGEgYHByb3BgIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBzaWcgU3RyaW5nIC0+IHtrOiB2fSAtPiB7azogdn1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcCB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gZGlzc29jaWF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogdGhlIG9iamVjdCB0byBjbG9uZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gYSBuZXcgb2JqZWN0IHNpbWlsYXIgdG8gdGhlIG9yaWdpbmFsIGJ1dCB3aXRob3V0IHRoZSBzcGVjaWZpZWQgcHJvcGVydHlcbiAgICAgKiBAc2VlIFIuYXNzb2NcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLmRpc3NvYygnYicsIHthOiAxLCBiOiAyLCBjOiAzfSk7IC8vPT4ge2E6IDEsIGM6IDN9XG4gICAgICovXG4gICAgdmFyIGRpc3NvYyA9IF9jdXJyeTIoZnVuY3Rpb24gZGlzc29jKHByb3AsIG9iaikge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAodmFyIHAgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAocCAhPT0gcHJvcCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtwXSA9IG9ialtwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogTWFrZXMgYSBzaGFsbG93IGNsb25lIG9mIGFuIG9iamVjdCwgb21pdHRpbmcgdGhlIHByb3BlcnR5IGF0IHRoZSBnaXZlbiBwYXRoLlxuICAgICAqIE5vdGUgdGhhdCB0aGlzIGNvcGllcyBhbmQgZmxhdHRlbnMgcHJvdG90eXBlIHByb3BlcnRpZXMgb250byB0aGUgbmV3IG9iamVjdFxuICAgICAqIGFzIHdlbGwuIEFsbCBub24tcHJpbWl0aXZlIHByb3BlcnRpZXMgYXJlIGNvcGllZCBieSByZWZlcmVuY2UuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjExLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHNpZyBbU3RyaW5nXSAtPiB7azogdn0gLT4ge2s6IHZ9XG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCB0aGUgcGF0aCB0byBzZXRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIHRoZSBvYmplY3QgdG8gY2xvbmVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGEgbmV3IG9iamVjdCB3aXRob3V0IHRoZSBwcm9wZXJ0eSBhdCBwYXRoXG4gICAgICogQHNlZSBSLmFzc29jUGF0aFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuZGlzc29jUGF0aChbJ2EnLCAnYicsICdjJ10sIHthOiB7Yjoge2M6IDQyfX19KTsgLy89PiB7YToge2I6IHt9fX1cbiAgICAgKi9cbiAgICB2YXIgZGlzc29jUGF0aCA9IF9jdXJyeTIoZnVuY3Rpb24gZGlzc29jUGF0aChwYXRoLCBvYmopIHtcbiAgICAgICAgc3dpdGNoIChwYXRoLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gZGlzc29jKHBhdGhbMF0sIG9iaik7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB2YXIgaGVhZCA9IHBhdGhbMF07XG4gICAgICAgICAgICB2YXIgdGFpbCA9IF9zbGljZShwYXRoLCAxKTtcbiAgICAgICAgICAgIHJldHVybiBvYmpbaGVhZF0gPT0gbnVsbCA/IG9iaiA6IGFzc29jKGhlYWQsIGRpc3NvY1BhdGgodGFpbCwgb2JqW2hlYWRdKSwgb2JqKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogRGl2aWRlcyB0d28gbnVtYmVycy4gRXF1aXZhbGVudCB0byBgYSAvIGJgLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBzaWcgTnVtYmVyIC0+IE51bWJlciAtPiBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYSBUaGUgZmlyc3QgdmFsdWUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGIgVGhlIHNlY29uZCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSByZXN1bHQgb2YgYGEgLyBiYC5cbiAgICAgKiBAc2VlIFIubXVsdGlwbHlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLmRpdmlkZSg3MSwgMTAwKTsgLy89PiAwLjcxXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBoYWxmID0gUi5kaXZpZGUoUi5fXywgMik7XG4gICAgICogICAgICBoYWxmKDQyKTsgLy89PiAyMVxuICAgICAqXG4gICAgICogICAgICB2YXIgcmVjaXByb2NhbCA9IFIuZGl2aWRlKDEpO1xuICAgICAqICAgICAgcmVjaXByb2NhbCg0KTsgICAvLz0+IDAuMjVcbiAgICAgKi9cbiAgICB2YXIgZGl2aWRlID0gX2N1cnJ5MihmdW5jdGlvbiBkaXZpZGUoYSwgYikge1xuICAgICAgICByZXR1cm4gYSAvIGI7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IGxpc3QgY29udGFpbmluZyB0aGUgbGFzdCBgbmAgZWxlbWVudHMgb2YgYSBnaXZlbiBsaXN0LCBwYXNzaW5nXG4gICAgICogZWFjaCB2YWx1ZSB0byB0aGUgc3VwcGxpZWQgcHJlZGljYXRlIGZ1bmN0aW9uLCBza2lwcGluZyBlbGVtZW50cyB3aGlsZSB0aGVcbiAgICAgKiBwcmVkaWNhdGUgZnVuY3Rpb24gcmV0dXJucyBgdHJ1ZWAuIFRoZSBwcmVkaWNhdGUgZnVuY3Rpb24gaXMgcGFzc2VkIG9uZVxuICAgICAqIGFyZ3VtZW50OiAqKHZhbHVlKSouXG4gICAgICpcbiAgICAgKiBEaXNwYXRjaGVzIHRvIHRoZSBgZHJvcFdoaWxlYCBtZXRob2Qgb2YgdGhlIHNlY29uZCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIEFjdHMgYXMgYSB0cmFuc2R1Y2VyIGlmIGEgdHJhbnNmb3JtZXIgaXMgZ2l2ZW4gaW4gbGlzdCBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuOS4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IFthXSAtPiBbYV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybiB7QXJyYXl9IEEgbmV3IGFycmF5LlxuICAgICAqIEBzZWUgUi50YWtlV2hpbGUsIFIudHJhbnNkdWNlLCBSLmFkZEluZGV4XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGx0ZVR3byA9IHggPT4geCA8PSAyO1xuICAgICAqXG4gICAgICogICAgICBSLmRyb3BXaGlsZShsdGVUd28sIFsxLCAyLCAzLCA0LCAzLCAyLCAxXSk7IC8vPT4gWzMsIDQsIDMsIDIsIDFdXG4gICAgICovXG4gICAgdmFyIGRyb3BXaGlsZSA9IF9jdXJyeTIoX2Rpc3BhdGNoYWJsZSgnZHJvcFdoaWxlJywgX3hkcm9wV2hpbGUsIGZ1bmN0aW9uIGRyb3BXaGlsZShwcmVkLCBsaXN0KSB7XG4gICAgICAgIHZhciBpZHggPSAwO1xuICAgICAgICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpZHggPCBsZW4gJiYgcHJlZChsaXN0W2lkeF0pKSB7XG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3NsaWNlKGxpc3QsIGlkeCk7XG4gICAgfSkpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZW1wdHkgdmFsdWUgb2YgaXRzIGFyZ3VtZW50J3MgdHlwZS4gUmFtZGEgZGVmaW5lcyB0aGUgZW1wdHlcbiAgICAgKiB2YWx1ZSBvZiBBcnJheSAoYFtdYCksIE9iamVjdCAoYHt9YCksIFN0cmluZyAoYCcnYCksIGFuZCBBcmd1bWVudHMuIE90aGVyXG4gICAgICogdHlwZXMgYXJlIHN1cHBvcnRlZCBpZiB0aGV5IGRlZmluZSBgPFR5cGU+LmVtcHR5YCBhbmQvb3JcbiAgICAgKiBgPFR5cGU+LnByb3RvdHlwZS5lbXB0eWAuXG4gICAgICpcbiAgICAgKiBEaXNwYXRjaGVzIHRvIHRoZSBgZW1wdHlgIG1ldGhvZCBvZiB0aGUgZmlyc3QgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjMuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBzaWcgYSAtPiBhXG4gICAgICogQHBhcmFtIHsqfSB4XG4gICAgICogQHJldHVybiB7Kn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLmVtcHR5KEp1c3QoNDIpKTsgICAgICAvLz0+IE5vdGhpbmcoKVxuICAgICAqICAgICAgUi5lbXB0eShbMSwgMiwgM10pOyAgICAgLy89PiBbXVxuICAgICAqICAgICAgUi5lbXB0eSgndW5pY29ybnMnKTsgICAgLy89PiAnJ1xuICAgICAqICAgICAgUi5lbXB0eSh7eDogMSwgeTogMn0pOyAgLy89PiB7fVxuICAgICAqL1xuICAgIC8vIGVsc2VcbiAgICB2YXIgZW1wdHkgPSBfY3VycnkxKGZ1bmN0aW9uIGVtcHR5KHgpIHtcbiAgICAgICAgcmV0dXJuIHggIT0gbnVsbCAmJiB0eXBlb2YgeC5lbXB0eSA9PT0gJ2Z1bmN0aW9uJyA/IHguZW1wdHkoKSA6IHggIT0gbnVsbCAmJiB4LmNvbnN0cnVjdG9yICE9IG51bGwgJiYgdHlwZW9mIHguY29uc3RydWN0b3IuZW1wdHkgPT09ICdmdW5jdGlvbicgPyB4LmNvbnN0cnVjdG9yLmVtcHR5KCkgOiBfaXNBcnJheSh4KSA/IFtdIDogX2lzU3RyaW5nKHgpID8gJycgOiBfaXNPYmplY3QoeCkgPyB7fSA6IF9pc0FyZ3VtZW50cyh4KSA/IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHM7XG4gICAgICAgIH0oKSA6IC8vIGVsc2VcbiAgICAgICAgdm9pZCAwO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBvYmplY3QgYnkgcmVjdXJzaXZlbHkgZXZvbHZpbmcgYSBzaGFsbG93IGNvcHkgb2YgYG9iamVjdGAsXG4gICAgICogYWNjb3JkaW5nIHRvIHRoZSBgdHJhbnNmb3JtYXRpb25gIGZ1bmN0aW9ucy4gQWxsIG5vbi1wcmltaXRpdmUgcHJvcGVydGllc1xuICAgICAqIGFyZSBjb3BpZWQgYnkgcmVmZXJlbmNlLlxuICAgICAqXG4gICAgICogQSBgdHJhbnNmb3JtYXRpb25gIGZ1bmN0aW9uIHdpbGwgbm90IGJlIGludm9rZWQgaWYgaXRzIGNvcnJlc3BvbmRpbmcga2V5XG4gICAgICogZG9lcyBub3QgZXhpc3QgaW4gdGhlIGV2b2x2ZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC45LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHNpZyB7azogKHYgLT4gdil9IC0+IHtrOiB2fSAtPiB7azogdn1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtYXRpb25zIFRoZSBvYmplY3Qgc3BlY2lmeWluZyB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbnMgdG8gYXBwbHlcbiAgICAgKiAgICAgICAgdG8gdGhlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gYmUgdHJhbnNmb3JtZWQuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgdHJhbnNmb3JtZWQgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciB0b21hdG8gID0ge2ZpcnN0TmFtZTogJyAgVG9tYXRvICcsIGRhdGE6IHtlbGFwc2VkOiAxMDAsIHJlbWFpbmluZzogMTQwMH0sIGlkOjEyM307XG4gICAgICogICAgICB2YXIgdHJhbnNmb3JtYXRpb25zID0ge1xuICAgICAqICAgICAgICBmaXJzdE5hbWU6IFIudHJpbSxcbiAgICAgKiAgICAgICAgbGFzdE5hbWU6IFIudHJpbSwgLy8gV2lsbCBub3QgZ2V0IGludm9rZWQuXG4gICAgICogICAgICAgIGRhdGE6IHtlbGFwc2VkOiBSLmFkZCgxKSwgcmVtYWluaW5nOiBSLmFkZCgtMSl9XG4gICAgICogICAgICB9O1xuICAgICAqICAgICAgUi5ldm9sdmUodHJhbnNmb3JtYXRpb25zLCB0b21hdG8pOyAvLz0+IHtmaXJzdE5hbWU6ICdUb21hdG8nLCBkYXRhOiB7ZWxhcHNlZDogMTAxLCByZW1haW5pbmc6IDEzOTl9LCBpZDoxMjN9XG4gICAgICovXG4gICAgdmFyIGV2b2x2ZSA9IF9jdXJyeTIoZnVuY3Rpb24gZXZvbHZlKHRyYW5zZm9ybWF0aW9ucywgb2JqZWN0KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgdmFyIHRyYW5zZm9ybWF0aW9uLCBrZXksIHR5cGU7XG4gICAgICAgIGZvciAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgdHJhbnNmb3JtYXRpb24gPSB0cmFuc2Zvcm1hdGlvbnNba2V5XTtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlb2YgdHJhbnNmb3JtYXRpb247XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHR5cGUgPT09ICdmdW5jdGlvbicgPyB0cmFuc2Zvcm1hdGlvbihvYmplY3Rba2V5XSkgOiB0eXBlID09PSAnb2JqZWN0JyA/IGV2b2x2ZSh0cmFuc2Zvcm1hdGlvbnNba2V5XSwgb2JqZWN0W2tleV0pIDogb2JqZWN0W2tleV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGxpc3Qgd2hpY2ggbWF0Y2hlcyB0aGUgcHJlZGljYXRlLCBvclxuICAgICAqIGB1bmRlZmluZWRgIGlmIG5vIGVsZW1lbnQgbWF0Y2hlcy5cbiAgICAgKlxuICAgICAqIERpc3BhdGNoZXMgdG8gdGhlIGBmaW5kYCBtZXRob2Qgb2YgdGhlIHNlY29uZCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIEFjdHMgYXMgYSB0cmFuc2R1Y2VyIGlmIGEgdHJhbnNmb3JtZXIgaXMgZ2l2ZW4gaW4gbGlzdCBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IFthXSAtPiBhIHwgdW5kZWZpbmVkXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIHByZWRpY2F0ZSBmdW5jdGlvbiB1c2VkIHRvIGRldGVybWluZSBpZiB0aGUgZWxlbWVudCBpcyB0aGVcbiAgICAgKiAgICAgICAgZGVzaXJlZCBvbmUuXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gY29uc2lkZXIuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgZWxlbWVudCBmb3VuZCwgb3IgYHVuZGVmaW5lZGAuXG4gICAgICogQHNlZSBSLnRyYW5zZHVjZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciB4cyA9IFt7YTogMX0sIHthOiAyfSwge2E6IDN9XTtcbiAgICAgKiAgICAgIFIuZmluZChSLnByb3BFcSgnYScsIDIpKSh4cyk7IC8vPT4ge2E6IDJ9XG4gICAgICogICAgICBSLmZpbmQoUi5wcm9wRXEoJ2EnLCA0KSkoeHMpOyAvLz0+IHVuZGVmaW5lZFxuICAgICAqL1xuICAgIHZhciBmaW5kID0gX2N1cnJ5MihfZGlzcGF0Y2hhYmxlKCdmaW5kJywgX3hmaW5kLCBmdW5jdGlvbiBmaW5kKGZuLCBsaXN0KSB7XG4gICAgICAgIHZhciBpZHggPSAwO1xuICAgICAgICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChmbihsaXN0W2lkeF0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RbaWR4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICB9XG4gICAgfSkpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGxpc3Qgd2hpY2ggbWF0Y2hlcyB0aGVcbiAgICAgKiBwcmVkaWNhdGUsIG9yIGAtMWAgaWYgbm8gZWxlbWVudCBtYXRjaGVzLlxuICAgICAqXG4gICAgICogRGlzcGF0Y2hlcyB0byB0aGUgYGZpbmRJbmRleGAgbWV0aG9kIG9mIHRoZSBzZWNvbmQgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gICAgICpcbiAgICAgKiBBY3RzIGFzIGEgdHJhbnNkdWNlciBpZiBhIHRyYW5zZm9ybWVyIGlzIGdpdmVuIGluIGxpc3QgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMVxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyAoYSAtPiBCb29sZWFuKSAtPiBbYV0gLT4gTnVtYmVyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIHByZWRpY2F0ZSBmdW5jdGlvbiB1c2VkIHRvIGRldGVybWluZSBpZiB0aGUgZWxlbWVudCBpcyB0aGVcbiAgICAgKiBkZXNpcmVkIG9uZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBjb25zaWRlci5cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCBmb3VuZCwgb3IgYC0xYC5cbiAgICAgKiBAc2VlIFIudHJhbnNkdWNlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIHhzID0gW3thOiAxfSwge2E6IDJ9LCB7YTogM31dO1xuICAgICAqICAgICAgUi5maW5kSW5kZXgoUi5wcm9wRXEoJ2EnLCAyKSkoeHMpOyAvLz0+IDFcbiAgICAgKiAgICAgIFIuZmluZEluZGV4KFIucHJvcEVxKCdhJywgNCkpKHhzKTsgLy89PiAtMVxuICAgICAqL1xuICAgIHZhciBmaW5kSW5kZXggPSBfY3VycnkyKF9kaXNwYXRjaGFibGUoJ2ZpbmRJbmRleCcsIF94ZmluZEluZGV4LCBmdW5jdGlvbiBmaW5kSW5kZXgoZm4sIGxpc3QpIHtcbiAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGZuKGxpc3RbaWR4XSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWR4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH0pKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxhc3QgZWxlbWVudCBvZiB0aGUgbGlzdCB3aGljaCBtYXRjaGVzIHRoZSBwcmVkaWNhdGUsIG9yXG4gICAgICogYHVuZGVmaW5lZGAgaWYgbm8gZWxlbWVudCBtYXRjaGVzLlxuICAgICAqXG4gICAgICogRGlzcGF0Y2hlcyB0byB0aGUgYGZpbmRMYXN0YCBtZXRob2Qgb2YgdGhlIHNlY29uZCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIEFjdHMgYXMgYSB0cmFuc2R1Y2VyIGlmIGEgdHJhbnNmb3JtZXIgaXMgZ2l2ZW4gaW4gbGlzdCBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4xXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IFthXSAtPiBhIHwgdW5kZWZpbmVkXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIHByZWRpY2F0ZSBmdW5jdGlvbiB1c2VkIHRvIGRldGVybWluZSBpZiB0aGUgZWxlbWVudCBpcyB0aGVcbiAgICAgKiBkZXNpcmVkIG9uZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBjb25zaWRlci5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBlbGVtZW50IGZvdW5kLCBvciBgdW5kZWZpbmVkYC5cbiAgICAgKiBAc2VlIFIudHJhbnNkdWNlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIHhzID0gW3thOiAxLCBiOiAwfSwge2E6MSwgYjogMX1dO1xuICAgICAqICAgICAgUi5maW5kTGFzdChSLnByb3BFcSgnYScsIDEpKSh4cyk7IC8vPT4ge2E6IDEsIGI6IDF9XG4gICAgICogICAgICBSLmZpbmRMYXN0KFIucHJvcEVxKCdhJywgNCkpKHhzKTsgLy89PiB1bmRlZmluZWRcbiAgICAgKi9cbiAgICB2YXIgZmluZExhc3QgPSBfY3VycnkyKF9kaXNwYXRjaGFibGUoJ2ZpbmRMYXN0JywgX3hmaW5kTGFzdCwgZnVuY3Rpb24gZmluZExhc3QoZm4sIGxpc3QpIHtcbiAgICAgICAgdmFyIGlkeCA9IGxpc3QubGVuZ3RoIC0gMTtcbiAgICAgICAgd2hpbGUgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICBpZiAoZm4obGlzdFtpZHhdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsaXN0W2lkeF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZHggLT0gMTtcbiAgICAgICAgfVxuICAgIH0pKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBsYXN0IGVsZW1lbnQgb2YgdGhlIGxpc3Qgd2hpY2ggbWF0Y2hlcyB0aGVcbiAgICAgKiBwcmVkaWNhdGUsIG9yIGAtMWAgaWYgbm8gZWxlbWVudCBtYXRjaGVzLlxuICAgICAqXG4gICAgICogRGlzcGF0Y2hlcyB0byB0aGUgYGZpbmRMYXN0SW5kZXhgIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICAgICAqXG4gICAgICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjFcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gW2FdIC0+IE51bWJlclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBwcmVkaWNhdGUgZnVuY3Rpb24gdXNlZCB0byBkZXRlcm1pbmUgaWYgdGhlIGVsZW1lbnQgaXMgdGhlXG4gICAgICogZGVzaXJlZCBvbmUuXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gY29uc2lkZXIuXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgZm91bmQsIG9yIGAtMWAuXG4gICAgICogQHNlZSBSLnRyYW5zZHVjZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciB4cyA9IFt7YTogMSwgYjogMH0sIHthOjEsIGI6IDF9XTtcbiAgICAgKiAgICAgIFIuZmluZExhc3RJbmRleChSLnByb3BFcSgnYScsIDEpKSh4cyk7IC8vPT4gMVxuICAgICAqICAgICAgUi5maW5kTGFzdEluZGV4KFIucHJvcEVxKCdhJywgNCkpKHhzKTsgLy89PiAtMVxuICAgICAqL1xuICAgIHZhciBmaW5kTGFzdEluZGV4ID0gX2N1cnJ5MihfZGlzcGF0Y2hhYmxlKCdmaW5kTGFzdEluZGV4JywgX3hmaW5kTGFzdEluZGV4LCBmdW5jdGlvbiBmaW5kTGFzdEluZGV4KGZuLCBsaXN0KSB7XG4gICAgICAgIHZhciBpZHggPSBsaXN0Lmxlbmd0aCAtIDE7XG4gICAgICAgIHdoaWxlIChpZHggPj0gMCkge1xuICAgICAgICAgICAgaWYgKGZuKGxpc3RbaWR4XSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWR4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWR4IC09IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH0pKTtcblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGUgb3ZlciBhbiBpbnB1dCBgbGlzdGAsIGNhbGxpbmcgYSBwcm92aWRlZCBmdW5jdGlvbiBgZm5gIGZvciBlYWNoXG4gICAgICogZWxlbWVudCBpbiB0aGUgbGlzdC5cbiAgICAgKlxuICAgICAqIGBmbmAgcmVjZWl2ZXMgb25lIGFyZ3VtZW50OiAqKHZhbHVlKSouXG4gICAgICpcbiAgICAgKiBOb3RlOiBgUi5mb3JFYWNoYCBkb2VzIG5vdCBza2lwIGRlbGV0ZWQgb3IgdW5hc3NpZ25lZCBpbmRpY2VzIChzcGFyc2VcbiAgICAgKiBhcnJheXMpLCB1bmxpa2UgdGhlIG5hdGl2ZSBgQXJyYXkucHJvdG90eXBlLmZvckVhY2hgIG1ldGhvZC4gRm9yIG1vcmVcbiAgICAgKiBkZXRhaWxzIG9uIHRoaXMgYmVoYXZpb3IsIHNlZTpcbiAgICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9mb3JFYWNoI0Rlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBBbHNvIG5vdGUgdGhhdCwgdW5saWtlIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAsIFJhbWRhJ3MgYGZvckVhY2hgIHJldHVybnNcbiAgICAgKiB0aGUgb3JpZ2luYWwgYXJyYXkuIEluIHNvbWUgbGlicmFyaWVzIHRoaXMgZnVuY3Rpb24gaXMgbmFtZWQgYGVhY2hgLlxuICAgICAqXG4gICAgICogRGlzcGF0Y2hlcyB0byB0aGUgYGZvckVhY2hgIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjFcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgKGEgLT4gKikgLT4gW2FdIC0+IFthXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuIFJlY2VpdmVzIG9uZSBhcmd1bWVudCwgYHZhbHVlYC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIG9yaWdpbmFsIGxpc3QuXG4gICAgICogQHNlZSBSLmFkZEluZGV4XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIHByaW50WFBsdXNGaXZlID0geCA9PiBjb25zb2xlLmxvZyh4ICsgNSk7XG4gICAgICogICAgICBSLmZvckVhY2gocHJpbnRYUGx1c0ZpdmUsIFsxLCAyLCAzXSk7IC8vPT4gWzEsIDIsIDNdXG4gICAgICogICAgICAvLy0+IDZcbiAgICAgKiAgICAgIC8vLT4gN1xuICAgICAqICAgICAgLy8tPiA4XG4gICAgICovXG4gICAgdmFyIGZvckVhY2ggPSBfY3VycnkyKF9jaGVja0Zvck1ldGhvZCgnZm9yRWFjaCcsIGZ1bmN0aW9uIGZvckVhY2goZm4sIGxpc3QpIHtcbiAgICAgICAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICAgICAgICB2YXIgaWR4ID0gMDtcbiAgICAgICAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgICAgICAgICAgZm4obGlzdFtpZHhdKTtcbiAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgIH0pKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgb2JqZWN0IG91dCBvZiBhIGxpc3Qga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgW1trLHZdXSAtPiB7azogdn1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYWlycyBBbiBhcnJheSBvZiB0d28tZWxlbWVudCBhcnJheXMgdGhhdCB3aWxsIGJlIHRoZSBrZXlzIGFuZCB2YWx1ZXMgb2YgdGhlIG91dHB1dCBvYmplY3QuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgb2JqZWN0IG1hZGUgYnkgcGFpcmluZyB1cCBga2V5c2AgYW5kIGB2YWx1ZXNgLlxuICAgICAqIEBzZWUgUi50b1BhaXJzLCBSLnBhaXJcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLmZyb21QYWlycyhbWydhJywgMV0sIFsnYicsIDJdLCAgWydjJywgM11dKTsgLy89PiB7YTogMSwgYjogMiwgYzogM31cbiAgICAgKi9cbiAgICB2YXIgZnJvbVBhaXJzID0gX2N1cnJ5MShmdW5jdGlvbiBmcm9tUGFpcnMocGFpcnMpIHtcbiAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgIHZhciBsZW4gPSBwYWlycy5sZW5ndGg7XG4gICAgICAgIHZhciBvdXQgPSB7fTtcbiAgICAgICAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKF9pc0FycmF5KHBhaXJzW2lkeF0pICYmIHBhaXJzW2lkeF0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb3V0W3BhaXJzW2lkeF1bMF1dID0gcGFpcnNbaWR4XVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUYWtlcyBhIGxpc3QgYW5kIHJldHVybnMgYSBsaXN0IG9mIGxpc3RzIHdoZXJlIGVhY2ggc3VibGlzdCdzIGVsZW1lbnRzIGFyZVxuICAgICAqIGFsbCBcImVxdWFsXCIgYWNjb3JkaW5nIHRvIHRoZSBwcm92aWRlZCBlcXVhbGl0eSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMjEuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyAoYSwgYSAtPiBCb29sZWFuKSAtPiBbYV0gLT4gW1thXV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiBmb3IgZGV0ZXJtaW5pbmcgd2hldGhlciB0d28gZ2l2ZW4gKGFkamFjZW50KVxuICAgICAqICAgICAgICBlbGVtZW50cyBzaG91bGQgYmUgaW4gdGhlIHNhbWUgZ3JvdXBcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBncm91cC4gQWxzbyBhY2NlcHRzIGEgc3RyaW5nLCB3aGljaCB3aWxsIGJlXG4gICAgICogICAgICAgIHRyZWF0ZWQgYXMgYSBsaXN0IG9mIGNoYXJhY3RlcnMuXG4gICAgICogQHJldHVybiB7TGlzdH0gQSBsaXN0IHRoYXQgY29udGFpbnMgc3VibGlzdHMgb2YgZXF1YWwgZWxlbWVudHMsXG4gICAgICogICAgICAgICB3aG9zZSBjb25jYXRlbmF0aW9ucyBpcyBlcXVhbCB0byB0aGUgb3JpZ2luYWwgbGlzdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgZ3JvdXBXaXRoKFIuZXF1YWxzLCBbMCwgMSwgMSwgMiwgMywgNSwgOCwgMTMsIDIxXSlcbiAgICAgKiAgICAvLyBbWzBdLCBbMSwgMV0sIFsyLCAzLCA1LCA4LCAxMywgMjFdXVxuICAgICAqXG4gICAgICogICAgZ3JvdXBXaXRoKChhLCBiKSA9PiBhICUgMiA9PT0gYiAlIDIsIFswLCAxLCAxLCAyLCAzLCA1LCA4LCAxMywgMjFdKVxuICAgICAqICAgIC8vIFtbMF0sIFsxLCAxXSwgWzJdLCBbMywgNV0sIFs4XSwgWzEzLCAyMV1dXG4gICAgICpcbiAgICAgKiAgICBSLmdyb3VwV2l0aChSLmVxQnkoaXNWb3dlbCksICdhZXN0aW91JylcbiAgICAgKiAgICAvLyBbJ2FlJywgJ3N0JywgJ2lvdSddXG4gICAgICovXG4gICAgdmFyIGdyb3VwV2l0aCA9IF9jdXJyeTIoZnVuY3Rpb24gKGZuLCBsaXN0KSB7XG4gICAgICAgIHZhciByZXMgPSBbXTtcbiAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgICAgICAgICAgdmFyIG5leHRpZHggPSBpZHggKyAxO1xuICAgICAgICAgICAgd2hpbGUgKG5leHRpZHggPCBsZW4gJiYgZm4obGlzdFtpZHhdLCBsaXN0W25leHRpZHhdKSkge1xuICAgICAgICAgICAgICAgIG5leHRpZHggKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcy5wdXNoKGxpc3Quc2xpY2UoaWR4LCBuZXh0aWR4KSk7XG4gICAgICAgICAgICBpZHggPSBuZXh0aWR4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgZ3JlYXRlciB0aGFuIHRoZSBzZWNvbmQ7IGBmYWxzZWBcbiAgICAgKiBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICAgICAqIEBzaWcgT3JkIGEgPT4gYSAtPiBhIC0+IEJvb2xlYW5cbiAgICAgKiBAcGFyYW0geyp9IGFcbiAgICAgKiBAcGFyYW0geyp9IGJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqIEBzZWUgUi5sdFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuZ3QoMiwgMSk7IC8vPT4gdHJ1ZVxuICAgICAqICAgICAgUi5ndCgyLCAyKTsgLy89PiBmYWxzZVxuICAgICAqICAgICAgUi5ndCgyLCAzKTsgLy89PiBmYWxzZVxuICAgICAqICAgICAgUi5ndCgnYScsICd6Jyk7IC8vPT4gZmFsc2VcbiAgICAgKiAgICAgIFIuZ3QoJ3onLCAnYScpOyAvLz0+IHRydWVcbiAgICAgKi9cbiAgICB2YXIgZ3QgPSBfY3VycnkyKGZ1bmN0aW9uIGd0KGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgPiBiO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgc2Vjb25kO1xuICAgICAqIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAgICAgKiBAc2lnIE9yZCBhID0+IGEgLT4gYSAtPiBCb29sZWFuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICogQHNlZSBSLmx0ZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuZ3RlKDIsIDEpOyAvLz0+IHRydWVcbiAgICAgKiAgICAgIFIuZ3RlKDIsIDIpOyAvLz0+IHRydWVcbiAgICAgKiAgICAgIFIuZ3RlKDIsIDMpOyAvLz0+IGZhbHNlXG4gICAgICogICAgICBSLmd0ZSgnYScsICd6Jyk7IC8vPT4gZmFsc2VcbiAgICAgKiAgICAgIFIuZ3RlKCd6JywgJ2EnKTsgLy89PiB0cnVlXG4gICAgICovXG4gICAgdmFyIGd0ZSA9IF9jdXJyeTIoZnVuY3Rpb24gZ3RlKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgPj0gYjtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgYW4gb2JqZWN0IGhhcyBhbiBvd24gcHJvcGVydHkgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWVcbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuNy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBzaWcgcyAtPiB7czogeH0gLT4gQm9vbGVhblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBjaGVjayBmb3IuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgdGhlIHByb3BlcnR5IGV4aXN0cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgaGFzTmFtZSA9IFIuaGFzKCduYW1lJyk7XG4gICAgICogICAgICBoYXNOYW1lKHtuYW1lOiAnYWxpY2UnfSk7ICAgLy89PiB0cnVlXG4gICAgICogICAgICBoYXNOYW1lKHtuYW1lOiAnYm9iJ30pOyAgICAgLy89PiB0cnVlXG4gICAgICogICAgICBoYXNOYW1lKHt9KTsgICAgICAgICAgICAgICAgLy89PiBmYWxzZVxuICAgICAqXG4gICAgICogICAgICB2YXIgcG9pbnQgPSB7eDogMCwgeTogMH07XG4gICAgICogICAgICB2YXIgcG9pbnRIYXMgPSBSLmhhcyhSLl9fLCBwb2ludCk7XG4gICAgICogICAgICBwb2ludEhhcygneCcpOyAgLy89PiB0cnVlXG4gICAgICogICAgICBwb2ludEhhcygneScpOyAgLy89PiB0cnVlXG4gICAgICogICAgICBwb2ludEhhcygneicpOyAgLy89PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBoYXMgPSBfY3VycnkyKF9oYXMpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCBhbiBvYmplY3Qgb3IgaXRzIHByb3RvdHlwZSBjaGFpbiBoYXMgYSBwcm9wZXJ0eSB3aXRoXG4gICAgICogdGhlIHNwZWNpZmllZCBuYW1lXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjcuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAc2lnIHMgLT4ge3M6IHh9IC0+IEJvb2xlYW5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcCBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gY2hlY2sgZm9yLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBleGlzdHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgZnVuY3Rpb24gUmVjdGFuZ2xlKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgKiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAqICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgKiAgICAgIH1cbiAgICAgKiAgICAgIFJlY3RhbmdsZS5wcm90b3R5cGUuYXJlYSA9IGZ1bmN0aW9uKCkge1xuICAgICAqICAgICAgICByZXR1cm4gdGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0O1xuICAgICAqICAgICAgfTtcbiAgICAgKlxuICAgICAqICAgICAgdmFyIHNxdWFyZSA9IG5ldyBSZWN0YW5nbGUoMiwgMik7XG4gICAgICogICAgICBSLmhhc0luKCd3aWR0aCcsIHNxdWFyZSk7ICAvLz0+IHRydWVcbiAgICAgKiAgICAgIFIuaGFzSW4oJ2FyZWEnLCBzcXVhcmUpOyAgLy89PiB0cnVlXG4gICAgICovXG4gICAgdmFyIGhhc0luID0gX2N1cnJ5MihmdW5jdGlvbiBoYXNJbihwcm9wLCBvYmopIHtcbiAgICAgICAgcmV0dXJuIHByb3AgaW4gb2JqO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIGl0cyBhcmd1bWVudHMgYXJlIGlkZW50aWNhbCwgZmFsc2Ugb3RoZXJ3aXNlLiBWYWx1ZXMgYXJlXG4gICAgICogaWRlbnRpY2FsIGlmIHRoZXkgcmVmZXJlbmNlIHRoZSBzYW1lIG1lbW9yeS4gYE5hTmAgaXMgaWRlbnRpY2FsIHRvIGBOYU5gO1xuICAgICAqIGAwYCBhbmQgYC0wYCBhcmUgbm90IGlkZW50aWNhbC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTUuMFxuICAgICAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICAgICAqIEBzaWcgYSAtPiBhIC0+IEJvb2xlYW5cbiAgICAgKiBAcGFyYW0geyp9IGFcbiAgICAgKiBAcGFyYW0geyp9IGJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBvID0ge307XG4gICAgICogICAgICBSLmlkZW50aWNhbChvLCBvKTsgLy89PiB0cnVlXG4gICAgICogICAgICBSLmlkZW50aWNhbCgxLCAxKTsgLy89PiB0cnVlXG4gICAgICogICAgICBSLmlkZW50aWNhbCgxLCAnMScpOyAvLz0+IGZhbHNlXG4gICAgICogICAgICBSLmlkZW50aWNhbChbXSwgW10pOyAvLz0+IGZhbHNlXG4gICAgICogICAgICBSLmlkZW50aWNhbCgwLCAtMCk7IC8vPT4gZmFsc2VcbiAgICAgKiAgICAgIFIuaWRlbnRpY2FsKE5hTiwgTmFOKTsgLy89PiB0cnVlXG4gICAgICovXG4gICAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICAgIC8vIFN0ZXBzIDEtNSwgNy0xMFxuICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgLy8gU3RlcCA2LmE6IE5hTiA9PSBOYU5cbiAgICB2YXIgaWRlbnRpY2FsID0gX2N1cnJ5MihmdW5jdGlvbiBpZGVudGljYWwoYSwgYikge1xuICAgICAgICAvLyBTYW1lVmFsdWUgYWxnb3JpdGhtXG4gICAgICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgICAgICAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAgICAgICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgICAgICAgICByZXR1cm4gYSAhPT0gMCB8fCAxIC8gYSA9PT0gMSAvIGI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgICAgICAgICAgcmV0dXJuIGEgIT09IGEgJiYgYiAhPT0gYjtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB0aGF0IGRvZXMgbm90aGluZyBidXQgcmV0dXJuIHRoZSBwYXJhbWV0ZXIgc3VwcGxpZWQgdG8gaXQuIEdvb2RcbiAgICAgKiBhcyBhIGRlZmF1bHQgb3IgcGxhY2Vob2xkZXIgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBzaWcgYSAtPiBhXG4gICAgICogQHBhcmFtIHsqfSB4IFRoZSB2YWx1ZSB0byByZXR1cm4uXG4gICAgICogQHJldHVybiB7Kn0gVGhlIGlucHV0IHZhbHVlLCBgeGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5pZGVudGl0eSgxKTsgLy89PiAxXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgKiAgICAgIFIuaWRlbnRpdHkob2JqKSA9PT0gb2JqOyAvLz0+IHRydWVcbiAgICAgKi9cbiAgICB2YXIgaWRlbnRpdHkgPSBfY3VycnkxKF9pZGVudGl0eSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3aWxsIHByb2Nlc3MgZWl0aGVyIHRoZSBgb25UcnVlYCBvciB0aGUgYG9uRmFsc2VgXG4gICAgICogZnVuY3Rpb24gZGVwZW5kaW5nIHVwb24gdGhlIHJlc3VsdCBvZiB0aGUgYGNvbmRpdGlvbmAgcHJlZGljYXRlLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC44LjBcbiAgICAgKiBAY2F0ZWdvcnkgTG9naWNcbiAgICAgKiBAc2lnICgqLi4uIC0+IEJvb2xlYW4pIC0+ICgqLi4uIC0+ICopIC0+ICgqLi4uIC0+ICopIC0+ICgqLi4uIC0+ICopXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29uZGl0aW9uIEEgcHJlZGljYXRlIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25UcnVlIEEgZnVuY3Rpb24gdG8gaW52b2tlIHdoZW4gdGhlIGBjb25kaXRpb25gIGV2YWx1YXRlcyB0byBhIHRydXRoeSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbkZhbHNlIEEgZnVuY3Rpb24gdG8gaW52b2tlIHdoZW4gdGhlIGBjb25kaXRpb25gIGV2YWx1YXRlcyB0byBhIGZhbHN5IHZhbHVlLlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIG5ldyB1bmFyeSBmdW5jdGlvbiB0aGF0IHdpbGwgcHJvY2VzcyBlaXRoZXIgdGhlIGBvblRydWVgIG9yIHRoZSBgb25GYWxzZWBcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZGVwZW5kaW5nIHVwb24gdGhlIHJlc3VsdCBvZiB0aGUgYGNvbmRpdGlvbmAgcHJlZGljYXRlLlxuICAgICAqIEBzZWUgUi51bmxlc3MsIFIud2hlblxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBpbmNDb3VudCA9IFIuaWZFbHNlKFxuICAgICAqICAgICAgICBSLmhhcygnY291bnQnKSxcbiAgICAgKiAgICAgICAgUi5vdmVyKFIubGVuc1Byb3AoJ2NvdW50JyksIFIuaW5jKSxcbiAgICAgKiAgICAgICAgUi5hc3NvYygnY291bnQnLCAxKVxuICAgICAqICAgICAgKTtcbiAgICAgKiAgICAgIGluY0NvdW50KHt9KTsgICAgICAgICAgIC8vPT4geyBjb3VudDogMSB9XG4gICAgICogICAgICBpbmNDb3VudCh7IGNvdW50OiAxIH0pOyAvLz0+IHsgY291bnQ6IDIgfVxuICAgICAqL1xuICAgIHZhciBpZkVsc2UgPSBfY3VycnkzKGZ1bmN0aW9uIGlmRWxzZShjb25kaXRpb24sIG9uVHJ1ZSwgb25GYWxzZSkge1xuICAgICAgICByZXR1cm4gY3VycnlOKE1hdGgubWF4KGNvbmRpdGlvbi5sZW5ndGgsIG9uVHJ1ZS5sZW5ndGgsIG9uRmFsc2UubGVuZ3RoKSwgZnVuY3Rpb24gX2lmRWxzZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25kaXRpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKSA/IG9uVHJ1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogb25GYWxzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEluY3JlbWVudHMgaXRzIGFyZ3VtZW50LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC45LjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBzaWcgTnVtYmVyIC0+IE51bWJlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqIEBzZWUgUi5kZWNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLmluYyg0Mik7IC8vPT4gNDNcbiAgICAgKi9cbiAgICB2YXIgaW5jID0gYWRkKDEpO1xuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyB0aGUgc3VwcGxpZWQgZWxlbWVudCBpbnRvIHRoZSBsaXN0LCBhdCBpbmRleCBgaW5kZXhgLiBfTm90ZSB0aGF0XG4gICAgICogdGhpcyBpcyBub3QgZGVzdHJ1Y3RpdmVfOiBpdCByZXR1cm5zIGEgY29weSBvZiB0aGUgbGlzdCB3aXRoIHRoZSBjaGFuZ2VzLlxuICAgICAqIDxzbWFsbD5ObyBsaXN0cyBoYXZlIGJlZW4gaGFybWVkIGluIHRoZSBhcHBsaWNhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uLjwvc21hbGw+XG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjIuMlxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyBOdW1iZXIgLT4gYSAtPiBbYV0gLT4gW2FdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFRoZSBwb3NpdGlvbiB0byBpbnNlcnQgdGhlIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0geyp9IGVsdCBUaGUgZWxlbWVudCB0byBpbnNlcnQgaW50byB0aGUgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIGluc2VydCBpbnRvXG4gICAgICogQHJldHVybiB7QXJyYXl9IEEgbmV3IEFycmF5IHdpdGggYGVsdGAgaW5zZXJ0ZWQgYXQgYGluZGV4YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLmluc2VydCgyLCAneCcsIFsxLDIsMyw0XSk7IC8vPT4gWzEsMiwneCcsMyw0XVxuICAgICAqL1xuICAgIHZhciBpbnNlcnQgPSBfY3VycnkzKGZ1bmN0aW9uIGluc2VydChpZHgsIGVsdCwgbGlzdCkge1xuICAgICAgICBpZHggPSBpZHggPCBsaXN0Lmxlbmd0aCAmJiBpZHggPj0gMCA/IGlkeCA6IGxpc3QubGVuZ3RoO1xuICAgICAgICB2YXIgcmVzdWx0ID0gX3NsaWNlKGxpc3QpO1xuICAgICAgICByZXN1bHQuc3BsaWNlKGlkeCwgMCwgZWx0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEluc2VydHMgdGhlIHN1Yi1saXN0IGludG8gdGhlIGxpc3QsIGF0IGluZGV4IGBpbmRleGAuIF9Ob3RlIHRoYXQgdGhpcyBpcyBub3RcbiAgICAgKiBkZXN0cnVjdGl2ZV86IGl0IHJldHVybnMgYSBjb3B5IG9mIHRoZSBsaXN0IHdpdGggdGhlIGNoYW5nZXMuXG4gICAgICogPHNtYWxsPk5vIGxpc3RzIGhhdmUgYmVlbiBoYXJtZWQgaW4gdGhlIGFwcGxpY2F0aW9uIG9mIHRoaXMgZnVuY3Rpb24uPC9zbWFsbD5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuOS4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIE51bWJlciAtPiBbYV0gLT4gW2FdIC0+IFthXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBUaGUgcG9zaXRpb24gdG8gaW5zZXJ0IHRoZSBzdWItbGlzdFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGVsdHMgVGhlIHN1Yi1saXN0IHRvIGluc2VydCBpbnRvIHRoZSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3QgdG8gaW5zZXJ0IHRoZSBzdWItbGlzdCBpbnRvXG4gICAgICogQHJldHVybiB7QXJyYXl9IEEgbmV3IEFycmF5IHdpdGggYGVsdHNgIGluc2VydGVkIHN0YXJ0aW5nIGF0IGBpbmRleGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5pbnNlcnRBbGwoMiwgWyd4JywneScsJ3onXSwgWzEsMiwzLDRdKTsgLy89PiBbMSwyLCd4JywneScsJ3onLDMsNF1cbiAgICAgKi9cbiAgICB2YXIgaW5zZXJ0QWxsID0gX2N1cnJ5MyhmdW5jdGlvbiBpbnNlcnRBbGwoaWR4LCBlbHRzLCBsaXN0KSB7XG4gICAgICAgIGlkeCA9IGlkeCA8IGxpc3QubGVuZ3RoICYmIGlkeCA+PSAwID8gaWR4IDogbGlzdC5sZW5ndGg7XG4gICAgICAgIHJldHVybiBfY29uY2F0KF9jb25jYXQoX3NsaWNlKGxpc3QsIDAsIGlkeCksIGVsdHMpLCBfc2xpY2UobGlzdCwgaWR4KSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGxpc3Qgd2l0aCB0aGUgc2VwYXJhdG9yIGludGVycG9zZWQgYmV0d2VlbiBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIERpc3BhdGNoZXMgdG8gdGhlIGBpbnRlcnNwZXJzZWAgbWV0aG9kIG9mIHRoZSBzZWNvbmQgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjE0LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgYSAtPiBbYV0gLT4gW2FdXG4gICAgICogQHBhcmFtIHsqfSBzZXBhcmF0b3IgVGhlIGVsZW1lbnQgdG8gYWRkIHRvIHRoZSBsaXN0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3QgdG8gYmUgaW50ZXJwb3NlZC5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIG5ldyBsaXN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuaW50ZXJzcGVyc2UoJ24nLCBbJ2JhJywgJ2EnLCAnYSddKTsgLy89PiBbJ2JhJywgJ24nLCAnYScsICduJywgJ2EnXVxuICAgICAqL1xuICAgIHZhciBpbnRlcnNwZXJzZSA9IF9jdXJyeTIoX2NoZWNrRm9yTWV0aG9kKCdpbnRlcnNwZXJzZScsIGZ1bmN0aW9uIGludGVyc3BlcnNlKHNlcGFyYXRvciwgbGlzdCkge1xuICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgIHZhciBpZHggPSAwO1xuICAgICAgICB2YXIgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpZHggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChpZHggPT09IGxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBvdXQucHVzaChsaXN0W2lkeF0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXQucHVzaChsaXN0W2lkeF0sIHNlcGFyYXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH0pKTtcblxuICAgIC8qKlxuICAgICAqIFNlZSBpZiBhbiBvYmplY3QgKGB2YWxgKSBpcyBhbiBpbnN0YW5jZSBvZiB0aGUgc3VwcGxpZWQgY29uc3RydWN0b3IuIFRoaXNcbiAgICAgKiBmdW5jdGlvbiB3aWxsIGNoZWNrIHVwIHRoZSBpbmhlcml0YW5jZSBjaGFpbiwgaWYgYW55LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgVHlwZVxuICAgICAqIEBzaWcgKCogLT4geyp9KSAtPiBhIC0+IEJvb2xlYW5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY3RvciBBIGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuaXMoT2JqZWN0LCB7fSk7IC8vPT4gdHJ1ZVxuICAgICAqICAgICAgUi5pcyhOdW1iZXIsIDEpOyAvLz0+IHRydWVcbiAgICAgKiAgICAgIFIuaXMoT2JqZWN0LCAxKTsgLy89PiBmYWxzZVxuICAgICAqICAgICAgUi5pcyhTdHJpbmcsICdzJyk7IC8vPT4gdHJ1ZVxuICAgICAqICAgICAgUi5pcyhTdHJpbmcsIG5ldyBTdHJpbmcoJycpKTsgLy89PiB0cnVlXG4gICAgICogICAgICBSLmlzKE9iamVjdCwgbmV3IFN0cmluZygnJykpOyAvLz0+IHRydWVcbiAgICAgKiAgICAgIFIuaXMoT2JqZWN0LCAncycpOyAvLz0+IGZhbHNlXG4gICAgICogICAgICBSLmlzKE51bWJlciwge30pOyAvLz0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzID0gX2N1cnJ5MihmdW5jdGlvbiBpcyhDdG9yLCB2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbCAhPSBudWxsICYmIHZhbC5jb25zdHJ1Y3RvciA9PT0gQ3RvciB8fCB2YWwgaW5zdGFuY2VvZiBDdG9yO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGVzdHMgd2hldGhlciBvciBub3QgYW4gb2JqZWN0IGlzIHNpbWlsYXIgdG8gYW4gYXJyYXkuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjUuMFxuICAgICAqIEBjYXRlZ29yeSBUeXBlXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnICogLT4gQm9vbGVhblxuICAgICAqIEBwYXJhbSB7Kn0geCBUaGUgb2JqZWN0IHRvIHRlc3QuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIGB4YCBoYXMgYSBudW1lcmljIGxlbmd0aCBwcm9wZXJ0eSBhbmQgZXh0cmVtZSBpbmRpY2VzIGRlZmluZWQ7IGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuaXNBcnJheUxpa2UoW10pOyAvLz0+IHRydWVcbiAgICAgKiAgICAgIFIuaXNBcnJheUxpa2UodHJ1ZSk7IC8vPT4gZmFsc2VcbiAgICAgKiAgICAgIFIuaXNBcnJheUxpa2Uoe30pOyAvLz0+IGZhbHNlXG4gICAgICogICAgICBSLmlzQXJyYXlMaWtlKHtsZW5ndGg6IDEwfSk7IC8vPT4gZmFsc2VcbiAgICAgKiAgICAgIFIuaXNBcnJheUxpa2UoezA6ICd6ZXJvJywgOTogJ25pbmUnLCBsZW5ndGg6IDEwfSk7IC8vPT4gdHJ1ZVxuICAgICAqL1xuICAgIHZhciBpc0FycmF5TGlrZSA9IF9jdXJyeTEoZnVuY3Rpb24gaXNBcnJheUxpa2UoeCkge1xuICAgICAgICBpZiAoX2lzQXJyYXkoeCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICgheCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgeCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeCBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh4Lm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gISF4Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh4Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB4Lmhhc093blByb3BlcnR5KDApICYmIHguaGFzT3duUHJvcGVydHkoeC5sZW5ndGggLSAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGlucHV0IHZhbHVlIGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuOS4wXG4gICAgICogQGNhdGVnb3J5IFR5cGVcbiAgICAgKiBAc2lnICogLT4gQm9vbGVhblxuICAgICAqIEBwYXJhbSB7Kn0geCBUaGUgdmFsdWUgdG8gdGVzdC5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgYHhgIGlzIGB1bmRlZmluZWRgIG9yIGBudWxsYCwgb3RoZXJ3aXNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5pc05pbChudWxsKTsgLy89PiB0cnVlXG4gICAgICogICAgICBSLmlzTmlsKHVuZGVmaW5lZCk7IC8vPT4gdHJ1ZVxuICAgICAqICAgICAgUi5pc05pbCgwKTsgLy89PiBmYWxzZVxuICAgICAqICAgICAgUi5pc05pbChbXSk7IC8vPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNOaWwgPSBfY3VycnkxKGZ1bmN0aW9uIGlzTmlsKHgpIHtcbiAgICAgICAgcmV0dXJuIHggPT0gbnVsbDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IGNvbnRhaW5pbmcgdGhlIG5hbWVzIG9mIGFsbCB0aGUgZW51bWVyYWJsZSBvd24gcHJvcGVydGllcyBvZlxuICAgICAqIHRoZSBzdXBwbGllZCBvYmplY3QuXG4gICAgICogTm90ZSB0aGF0IHRoZSBvcmRlciBvZiB0aGUgb3V0cHV0IGFycmF5IGlzIG5vdCBndWFyYW50ZWVkIHRvIGJlIGNvbnNpc3RlbnRcbiAgICAgKiBhY3Jvc3MgZGlmZmVyZW50IEpTIHBsYXRmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBzaWcge2s6IHZ9IC0+IFtrXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBleHRyYWN0IHByb3BlcnRpZXMgZnJvbVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvZiB0aGUgb2JqZWN0J3Mgb3duIHByb3BlcnRpZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5rZXlzKHthOiAxLCBiOiAyLCBjOiAzfSk7IC8vPT4gWydhJywgJ2InLCAnYyddXG4gICAgICovXG4gICAgLy8gY292ZXIgSUUgPCA5IGtleXMgaXNzdWVzXG4gICAgLy8gU2FmYXJpIGJ1Z1xuICAgIHZhciBrZXlzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBjb3ZlciBJRSA8IDkga2V5cyBpc3N1ZXNcbiAgICAgICAgdmFyIGhhc0VudW1CdWcgPSAheyB0b1N0cmluZzogbnVsbCB9LnByb3BlcnR5SXNFbnVtZXJhYmxlKCd0b1N0cmluZycpO1xuICAgICAgICB2YXIgbm9uRW51bWVyYWJsZVByb3BzID0gW1xuICAgICAgICAgICAgJ2NvbnN0cnVjdG9yJyxcbiAgICAgICAgICAgICd2YWx1ZU9mJyxcbiAgICAgICAgICAgICdpc1Byb3RvdHlwZU9mJyxcbiAgICAgICAgICAgICd0b1N0cmluZycsXG4gICAgICAgICAgICAncHJvcGVydHlJc0VudW1lcmFibGUnLFxuICAgICAgICAgICAgJ2hhc093blByb3BlcnR5JyxcbiAgICAgICAgICAgICd0b0xvY2FsZVN0cmluZydcbiAgICAgICAgXTtcbiAgICAgICAgLy8gU2FmYXJpIGJ1Z1xuICAgICAgICB2YXIgaGFzQXJnc0VudW1CdWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAndXNlIHN0cmljdCc7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLnByb3BlcnR5SXNFbnVtZXJhYmxlKCdsZW5ndGgnKTtcbiAgICAgICAgfSgpO1xuICAgICAgICB2YXIgY29udGFpbnMgPSBmdW5jdGlvbiBjb250YWlucyhsaXN0LCBpdGVtKSB7XG4gICAgICAgICAgICB2YXIgaWR4ID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChpZHggPCBsaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChsaXN0W2lkeF0gPT09IGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdHlwZW9mIE9iamVjdC5rZXlzID09PSAnZnVuY3Rpb24nICYmICFoYXNBcmdzRW51bUJ1ZyA/IF9jdXJyeTEoZnVuY3Rpb24ga2V5cyhvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qob2JqKSAhPT0gb2JqID8gW10gOiBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICB9KSA6IF9jdXJyeTEoZnVuY3Rpb24ga2V5cyhvYmopIHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qob2JqKSAhPT0gb2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHByb3AsIG5JZHg7XG4gICAgICAgICAgICB2YXIga3MgPSBbXTtcbiAgICAgICAgICAgIHZhciBjaGVja0FyZ3NMZW5ndGggPSBoYXNBcmdzRW51bUJ1ZyAmJiBfaXNBcmd1bWVudHMob2JqKTtcbiAgICAgICAgICAgIGZvciAocHJvcCBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAoX2hhcyhwcm9wLCBvYmopICYmICghY2hlY2tBcmdzTGVuZ3RoIHx8IHByb3AgIT09ICdsZW5ndGgnKSkge1xuICAgICAgICAgICAgICAgICAgICBrc1trcy5sZW5ndGhdID0gcHJvcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzRW51bUJ1Zykge1xuICAgICAgICAgICAgICAgIG5JZHggPSBub25FbnVtZXJhYmxlUHJvcHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICB3aGlsZSAobklkeCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3AgPSBub25FbnVtZXJhYmxlUHJvcHNbbklkeF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChfaGFzKHByb3AsIG9iaikgJiYgIWNvbnRhaW5zKGtzLCBwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAga3Nba3MubGVuZ3RoXSA9IHByb3A7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbklkeCAtPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBrcztcbiAgICAgICAgfSk7XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3QgY29udGFpbmluZyB0aGUgbmFtZXMgb2YgYWxsIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBzdXBwbGllZFxuICAgICAqIG9iamVjdCwgaW5jbHVkaW5nIHByb3RvdHlwZSBwcm9wZXJ0aWVzLlxuICAgICAqIE5vdGUgdGhhdCB0aGUgb3JkZXIgb2YgdGhlIG91dHB1dCBhcnJheSBpcyBub3QgZ3VhcmFudGVlZCB0byBiZSBjb25zaXN0ZW50XG4gICAgICogYWNyb3NzIGRpZmZlcmVudCBKUyBwbGF0Zm9ybXMuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjIuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAc2lnIHtrOiB2fSAtPiBba11cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gZXh0cmFjdCBwcm9wZXJ0aWVzIGZyb21cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgb2YgdGhlIG9iamVjdCdzIG93biBhbmQgcHJvdG90eXBlIHByb3BlcnRpZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIEYgPSBmdW5jdGlvbigpIHsgdGhpcy54ID0gJ1gnOyB9O1xuICAgICAqICAgICAgRi5wcm90b3R5cGUueSA9ICdZJztcbiAgICAgKiAgICAgIHZhciBmID0gbmV3IEYoKTtcbiAgICAgKiAgICAgIFIua2V5c0luKGYpOyAvLz0+IFsneCcsICd5J11cbiAgICAgKi9cbiAgICB2YXIga2V5c0luID0gX2N1cnJ5MShmdW5jdGlvbiBrZXlzSW4ob2JqKSB7XG4gICAgICAgIHZhciBwcm9wO1xuICAgICAgICB2YXIga3MgPSBbXTtcbiAgICAgICAgZm9yIChwcm9wIGluIG9iaikge1xuICAgICAgICAgICAga3Nba3MubGVuZ3RoXSA9IHByb3A7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtzO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBhcnJheSBieSByZXR1cm5pbmcgYGxpc3QubGVuZ3RoYC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMy4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIFthXSAtPiBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5sZW5ndGgoW10pOyAvLz0+IDBcbiAgICAgKiAgICAgIFIubGVuZ3RoKFsxLCAyLCAzXSk7IC8vPT4gM1xuICAgICAqL1xuICAgIHZhciBsZW5ndGggPSBfY3VycnkxKGZ1bmN0aW9uIGxlbmd0aChsaXN0KSB7XG4gICAgICAgIHJldHVybiBsaXN0ICE9IG51bGwgJiYgaXMoTnVtYmVyLCBsaXN0Lmxlbmd0aCkgPyBsaXN0Lmxlbmd0aCA6IE5hTjtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBsZXNzIHRoYW4gdGhlIHNlY29uZDsgYGZhbHNlYFxuICAgICAqIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gICAgICogQHNpZyBPcmQgYSA9PiBhIC0+IGEgLT4gQm9vbGVhblxuICAgICAqIEBwYXJhbSB7Kn0gYVxuICAgICAqIEBwYXJhbSB7Kn0gYlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICogQHNlZSBSLmd0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5sdCgyLCAxKTsgLy89PiBmYWxzZVxuICAgICAqICAgICAgUi5sdCgyLCAyKTsgLy89PiBmYWxzZVxuICAgICAqICAgICAgUi5sdCgyLCAzKTsgLy89PiB0cnVlXG4gICAgICogICAgICBSLmx0KCdhJywgJ3onKTsgLy89PiB0cnVlXG4gICAgICogICAgICBSLmx0KCd6JywgJ2EnKTsgLy89PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBsdCA9IF9jdXJyeTIoZnVuY3Rpb24gbHQoYSwgYikge1xuICAgICAgICByZXR1cm4gYSA8IGI7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBzZWNvbmQ7XG4gICAgICogYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICAgICAqIEBzaWcgT3JkIGEgPT4gYSAtPiBhIC0+IEJvb2xlYW5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBiXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKiBAc2VlIFIuZ3RlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5sdGUoMiwgMSk7IC8vPT4gZmFsc2VcbiAgICAgKiAgICAgIFIubHRlKDIsIDIpOyAvLz0+IHRydWVcbiAgICAgKiAgICAgIFIubHRlKDIsIDMpOyAvLz0+IHRydWVcbiAgICAgKiAgICAgIFIubHRlKCdhJywgJ3onKTsgLy89PiB0cnVlXG4gICAgICogICAgICBSLmx0ZSgneicsICdhJyk7IC8vPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgbHRlID0gX2N1cnJ5MihmdW5jdGlvbiBsdGUoYSwgYikge1xuICAgICAgICByZXR1cm4gYSA8PSBiO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG1hcEFjY3VtIGZ1bmN0aW9uIGJlaGF2ZXMgbGlrZSBhIGNvbWJpbmF0aW9uIG9mIG1hcCBhbmQgcmVkdWNlOyBpdFxuICAgICAqIGFwcGxpZXMgYSBmdW5jdGlvbiB0byBlYWNoIGVsZW1lbnQgb2YgYSBsaXN0LCBwYXNzaW5nIGFuIGFjY3VtdWxhdGluZ1xuICAgICAqIHBhcmFtZXRlciBmcm9tIGxlZnQgdG8gcmlnaHQsIGFuZCByZXR1cm5pbmcgYSBmaW5hbCB2YWx1ZSBvZiB0aGlzXG4gICAgICogYWNjdW11bGF0b3IgdG9nZXRoZXIgd2l0aCB0aGUgbmV3IGxpc3QuXG4gICAgICpcbiAgICAgKiBUaGUgaXRlcmF0b3IgZnVuY3Rpb24gcmVjZWl2ZXMgdHdvIGFyZ3VtZW50cywgKmFjYyogYW5kICp2YWx1ZSosIGFuZCBzaG91bGRcbiAgICAgKiByZXR1cm4gYSB0dXBsZSAqW2FjYywgdmFsdWVdKi5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyAoYWNjIC0+IHggLT4gKGFjYywgeSkpIC0+IGFjYyAtPiBbeF0gLT4gKGFjYywgW3ldKVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gZXZlcnkgZWxlbWVudCBvZiB0aGUgaW5wdXQgYGxpc3RgLlxuICAgICAqIEBwYXJhbSB7Kn0gYWNjIFRoZSBhY2N1bXVsYXRvciB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJuIHsqfSBUaGUgZmluYWwsIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBzZWUgUi5hZGRJbmRleFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBkaWdpdHMgPSBbJzEnLCAnMicsICczJywgJzQnXTtcbiAgICAgKiAgICAgIHZhciBhcHBlbmRlciA9IChhLCBiKSA9PiBbYSArIGIsIGEgKyBiXTtcbiAgICAgKlxuICAgICAqICAgICAgUi5tYXBBY2N1bShhcHBlbmRlciwgMCwgZGlnaXRzKTsgLy89PiBbJzAxMjM0JywgWycwMScsICcwMTInLCAnMDEyMycsICcwMTIzNCddXVxuICAgICAqL1xuICAgIHZhciBtYXBBY2N1bSA9IF9jdXJyeTMoZnVuY3Rpb24gbWFwQWNjdW0oZm4sIGFjYywgbGlzdCkge1xuICAgICAgICB2YXIgaWR4ID0gMDtcbiAgICAgICAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHZhciB0dXBsZSA9IFthY2NdO1xuICAgICAgICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgICAgICAgICB0dXBsZSA9IGZuKHR1cGxlWzBdLCBsaXN0W2lkeF0pO1xuICAgICAgICAgICAgcmVzdWx0W2lkeF0gPSB0dXBsZVsxXTtcbiAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB0dXBsZVswXSxcbiAgICAgICAgICAgIHJlc3VsdFxuICAgICAgICBdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG1hcEFjY3VtUmlnaHQgZnVuY3Rpb24gYmVoYXZlcyBsaWtlIGEgY29tYmluYXRpb24gb2YgbWFwIGFuZCByZWR1Y2U7IGl0XG4gICAgICogYXBwbGllcyBhIGZ1bmN0aW9uIHRvIGVhY2ggZWxlbWVudCBvZiBhIGxpc3QsIHBhc3NpbmcgYW4gYWNjdW11bGF0aW5nXG4gICAgICogcGFyYW1ldGVyIGZyb20gcmlnaHQgdG8gbGVmdCwgYW5kIHJldHVybmluZyBhIGZpbmFsIHZhbHVlIG9mIHRoaXNcbiAgICAgKiBhY2N1bXVsYXRvciB0b2dldGhlciB3aXRoIHRoZSBuZXcgbGlzdC5cbiAgICAgKlxuICAgICAqIFNpbWlsYXIgdG8gYG1hcEFjY3VtYCwgZXhjZXB0IG1vdmVzIHRocm91Z2ggdGhlIGlucHV0IGxpc3QgZnJvbSB0aGUgcmlnaHQgdG9cbiAgICAgKiB0aGUgbGVmdC5cbiAgICAgKlxuICAgICAqIFRoZSBpdGVyYXRvciBmdW5jdGlvbiByZWNlaXZlcyB0d28gYXJndW1lbnRzLCAqYWNjKiBhbmQgKnZhbHVlKiwgYW5kIHNob3VsZFxuICAgICAqIHJldHVybiBhIHR1cGxlICpbYWNjLCB2YWx1ZV0qLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xMC4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIChhY2MgLT4geCAtPiAoYWNjLCB5KSkgLT4gYWNjIC0+IFt4XSAtPiAoYWNjLCBbeV0pXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBldmVyeSBlbGVtZW50IG9mIHRoZSBpbnB1dCBgbGlzdGAuXG4gICAgICogQHBhcmFtIHsqfSBhY2MgVGhlIGFjY3VtdWxhdG9yIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEByZXR1cm4geyp9IFRoZSBmaW5hbCwgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQHNlZSBSLmFkZEluZGV4XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGRpZ2l0cyA9IFsnMScsICcyJywgJzMnLCAnNCddO1xuICAgICAqICAgICAgdmFyIGFwcGVuZCA9IChhLCBiKSA9PiBbYSArIGIsIGEgKyBiXTtcbiAgICAgKlxuICAgICAqICAgICAgUi5tYXBBY2N1bVJpZ2h0KGFwcGVuZCwgMCwgZGlnaXRzKTsgLy89PiBbJzA0MzIxJywgWycwNDMyMScsICcwNDMyJywgJzA0MycsICcwNCddXVxuICAgICAqL1xuICAgIHZhciBtYXBBY2N1bVJpZ2h0ID0gX2N1cnJ5MyhmdW5jdGlvbiBtYXBBY2N1bVJpZ2h0KGZuLCBhY2MsIGxpc3QpIHtcbiAgICAgICAgdmFyIGlkeCA9IGxpc3QubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB2YXIgdHVwbGUgPSBbYWNjXTtcbiAgICAgICAgd2hpbGUgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICB0dXBsZSA9IGZuKHR1cGxlWzBdLCBsaXN0W2lkeF0pO1xuICAgICAgICAgICAgcmVzdWx0W2lkeF0gPSB0dXBsZVsxXTtcbiAgICAgICAgICAgIGlkeCAtPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB0dXBsZVswXSxcbiAgICAgICAgICAgIHJlc3VsdFxuICAgICAgICBdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGVzdHMgYSByZWd1bGFyIGV4cHJlc3Npb24gYWdhaW5zdCBhIFN0cmluZy4gTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gd2lsbFxuICAgICAqIHJldHVybiBhbiBlbXB0eSBhcnJheSB3aGVuIHRoZXJlIGFyZSBubyBtYXRjaGVzLiBUaGlzIGRpZmZlcnMgZnJvbVxuICAgICAqIFtgU3RyaW5nLnByb3RvdHlwZS5tYXRjaGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9tYXRjaClcbiAgICAgKiB3aGljaCByZXR1cm5zIGBudWxsYCB3aGVuIHRoZXJlIGFyZSBubyBtYXRjaGVzLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHNpZyBSZWdFeHAgLT4gU3RyaW5nIC0+IFtTdHJpbmcgfCBVbmRlZmluZWRdXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IHJ4IEEgcmVndWxhciBleHByZXNzaW9uLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byBtYXRjaCBhZ2FpbnN0XG4gICAgICogQHJldHVybiB7QXJyYXl9IFRoZSBsaXN0IG9mIG1hdGNoZXMgb3IgZW1wdHkgYXJyYXkuXG4gICAgICogQHNlZSBSLnRlc3RcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLm1hdGNoKC8oW2Etel1hKS9nLCAnYmFuYW5hcycpOyAvLz0+IFsnYmEnLCAnbmEnLCAnbmEnXVxuICAgICAqICAgICAgUi5tYXRjaCgvYS8sICdiJyk7IC8vPT4gW11cbiAgICAgKiAgICAgIFIubWF0Y2goL2EvLCBudWxsKTsgLy89PiBUeXBlRXJyb3I6IG51bGwgZG9lcyBub3QgaGF2ZSBhIG1ldGhvZCBuYW1lZCBcIm1hdGNoXCJcbiAgICAgKi9cbiAgICB2YXIgbWF0Y2ggPSBfY3VycnkyKGZ1bmN0aW9uIG1hdGNoKHJ4LCBzdHIpIHtcbiAgICAgICAgcmV0dXJuIHN0ci5tYXRjaChyeCkgfHwgW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBtYXRoTW9kIGJlaGF2ZXMgbGlrZSB0aGUgbW9kdWxvIG9wZXJhdG9yIHNob3VsZCBtYXRoZW1hdGljYWxseSwgdW5saWtlIHRoZVxuICAgICAqIGAlYCBvcGVyYXRvciAoYW5kIGJ5IGV4dGVuc2lvbiwgUi5tb2R1bG8pLiBTbyB3aGlsZSBcIi0xNyAlIDVcIiBpcyAtMixcbiAgICAgKiBtYXRoTW9kKC0xNywgNSkgaXMgMy4gbWF0aE1vZCByZXF1aXJlcyBJbnRlZ2VyIGFyZ3VtZW50cywgYW5kIHJldHVybnMgTmFOXG4gICAgICogd2hlbiB0aGUgbW9kdWx1cyBpcyB6ZXJvIG9yIG5lZ2F0aXZlLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBzaWcgTnVtYmVyIC0+IE51bWJlciAtPiBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbSBUaGUgZGl2aWRlbmQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHAgdGhlIG1vZHVsdXMuXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgcmVzdWx0IG9mIGBiIG1vZCBhYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLm1hdGhNb2QoLTE3LCA1KTsgIC8vPT4gM1xuICAgICAqICAgICAgUi5tYXRoTW9kKDE3LCA1KTsgICAvLz0+IDJcbiAgICAgKiAgICAgIFIubWF0aE1vZCgxNywgLTUpOyAgLy89PiBOYU5cbiAgICAgKiAgICAgIFIubWF0aE1vZCgxNywgMCk7ICAgLy89PiBOYU5cbiAgICAgKiAgICAgIFIubWF0aE1vZCgxNy4yLCA1KTsgLy89PiBOYU5cbiAgICAgKiAgICAgIFIubWF0aE1vZCgxNywgNS4zKTsgLy89PiBOYU5cbiAgICAgKlxuICAgICAqICAgICAgdmFyIGNsb2NrID0gUi5tYXRoTW9kKFIuX18sIDEyKTtcbiAgICAgKiAgICAgIGNsb2NrKDE1KTsgLy89PiAzXG4gICAgICogICAgICBjbG9jaygyNCk7IC8vPT4gMFxuICAgICAqXG4gICAgICogICAgICB2YXIgc2V2ZW50ZWVuTW9kID0gUi5tYXRoTW9kKDE3KTtcbiAgICAgKiAgICAgIHNldmVudGVlbk1vZCgzKTsgIC8vPT4gMlxuICAgICAqICAgICAgc2V2ZW50ZWVuTW9kKDQpOyAgLy89PiAxXG4gICAgICogICAgICBzZXZlbnRlZW5Nb2QoMTApOyAvLz0+IDdcbiAgICAgKi9cbiAgICB2YXIgbWF0aE1vZCA9IF9jdXJyeTIoZnVuY3Rpb24gbWF0aE1vZChtLCBwKSB7XG4gICAgICAgIGlmICghX2lzSW50ZWdlcihtKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIV9pc0ludGVnZXIocCkgfHwgcCA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChtICUgcCArIHApICUgcDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxhcmdlciBvZiBpdHMgdHdvIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gICAgICogQHNpZyBPcmQgYSA9PiBhIC0+IGEgLT4gYVxuICAgICAqIEBwYXJhbSB7Kn0gYVxuICAgICAqIEBwYXJhbSB7Kn0gYlxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICogQHNlZSBSLm1heEJ5LCBSLm1pblxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIubWF4KDc4OSwgMTIzKTsgLy89PiA3ODlcbiAgICAgKiAgICAgIFIubWF4KCdhJywgJ2InKTsgLy89PiAnYidcbiAgICAgKi9cbiAgICB2YXIgbWF4ID0gX2N1cnJ5MihmdW5jdGlvbiBtYXgoYSwgYikge1xuICAgICAgICByZXR1cm4gYiA+IGEgPyBiIDogYTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRha2VzIGEgZnVuY3Rpb24gYW5kIHR3byB2YWx1ZXMsIGFuZCByZXR1cm5zIHdoaWNoZXZlciB2YWx1ZSBwcm9kdWNlcyB0aGVcbiAgICAgKiBsYXJnZXIgcmVzdWx0IHdoZW4gcGFzc2VkIHRvIHRoZSBwcm92aWRlZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuOC4wXG4gICAgICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gICAgICogQHNpZyBPcmQgYiA9PiAoYSAtPiBiKSAtPiBhIC0+IGEgLT4gYVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZcbiAgICAgKiBAcGFyYW0geyp9IGFcbiAgICAgKiBAcGFyYW0geyp9IGJcbiAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAqIEBzZWUgUi5tYXgsIFIubWluQnlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICAvLyAgc3F1YXJlIDo6IE51bWJlciAtPiBOdW1iZXJcbiAgICAgKiAgICAgIHZhciBzcXVhcmUgPSBuID0+IG4gKiBuO1xuICAgICAqXG4gICAgICogICAgICBSLm1heEJ5KHNxdWFyZSwgLTMsIDIpOyAvLz0+IC0zXG4gICAgICpcbiAgICAgKiAgICAgIFIucmVkdWNlKFIubWF4Qnkoc3F1YXJlKSwgMCwgWzMsIC01LCA0LCAxLCAtMl0pOyAvLz0+IC01XG4gICAgICogICAgICBSLnJlZHVjZShSLm1heEJ5KHNxdWFyZSksIDAsIFtdKTsgLy89PiAwXG4gICAgICovXG4gICAgdmFyIG1heEJ5ID0gX2N1cnJ5MyhmdW5jdGlvbiBtYXhCeShmLCBhLCBiKSB7XG4gICAgICAgIHJldHVybiBmKGIpID4gZihhKSA/IGIgOiBhO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBvd24gcHJvcGVydGllcyBvZiB0aGUgZmlyc3Qgb2JqZWN0IG1lcmdlZCB3aXRoXG4gICAgICogdGhlIG93biBwcm9wZXJ0aWVzIG9mIHRoZSBzZWNvbmQgb2JqZWN0LiBJZiBhIGtleSBleGlzdHMgaW4gYm90aCBvYmplY3RzLFxuICAgICAqIHRoZSB2YWx1ZSBmcm9tIHRoZSBzZWNvbmQgb2JqZWN0IHdpbGwgYmUgdXNlZC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBzaWcge2s6IHZ9IC0+IHtrOiB2fSAtPiB7azogdn1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqIEBzZWUgUi5tZXJnZVdpdGgsIFIubWVyZ2VXaXRoS2V5XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5tZXJnZSh7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogMTAgfSwgeyAnYWdlJzogNDAgfSk7XG4gICAgICogICAgICAvLz0+IHsgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCB9XG4gICAgICpcbiAgICAgKiAgICAgIHZhciByZXNldFRvRGVmYXVsdCA9IFIubWVyZ2UoUi5fXywge3g6IDB9KTtcbiAgICAgKiAgICAgIHJlc2V0VG9EZWZhdWx0KHt4OiA1LCB5OiAyfSk7IC8vPT4ge3g6IDAsIHk6IDJ9XG4gICAgICovXG4gICAgdmFyIG1lcmdlID0gX2N1cnJ5MihmdW5jdGlvbiBtZXJnZShsLCByKSB7XG4gICAgICAgIHJldHVybiBfYXNzaWduKHt9LCBsLCByKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIE1lcmdlcyBhIGxpc3Qgb2Ygb2JqZWN0cyB0b2dldGhlciBpbnRvIG9uZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgW3trOiB2fV0gLT4ge2s6IHZ9XG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBBbiBhcnJheSBvZiBvYmplY3RzXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBBIG1lcmdlZCBvYmplY3QuXG4gICAgICogQHNlZSBSLnJlZHVjZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIubWVyZ2VBbGwoW3tmb286MX0se2JhcjoyfSx7YmF6OjN9XSk7IC8vPT4ge2ZvbzoxLGJhcjoyLGJhejozfVxuICAgICAqICAgICAgUi5tZXJnZUFsbChbe2ZvbzoxfSx7Zm9vOjJ9LHtiYXI6Mn1dKTsgLy89PiB7Zm9vOjIsYmFyOjJ9XG4gICAgICovXG4gICAgdmFyIG1lcmdlQWxsID0gX2N1cnJ5MShmdW5jdGlvbiBtZXJnZUFsbChsaXN0KSB7XG4gICAgICAgIHJldHVybiBfYXNzaWduLmFwcGx5KG51bGwsIFt7fV0uY29uY2F0KGxpc3QpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgb2JqZWN0IHdpdGggdGhlIG93biBwcm9wZXJ0aWVzIG9mIHRoZSB0d28gcHJvdmlkZWQgb2JqZWN0cy4gSWZcbiAgICAgKiBhIGtleSBleGlzdHMgaW4gYm90aCBvYmplY3RzLCB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gaXMgYXBwbGllZCB0byB0aGUga2V5XG4gICAgICogYW5kIHRoZSB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBrZXkgaW4gZWFjaCBvYmplY3QsIHdpdGggdGhlIHJlc3VsdCBiZWluZ1xuICAgICAqIHVzZWQgYXMgdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUga2V5IGluIHRoZSByZXR1cm5lZCBvYmplY3QuIFRoZSBrZXlcbiAgICAgKiB3aWxsIGJlIGV4Y2x1ZGVkIGZyb20gdGhlIHJldHVybmVkIG9iamVjdCBpZiB0aGUgcmVzdWx0aW5nIHZhbHVlIGlzXG4gICAgICogYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjE5LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHNpZyAoU3RyaW5nIC0+IGEgLT4gYSAtPiBhKSAtPiB7YX0gLT4ge2F9IC0+IHthfVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gclxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKiBAc2VlIFIubWVyZ2UsIFIubWVyZ2VXaXRoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgbGV0IGNvbmNhdFZhbHVlcyA9IChrLCBsLCByKSA9PiBrID09ICd2YWx1ZXMnID8gUi5jb25jYXQobCwgcikgOiByXG4gICAgICogICAgICBSLm1lcmdlV2l0aEtleShjb25jYXRWYWx1ZXMsXG4gICAgICogICAgICAgICAgICAgICAgICAgICB7IGE6IHRydWUsIHRoaW5nOiAnZm9vJywgdmFsdWVzOiBbMTAsIDIwXSB9LFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgeyBiOiB0cnVlLCB0aGluZzogJ2JhcicsIHZhbHVlczogWzE1LCAzNV0gfSk7XG4gICAgICogICAgICAvLz0+IHsgYTogdHJ1ZSwgYjogdHJ1ZSwgdGhpbmc6ICdiYXInLCB2YWx1ZXM6IFsxMCwgMjAsIDE1LCAzNV0gfVxuICAgICAqL1xuICAgIHZhciBtZXJnZVdpdGhLZXkgPSBfY3VycnkzKGZ1bmN0aW9uIG1lcmdlV2l0aEtleShmbiwgbCwgcikge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIHZhciBrO1xuICAgICAgICBmb3IgKGsgaW4gbCkge1xuICAgICAgICAgICAgaWYgKF9oYXMoaywgbCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRba10gPSBfaGFzKGssIHIpID8gZm4oaywgbFtrXSwgcltrXSkgOiBsW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoayBpbiByKSB7XG4gICAgICAgICAgICBpZiAoX2hhcyhrLCByKSAmJiAhX2hhcyhrLCByZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tdID0gcltrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc21hbGxlciBvZiBpdHMgdHdvIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gICAgICogQHNpZyBPcmQgYSA9PiBhIC0+IGEgLT4gYVxuICAgICAqIEBwYXJhbSB7Kn0gYVxuICAgICAqIEBwYXJhbSB7Kn0gYlxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICogQHNlZSBSLm1pbkJ5LCBSLm1heFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIubWluKDc4OSwgMTIzKTsgLy89PiAxMjNcbiAgICAgKiAgICAgIFIubWluKCdhJywgJ2InKTsgLy89PiAnYSdcbiAgICAgKi9cbiAgICB2YXIgbWluID0gX2N1cnJ5MihmdW5jdGlvbiBtaW4oYSwgYikge1xuICAgICAgICByZXR1cm4gYiA8IGEgPyBiIDogYTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRha2VzIGEgZnVuY3Rpb24gYW5kIHR3byB2YWx1ZXMsIGFuZCByZXR1cm5zIHdoaWNoZXZlciB2YWx1ZSBwcm9kdWNlcyB0aGVcbiAgICAgKiBzbWFsbGVyIHJlc3VsdCB3aGVuIHBhc3NlZCB0byB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjguMFxuICAgICAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICAgICAqIEBzaWcgT3JkIGIgPT4gKGEgLT4gYikgLT4gYSAtPiBhIC0+IGFcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmXG4gICAgICogQHBhcmFtIHsqfSBhXG4gICAgICogQHBhcmFtIHsqfSBiXG4gICAgICogQHJldHVybiB7Kn1cbiAgICAgKiBAc2VlIFIubWluLCBSLm1heEJ5XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgLy8gIHNxdWFyZSA6OiBOdW1iZXIgLT4gTnVtYmVyXG4gICAgICogICAgICB2YXIgc3F1YXJlID0gbiA9PiBuICogbjtcbiAgICAgKlxuICAgICAqICAgICAgUi5taW5CeShzcXVhcmUsIC0zLCAyKTsgLy89PiAyXG4gICAgICpcbiAgICAgKiAgICAgIFIucmVkdWNlKFIubWluQnkoc3F1YXJlKSwgSW5maW5pdHksIFszLCAtNSwgNCwgMSwgLTJdKTsgLy89PiAxXG4gICAgICogICAgICBSLnJlZHVjZShSLm1pbkJ5KHNxdWFyZSksIEluZmluaXR5LCBbXSk7IC8vPT4gSW5maW5pdHlcbiAgICAgKi9cbiAgICB2YXIgbWluQnkgPSBfY3VycnkzKGZ1bmN0aW9uIG1pbkJ5KGYsIGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGYoYikgPCBmKGEpID8gYiA6IGE7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBEaXZpZGVzIHRoZSBzZWNvbmQgcGFyYW1ldGVyIGJ5IHRoZSBmaXJzdCBhbmQgcmV0dXJucyB0aGUgcmVtYWluZGVyLiBOb3RlXG4gICAgICogdGhhdCB0aGlzIGZ1bmN0aW9uIHByZXNlcnZlcyB0aGUgSmF2YVNjcmlwdC1zdHlsZSBiZWhhdmlvciBmb3IgbW9kdWxvLiBGb3JcbiAgICAgKiBtYXRoZW1hdGljYWwgbW9kdWxvIHNlZSBgbWF0aE1vZGAuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMVxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHNpZyBOdW1iZXIgLT4gTnVtYmVyIC0+IE51bWJlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhIFRoZSB2YWx1ZSB0byB0aGUgZGl2aWRlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBiIFRoZSBwc2V1ZG8tbW9kdWx1c1xuICAgICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHJlc3VsdCBvZiBgYiAlIGFgLlxuICAgICAqIEBzZWUgUi5tYXRoTW9kXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5tb2R1bG8oMTcsIDMpOyAvLz0+IDJcbiAgICAgKiAgICAgIC8vIEpTIGJlaGF2aW9yOlxuICAgICAqICAgICAgUi5tb2R1bG8oLTE3LCAzKTsgLy89PiAtMlxuICAgICAqICAgICAgUi5tb2R1bG8oMTcsIC0zKTsgLy89PiAyXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBpc09kZCA9IFIubW9kdWxvKFIuX18sIDIpO1xuICAgICAqICAgICAgaXNPZGQoNDIpOyAvLz0+IDBcbiAgICAgKiAgICAgIGlzT2RkKDIxKTsgLy89PiAxXG4gICAgICovXG4gICAgdmFyIG1vZHVsbyA9IF9jdXJyeTIoZnVuY3Rpb24gbW9kdWxvKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgJSBiO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyB0d28gbnVtYmVycy4gRXF1aXZhbGVudCB0byBgYSAqIGJgIGJ1dCBjdXJyaWVkLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBzaWcgTnVtYmVyIC0+IE51bWJlciAtPiBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYSBUaGUgZmlyc3QgdmFsdWUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGIgVGhlIHNlY29uZCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSByZXN1bHQgb2YgYGEgKiBiYC5cbiAgICAgKiBAc2VlIFIuZGl2aWRlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGRvdWJsZSA9IFIubXVsdGlwbHkoMik7XG4gICAgICogICAgICB2YXIgdHJpcGxlID0gUi5tdWx0aXBseSgzKTtcbiAgICAgKiAgICAgIGRvdWJsZSgzKTsgICAgICAgLy89PiAgNlxuICAgICAqICAgICAgdHJpcGxlKDQpOyAgICAgICAvLz0+IDEyXG4gICAgICogICAgICBSLm11bHRpcGx5KDIsIDUpOyAgLy89PiAxMFxuICAgICAqL1xuICAgIHZhciBtdWx0aXBseSA9IF9jdXJyeTIoZnVuY3Rpb24gbXVsdGlwbHkoYSwgYikge1xuICAgICAgICByZXR1cm4gYSAqIGI7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBXcmFwcyBhIGZ1bmN0aW9uIG9mIGFueSBhcml0eSAoaW5jbHVkaW5nIG51bGxhcnkpIGluIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzXG4gICAgICogZXhhY3RseSBgbmAgcGFyYW1ldGVycy4gQW55IGV4dHJhbmVvdXMgcGFyYW1ldGVycyB3aWxsIG5vdCBiZSBwYXNzZWQgdG8gdGhlXG4gICAgICogc3VwcGxpZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBzaWcgTnVtYmVyIC0+ICgqIC0+IGEpIC0+ICgqIC0+IGEpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG4gVGhlIGRlc2lyZWQgYXJpdHkgb2YgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBuZXcgZnVuY3Rpb24gd3JhcHBpbmcgYGZuYC4gVGhlIG5ldyBmdW5jdGlvbiBpcyBndWFyYW50ZWVkIHRvIGJlIG9mXG4gICAgICogICAgICAgICBhcml0eSBgbmAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIHRha2VzVHdvQXJncyA9IChhLCBiKSA9PiBbYSwgYl07XG4gICAgICpcbiAgICAgKiAgICAgIHRha2VzVHdvQXJncy5sZW5ndGg7IC8vPT4gMlxuICAgICAqICAgICAgdGFrZXNUd29BcmdzKDEsIDIpOyAvLz0+IFsxLCAyXVxuICAgICAqXG4gICAgICogICAgICB2YXIgdGFrZXNPbmVBcmcgPSBSLm5BcnkoMSwgdGFrZXNUd29BcmdzKTtcbiAgICAgKiAgICAgIHRha2VzT25lQXJnLmxlbmd0aDsgLy89PiAxXG4gICAgICogICAgICAvLyBPbmx5IGBuYCBhcmd1bWVudHMgYXJlIHBhc3NlZCB0byB0aGUgd3JhcHBlZCBmdW5jdGlvblxuICAgICAqICAgICAgdGFrZXNPbmVBcmcoMSwgMik7IC8vPT4gWzEsIHVuZGVmaW5lZF1cbiAgICAgKi9cbiAgICB2YXIgbkFyeSA9IF9jdXJyeTIoZnVuY3Rpb24gbkFyeShuLCBmbikge1xuICAgICAgICBzd2l0Y2ggKG4pIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBhMCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGEwLCBhMSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSwgYTIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBhMCwgYTEsIGEyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTAsIGExLCBhMiwgYTMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBhMCwgYTEsIGEyLCBhMyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSwgYTIsIGEzLCBhNCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGEwLCBhMSwgYTIsIGEzLCBhNCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBhMCwgYTEsIGEyLCBhMywgYTQsIGE1KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBhMCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNik7XG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBhMCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgsIGE5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCwgYTkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgdG8gbkFyeSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIgbm8gZ3JlYXRlciB0aGFuIHRlbicpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBOZWdhdGVzIGl0cyBhcmd1bWVudC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuOS4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAc2lnIE51bWJlciAtPiBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gblxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLm5lZ2F0ZSg0Mik7IC8vPT4gLTQyXG4gICAgICovXG4gICAgdmFyIG5lZ2F0ZSA9IF9jdXJyeTEoZnVuY3Rpb24gbmVnYXRlKG4pIHtcbiAgICAgICAgcmV0dXJuIC1uO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgbm8gZWxlbWVudHMgb2YgdGhlIGxpc3QgbWF0Y2ggdGhlIHByZWRpY2F0ZSwgYGZhbHNlYFxuICAgICAqIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIERpc3BhdGNoZXMgdG8gdGhlIGBhbnlgIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xMi4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IFthXSAtPiBCb29sZWFuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIHByZWRpY2F0ZSBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBjb25zaWRlci5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIHByZWRpY2F0ZSBpcyBub3Qgc2F0aXNmaWVkIGJ5IGV2ZXJ5IGVsZW1lbnQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqIEBzZWUgUi5hbGwsIFIuYW55XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGlzRXZlbiA9IG4gPT4gbiAlIDIgPT09IDA7XG4gICAgICpcbiAgICAgKiAgICAgIFIubm9uZShpc0V2ZW4sIFsxLCAzLCA1LCA3LCA5LCAxMV0pOyAvLz0+IHRydWVcbiAgICAgKiAgICAgIFIubm9uZShpc0V2ZW4sIFsxLCAzLCA1LCA3LCA4LCAxMV0pOyAvLz0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIG5vbmUgPSBfY3VycnkyKF9jb21wbGVtZW50KF9kaXNwYXRjaGFibGUoJ2FueScsIF94YW55LCBhbnkpKSk7XG5cbiAgICAvKipcbiAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgYCFgIG9mIGl0cyBhcmd1bWVudC4gSXQgd2lsbCByZXR1cm4gYHRydWVgIHdoZW5cbiAgICAgKiBwYXNzZWQgZmFsc2UteSB2YWx1ZSwgYW5kIGBmYWxzZWAgd2hlbiBwYXNzZWQgYSB0cnV0aC15IG9uZS5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IExvZ2ljXG4gICAgICogQHNpZyAqIC0+IEJvb2xlYW5cbiAgICAgKiBAcGFyYW0geyp9IGEgYW55IHZhbHVlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdGhlIGxvZ2ljYWwgaW52ZXJzZSBvZiBwYXNzZWQgYXJndW1lbnQuXG4gICAgICogQHNlZSBSLmNvbXBsZW1lbnRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLm5vdCh0cnVlKTsgLy89PiBmYWxzZVxuICAgICAqICAgICAgUi5ub3QoZmFsc2UpOyAvLz0+IHRydWVcbiAgICAgKiAgICAgIFIubm90KDApOyA9PiB0cnVlXG4gICAgICogICAgICBSLm5vdCgxKTsgPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgbm90ID0gX2N1cnJ5MShmdW5jdGlvbiBub3QoYSkge1xuICAgICAgICByZXR1cm4gIWE7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBudGggZWxlbWVudCBvZiB0aGUgZ2l2ZW4gbGlzdCBvciBzdHJpbmcuIElmIG4gaXMgbmVnYXRpdmUgdGhlXG4gICAgICogZWxlbWVudCBhdCBpbmRleCBsZW5ndGggKyBuIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgTnVtYmVyIC0+IFthXSAtPiBhIHwgVW5kZWZpbmVkXG4gICAgICogQHNpZyBOdW1iZXIgLT4gU3RyaW5nIC0+IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXRcbiAgICAgKiBAcGFyYW0geyp9IGxpc3RcbiAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBsaXN0ID0gWydmb28nLCAnYmFyJywgJ2JheicsICdxdXV4J107XG4gICAgICogICAgICBSLm50aCgxLCBsaXN0KTsgLy89PiAnYmFyJ1xuICAgICAqICAgICAgUi5udGgoLTEsIGxpc3QpOyAvLz0+ICdxdXV4J1xuICAgICAqICAgICAgUi5udGgoLTk5LCBsaXN0KTsgLy89PiB1bmRlZmluZWRcbiAgICAgKlxuICAgICAqICAgICAgUi5udGgoMiwgJ2FiYycpOyAvLz0+ICdjJ1xuICAgICAqICAgICAgUi5udGgoMywgJ2FiYycpOyAvLz0+ICcnXG4gICAgICovXG4gICAgdmFyIG50aCA9IF9jdXJyeTIoZnVuY3Rpb24gbnRoKG9mZnNldCwgbGlzdCkge1xuICAgICAgICB2YXIgaWR4ID0gb2Zmc2V0IDwgMCA/IGxpc3QubGVuZ3RoICsgb2Zmc2V0IDogb2Zmc2V0O1xuICAgICAgICByZXR1cm4gX2lzU3RyaW5nKGxpc3QpID8gbGlzdC5jaGFyQXQoaWR4KSA6IGxpc3RbaWR4XTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGl0cyBudGggYXJndW1lbnQuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjkuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBzaWcgTnVtYmVyIC0+ICouLi4gLT4gKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5udGhBcmcoMSkoJ2EnLCAnYicsICdjJyk7IC8vPT4gJ2InXG4gICAgICogICAgICBSLm50aEFyZygtMSkoJ2EnLCAnYicsICdjJyk7IC8vPT4gJ2MnXG4gICAgICovXG4gICAgdmFyIG50aEFyZyA9IF9jdXJyeTEoZnVuY3Rpb24gbnRoQXJnKG4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBudGgobiwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYSBzaW5nbGUga2V5OnZhbHVlIHBhaXIuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjE4LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHNpZyBTdHJpbmcgLT4gYSAtPiB7U3RyaW5nOmF9XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqIEBzZWUgUi5wYWlyXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIG1hdGNoUGhyYXNlcyA9IFIuY29tcG9zZShcbiAgICAgKiAgICAgICAgUi5vYmpPZignbXVzdCcpLFxuICAgICAqICAgICAgICBSLm1hcChSLm9iak9mKCdtYXRjaF9waHJhc2UnKSlcbiAgICAgKiAgICAgICk7XG4gICAgICogICAgICBtYXRjaFBocmFzZXMoWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiB7bXVzdDogW3ttYXRjaF9waHJhc2U6ICdmb28nfSwge21hdGNoX3BocmFzZTogJ2Jhcid9LCB7bWF0Y2hfcGhyYXNlOiAnYmF6J31dfVxuICAgICAqL1xuICAgIHZhciBvYmpPZiA9IF9jdXJyeTIoZnVuY3Rpb24gb2JqT2Yoa2V5LCB2YWwpIHtcbiAgICAgICAgdmFyIG9iaiA9IHt9O1xuICAgICAgICBvYmpba2V5XSA9IHZhbDtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzaW5nbGV0b24gYXJyYXkgY29udGFpbmluZyB0aGUgdmFsdWUgcHJvdmlkZWQuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoaXMgYG9mYCBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgRVM2IGBvZmA7IFNlZVxuICAgICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L29mXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjMuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBzaWcgYSAtPiBbYV1cbiAgICAgKiBAcGFyYW0geyp9IHggYW55IHZhbHVlXG4gICAgICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IHdyYXBwaW5nIGB4YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLm9mKG51bGwpOyAvLz0+IFtudWxsXVxuICAgICAqICAgICAgUi5vZihbNDJdKTsgLy89PiBbWzQyXV1cbiAgICAgKi9cbiAgICB2YXIgb2YgPSBfY3VycnkxKF9vZik7XG5cbiAgICAvKipcbiAgICAgKiBBY2NlcHRzIGEgZnVuY3Rpb24gYGZuYCBhbmQgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgZ3VhcmRzIGludm9jYXRpb24gb2ZcbiAgICAgKiBgZm5gIHN1Y2ggdGhhdCBgZm5gIGNhbiBvbmx5IGV2ZXIgYmUgY2FsbGVkIG9uY2UsIG5vIG1hdHRlciBob3cgbWFueSB0aW1lc1xuICAgICAqIHRoZSByZXR1cm5lZCBmdW5jdGlvbiBpcyBpbnZva2VkLiBUaGUgZmlyc3QgdmFsdWUgY2FsY3VsYXRlZCBpcyByZXR1cm5lZCBpblxuICAgICAqIHN1YnNlcXVlbnQgaW52b2NhdGlvbnMuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBzaWcgKGEuLi4gLT4gYikgLT4gKGEuLi4gLT4gYilcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gd3JhcCBpbiBhIGNhbGwtb25seS1vbmNlIHdyYXBwZXIuXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IFRoZSB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBhZGRPbmVPbmNlID0gUi5vbmNlKHggPT4geCArIDEpO1xuICAgICAqICAgICAgYWRkT25lT25jZSgxMCk7IC8vPT4gMTFcbiAgICAgKiAgICAgIGFkZE9uZU9uY2UoYWRkT25lT25jZSg1MCkpOyAvLz0+IDExXG4gICAgICovXG4gICAgdmFyIG9uY2UgPSBfY3VycnkxKGZ1bmN0aW9uIG9uY2UoZm4pIHtcbiAgICAgICAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICByZXR1cm4gX2FyaXR5KGZuLmxlbmd0aCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGNhbGxlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmVzdWx0ID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgb25lIG9yIGJvdGggb2YgaXRzIGFyZ3VtZW50cyBhcmUgYHRydWVgLiBSZXR1cm5zIGBmYWxzZWBcbiAgICAgKiBpZiBib3RoIGFyZ3VtZW50cyBhcmUgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IExvZ2ljXG4gICAgICogQHNpZyAqIC0+ICogLT4gKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gYSBBIGJvb2xlYW4gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGIgQSBib29sZWFuIHZhbHVlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIG9uZSBvciBib3RoIGFyZ3VtZW50cyBhcmUgYHRydWVgLCBgZmFsc2VgIG90aGVyd2lzZVxuICAgICAqIEBzZWUgUi5laXRoZXJcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLm9yKHRydWUsIHRydWUpOyAvLz0+IHRydWVcbiAgICAgKiAgICAgIFIub3IodHJ1ZSwgZmFsc2UpOyAvLz0+IHRydWVcbiAgICAgKiAgICAgIFIub3IoZmFsc2UsIHRydWUpOyAvLz0+IHRydWVcbiAgICAgKiAgICAgIFIub3IoZmFsc2UsIGZhbHNlKTsgLy89PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBvciA9IF9jdXJyeTIoZnVuY3Rpb24gb3IoYSwgYikge1xuICAgICAgICByZXR1cm4gYSB8fCBiO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIFwic2V0dGluZ1wiIHRoZSBwb3J0aW9uIG9mIHRoZSBnaXZlbiBkYXRhIHN0cnVjdHVyZVxuICAgICAqIGZvY3VzZWQgYnkgdGhlIGdpdmVuIGxlbnMgdG8gdGhlIHJlc3VsdCBvZiBhcHBseWluZyB0aGUgZ2l2ZW4gZnVuY3Rpb24gdG9cbiAgICAgKiB0aGUgZm9jdXNlZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTYuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAdHlwZWRlZm4gTGVucyBzIGEgPSBGdW5jdG9yIGYgPT4gKGEgLT4gZiBhKSAtPiBzIC0+IGYgc1xuICAgICAqIEBzaWcgTGVucyBzIGEgLT4gKGEgLT4gYSkgLT4gcyAtPiBzXG4gICAgICogQHBhcmFtIHtMZW5zfSBsZW5zXG4gICAgICogQHBhcmFtIHsqfSB2XG4gICAgICogQHBhcmFtIHsqfSB4XG4gICAgICogQHJldHVybiB7Kn1cbiAgICAgKiBAc2VlIFIucHJvcCwgUi5sZW5zSW5kZXgsIFIubGVuc1Byb3BcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgaGVhZExlbnMgPSBSLmxlbnNJbmRleCgwKTtcbiAgICAgKlxuICAgICAqICAgICAgUi5vdmVyKGhlYWRMZW5zLCBSLnRvVXBwZXIsIFsnZm9vJywgJ2JhcicsICdiYXonXSk7IC8vPT4gWydGT08nLCAnYmFyJywgJ2JheiddXG4gICAgICovXG4gICAgLy8gYElkZW50aXR5YCBpcyBhIGZ1bmN0b3IgdGhhdCBob2xkcyBhIHNpbmdsZSB2YWx1ZSwgd2hlcmUgYG1hcGAgc2ltcGx5XG4gICAgLy8gdHJhbnNmb3JtcyB0aGUgaGVsZCB2YWx1ZSB3aXRoIHRoZSBwcm92aWRlZCBmdW5jdGlvbi5cbiAgICAvLyBUaGUgdmFsdWUgcmV0dXJuZWQgYnkgdGhlIGdldHRlciBmdW5jdGlvbiBpcyBmaXJzdCB0cmFuc2Zvcm1lZCB3aXRoIGBmYCxcbiAgICAvLyB0aGVuIHNldCBhcyB0aGUgdmFsdWUgb2YgYW4gYElkZW50aXR5YC4gVGhpcyBpcyB0aGVuIG1hcHBlZCBvdmVyIHdpdGggdGhlXG4gICAgLy8gc2V0dGVyIGZ1bmN0aW9uIG9mIHRoZSBsZW5zLlxuICAgIHZhciBvdmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBgSWRlbnRpdHlgIGlzIGEgZnVuY3RvciB0aGF0IGhvbGRzIGEgc2luZ2xlIHZhbHVlLCB3aGVyZSBgbWFwYCBzaW1wbHlcbiAgICAgICAgLy8gdHJhbnNmb3JtcyB0aGUgaGVsZCB2YWx1ZSB3aXRoIHRoZSBwcm92aWRlZCBmdW5jdGlvbi5cbiAgICAgICAgdmFyIElkZW50aXR5ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHgsXG4gICAgICAgICAgICAgICAgbWFwOiBmdW5jdGlvbiAoZikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSWRlbnRpdHkoZih4KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF9jdXJyeTMoZnVuY3Rpb24gb3ZlcihsZW5zLCBmLCB4KSB7XG4gICAgICAgICAgICAvLyBUaGUgdmFsdWUgcmV0dXJuZWQgYnkgdGhlIGdldHRlciBmdW5jdGlvbiBpcyBmaXJzdCB0cmFuc2Zvcm1lZCB3aXRoIGBmYCxcbiAgICAgICAgICAgIC8vIHRoZW4gc2V0IGFzIHRoZSB2YWx1ZSBvZiBhbiBgSWRlbnRpdHlgLiBUaGlzIGlzIHRoZW4gbWFwcGVkIG92ZXIgd2l0aCB0aGVcbiAgICAgICAgICAgIC8vIHNldHRlciBmdW5jdGlvbiBvZiB0aGUgbGVucy5cbiAgICAgICAgICAgIHJldHVybiBsZW5zKGZ1bmN0aW9uICh5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIElkZW50aXR5KGYoeSkpO1xuICAgICAgICAgICAgfSkoeCkudmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH0oKTtcblxuICAgIC8qKlxuICAgICAqIFRha2VzIHR3byBhcmd1bWVudHMsIGBmc3RgIGFuZCBgc25kYCwgYW5kIHJldHVybnMgYFtmc3QsIHNuZF1gLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xOC4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIGEgLT4gYiAtPiAoYSxiKVxuICAgICAqIEBwYXJhbSB7Kn0gZnN0XG4gICAgICogQHBhcmFtIHsqfSBzbmRcbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKiBAc2VlIFIub2JqT2YsIFIub2ZcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLnBhaXIoJ2ZvbycsICdiYXInKTsgLy89PiBbJ2ZvbycsICdiYXInXVxuICAgICAqL1xuICAgIHZhciBwYWlyID0gX2N1cnJ5MihmdW5jdGlvbiBwYWlyKGZzdCwgc25kKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBmc3QsXG4gICAgICAgICAgICBzbmRcbiAgICAgICAgXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSB2YWx1ZSBhdCBhIGdpdmVuIHBhdGguXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjIuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAc2lnIFtTdHJpbmddIC0+IHtrOiB2fSAtPiB2IHwgVW5kZWZpbmVkXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCBUaGUgcGF0aCB0byB1c2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHJldHJpZXZlIHRoZSBuZXN0ZWQgcHJvcGVydHkgZnJvbS5cbiAgICAgKiBAcmV0dXJuIHsqfSBUaGUgZGF0YSBhdCBgcGF0aGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5wYXRoKFsnYScsICdiJ10sIHthOiB7YjogMn19KTsgLy89PiAyXG4gICAgICogICAgICBSLnBhdGgoWydhJywgJ2InXSwge2M6IHtiOiAyfX0pOyAvLz0+IHVuZGVmaW5lZFxuICAgICAqL1xuICAgIHZhciBwYXRoID0gX2N1cnJ5MihmdW5jdGlvbiBwYXRoKHBhdGhzLCBvYmopIHtcbiAgICAgICAgdmFyIHZhbCA9IG9iajtcbiAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgIHdoaWxlIChpZHggPCBwYXRocy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbCA9IHZhbFtwYXRoc1tpZHhdXTtcbiAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgZ2l2ZW4sIG5vbi1udWxsIG9iamVjdCBoYXMgYSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gcGF0aCwgcmV0dXJucyB0aGVcbiAgICAgKiB2YWx1ZSBhdCB0aGF0IHBhdGguIE90aGVyd2lzZSByZXR1cm5zIHRoZSBwcm92aWRlZCBkZWZhdWx0IHZhbHVlLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xOC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBzaWcgYSAtPiBbU3RyaW5nXSAtPiBPYmplY3QgLT4gYVxuICAgICAqIEBwYXJhbSB7Kn0gZCBUaGUgZGVmYXVsdCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwIFRoZSBwYXRoIHRvIHVzZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcmV0cmlldmUgdGhlIG5lc3RlZCBwcm9wZXJ0eSBmcm9tLlxuICAgICAqIEByZXR1cm4geyp9IFRoZSBkYXRhIGF0IGBwYXRoYCBvZiB0aGUgc3VwcGxpZWQgb2JqZWN0IG9yIHRoZSBkZWZhdWx0IHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIucGF0aE9yKCdOL0EnLCBbJ2EnLCAnYiddLCB7YToge2I6IDJ9fSk7IC8vPT4gMlxuICAgICAqICAgICAgUi5wYXRoT3IoJ04vQScsIFsnYScsICdiJ10sIHtjOiB7YjogMn19KTsgLy89PiBcIk4vQVwiXG4gICAgICovXG4gICAgdmFyIHBhdGhPciA9IF9jdXJyeTMoZnVuY3Rpb24gcGF0aE9yKGQsIHAsIG9iaikge1xuICAgICAgICByZXR1cm4gZGVmYXVsdFRvKGQsIHBhdGgocCwgb2JqKSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgc3BlY2lmaWVkIG9iamVjdCBwcm9wZXJ0eSBhdCBnaXZlbiBwYXRoIHNhdGlzZmllcyB0aGVcbiAgICAgKiBnaXZlbiBwcmVkaWNhdGU7IGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xOS4wXG4gICAgICogQGNhdGVnb3J5IExvZ2ljXG4gICAgICogQHNpZyAoYSAtPiBCb29sZWFuKSAtPiBbU3RyaW5nXSAtPiBPYmplY3QgLT4gQm9vbGVhblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wUGF0aFxuICAgICAqIEBwYXJhbSB7Kn0gb2JqXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKiBAc2VlIFIucHJvcFNhdGlzZmllcywgUi5wYXRoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5wYXRoU2F0aXNmaWVzKHkgPT4geSA+IDAsIFsneCcsICd5J10sIHt4OiB7eTogMn19KTsgLy89PiB0cnVlXG4gICAgICovXG4gICAgdmFyIHBhdGhTYXRpc2ZpZXMgPSBfY3VycnkzKGZ1bmN0aW9uIHBhdGhTYXRpc2ZpZXMocHJlZCwgcHJvcFBhdGgsIG9iaikge1xuICAgICAgICByZXR1cm4gcHJvcFBhdGgubGVuZ3RoID4gMCAmJiBwcmVkKHBhdGgocHJvcFBhdGgsIG9iaikpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHBhcnRpYWwgY29weSBvZiBhbiBvYmplY3QgY29udGFpbmluZyBvbmx5IHRoZSBrZXlzIHNwZWNpZmllZC4gSWZcbiAgICAgKiB0aGUga2V5IGRvZXMgbm90IGV4aXN0LCB0aGUgcHJvcGVydHkgaXMgaWdub3JlZC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBzaWcgW2tdIC0+IHtrOiB2fSAtPiB7azogdn1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBuYW1lcyBhbiBhcnJheSBvZiBTdHJpbmcgcHJvcGVydHkgbmFtZXMgdG8gY29weSBvbnRvIGEgbmV3IG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBjb3B5IGZyb21cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEEgbmV3IG9iamVjdCB3aXRoIG9ubHkgcHJvcGVydGllcyBmcm9tIGBuYW1lc2Agb24gaXQuXG4gICAgICogQHNlZSBSLm9taXQsIFIucHJvcHNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLnBpY2soWydhJywgJ2QnXSwge2E6IDEsIGI6IDIsIGM6IDMsIGQ6IDR9KTsgLy89PiB7YTogMSwgZDogNH1cbiAgICAgKiAgICAgIFIucGljayhbJ2EnLCAnZScsICdmJ10sIHthOiAxLCBiOiAyLCBjOiAzLCBkOiA0fSk7IC8vPT4ge2E6IDF9XG4gICAgICovXG4gICAgdmFyIHBpY2sgPSBfY3VycnkyKGZ1bmN0aW9uIHBpY2sobmFtZXMsIG9iaikge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIHZhciBpZHggPSAwO1xuICAgICAgICB3aGlsZSAoaWR4IDwgbmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAobmFtZXNbaWR4XSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbbmFtZXNbaWR4XV0gPSBvYmpbbmFtZXNbaWR4XV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogU2ltaWxhciB0byBgcGlja2AgZXhjZXB0IHRoYXQgdGhpcyBvbmUgaW5jbHVkZXMgYSBga2V5OiB1bmRlZmluZWRgIHBhaXIgZm9yXG4gICAgICogcHJvcGVydGllcyB0aGF0IGRvbid0IGV4aXN0LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHNpZyBba10gLT4ge2s6IHZ9IC0+IHtrOiB2fVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG5hbWVzIGFuIGFycmF5IG9mIFN0cmluZyBwcm9wZXJ0eSBuYW1lcyB0byBjb3B5IG9udG8gYSBuZXcgb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGNvcHkgZnJvbVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQSBuZXcgb2JqZWN0IHdpdGggb25seSBwcm9wZXJ0aWVzIGZyb20gYG5hbWVzYCBvbiBpdC5cbiAgICAgKiBAc2VlIFIucGlja1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIucGlja0FsbChbJ2EnLCAnZCddLCB7YTogMSwgYjogMiwgYzogMywgZDogNH0pOyAvLz0+IHthOiAxLCBkOiA0fVxuICAgICAqICAgICAgUi5waWNrQWxsKFsnYScsICdlJywgJ2YnXSwge2E6IDEsIGI6IDIsIGM6IDMsIGQ6IDR9KTsgLy89PiB7YTogMSwgZTogdW5kZWZpbmVkLCBmOiB1bmRlZmluZWR9XG4gICAgICovXG4gICAgdmFyIHBpY2tBbGwgPSBfY3VycnkyKGZ1bmN0aW9uIHBpY2tBbGwobmFtZXMsIG9iaikge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIHZhciBpZHggPSAwO1xuICAgICAgICB2YXIgbGVuID0gbmFtZXMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IG5hbWVzW2lkeF07XG4gICAgICAgICAgICByZXN1bHRbbmFtZV0gPSBvYmpbbmFtZV07XG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHBhcnRpYWwgY29weSBvZiBhbiBvYmplY3QgY29udGFpbmluZyBvbmx5IHRoZSBrZXlzIHRoYXQgc2F0aXNmeVxuICAgICAqIHRoZSBzdXBwbGllZCBwcmVkaWNhdGUuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjguMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAc2lnICh2LCBrIC0+IEJvb2xlYW4pIC0+IHtrOiB2fSAtPiB7azogdn1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkIEEgcHJlZGljYXRlIHRvIGRldGVybWluZSB3aGV0aGVyIG9yIG5vdCBhIGtleVxuICAgICAqICAgICAgICBzaG91bGQgYmUgaW5jbHVkZWQgb24gdGhlIG91dHB1dCBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGNvcHkgZnJvbVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQSBuZXcgb2JqZWN0IHdpdGggb25seSBwcm9wZXJ0aWVzIHRoYXQgc2F0aXNmeSBgcHJlZGBcbiAgICAgKiAgICAgICAgIG9uIGl0LlxuICAgICAqIEBzZWUgUi5waWNrLCBSLmZpbHRlclxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBpc1VwcGVyQ2FzZSA9ICh2YWwsIGtleSkgPT4ga2V5LnRvVXBwZXJDYXNlKCkgPT09IGtleTtcbiAgICAgKiAgICAgIFIucGlja0J5KGlzVXBwZXJDYXNlLCB7YTogMSwgYjogMiwgQTogMywgQjogNH0pOyAvLz0+IHtBOiAzLCBCOiA0fVxuICAgICAqL1xuICAgIHZhciBwaWNrQnkgPSBfY3VycnkyKGZ1bmN0aW9uIHBpY2tCeSh0ZXN0LCBvYmopIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKHRlc3Qob2JqW3Byb3BdLCBwcm9wLCBvYmopKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W3Byb3BdID0gb2JqW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IGxpc3Qgd2l0aCB0aGUgZ2l2ZW4gZWxlbWVudCBhdCB0aGUgZnJvbnQsIGZvbGxvd2VkIGJ5IHRoZVxuICAgICAqIGNvbnRlbnRzIG9mIHRoZSBsaXN0LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgYSAtPiBbYV0gLT4gW2FdXG4gICAgICogQHBhcmFtIHsqfSBlbCBUaGUgaXRlbSB0byBhZGQgdG8gdGhlIGhlYWQgb2YgdGhlIG91dHB1dCBsaXN0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGFkZCB0byB0aGUgdGFpbCBvZiB0aGUgb3V0cHV0IGxpc3QuXG4gICAgICogQHJldHVybiB7QXJyYXl9IEEgbmV3IGFycmF5LlxuICAgICAqIEBzZWUgUi5hcHBlbmRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLnByZXBlbmQoJ2ZlZScsIFsnZmknLCAnZm8nLCAnZnVtJ10pOyAvLz0+IFsnZmVlJywgJ2ZpJywgJ2ZvJywgJ2Z1bSddXG4gICAgICovXG4gICAgdmFyIHByZXBlbmQgPSBfY3VycnkyKGZ1bmN0aW9uIHByZXBlbmQoZWwsIGxpc3QpIHtcbiAgICAgICAgcmV0dXJuIF9jb25jYXQoW2VsXSwgbGlzdCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aGVuIHN1cHBsaWVkIGFuIG9iamVjdCByZXR1cm5zIHRoZSBpbmRpY2F0ZWRcbiAgICAgKiBwcm9wZXJ0eSBvZiB0aGF0IG9iamVjdCwgaWYgaXQgZXhpc3RzLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHNpZyBzIC0+IHtzOiBhfSAtPiBhIHwgVW5kZWZpbmVkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHAgVGhlIHByb3BlcnR5IG5hbWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcXVlcnlcbiAgICAgKiBAcmV0dXJuIHsqfSBUaGUgdmFsdWUgYXQgYG9iai5wYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLnByb3AoJ3gnLCB7eDogMTAwfSk7IC8vPT4gMTAwXG4gICAgICogICAgICBSLnByb3AoJ3gnLCB7fSk7IC8vPT4gdW5kZWZpbmVkXG4gICAgICovXG4gICAgdmFyIHByb3AgPSBfY3VycnkyKGZ1bmN0aW9uIHByb3AocCwgb2JqKSB7XG4gICAgICAgIHJldHVybiBvYmpbcF07XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgZ2l2ZW4sIG5vbi1udWxsIG9iamVjdCBoYXMgYW4gb3duIHByb3BlcnR5IHdpdGggdGhlIHNwZWNpZmllZCBuYW1lLFxuICAgICAqIHJldHVybnMgdGhlIHZhbHVlIG9mIHRoYXQgcHJvcGVydHkuIE90aGVyd2lzZSByZXR1cm5zIHRoZSBwcm92aWRlZCBkZWZhdWx0XG4gICAgICogdmFsdWUuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjYuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAc2lnIGEgLT4gU3RyaW5nIC0+IE9iamVjdCAtPiBhXG4gICAgICogQHBhcmFtIHsqfSB2YWwgVGhlIGRlZmF1bHQgdmFsdWUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHAgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIHJldHVybi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybiB7Kn0gVGhlIHZhbHVlIG9mIGdpdmVuIHByb3BlcnR5IG9mIHRoZSBzdXBwbGllZCBvYmplY3Qgb3IgdGhlIGRlZmF1bHQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGFsaWNlID0ge1xuICAgICAqICAgICAgICBuYW1lOiAnQUxJQ0UnLFxuICAgICAqICAgICAgICBhZ2U6IDEwMVxuICAgICAqICAgICAgfTtcbiAgICAgKiAgICAgIHZhciBmYXZvcml0ZSA9IFIucHJvcCgnZmF2b3JpdGVMaWJyYXJ5Jyk7XG4gICAgICogICAgICB2YXIgZmF2b3JpdGVXaXRoRGVmYXVsdCA9IFIucHJvcE9yKCdSYW1kYScsICdmYXZvcml0ZUxpYnJhcnknKTtcbiAgICAgKlxuICAgICAqICAgICAgZmF2b3JpdGUoYWxpY2UpOyAgLy89PiB1bmRlZmluZWRcbiAgICAgKiAgICAgIGZhdm9yaXRlV2l0aERlZmF1bHQoYWxpY2UpOyAgLy89PiAnUmFtZGEnXG4gICAgICovXG4gICAgdmFyIHByb3BPciA9IF9jdXJyeTMoZnVuY3Rpb24gcHJvcE9yKHZhbCwgcCwgb2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiBfaGFzKHAsIG9iaikgPyBvYmpbcF0gOiB2YWw7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgc3BlY2lmaWVkIG9iamVjdCBwcm9wZXJ0eSBzYXRpc2ZpZXMgdGhlIGdpdmVuXG4gICAgICogcHJlZGljYXRlOyBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTYuMFxuICAgICAqIEBjYXRlZ29yeSBMb2dpY1xuICAgICAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gU3RyaW5nIC0+IHtTdHJpbmc6IGF9IC0+IEJvb2xlYW5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0geyp9IG9ialxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICogQHNlZSBSLnByb3BFcSwgUi5wcm9wSXNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLnByb3BTYXRpc2ZpZXMoeCA9PiB4ID4gMCwgJ3gnLCB7eDogMSwgeTogMn0pOyAvLz0+IHRydWVcbiAgICAgKi9cbiAgICB2YXIgcHJvcFNhdGlzZmllcyA9IF9jdXJyeTMoZnVuY3Rpb24gcHJvcFNhdGlzZmllcyhwcmVkLCBuYW1lLCBvYmopIHtcbiAgICAgICAgcmV0dXJuIHByZWQob2JqW25hbWVdKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEFjdHMgYXMgbXVsdGlwbGUgYHByb3BgOiBhcnJheSBvZiBrZXlzIGluLCBhcnJheSBvZiB2YWx1ZXMgb3V0LiBQcmVzZXJ2ZXNcbiAgICAgKiBvcmRlci5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBzaWcgW2tdIC0+IHtrOiB2fSAtPiBbdl1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZmV0Y2hcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcXVlcnlcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVzIG9yIHBhcnRpYWxseSBhcHBsaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIucHJvcHMoWyd4JywgJ3knXSwge3g6IDEsIHk6IDJ9KTsgLy89PiBbMSwgMl1cbiAgICAgKiAgICAgIFIucHJvcHMoWydjJywgJ2EnLCAnYiddLCB7YjogMiwgYTogMX0pOyAvLz0+IFt1bmRlZmluZWQsIDEsIDJdXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBmdWxsTmFtZSA9IFIuY29tcG9zZShSLmpvaW4oJyAnKSwgUi5wcm9wcyhbJ2ZpcnN0JywgJ2xhc3QnXSkpO1xuICAgICAqICAgICAgZnVsbE5hbWUoe2xhc3Q6ICdCdWxsZXQtVG9vdGgnLCBhZ2U6IDMzLCBmaXJzdDogJ1RvbnknfSk7IC8vPT4gJ1RvbnkgQnVsbGV0LVRvb3RoJ1xuICAgICAqL1xuICAgIHZhciBwcm9wcyA9IF9jdXJyeTIoZnVuY3Rpb24gcHJvcHMocHMsIG9iaikge1xuICAgICAgICB2YXIgbGVuID0gcHMubGVuZ3RoO1xuICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgIHZhciBpZHggPSAwO1xuICAgICAgICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgICAgICAgICBvdXRbaWR4XSA9IG9ialtwc1tpZHhdXTtcbiAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBudW1iZXJzIGZyb20gYGZyb21gIChpbmNsdXNpdmUpIHRvIGB0b2AgKGV4Y2x1c2l2ZSkuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyBOdW1iZXIgLT4gTnVtYmVyIC0+IFtOdW1iZXJdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGZyb20gVGhlIGZpcnN0IG51bWJlciBpbiB0aGUgbGlzdC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdG8gT25lIG1vcmUgdGhhbiB0aGUgbGFzdCBudW1iZXIgaW4gdGhlIGxpc3QuXG4gICAgICogQHJldHVybiB7QXJyYXl9IFRoZSBsaXN0IG9mIG51bWJlcnMgaW4gdHRoZSBzZXQgYFthLCBiKWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5yYW5nZSgxLCA1KTsgICAgLy89PiBbMSwgMiwgMywgNF1cbiAgICAgKiAgICAgIFIucmFuZ2UoNTAsIDUzKTsgIC8vPT4gWzUwLCA1MSwgNTJdXG4gICAgICovXG4gICAgdmFyIHJhbmdlID0gX2N1cnJ5MihmdW5jdGlvbiByYW5nZShmcm9tLCB0bykge1xuICAgICAgICBpZiAoIShfaXNOdW1iZXIoZnJvbSkgJiYgX2lzTnVtYmVyKHRvKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JvdGggYXJndW1lbnRzIHRvIHJhbmdlIG11c3QgYmUgbnVtYmVycycpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdmFyIG4gPSBmcm9tO1xuICAgICAgICB3aGlsZSAobiA8IHRvKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChuKTtcbiAgICAgICAgICAgIG4gKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHNpbmdsZSBpdGVtIGJ5IGl0ZXJhdGluZyB0aHJvdWdoIHRoZSBsaXN0LCBzdWNjZXNzaXZlbHkgY2FsbGluZ1xuICAgICAqIHRoZSBpdGVyYXRvciBmdW5jdGlvbiBhbmQgcGFzc2luZyBpdCBhbiBhY2N1bXVsYXRvciB2YWx1ZSBhbmQgdGhlIGN1cnJlbnRcbiAgICAgKiB2YWx1ZSBmcm9tIHRoZSBhcnJheSwgYW5kIHRoZW4gcGFzc2luZyB0aGUgcmVzdWx0IHRvIHRoZSBuZXh0IGNhbGwuXG4gICAgICpcbiAgICAgKiBTaW1pbGFyIHRvIGByZWR1Y2VgLCBleGNlcHQgbW92ZXMgdGhyb3VnaCB0aGUgaW5wdXQgbGlzdCBmcm9tIHRoZSByaWdodCB0b1xuICAgICAqIHRoZSBsZWZ0LlxuICAgICAqXG4gICAgICogVGhlIGl0ZXJhdG9yIGZ1bmN0aW9uIHJlY2VpdmVzIHR3byB2YWx1ZXM6ICooYWNjLCB2YWx1ZSkqXG4gICAgICpcbiAgICAgKiBOb3RlOiBgUi5yZWR1Y2VSaWdodGAgZG9lcyBub3Qgc2tpcCBkZWxldGVkIG9yIHVuYXNzaWduZWQgaW5kaWNlcyAoc3BhcnNlXG4gICAgICogYXJyYXlzKSwgdW5saWtlIHRoZSBuYXRpdmUgYEFycmF5LnByb3RvdHlwZS5yZWR1Y2VgIG1ldGhvZC4gRm9yIG1vcmUgZGV0YWlsc1xuICAgICAqIG9uIHRoaXMgYmVoYXZpb3IsIHNlZTpcbiAgICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9yZWR1Y2VSaWdodCNEZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgKGEsYiAtPiBhKSAtPiBhIC0+IFtiXSAtPiBhXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGl0ZXJhdG9yIGZ1bmN0aW9uLiBSZWNlaXZlcyB0d28gdmFsdWVzLCB0aGUgYWNjdW11bGF0b3IgYW5kIHRoZVxuICAgICAqICAgICAgICBjdXJyZW50IGVsZW1lbnQgZnJvbSB0aGUgYXJyYXkuXG4gICAgICogQHBhcmFtIHsqfSBhY2MgVGhlIGFjY3VtdWxhdG9yIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEByZXR1cm4geyp9IFRoZSBmaW5hbCwgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQHNlZSBSLmFkZEluZGV4XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIHBhaXJzID0gWyBbJ2EnLCAxXSwgWydiJywgMl0sIFsnYycsIDNdIF07XG4gICAgICogICAgICB2YXIgZmxhdHRlblBhaXJzID0gKGFjYywgcGFpcikgPT4gYWNjLmNvbmNhdChwYWlyKTtcbiAgICAgKlxuICAgICAqICAgICAgUi5yZWR1Y2VSaWdodChmbGF0dGVuUGFpcnMsIFtdLCBwYWlycyk7IC8vPT4gWyAnYycsIDMsICdiJywgMiwgJ2EnLCAxIF1cbiAgICAgKi9cbiAgICB2YXIgcmVkdWNlUmlnaHQgPSBfY3VycnkzKGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGZuLCBhY2MsIGxpc3QpIHtcbiAgICAgICAgdmFyIGlkeCA9IGxpc3QubGVuZ3RoIC0gMTtcbiAgICAgICAgd2hpbGUgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICBhY2MgPSBmbihhY2MsIGxpc3RbaWR4XSk7XG4gICAgICAgICAgICBpZHggLT0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHZhbHVlIHdyYXBwZWQgdG8gaW5kaWNhdGUgdGhhdCBpdCBpcyB0aGUgZmluYWwgdmFsdWUgb2YgdGhlIHJlZHVjZVxuICAgICAqIGFuZCB0cmFuc2R1Y2UgZnVuY3Rpb25zLiBUaGUgcmV0dXJuZWQgdmFsdWUgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYSBibGFja1xuICAgICAqIGJveDogdGhlIGludGVybmFsIHN0cnVjdHVyZSBpcyBub3QgZ3VhcmFudGVlZCB0byBiZSBzdGFibGUuXG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGlzIG9wdGltaXphdGlvbiBpcyB1bmF2YWlsYWJsZSB0byBmdW5jdGlvbnMgbm90IGV4cGxpY2l0bHkgbGlzdGVkXG4gICAgICogYWJvdmUuIEZvciBpbnN0YW5jZSwgaXQgaXMgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQgYnkgcmVkdWNlUmlnaHQuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjE1LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgYSAtPiAqXG4gICAgICogQHBhcmFtIHsqfSB4IFRoZSBmaW5hbCB2YWx1ZSBvZiB0aGUgcmVkdWNlLlxuICAgICAqIEByZXR1cm4geyp9IFRoZSB3cmFwcGVkIHZhbHVlLlxuICAgICAqIEBzZWUgUi5yZWR1Y2UsIFIudHJhbnNkdWNlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5yZWR1Y2UoXG4gICAgICogICAgICAgIFIucGlwZShSLmFkZCwgUi53aGVuKFIuZ3RlKFIuX18sIDEwKSwgUi5yZWR1Y2VkKSksXG4gICAgICogICAgICAgIDAsXG4gICAgICogICAgICAgIFsxLCAyLCAzLCA0LCA1XSkgLy8gMTBcbiAgICAgKi9cbiAgICB2YXIgcmVkdWNlZCA9IF9jdXJyeTEoX3JlZHVjZWQpO1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgc3ViLWxpc3Qgb2YgYGxpc3RgIHN0YXJ0aW5nIGF0IGluZGV4IGBzdGFydGAgYW5kIGNvbnRhaW5pbmdcbiAgICAgKiBgY291bnRgIGVsZW1lbnRzLiBfTm90ZSB0aGF0IHRoaXMgaXMgbm90IGRlc3RydWN0aXZlXzogaXQgcmV0dXJucyBhIGNvcHkgb2ZcbiAgICAgKiB0aGUgbGlzdCB3aXRoIHRoZSBjaGFuZ2VzLlxuICAgICAqIDxzbWFsbD5ObyBsaXN0cyBoYXZlIGJlZW4gaGFybWVkIGluIHRoZSBhcHBsaWNhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uLjwvc21hbGw+XG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjIuMlxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyBOdW1iZXIgLT4gTnVtYmVyIC0+IFthXSAtPiBbYV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgVGhlIHBvc2l0aW9uIHRvIHN0YXJ0IHJlbW92aW5nIGVsZW1lbnRzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gcmVtb3ZlXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byByZW1vdmUgZnJvbVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBBIG5ldyBBcnJheSB3aXRoIGBjb3VudGAgZWxlbWVudHMgZnJvbSBgc3RhcnRgIHJlbW92ZWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5yZW1vdmUoMiwgMywgWzEsMiwzLDQsNSw2LDcsOF0pOyAvLz0+IFsxLDIsNiw3LDhdXG4gICAgICovXG4gICAgdmFyIHJlbW92ZSA9IF9jdXJyeTMoZnVuY3Rpb24gcmVtb3ZlKHN0YXJ0LCBjb3VudCwgbGlzdCkge1xuICAgICAgICByZXR1cm4gX2NvbmNhdChfc2xpY2UobGlzdCwgMCwgTWF0aC5taW4oc3RhcnQsIGxpc3QubGVuZ3RoKSksIF9zbGljZShsaXN0LCBNYXRoLm1pbihsaXN0Lmxlbmd0aCwgc3RhcnQgKyBjb3VudCkpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2UgYSBzdWJzdHJpbmcgb3IgcmVnZXggbWF0Y2ggaW4gYSBzdHJpbmcgd2l0aCBhIHJlcGxhY2VtZW50LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHNpZyBSZWdFeHB8U3RyaW5nIC0+IFN0cmluZyAtPiBTdHJpbmcgLT4gU3RyaW5nXG4gICAgICogQHBhcmFtIHtSZWdFeHB8U3RyaW5nfSBwYXR0ZXJuIEEgcmVndWxhciBleHByZXNzaW9uIG9yIGEgc3Vic3RyaW5nIHRvIG1hdGNoLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSByZXBsYWNlbWVudCBUaGUgc3RyaW5nIHRvIHJlcGxhY2UgdGhlIG1hdGNoZXMgd2l0aC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBTdHJpbmcgdG8gZG8gdGhlIHNlYXJjaCBhbmQgcmVwbGFjZW1lbnQgaW4uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgcmVzdWx0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIucmVwbGFjZSgnZm9vJywgJ2JhcicsICdmb28gZm9vIGZvbycpOyAvLz0+ICdiYXIgZm9vIGZvbydcbiAgICAgKiAgICAgIFIucmVwbGFjZSgvZm9vLywgJ2JhcicsICdmb28gZm9vIGZvbycpOyAvLz0+ICdiYXIgZm9vIGZvbydcbiAgICAgKlxuICAgICAqICAgICAgLy8gVXNlIHRoZSBcImdcIiAoZ2xvYmFsKSBmbGFnIHRvIHJlcGxhY2UgYWxsIG9jY3VycmVuY2VzOlxuICAgICAqICAgICAgUi5yZXBsYWNlKC9mb28vZywgJ2JhcicsICdmb28gZm9vIGZvbycpOyAvLz0+ICdiYXIgYmFyIGJhcidcbiAgICAgKi9cbiAgICB2YXIgcmVwbGFjZSA9IF9jdXJyeTMoZnVuY3Rpb24gcmVwbGFjZShyZWdleCwgcmVwbGFjZW1lbnQsIHN0cikge1xuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UocmVnZXgsIHJlcGxhY2VtZW50KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgbGlzdCBvciBzdHJpbmcgd2l0aCB0aGUgZWxlbWVudHMgb3IgY2hhcmFjdGVycyBpbiByZXZlcnNlXG4gICAgICogb3JkZXIuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyBbYV0gLT4gW2FdXG4gICAgICogQHNpZyBTdHJpbmcgLT4gU3RyaW5nXG4gICAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IGxpc3RcbiAgICAgKiBAcmV0dXJuIHtBcnJheXxTdHJpbmd9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5yZXZlcnNlKFsxLCAyLCAzXSk7ICAvLz0+IFszLCAyLCAxXVxuICAgICAqICAgICAgUi5yZXZlcnNlKFsxLCAyXSk7ICAgICAvLz0+IFsyLCAxXVxuICAgICAqICAgICAgUi5yZXZlcnNlKFsxXSk7ICAgICAgICAvLz0+IFsxXVxuICAgICAqICAgICAgUi5yZXZlcnNlKFtdKTsgICAgICAgICAvLz0+IFtdXG4gICAgICpcbiAgICAgKiAgICAgIFIucmV2ZXJzZSgnYWJjJyk7ICAgICAgLy89PiAnY2JhJ1xuICAgICAqICAgICAgUi5yZXZlcnNlKCdhYicpOyAgICAgICAvLz0+ICdiYSdcbiAgICAgKiAgICAgIFIucmV2ZXJzZSgnYScpOyAgICAgICAgLy89PiAnYSdcbiAgICAgKiAgICAgIFIucmV2ZXJzZSgnJyk7ICAgICAgICAgLy89PiAnJ1xuICAgICAqL1xuICAgIHZhciByZXZlcnNlID0gX2N1cnJ5MShmdW5jdGlvbiByZXZlcnNlKGxpc3QpIHtcbiAgICAgICAgcmV0dXJuIF9pc1N0cmluZyhsaXN0KSA/IGxpc3Quc3BsaXQoJycpLnJldmVyc2UoKS5qb2luKCcnKSA6IF9zbGljZShsaXN0KS5yZXZlcnNlKCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBTY2FuIGlzIHNpbWlsYXIgdG8gcmVkdWNlLCBidXQgcmV0dXJucyBhIGxpc3Qgb2Ygc3VjY2Vzc2l2ZWx5IHJlZHVjZWQgdmFsdWVzXG4gICAgICogZnJvbSB0aGUgbGVmdFxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xMC4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIChhLGIgLT4gYSkgLT4gYSAtPiBbYl0gLT4gW2FdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGl0ZXJhdG9yIGZ1bmN0aW9uLiBSZWNlaXZlcyB0d28gdmFsdWVzLCB0aGUgYWNjdW11bGF0b3IgYW5kIHRoZVxuICAgICAqICAgICAgICBjdXJyZW50IGVsZW1lbnQgZnJvbSB0aGUgYXJyYXlcbiAgICAgKiBAcGFyYW0geyp9IGFjYyBUaGUgYWNjdW11bGF0b3IgdmFsdWUuXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybiB7QXJyYXl9IEEgbGlzdCBvZiBhbGwgaW50ZXJtZWRpYXRlbHkgcmVkdWNlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIG51bWJlcnMgPSBbMSwgMiwgMywgNF07XG4gICAgICogICAgICB2YXIgZmFjdG9yaWFscyA9IFIuc2NhbihSLm11bHRpcGx5LCAxLCBudW1iZXJzKTsgLy89PiBbMSwgMSwgMiwgNiwgMjRdXG4gICAgICovXG4gICAgdmFyIHNjYW4gPSBfY3VycnkzKGZ1bmN0aW9uIHNjYW4oZm4sIGFjYywgbGlzdCkge1xuICAgICAgICB2YXIgaWR4ID0gMDtcbiAgICAgICAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW2FjY107XG4gICAgICAgIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICAgICAgICAgIGFjYyA9IGZuKGFjYywgbGlzdFtpZHhdKTtcbiAgICAgICAgICAgIHJlc3VsdFtpZHggKyAxXSA9IGFjYztcbiAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSByZXN1bHQgb2YgXCJzZXR0aW5nXCIgdGhlIHBvcnRpb24gb2YgdGhlIGdpdmVuIGRhdGEgc3RydWN0dXJlXG4gICAgICogZm9jdXNlZCBieSB0aGUgZ2l2ZW4gbGVucyB0byB0aGUgZ2l2ZW4gdmFsdWUuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjE2LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHR5cGVkZWZuIExlbnMgcyBhID0gRnVuY3RvciBmID0+IChhIC0+IGYgYSkgLT4gcyAtPiBmIHNcbiAgICAgKiBAc2lnIExlbnMgcyBhIC0+IGEgLT4gcyAtPiBzXG4gICAgICogQHBhcmFtIHtMZW5zfSBsZW5zXG4gICAgICogQHBhcmFtIHsqfSB2XG4gICAgICogQHBhcmFtIHsqfSB4XG4gICAgICogQHJldHVybiB7Kn1cbiAgICAgKiBAc2VlIFIucHJvcCwgUi5sZW5zSW5kZXgsIFIubGVuc1Byb3BcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgeExlbnMgPSBSLmxlbnNQcm9wKCd4Jyk7XG4gICAgICpcbiAgICAgKiAgICAgIFIuc2V0KHhMZW5zLCA0LCB7eDogMSwgeTogMn0pOyAgLy89PiB7eDogNCwgeTogMn1cbiAgICAgKiAgICAgIFIuc2V0KHhMZW5zLCA4LCB7eDogMSwgeTogMn0pOyAgLy89PiB7eDogOCwgeTogMn1cbiAgICAgKi9cbiAgICB2YXIgc2V0ID0gX2N1cnJ5MyhmdW5jdGlvbiBzZXQobGVucywgdiwgeCkge1xuICAgICAgICByZXR1cm4gb3ZlcihsZW5zLCBhbHdheXModiksIHgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZWxlbWVudHMgb2YgdGhlIGdpdmVuIGxpc3Qgb3Igc3RyaW5nIChvciBvYmplY3Qgd2l0aCBhIGBzbGljZWBcbiAgICAgKiBtZXRob2QpIGZyb20gYGZyb21JbmRleGAgKGluY2x1c2l2ZSkgdG8gYHRvSW5kZXhgIChleGNsdXNpdmUpLlxuICAgICAqXG4gICAgICogRGlzcGF0Y2hlcyB0byB0aGUgYHNsaWNlYCBtZXRob2Qgb2YgdGhlIHRoaXJkIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjRcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgTnVtYmVyIC0+IE51bWJlciAtPiBbYV0gLT4gW2FdXG4gICAgICogQHNpZyBOdW1iZXIgLT4gTnVtYmVyIC0+IFN0cmluZyAtPiBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZnJvbUluZGV4IFRoZSBzdGFydCBpbmRleCAoaW5jbHVzaXZlKS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdG9JbmRleCBUaGUgZW5kIGluZGV4IChleGNsdXNpdmUpLlxuICAgICAqIEBwYXJhbSB7Kn0gbGlzdFxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5zbGljZSgxLCAzLCBbJ2EnLCAnYicsICdjJywgJ2QnXSk7ICAgICAgICAvLz0+IFsnYicsICdjJ11cbiAgICAgKiAgICAgIFIuc2xpY2UoMSwgSW5maW5pdHksIFsnYScsICdiJywgJ2MnLCAnZCddKTsgLy89PiBbJ2InLCAnYycsICdkJ11cbiAgICAgKiAgICAgIFIuc2xpY2UoMCwgLTEsIFsnYScsICdiJywgJ2MnLCAnZCddKTsgICAgICAgLy89PiBbJ2EnLCAnYicsICdjJ11cbiAgICAgKiAgICAgIFIuc2xpY2UoLTMsIC0xLCBbJ2EnLCAnYicsICdjJywgJ2QnXSk7ICAgICAgLy89PiBbJ2InLCAnYyddXG4gICAgICogICAgICBSLnNsaWNlKDAsIDMsICdyYW1kYScpOyAgICAgICAgICAgICAgICAgICAgIC8vPT4gJ3JhbSdcbiAgICAgKi9cbiAgICB2YXIgc2xpY2UgPSBfY3VycnkzKF9jaGVja0Zvck1ldGhvZCgnc2xpY2UnLCBmdW5jdGlvbiBzbGljZShmcm9tSW5kZXgsIHRvSW5kZXgsIGxpc3QpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGxpc3QsIGZyb21JbmRleCwgdG9JbmRleCk7XG4gICAgfSkpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIGxpc3QsIHNvcnRlZCBhY2NvcmRpbmcgdG8gdGhlIGNvbXBhcmF0b3IgZnVuY3Rpb24sXG4gICAgICogd2hpY2ggc2hvdWxkIGFjY2VwdCB0d28gdmFsdWVzIGF0IGEgdGltZSBhbmQgcmV0dXJuIGEgbmVnYXRpdmUgbnVtYmVyIGlmIHRoZVxuICAgICAqIGZpcnN0IHZhbHVlIGlzIHNtYWxsZXIsIGEgcG9zaXRpdmUgbnVtYmVyIGlmIGl0J3MgbGFyZ2VyLCBhbmQgemVybyBpZiB0aGV5XG4gICAgICogYXJlIGVxdWFsLiBQbGVhc2Ugbm90ZSB0aGF0IHRoaXMgaXMgYSAqKmNvcHkqKiBvZiB0aGUgbGlzdC4gSXQgZG9lcyBub3RcbiAgICAgKiBtb2RpZnkgdGhlIG9yaWdpbmFsLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgKGEsYSAtPiBOdW1iZXIpIC0+IFthXSAtPiBbYV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIEEgc29ydGluZyBmdW5jdGlvbiA6OiBhIC0+IGIgLT4gSW50XG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byBzb3J0XG4gICAgICogQHJldHVybiB7QXJyYXl9IGEgbmV3IGFycmF5IHdpdGggaXRzIGVsZW1lbnRzIHNvcnRlZCBieSB0aGUgY29tcGFyYXRvciBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgZGlmZiA9IGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGEgLSBiOyB9O1xuICAgICAqICAgICAgUi5zb3J0KGRpZmYsIFs0LDIsNyw1XSk7IC8vPT4gWzIsIDQsIDUsIDddXG4gICAgICovXG4gICAgdmFyIHNvcnQgPSBfY3VycnkyKGZ1bmN0aW9uIHNvcnQoY29tcGFyYXRvciwgbGlzdCkge1xuICAgICAgICByZXR1cm4gX3NsaWNlKGxpc3QpLnNvcnQoY29tcGFyYXRvcik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBTb3J0cyB0aGUgbGlzdCBhY2NvcmRpbmcgdG8gdGhlIHN1cHBsaWVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAgICAgKiBAc2lnIE9yZCBiID0+IChhIC0+IGIpIC0+IFthXSAtPiBbYV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3QgdG8gc29ydC5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gQSBuZXcgbGlzdCBzb3J0ZWQgYnkgdGhlIGtleXMgZ2VuZXJhdGVkIGJ5IGBmbmAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIHNvcnRCeUZpcnN0SXRlbSA9IFIuc29ydEJ5KFIucHJvcCgwKSk7XG4gICAgICogICAgICB2YXIgc29ydEJ5TmFtZUNhc2VJbnNlbnNpdGl2ZSA9IFIuc29ydEJ5KFIuY29tcG9zZShSLnRvTG93ZXIsIFIucHJvcCgnbmFtZScpKSk7XG4gICAgICogICAgICB2YXIgcGFpcnMgPSBbWy0xLCAxXSwgWy0yLCAyXSwgWy0zLCAzXV07XG4gICAgICogICAgICBzb3J0QnlGaXJzdEl0ZW0ocGFpcnMpOyAvLz0+IFtbLTMsIDNdLCBbLTIsIDJdLCBbLTEsIDFdXVxuICAgICAqICAgICAgdmFyIGFsaWNlID0ge1xuICAgICAqICAgICAgICBuYW1lOiAnQUxJQ0UnLFxuICAgICAqICAgICAgICBhZ2U6IDEwMVxuICAgICAqICAgICAgfTtcbiAgICAgKiAgICAgIHZhciBib2IgPSB7XG4gICAgICogICAgICAgIG5hbWU6ICdCb2InLFxuICAgICAqICAgICAgICBhZ2U6IC0xMFxuICAgICAqICAgICAgfTtcbiAgICAgKiAgICAgIHZhciBjbGFyYSA9IHtcbiAgICAgKiAgICAgICAgbmFtZTogJ2NsYXJhJyxcbiAgICAgKiAgICAgICAgYWdlOiAzMTQuMTU5XG4gICAgICogICAgICB9O1xuICAgICAqICAgICAgdmFyIHBlb3BsZSA9IFtjbGFyYSwgYm9iLCBhbGljZV07XG4gICAgICogICAgICBzb3J0QnlOYW1lQ2FzZUluc2Vuc2l0aXZlKHBlb3BsZSk7IC8vPT4gW2FsaWNlLCBib2IsIGNsYXJhXVxuICAgICAqL1xuICAgIHZhciBzb3J0QnkgPSBfY3VycnkyKGZ1bmN0aW9uIHNvcnRCeShmbiwgbGlzdCkge1xuICAgICAgICByZXR1cm4gX3NsaWNlKGxpc3QpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHZhciBhYSA9IGZuKGEpO1xuICAgICAgICAgICAgdmFyIGJiID0gZm4oYik7XG4gICAgICAgICAgICByZXR1cm4gYWEgPCBiYiA/IC0xIDogYWEgPiBiYiA/IDEgOiAwO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFNwbGl0cyBhIGdpdmVuIGxpc3Qgb3Igc3RyaW5nIGF0IGEgZ2l2ZW4gaW5kZXguXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjE5LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgTnVtYmVyIC0+IFthXSAtPiBbW2FdLCBbYV1dXG4gICAgICogQHNpZyBOdW1iZXIgLT4gU3RyaW5nIC0+IFtTdHJpbmcsIFN0cmluZ11cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggVGhlIGluZGV4IHdoZXJlIHRoZSBhcnJheS9zdHJpbmcgaXMgc3BsaXQuXG4gICAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IGFycmF5IFRoZSBhcnJheS9zdHJpbmcgdG8gYmUgc3BsaXQuXG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5zcGxpdEF0KDEsIFsxLCAyLCAzXSk7ICAgICAgICAgIC8vPT4gW1sxXSwgWzIsIDNdXVxuICAgICAqICAgICAgUi5zcGxpdEF0KDUsICdoZWxsbyB3b3JsZCcpOyAgICAgIC8vPT4gWydoZWxsbycsICcgd29ybGQnXVxuICAgICAqICAgICAgUi5zcGxpdEF0KC0xLCAnZm9vYmFyJyk7ICAgICAgICAgIC8vPT4gWydmb29iYScsICdyJ11cbiAgICAgKi9cbiAgICB2YXIgc3BsaXRBdCA9IF9jdXJyeTIoZnVuY3Rpb24gc3BsaXRBdChpbmRleCwgYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHNsaWNlKDAsIGluZGV4LCBhcnJheSksXG4gICAgICAgICAgICBzbGljZShpbmRleCwgbGVuZ3RoKGFycmF5KSwgYXJyYXkpXG4gICAgICAgIF07XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBTcGxpdHMgYSBjb2xsZWN0aW9uIGludG8gc2xpY2VzIG9mIHRoZSBzcGVjaWZpZWQgbGVuZ3RoLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xNi4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIE51bWJlciAtPiBbYV0gLT4gW1thXV1cbiAgICAgKiBAc2lnIE51bWJlciAtPiBTdHJpbmcgLT4gW1N0cmluZ11cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gblxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3RcbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLnNwbGl0RXZlcnkoMywgWzEsIDIsIDMsIDQsIDUsIDYsIDddKTsgLy89PiBbWzEsIDIsIDNdLCBbNCwgNSwgNl0sIFs3XV1cbiAgICAgKiAgICAgIFIuc3BsaXRFdmVyeSgzLCAnZm9vYmFyYmF6Jyk7IC8vPT4gWydmb28nLCAnYmFyJywgJ2JheiddXG4gICAgICovXG4gICAgdmFyIHNwbGl0RXZlcnkgPSBfY3VycnkyKGZ1bmN0aW9uIHNwbGl0RXZlcnkobiwgbGlzdCkge1xuICAgICAgICBpZiAobiA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IHRvIHNwbGl0RXZlcnkgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHZhciBpZHggPSAwO1xuICAgICAgICB3aGlsZSAoaWR4IDwgbGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNsaWNlKGlkeCwgaWR4ICs9IG4sIGxpc3QpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGFrZXMgYSBsaXN0IGFuZCBhIHByZWRpY2F0ZSBhbmQgcmV0dXJucyBhIHBhaXIgb2YgbGlzdHMgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgICpcbiAgICAgKiAgLSB0aGUgcmVzdWx0IG9mIGNvbmNhdGVuYXRpbmcgdGhlIHR3byBvdXRwdXQgbGlzdHMgaXMgZXF1aXZhbGVudCB0byB0aGUgaW5wdXQgbGlzdDtcbiAgICAgKiAgLSBub25lIG9mIHRoZSBlbGVtZW50cyBvZiB0aGUgZmlyc3Qgb3V0cHV0IGxpc3Qgc2F0aXNmaWVzIHRoZSBwcmVkaWNhdGU7IGFuZFxuICAgICAqICAtIGlmIHRoZSBzZWNvbmQgb3V0cHV0IGxpc3QgaXMgbm9uLWVtcHR5LCBpdHMgZmlyc3QgZWxlbWVudCBzYXRpc2ZpZXMgdGhlIHByZWRpY2F0ZS5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTkuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyAoYSAtPiBCb29sZWFuKSAtPiBbYV0gLT4gW1thXSwgW2FdXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWQgVGhlIHByZWRpY2F0ZSB0aGF0IGRldGVybWluZXMgd2hlcmUgdGhlIGFycmF5IGlzIHNwbGl0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGJlIHNwbGl0LlxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuc3BsaXRXaGVuKFIuZXF1YWxzKDIpLCBbMSwgMiwgMywgMSwgMiwgM10pOyAgIC8vPT4gW1sxXSwgWzIsIDMsIDEsIDIsIDNdXVxuICAgICAqL1xuICAgIHZhciBzcGxpdFdoZW4gPSBfY3VycnkyKGZ1bmN0aW9uIHNwbGl0V2hlbihwcmVkLCBsaXN0KSB7XG4gICAgICAgIHZhciBpZHggPSAwO1xuICAgICAgICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gICAgICAgIHZhciBwcmVmaXggPSBbXTtcbiAgICAgICAgd2hpbGUgKGlkeCA8IGxlbiAmJiAhcHJlZChsaXN0W2lkeF0pKSB7XG4gICAgICAgICAgICBwcmVmaXgucHVzaChsaXN0W2lkeF0pO1xuICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHByZWZpeCxcbiAgICAgICAgICAgIF9zbGljZShsaXN0LCBpZHgpXG4gICAgICAgIF07XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdHMgaXRzIHNlY29uZCBhcmd1bWVudCBmcm9tIGl0cyBmaXJzdCBhcmd1bWVudC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAc2lnIE51bWJlciAtPiBOdW1iZXIgLT4gTnVtYmVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGEgVGhlIGZpcnN0IHZhbHVlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBiIFRoZSBzZWNvbmQgdmFsdWUuXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgcmVzdWx0IG9mIGBhIC0gYmAuXG4gICAgICogQHNlZSBSLmFkZFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuc3VidHJhY3QoMTAsIDgpOyAvLz0+IDJcbiAgICAgKlxuICAgICAqICAgICAgdmFyIG1pbnVzNSA9IFIuc3VidHJhY3QoUi5fXywgNSk7XG4gICAgICogICAgICBtaW51czUoMTcpOyAvLz0+IDEyXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBjb21wbGVtZW50YXJ5QW5nbGUgPSBSLnN1YnRyYWN0KDkwKTtcbiAgICAgKiAgICAgIGNvbXBsZW1lbnRhcnlBbmdsZSgzMCk7IC8vPT4gNjBcbiAgICAgKiAgICAgIGNvbXBsZW1lbnRhcnlBbmdsZSg3Mik7IC8vPT4gMThcbiAgICAgKi9cbiAgICB2YXIgc3VidHJhY3QgPSBfY3VycnkyKGZ1bmN0aW9uIHN1YnRyYWN0KGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlcihhKSAtIE51bWJlcihiKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIGJ1dCB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgZ2l2ZW4gbGlzdCBvciBzdHJpbmcgKG9yIG9iamVjdFxuICAgICAqIHdpdGggYSBgdGFpbGAgbWV0aG9kKS5cbiAgICAgKlxuICAgICAqIERpc3BhdGNoZXMgdG8gdGhlIGBzbGljZWAgbWV0aG9kIG9mIHRoZSBmaXJzdCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIFthXSAtPiBbYV1cbiAgICAgKiBAc2lnIFN0cmluZyAtPiBTdHJpbmdcbiAgICAgKiBAcGFyYW0geyp9IGxpc3RcbiAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAqIEBzZWUgUi5oZWFkLCBSLmluaXQsIFIubGFzdFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIudGFpbChbMSwgMiwgM10pOyAgLy89PiBbMiwgM11cbiAgICAgKiAgICAgIFIudGFpbChbMSwgMl0pOyAgICAgLy89PiBbMl1cbiAgICAgKiAgICAgIFIudGFpbChbMV0pOyAgICAgICAgLy89PiBbXVxuICAgICAqICAgICAgUi50YWlsKFtdKTsgICAgICAgICAvLz0+IFtdXG4gICAgICpcbiAgICAgKiAgICAgIFIudGFpbCgnYWJjJyk7ICAvLz0+ICdiYydcbiAgICAgKiAgICAgIFIudGFpbCgnYWInKTsgICAvLz0+ICdiJ1xuICAgICAqICAgICAgUi50YWlsKCdhJyk7ICAgIC8vPT4gJydcbiAgICAgKiAgICAgIFIudGFpbCgnJyk7ICAgICAvLz0+ICcnXG4gICAgICovXG4gICAgdmFyIHRhaWwgPSBfY2hlY2tGb3JNZXRob2QoJ3RhaWwnLCBzbGljZSgxLCBJbmZpbml0eSkpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3QgYG5gIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBsaXN0LCBzdHJpbmcsIG9yXG4gICAgICogdHJhbnNkdWNlci90cmFuc2Zvcm1lciAob3Igb2JqZWN0IHdpdGggYSBgdGFrZWAgbWV0aG9kKS5cbiAgICAgKlxuICAgICAqIERpc3BhdGNoZXMgdG8gdGhlIGB0YWtlYCBtZXRob2Qgb2YgdGhlIHNlY29uZCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIE51bWJlciAtPiBbYV0gLT4gW2FdXG4gICAgICogQHNpZyBOdW1iZXIgLT4gU3RyaW5nIC0+IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gICAgICogQHBhcmFtIHsqfSBsaXN0XG4gICAgICogQHJldHVybiB7Kn1cbiAgICAgKiBAc2VlIFIuZHJvcFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIudGFrZSgxLCBbJ2ZvbycsICdiYXInLCAnYmF6J10pOyAvLz0+IFsnZm9vJ11cbiAgICAgKiAgICAgIFIudGFrZSgyLCBbJ2ZvbycsICdiYXInLCAnYmF6J10pOyAvLz0+IFsnZm9vJywgJ2JhciddXG4gICAgICogICAgICBSLnRha2UoMywgWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiBbJ2ZvbycsICdiYXInLCAnYmF6J11cbiAgICAgKiAgICAgIFIudGFrZSg0LCBbJ2ZvbycsICdiYXInLCAnYmF6J10pOyAvLz0+IFsnZm9vJywgJ2JhcicsICdiYXonXVxuICAgICAqICAgICAgUi50YWtlKDMsICdyYW1kYScpOyAgICAgICAgICAgICAgIC8vPT4gJ3JhbSdcbiAgICAgKlxuICAgICAqICAgICAgdmFyIHBlcnNvbm5lbCA9IFtcbiAgICAgKiAgICAgICAgJ0RhdmUgQnJ1YmVjaycsXG4gICAgICogICAgICAgICdQYXVsIERlc21vbmQnLFxuICAgICAqICAgICAgICAnRXVnZW5lIFdyaWdodCcsXG4gICAgICogICAgICAgICdKb2UgTW9yZWxsbycsXG4gICAgICogICAgICAgICdHZXJyeSBNdWxsaWdhbicsXG4gICAgICogICAgICAgICdCb2IgQmF0ZXMnLFxuICAgICAqICAgICAgICAnSm9lIERvZGdlJyxcbiAgICAgKiAgICAgICAgJ1JvbiBDcm90dHknXG4gICAgICogICAgICBdO1xuICAgICAqXG4gICAgICogICAgICB2YXIgdGFrZUZpdmUgPSBSLnRha2UoNSk7XG4gICAgICogICAgICB0YWtlRml2ZShwZXJzb25uZWwpO1xuICAgICAqICAgICAgLy89PiBbJ0RhdmUgQnJ1YmVjaycsICdQYXVsIERlc21vbmQnLCAnRXVnZW5lIFdyaWdodCcsICdKb2UgTW9yZWxsbycsICdHZXJyeSBNdWxsaWdhbiddXG4gICAgICovXG4gICAgdmFyIHRha2UgPSBfY3VycnkyKF9kaXNwYXRjaGFibGUoJ3Rha2UnLCBfeHRha2UsIGZ1bmN0aW9uIHRha2UobiwgeHMpIHtcbiAgICAgICAgcmV0dXJuIHNsaWNlKDAsIG4gPCAwID8gSW5maW5pdHkgOiBuLCB4cyk7XG4gICAgfSkpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBsaXN0IGNvbnRhaW5pbmcgdGhlIGxhc3QgYG5gIGVsZW1lbnRzIG9mIGEgZ2l2ZW4gbGlzdCwgcGFzc2luZ1xuICAgICAqIGVhY2ggdmFsdWUgdG8gdGhlIHN1cHBsaWVkIHByZWRpY2F0ZSBmdW5jdGlvbiwgYW5kIHRlcm1pbmF0aW5nIHdoZW4gdGhlXG4gICAgICogcHJlZGljYXRlIGZ1bmN0aW9uIHJldHVybnMgYGZhbHNlYC4gRXhjbHVkZXMgdGhlIGVsZW1lbnQgdGhhdCBjYXVzZWQgdGhlXG4gICAgICogcHJlZGljYXRlIGZ1bmN0aW9uIHRvIGZhaWwuIFRoZSBwcmVkaWNhdGUgZnVuY3Rpb24gaXMgcGFzc2VkIG9uZSBhcmd1bWVudDpcbiAgICAgKiAqKHZhbHVlKSouXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjE2LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gW2FdIC0+IFthXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gQSBuZXcgYXJyYXkuXG4gICAgICogQHNlZSBSLmRyb3BMYXN0V2hpbGUsIFIuYWRkSW5kZXhcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgaXNOb3RPbmUgPSB4ID0+IHggIT09IDE7XG4gICAgICpcbiAgICAgKiAgICAgIFIudGFrZUxhc3RXaGlsZShpc05vdE9uZSwgWzEsIDIsIDMsIDRdKTsgLy89PiBbMiwgMywgNF1cbiAgICAgKi9cbiAgICB2YXIgdGFrZUxhc3RXaGlsZSA9IF9jdXJyeTIoZnVuY3Rpb24gdGFrZUxhc3RXaGlsZShmbiwgbGlzdCkge1xuICAgICAgICB2YXIgaWR4ID0gbGlzdC5sZW5ndGggLSAxO1xuICAgICAgICB3aGlsZSAoaWR4ID49IDAgJiYgZm4obGlzdFtpZHhdKSkge1xuICAgICAgICAgICAgaWR4IC09IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9zbGljZShsaXN0LCBpZHggKyAxLCBJbmZpbml0eSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IGxpc3QgY29udGFpbmluZyB0aGUgZmlyc3QgYG5gIGVsZW1lbnRzIG9mIGEgZ2l2ZW4gbGlzdCxcbiAgICAgKiBwYXNzaW5nIGVhY2ggdmFsdWUgdG8gdGhlIHN1cHBsaWVkIHByZWRpY2F0ZSBmdW5jdGlvbiwgYW5kIHRlcm1pbmF0aW5nIHdoZW5cbiAgICAgKiB0aGUgcHJlZGljYXRlIGZ1bmN0aW9uIHJldHVybnMgYGZhbHNlYC4gRXhjbHVkZXMgdGhlIGVsZW1lbnQgdGhhdCBjYXVzZWQgdGhlXG4gICAgICogcHJlZGljYXRlIGZ1bmN0aW9uIHRvIGZhaWwuIFRoZSBwcmVkaWNhdGUgZnVuY3Rpb24gaXMgcGFzc2VkIG9uZSBhcmd1bWVudDpcbiAgICAgKiAqKHZhbHVlKSouXG4gICAgICpcbiAgICAgKiBEaXNwYXRjaGVzIHRvIHRoZSBgdGFrZVdoaWxlYCBtZXRob2Qgb2YgdGhlIHNlY29uZCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIEFjdHMgYXMgYSB0cmFuc2R1Y2VyIGlmIGEgdHJhbnNmb3JtZXIgaXMgZ2l2ZW4gaW4gbGlzdCBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IFthXSAtPiBbYV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybiB7QXJyYXl9IEEgbmV3IGFycmF5LlxuICAgICAqIEBzZWUgUi5kcm9wV2hpbGUsIFIudHJhbnNkdWNlLCBSLmFkZEluZGV4XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGlzTm90Rm91ciA9IHggPT4geCAhPT0gNDtcbiAgICAgKlxuICAgICAqICAgICAgUi50YWtlV2hpbGUoaXNOb3RGb3VyLCBbMSwgMiwgMywgNCwgMywgMiwgMV0pOyAvLz0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIHZhciB0YWtlV2hpbGUgPSBfY3VycnkyKF9kaXNwYXRjaGFibGUoJ3Rha2VXaGlsZScsIF94dGFrZVdoaWxlLCBmdW5jdGlvbiB0YWtlV2hpbGUoZm4sIGxpc3QpIHtcbiAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGlkeCA8IGxlbiAmJiBmbihsaXN0W2lkeF0pKSB7XG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3NsaWNlKGxpc3QsIDAsIGlkeCk7XG4gICAgfSkpO1xuXG4gICAgLyoqXG4gICAgICogUnVucyB0aGUgZ2l2ZW4gZnVuY3Rpb24gd2l0aCB0aGUgc3VwcGxpZWQgb2JqZWN0LCB0aGVuIHJldHVybnMgdGhlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHNpZyAoYSAtPiAqKSAtPiBhIC0+IGFcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aXRoIGB4YC4gVGhlIHJldHVybiB2YWx1ZSBvZiBgZm5gIHdpbGwgYmUgdGhyb3duIGF3YXkuXG4gICAgICogQHBhcmFtIHsqfSB4XG4gICAgICogQHJldHVybiB7Kn0gYHhgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBzYXlYID0geCA9PiBjb25zb2xlLmxvZygneCBpcyAnICsgeCk7XG4gICAgICogICAgICBSLnRhcChzYXlYLCAxMDApOyAvLz0+IDEwMFxuICAgICAqICAgICAgLy8tPiAneCBpcyAxMDAnXG4gICAgICovXG4gICAgdmFyIHRhcCA9IF9jdXJyeTIoZnVuY3Rpb24gdGFwKGZuLCB4KSB7XG4gICAgICAgIGZuKHgpO1xuICAgICAgICByZXR1cm4geDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENhbGxzIGFuIGlucHV0IGZ1bmN0aW9uIGBuYCB0aW1lcywgcmV0dXJuaW5nIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIHJlc3VsdHNcbiAgICAgKiBvZiB0aG9zZSBmdW5jdGlvbiBjYWxscy5cbiAgICAgKlxuICAgICAqIGBmbmAgaXMgcGFzc2VkIG9uZSBhcmd1bWVudDogVGhlIGN1cnJlbnQgdmFsdWUgb2YgYG5gLCB3aGljaCBiZWdpbnMgYXQgYDBgXG4gICAgICogYW5kIGlzIGdyYWR1YWxseSBpbmNyZW1lbnRlZCB0byBgbiAtIDFgLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4yLjNcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgKE51bWJlciAtPiBhKSAtPiBOdW1iZXIgLT4gW2FdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGludm9rZS4gUGFzc2VkIG9uZSBhcmd1bWVudCwgdGhlIGN1cnJlbnQgdmFsdWUgb2YgYG5gLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuIEEgdmFsdWUgYmV0d2VlbiBgMGAgYW5kIGBuIC0gMWAuIEluY3JlbWVudHMgYWZ0ZXIgZWFjaCBmdW5jdGlvbiBjYWxsLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBjb250YWluaW5nIHRoZSByZXR1cm4gdmFsdWVzIG9mIGFsbCBjYWxscyB0byBgZm5gLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIudGltZXMoUi5pZGVudGl0eSwgNSk7IC8vPT4gWzAsIDEsIDIsIDMsIDRdXG4gICAgICovXG4gICAgdmFyIHRpbWVzID0gX2N1cnJ5MihmdW5jdGlvbiB0aW1lcyhmbiwgbikge1xuICAgICAgICB2YXIgbGVuID0gTnVtYmVyKG4pO1xuICAgICAgICB2YXIgaWR4ID0gMDtcbiAgICAgICAgdmFyIGxpc3Q7XG4gICAgICAgIGlmIChsZW4gPCAwIHx8IGlzTmFOKGxlbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCduIG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGlzdCA9IG5ldyBBcnJheShsZW4pO1xuICAgICAgICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgICAgICAgICBsaXN0W2lkeF0gPSBmbihpZHgpO1xuICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbiBvYmplY3QgaW50byBhbiBhcnJheSBvZiBrZXksIHZhbHVlIGFycmF5cy4gT25seSB0aGUgb2JqZWN0J3NcbiAgICAgKiBvd24gcHJvcGVydGllcyBhcmUgdXNlZC5cbiAgICAgKiBOb3RlIHRoYXQgdGhlIG9yZGVyIG9mIHRoZSBvdXRwdXQgYXJyYXkgaXMgbm90IGd1YXJhbnRlZWQgdG8gYmUgY29uc2lzdGVudFxuICAgICAqIGFjcm9zcyBkaWZmZXJlbnQgSlMgcGxhdGZvcm1zLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC40LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHNpZyB7U3RyaW5nOiAqfSAtPiBbW1N0cmluZywqXV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gZXh0cmFjdCBmcm9tXG4gICAgICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9mIGtleSwgdmFsdWUgYXJyYXlzIGZyb20gdGhlIG9iamVjdCdzIG93biBwcm9wZXJ0aWVzLlxuICAgICAqIEBzZWUgUi5mcm9tUGFpcnNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLnRvUGFpcnMoe2E6IDEsIGI6IDIsIGM6IDN9KTsgLy89PiBbWydhJywgMV0sIFsnYicsIDJdLCBbJ2MnLCAzXV1cbiAgICAgKi9cbiAgICB2YXIgdG9QYWlycyA9IF9jdXJyeTEoZnVuY3Rpb24gdG9QYWlycyhvYmopIHtcbiAgICAgICAgdmFyIHBhaXJzID0gW107XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAoX2hhcyhwcm9wLCBvYmopKSB7XG4gICAgICAgICAgICAgICAgcGFpcnNbcGFpcnMubGVuZ3RoXSA9IFtcbiAgICAgICAgICAgICAgICAgICAgcHJvcCxcbiAgICAgICAgICAgICAgICAgICAgb2JqW3Byb3BdXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFpcnM7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbiBvYmplY3QgaW50byBhbiBhcnJheSBvZiBrZXksIHZhbHVlIGFycmF5cy4gVGhlIG9iamVjdCdzIG93blxuICAgICAqIHByb3BlcnRpZXMgYW5kIHByb3RvdHlwZSBwcm9wZXJ0aWVzIGFyZSB1c2VkLiBOb3RlIHRoYXQgdGhlIG9yZGVyIG9mIHRoZVxuICAgICAqIG91dHB1dCBhcnJheSBpcyBub3QgZ3VhcmFudGVlZCB0byBiZSBjb25zaXN0ZW50IGFjcm9zcyBkaWZmZXJlbnQgSlNcbiAgICAgKiBwbGF0Zm9ybXMuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjQuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAc2lnIHtTdHJpbmc6ICp9IC0+IFtbU3RyaW5nLCpdXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBleHRyYWN0IGZyb21cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgb2Yga2V5LCB2YWx1ZSBhcnJheXMgZnJvbSB0aGUgb2JqZWN0J3Mgb3duXG4gICAgICogICAgICAgICBhbmQgcHJvdG90eXBlIHByb3BlcnRpZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIEYgPSBmdW5jdGlvbigpIHsgdGhpcy54ID0gJ1gnOyB9O1xuICAgICAqICAgICAgRi5wcm90b3R5cGUueSA9ICdZJztcbiAgICAgKiAgICAgIHZhciBmID0gbmV3IEYoKTtcbiAgICAgKiAgICAgIFIudG9QYWlyc0luKGYpOyAvLz0+IFtbJ3gnLCdYJ10sIFsneScsJ1knXV1cbiAgICAgKi9cbiAgICB2YXIgdG9QYWlyc0luID0gX2N1cnJ5MShmdW5jdGlvbiB0b1BhaXJzSW4ob2JqKSB7XG4gICAgICAgIHZhciBwYWlycyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgICAgICAgICAgcGFpcnNbcGFpcnMubGVuZ3RoXSA9IFtcbiAgICAgICAgICAgICAgICBwcm9wLFxuICAgICAgICAgICAgICAgIG9ialtwcm9wXVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFpcnM7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc3Bvc2VzIHRoZSByb3dzIGFuZCBjb2x1bW5zIG9mIGEgMkQgbGlzdC5cbiAgICAgKiBXaGVuIHBhc3NlZCBhIGxpc3Qgb2YgYG5gIGxpc3RzIG9mIGxlbmd0aCBgeGAsXG4gICAgICogcmV0dXJucyBhIGxpc3Qgb2YgYHhgIGxpc3RzIG9mIGxlbmd0aCBgbmAuXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTkuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyBbW2FdXSAtPiBbW2FdXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgQSAyRCBsaXN0XG4gICAgICogQHJldHVybiB7QXJyYXl9IEEgMkQgbGlzdFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIudHJhbnNwb3NlKFtbMSwgJ2EnXSwgWzIsICdiJ10sIFszLCAnYyddXSkgLy89PiBbWzEsIDIsIDNdLCBbJ2EnLCAnYicsICdjJ11dXG4gICAgICogICAgICBSLnRyYW5zcG9zZShbWzEsIDIsIDNdLCBbJ2EnLCAnYicsICdjJ11dKSAvLz0+IFtbMSwgJ2EnXSwgWzIsICdiJ10sIFszLCAnYyddXVxuICAgICAqXG4gICAgICogSWYgc29tZSBvZiB0aGUgcm93cyBhcmUgc2hvcnRlciB0aGFuIHRoZSBmb2xsb3dpbmcgcm93cywgdGhlaXIgZWxlbWVudHMgYXJlIHNraXBwZWQ6XG4gICAgICpcbiAgICAgKiAgICAgIFIudHJhbnNwb3NlKFtbMTAsIDExXSwgWzIwXSwgW10sIFszMCwgMzEsIDMyXV0pIC8vPT4gW1sxMCwgMjAsIDMwXSwgWzExLCAzMV0sIFszMl1dXG4gICAgICovXG4gICAgdmFyIHRyYW5zcG9zZSA9IF9jdXJyeTEoZnVuY3Rpb24gdHJhbnNwb3NlKG91dGVybGlzdCkge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgd2hpbGUgKGkgPCBvdXRlcmxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgaW5uZXJsaXN0ID0gb3V0ZXJsaXN0W2ldO1xuICAgICAgICAgICAgdmFyIGogPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGogPCBpbm5lcmxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHRbal0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtqXSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRbal0ucHVzaChpbm5lcmxpc3Rbal0pO1xuICAgICAgICAgICAgICAgIGogKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyAoc3RyaXBzKSB3aGl0ZXNwYWNlIGZyb20gYm90aCBlbmRzIG9mIHRoZSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjYuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAc2lnIFN0cmluZyAtPiBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRyaW1tZWQgdmVyc2lvbiBvZiBgc3RyYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLnRyaW0oJyAgIHh5eiAgJyk7IC8vPT4gJ3h5eidcbiAgICAgKiAgICAgIFIubWFwKFIudHJpbSwgUi5zcGxpdCgnLCcsICd4LCB5LCB6JykpOyAvLz0+IFsneCcsICd5JywgJ3onXVxuICAgICAqL1xuICAgIHZhciB0cmltID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd3MgPSAnXFx0XFxuXFx4MEJcXGZcXHIgXFx4QTBcXHUxNjgwXFx1MTgwRVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDMnICsgJ1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMEFcXHUyMDJGXFx1MjA1RlxcdTMwMDBcXHUyMDI4JyArICdcXHUyMDI5XFx1RkVGRic7XG4gICAgICAgIHZhciB6ZXJvV2lkdGggPSAnXFx1MjAwQic7XG4gICAgICAgIHZhciBoYXNQcm90b1RyaW0gPSB0eXBlb2YgU3RyaW5nLnByb3RvdHlwZS50cmltID09PSAnZnVuY3Rpb24nO1xuICAgICAgICBpZiAoIWhhc1Byb3RvVHJpbSB8fCAod3MudHJpbSgpIHx8ICF6ZXJvV2lkdGgudHJpbSgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIF9jdXJyeTEoZnVuY3Rpb24gdHJpbShzdHIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmVnaW5SeCA9IG5ldyBSZWdFeHAoJ15bJyArIHdzICsgJ11bJyArIHdzICsgJ10qJyk7XG4gICAgICAgICAgICAgICAgdmFyIGVuZFJ4ID0gbmV3IFJlZ0V4cCgnWycgKyB3cyArICddWycgKyB3cyArICddKiQnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoYmVnaW5SeCwgJycpLnJlcGxhY2UoZW5kUngsICcnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIF9jdXJyeTEoZnVuY3Rpb24gdHJpbShzdHIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyLnRyaW0oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogYHRyeUNhdGNoYCB0YWtlcyB0d28gZnVuY3Rpb25zLCBhIGB0cnllcmAgYW5kIGEgYGNhdGNoZXJgLiBUaGUgcmV0dXJuZWRcbiAgICAgKiBmdW5jdGlvbiBldmFsdWF0ZXMgdGhlIGB0cnllcmA7IGlmIGl0IGRvZXMgbm90IHRocm93LCBpdCBzaW1wbHkgcmV0dXJucyB0aGVcbiAgICAgKiByZXN1bHQuIElmIHRoZSBgdHJ5ZXJgICpkb2VzKiB0aHJvdywgdGhlIHJldHVybmVkIGZ1bmN0aW9uIGV2YWx1YXRlcyB0aGVcbiAgICAgKiBgY2F0Y2hlcmAgZnVuY3Rpb24gYW5kIHJldHVybnMgaXRzIHJlc3VsdC4gTm90ZSB0aGF0IGZvciBlZmZlY3RpdmVcbiAgICAgKiBjb21wb3NpdGlvbiB3aXRoIHRoaXMgZnVuY3Rpb24sIGJvdGggdGhlIGB0cnllcmAgYW5kIGBjYXRjaGVyYCBmdW5jdGlvbnNcbiAgICAgKiBtdXN0IHJldHVybiB0aGUgc2FtZSB0eXBlIG9mIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjIwLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAc2lnICguLi54IC0+IGEpIC0+ICgoZSwgLi4ueCkgLT4gYSkgLT4gKC4uLnggLT4gYSlcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cnllciBUaGUgZnVuY3Rpb24gdGhhdCBtYXkgdGhyb3cuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2F0Y2hlciBUaGUgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV2YWx1YXRlZCBpZiBgdHJ5ZXJgIHRocm93cy5cbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBuZXcgZnVuY3Rpb24gdGhhdCB3aWxsIGNhdGNoIGV4Y2VwdGlvbnMgYW5kIHNlbmQgdGhlbiB0byB0aGUgY2F0Y2hlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLnRyeUNhdGNoKFIucHJvcCgneCcpLCBSLkYsIHt4OiB0cnVlfSk7IC8vPT4gdHJ1ZVxuICAgICAqICAgICAgUi50cnlDYXRjaChSLnByb3AoJ3gnKSwgUi5GLCBudWxsKTsgICAgICAvLz0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIHRyeUNhdGNoID0gX2N1cnJ5MihmdW5jdGlvbiBfdHJ5Q2F0Y2godHJ5ZXIsIGNhdGNoZXIpIHtcbiAgICAgICAgcmV0dXJuIF9hcml0eSh0cnllci5sZW5ndGgsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyeWVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhdGNoZXIuYXBwbHkodGhpcywgX2NvbmNhdChbZV0sIGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEdpdmVzIGEgc2luZ2xlLXdvcmQgc3RyaW5nIGRlc2NyaXB0aW9uIG9mIHRoZSAobmF0aXZlKSB0eXBlIG9mIGEgdmFsdWUsXG4gICAgICogcmV0dXJuaW5nIHN1Y2ggYW5zd2VycyBhcyAnT2JqZWN0JywgJ051bWJlcicsICdBcnJheScsIG9yICdOdWxsJy4gRG9lcyBub3RcbiAgICAgKiBhdHRlbXB0IHRvIGRpc3Rpbmd1aXNoIHVzZXIgT2JqZWN0IHR5cGVzIGFueSBmdXJ0aGVyLCByZXBvcnRpbmcgdGhlbSBhbGwgYXNcbiAgICAgKiAnT2JqZWN0Jy5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuOC4wXG4gICAgICogQGNhdGVnb3J5IFR5cGVcbiAgICAgKiBAc2lnICgqIC0+IHsqfSkgLT4gU3RyaW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi50eXBlKHt9KTsgLy89PiBcIk9iamVjdFwiXG4gICAgICogICAgICBSLnR5cGUoMSk7IC8vPT4gXCJOdW1iZXJcIlxuICAgICAqICAgICAgUi50eXBlKGZhbHNlKTsgLy89PiBcIkJvb2xlYW5cIlxuICAgICAqICAgICAgUi50eXBlKCdzJyk7IC8vPT4gXCJTdHJpbmdcIlxuICAgICAqICAgICAgUi50eXBlKG51bGwpOyAvLz0+IFwiTnVsbFwiXG4gICAgICogICAgICBSLnR5cGUoW10pOyAvLz0+IFwiQXJyYXlcIlxuICAgICAqICAgICAgUi50eXBlKC9bQS16XS8pOyAvLz0+IFwiUmVnRXhwXCJcbiAgICAgKi9cbiAgICB2YXIgdHlwZSA9IF9jdXJyeTEoZnVuY3Rpb24gdHlwZSh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbCA9PT0gbnVsbCA/ICdOdWxsJyA6IHZhbCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsKS5zbGljZSg4LCAtMSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUYWtlcyBhIGZ1bmN0aW9uIGBmbmAsIHdoaWNoIHRha2VzIGEgc2luZ2xlIGFycmF5IGFyZ3VtZW50LCBhbmQgcmV0dXJucyBhXG4gICAgICogZnVuY3Rpb24gd2hpY2g6XG4gICAgICpcbiAgICAgKiAgIC0gdGFrZXMgYW55IG51bWJlciBvZiBwb3NpdGlvbmFsIGFyZ3VtZW50cztcbiAgICAgKiAgIC0gcGFzc2VzIHRoZXNlIGFyZ3VtZW50cyB0byBgZm5gIGFzIGFuIGFycmF5OyBhbmRcbiAgICAgKiAgIC0gcmV0dXJucyB0aGUgcmVzdWx0LlxuICAgICAqXG4gICAgICogSW4gb3RoZXIgd29yZHMsIFIudW5hcHBseSBkZXJpdmVzIGEgdmFyaWFkaWMgZnVuY3Rpb24gZnJvbSBhIGZ1bmN0aW9uIHdoaWNoXG4gICAgICogdGFrZXMgYW4gYXJyYXkuIFIudW5hcHBseSBpcyB0aGUgaW52ZXJzZSBvZiBSLmFwcGx5LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC44LjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAc2lnIChbKi4uLl0gLT4gYSkgLT4gKCouLi4gLT4gYSlcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgICAqIEBzZWUgUi5hcHBseVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIudW5hcHBseShKU09OLnN0cmluZ2lmeSkoMSwgMiwgMyk7IC8vPT4gJ1sxLDIsM10nXG4gICAgICovXG4gICAgdmFyIHVuYXBwbHkgPSBfY3VycnkxKGZ1bmN0aW9uIHVuYXBwbHkoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBmbihfc2xpY2UoYXJndW1lbnRzKSk7XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBXcmFwcyBhIGZ1bmN0aW9uIG9mIGFueSBhcml0eSAoaW5jbHVkaW5nIG51bGxhcnkpIGluIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzXG4gICAgICogZXhhY3RseSAxIHBhcmFtZXRlci4gQW55IGV4dHJhbmVvdXMgcGFyYW1ldGVycyB3aWxsIG5vdCBiZSBwYXNzZWQgdG8gdGhlXG4gICAgICogc3VwcGxpZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjIuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBzaWcgKCogLT4gYikgLT4gKGEgLT4gYilcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBuZXcgZnVuY3Rpb24gd3JhcHBpbmcgYGZuYC4gVGhlIG5ldyBmdW5jdGlvbiBpcyBndWFyYW50ZWVkIHRvIGJlIG9mXG4gICAgICogICAgICAgICBhcml0eSAxLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciB0YWtlc1R3b0FyZ3MgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgICogICAgICAgIHJldHVybiBbYSwgYl07XG4gICAgICogICAgICB9O1xuICAgICAqICAgICAgdGFrZXNUd29BcmdzLmxlbmd0aDsgLy89PiAyXG4gICAgICogICAgICB0YWtlc1R3b0FyZ3MoMSwgMik7IC8vPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiAgICAgIHZhciB0YWtlc09uZUFyZyA9IFIudW5hcnkodGFrZXNUd29BcmdzKTtcbiAgICAgKiAgICAgIHRha2VzT25lQXJnLmxlbmd0aDsgLy89PiAxXG4gICAgICogICAgICAvLyBPbmx5IDEgYXJndW1lbnQgaXMgcGFzc2VkIHRvIHRoZSB3cmFwcGVkIGZ1bmN0aW9uXG4gICAgICogICAgICB0YWtlc09uZUFyZygxLCAyKTsgLy89PiBbMSwgdW5kZWZpbmVkXVxuICAgICAqL1xuICAgIHZhciB1bmFyeSA9IF9jdXJyeTEoZnVuY3Rpb24gdW5hcnkoZm4pIHtcbiAgICAgICAgcmV0dXJuIG5BcnkoMSwgZm4pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGZ1bmN0aW9uIG9mIGFyaXR5IGBuYCBmcm9tIGEgKG1hbnVhbGx5KSBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xNC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHNpZyBOdW1iZXIgLT4gKGEgLT4gYikgLT4gKGEgLT4gYylcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIFRoZSBhcml0eSBmb3IgdGhlIHJldHVybmVkIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byB1bmN1cnJ5LlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAc2VlIFIuY3VycnlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgYWRkRm91ciA9IGEgPT4gYiA9PiBjID0+IGQgPT4gYSArIGIgKyBjICsgZDtcbiAgICAgKlxuICAgICAqICAgICAgdmFyIHVuY3VycmllZEFkZEZvdXIgPSBSLnVuY3VycnlOKDQsIGFkZEZvdXIpO1xuICAgICAqICAgICAgdW5jdXJyaWVkQWRkRm91cigxLCAyLCAzLCA0KTsgLy89PiAxMFxuICAgICAqL1xuICAgIHZhciB1bmN1cnJ5TiA9IF9jdXJyeTIoZnVuY3Rpb24gdW5jdXJyeU4oZGVwdGgsIGZuKSB7XG4gICAgICAgIHJldHVybiBjdXJyeU4oZGVwdGgsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50RGVwdGggPSAxO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gZm47XG4gICAgICAgICAgICB2YXIgaWR4ID0gMDtcbiAgICAgICAgICAgIHZhciBlbmRJZHg7XG4gICAgICAgICAgICB3aGlsZSAoY3VycmVudERlcHRoIDw9IGRlcHRoICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVuZElkeCA9IGN1cnJlbnREZXB0aCA9PT0gZGVwdGggPyBhcmd1bWVudHMubGVuZ3RoIDogaWR4ICsgdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuYXBwbHkodGhpcywgX3NsaWNlKGFyZ3VtZW50cywgaWR4LCBlbmRJZHgpKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50RGVwdGggKz0gMTtcbiAgICAgICAgICAgICAgICBpZHggPSBlbmRJZHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQnVpbGRzIGEgbGlzdCBmcm9tIGEgc2VlZCB2YWx1ZS4gQWNjZXB0cyBhbiBpdGVyYXRvciBmdW5jdGlvbiwgd2hpY2ggcmV0dXJuc1xuICAgICAqIGVpdGhlciBmYWxzZSB0byBzdG9wIGl0ZXJhdGlvbiBvciBhbiBhcnJheSBvZiBsZW5ndGggMiBjb250YWluaW5nIHRoZSB2YWx1ZVxuICAgICAqIHRvIGFkZCB0byB0aGUgcmVzdWx0aW5nIGxpc3QgYW5kIHRoZSBzZWVkIHRvIGJlIHVzZWQgaW4gdGhlIG5leHQgY2FsbCB0byB0aGVcbiAgICAgKiBpdGVyYXRvciBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIFRoZSBpdGVyYXRvciBmdW5jdGlvbiByZWNlaXZlcyBvbmUgYXJndW1lbnQ6ICooc2VlZCkqLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xMC4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIChhIC0+IFtiXSkgLT4gKiAtPiBbYl1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgaXRlcmF0b3IgZnVuY3Rpb24uIHJlY2VpdmVzIG9uZSBhcmd1bWVudCwgYHNlZWRgLCBhbmQgcmV0dXJuc1xuICAgICAqICAgICAgICBlaXRoZXIgZmFsc2UgdG8gcXVpdCBpdGVyYXRpb24gb3IgYW4gYXJyYXkgb2YgbGVuZ3RoIHR3byB0byBwcm9jZWVkLiBUaGUgZWxlbWVudFxuICAgICAqICAgICAgICBhdCBpbmRleCAwIG9mIHRoaXMgYXJyYXkgd2lsbCBiZSBhZGRlZCB0byB0aGUgcmVzdWx0aW5nIGFycmF5LCBhbmQgdGhlIGVsZW1lbnRcbiAgICAgKiAgICAgICAgYXQgaW5kZXggMSB3aWxsIGJlIHBhc3NlZCB0byB0aGUgbmV4dCBjYWxsIHRvIGBmbmAuXG4gICAgICogQHBhcmFtIHsqfSBzZWVkIFRoZSBzZWVkIHZhbHVlLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBUaGUgZmluYWwgbGlzdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgZiA9IG4gPT4gbiA+IDUwID8gZmFsc2UgOiBbLW4sIG4gKyAxMF07XG4gICAgICogICAgICBSLnVuZm9sZChmLCAxMCk7IC8vPT4gWy0xMCwgLTIwLCAtMzAsIC00MCwgLTUwXVxuICAgICAqL1xuICAgIHZhciB1bmZvbGQgPSBfY3VycnkyKGZ1bmN0aW9uIHVuZm9sZChmbiwgc2VlZCkge1xuICAgICAgICB2YXIgcGFpciA9IGZuKHNlZWQpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHdoaWxlIChwYWlyICYmIHBhaXIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSBwYWlyWzBdO1xuICAgICAgICAgICAgcGFpciA9IGZuKHBhaXJbMV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IGxpc3QgY29udGFpbmluZyBvbmx5IG9uZSBjb3B5IG9mIGVhY2ggZWxlbWVudCBpbiB0aGUgb3JpZ2luYWxcbiAgICAgKiBsaXN0LCBiYXNlZCB1cG9uIHRoZSB2YWx1ZSByZXR1cm5lZCBieSBhcHBseWluZyB0aGUgc3VwcGxpZWQgcHJlZGljYXRlIHRvXG4gICAgICogdHdvIGxpc3QgZWxlbWVudHMuIFByZWZlcnMgdGhlIGZpcnN0IGl0ZW0gaWYgdHdvIGl0ZW1zIGNvbXBhcmUgZXF1YWwgYmFzZWRcbiAgICAgKiBvbiB0aGUgcHJlZGljYXRlLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgKGEsIGEgLT4gQm9vbGVhbikgLT4gW2FdIC0+IFthXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWQgQSBwcmVkaWNhdGUgdXNlZCB0byB0ZXN0IHdoZXRoZXIgdHdvIGl0ZW1zIGFyZSBlcXVhbC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBjb25zaWRlci5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGxpc3Qgb2YgdW5pcXVlIGl0ZW1zLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBzdHJFcSA9IFIuZXFCeShTdHJpbmcpO1xuICAgICAqICAgICAgUi51bmlxV2l0aChzdHJFcSkoWzEsICcxJywgMiwgMV0pOyAvLz0+IFsxLCAyXVxuICAgICAqICAgICAgUi51bmlxV2l0aChzdHJFcSkoW3t9LCB7fV0pOyAgICAgICAvLz0+IFt7fV1cbiAgICAgKiAgICAgIFIudW5pcVdpdGgoc3RyRXEpKFsxLCAnMScsIDFdKTsgICAgLy89PiBbMV1cbiAgICAgKiAgICAgIFIudW5pcVdpdGgoc3RyRXEpKFsnMScsIDEsIDFdKTsgICAgLy89PiBbJzEnXVxuICAgICAqL1xuICAgIHZhciB1bmlxV2l0aCA9IF9jdXJyeTIoZnVuY3Rpb24gdW5pcVdpdGgocHJlZCwgbGlzdCkge1xuICAgICAgICB2YXIgaWR4ID0gMDtcbiAgICAgICAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHZhciBpdGVtO1xuICAgICAgICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgICAgICAgICBpdGVtID0gbGlzdFtpZHhdO1xuICAgICAgICAgICAgaWYgKCFfY29udGFpbnNXaXRoKHByZWQsIGl0ZW0sIHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRlc3RzIHRoZSBmaW5hbCBhcmd1bWVudCBieSBwYXNzaW5nIGl0IHRvIHRoZSBnaXZlbiBwcmVkaWNhdGUgZnVuY3Rpb24uIElmXG4gICAgICogdGhlIHByZWRpY2F0ZSBpcyBub3Qgc2F0aXNmaWVkLCB0aGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIHJlc3VsdCBvZlxuICAgICAqIGNhbGxpbmcgdGhlIGB3aGVuRmFsc2VGbmAgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBhcmd1bWVudC4gSWYgdGhlIHByZWRpY2F0ZVxuICAgICAqIGlzIHNhdGlzZmllZCwgdGhlIGFyZ3VtZW50IGlzIHJldHVybmVkIGFzIGlzLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xOC4wXG4gICAgICogQGNhdGVnb3J5IExvZ2ljXG4gICAgICogQHNpZyAoYSAtPiBCb29sZWFuKSAtPiAoYSAtPiBhKSAtPiBhIC0+IGFcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkICAgICAgICBBIHByZWRpY2F0ZSBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHdoZW5GYWxzZUZuIEEgZnVuY3Rpb24gdG8gaW52b2tlIHdoZW4gdGhlIGBwcmVkYCBldmFsdWF0ZXNcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBhIGZhbHN5IHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0gICAgICAgIHggICAgICAgICAgIEFuIG9iamVjdCB0byB0ZXN0IHdpdGggdGhlIGBwcmVkYCBmdW5jdGlvbiBhbmRcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXNzIHRvIGB3aGVuRmFsc2VGbmAgaWYgbmVjZXNzYXJ5LlxuICAgICAqIEByZXR1cm4geyp9IEVpdGhlciBgeGAgb3IgdGhlIHJlc3VsdCBvZiBhcHBseWluZyBgeGAgdG8gYHdoZW5GYWxzZUZuYC5cbiAgICAgKiBAc2VlIFIuaWZFbHNlLCBSLndoZW5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICAvLyBjb2VyY2VBcnJheSA6OiAoYXxbYV0pIC0+IFthXVxuICAgICAqICAgICAgdmFyIGNvZXJjZUFycmF5ID0gUi51bmxlc3MoUi5pc0FycmF5TGlrZSwgUi5vZik7XG4gICAgICogICAgICBjb2VyY2VBcnJheShbMSwgMiwgM10pOyAvLz0+IFsxLCAyLCAzXVxuICAgICAqICAgICAgY29lcmNlQXJyYXkoMSk7ICAgICAgICAgLy89PiBbMV1cbiAgICAgKi9cbiAgICB2YXIgdW5sZXNzID0gX2N1cnJ5MyhmdW5jdGlvbiB1bmxlc3MocHJlZCwgd2hlbkZhbHNlRm4sIHgpIHtcbiAgICAgICAgcmV0dXJuIHByZWQoeCkgPyB4IDogd2hlbkZhbHNlRm4oeCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUYWtlcyBhIHByZWRpY2F0ZSwgYSB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbiwgYW5kIGFuIGluaXRpYWwgdmFsdWUsXG4gICAgICogYW5kIHJldHVybnMgYSB2YWx1ZSBvZiB0aGUgc2FtZSB0eXBlIGFzIHRoZSBpbml0aWFsIHZhbHVlLlxuICAgICAqIEl0IGRvZXMgc28gYnkgYXBwbHlpbmcgdGhlIHRyYW5zZm9ybWF0aW9uIHVudGlsIHRoZSBwcmVkaWNhdGUgaXMgc2F0aXNmaWVkLFxuICAgICAqIGF0IHdoaWNoIHBvaW50IGl0IHJldHVybnMgdGhlIHNhdGlzZmFjdG9yeSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMjAuMFxuICAgICAqIEBjYXRlZ29yeSBMb2dpY1xuICAgICAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gKGEgLT4gYSkgLT4gYSAtPiBhXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZCBBIHByZWRpY2F0ZSBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBpdGVyYXRvciBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Kn0gaW5pdCBJbml0aWFsIHZhbHVlXG4gICAgICogQHJldHVybiB7Kn0gRmluYWwgdmFsdWUgdGhhdCBzYXRpc2ZpZXMgcHJlZGljYXRlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi51bnRpbChSLmd0KFIuX18sIDEwMCksIFIubXVsdGlwbHkoMikpKDEpIC8vID0+IDEyOFxuICAgICAqL1xuICAgIHZhciB1bnRpbCA9IF9jdXJyeTMoZnVuY3Rpb24gdW50aWwocHJlZCwgZm4sIGluaXQpIHtcbiAgICAgICAgdmFyIHZhbCA9IGluaXQ7XG4gICAgICAgIHdoaWxlICghcHJlZCh2YWwpKSB7XG4gICAgICAgICAgICB2YWwgPSBmbih2YWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IGNvcHkgb2YgdGhlIGFycmF5IHdpdGggdGhlIGVsZW1lbnQgYXQgdGhlIHByb3ZpZGVkIGluZGV4XG4gICAgICogcmVwbGFjZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWUuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjE0LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgTnVtYmVyIC0+IGEgLT4gW2FdIC0+IFthXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpZHggVGhlIGluZGV4IHRvIHVwZGF0ZS5cbiAgICAgKiBAcGFyYW0geyp9IHggVGhlIHZhbHVlIHRvIGV4aXN0IGF0IHRoZSBnaXZlbiBpbmRleCBvZiB0aGUgcmV0dXJuZWQgYXJyYXkuXG4gICAgICogQHBhcmFtIHtBcnJheXxBcmd1bWVudHN9IGxpc3QgVGhlIHNvdXJjZSBhcnJheS1saWtlIG9iamVjdCB0byBiZSB1cGRhdGVkLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBBIGNvcHkgb2YgYGxpc3RgIHdpdGggdGhlIHZhbHVlIGF0IGluZGV4IGBpZHhgIHJlcGxhY2VkIHdpdGggYHhgLlxuICAgICAqIEBzZWUgUi5hZGp1c3RcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLnVwZGF0ZSgxLCAxMSwgWzAsIDEsIDJdKTsgICAgIC8vPT4gWzAsIDExLCAyXVxuICAgICAqICAgICAgUi51cGRhdGUoMSkoMTEpKFswLCAxLCAyXSk7ICAgICAvLz0+IFswLCAxMSwgMl1cbiAgICAgKi9cbiAgICB2YXIgdXBkYXRlID0gX2N1cnJ5MyhmdW5jdGlvbiB1cGRhdGUoaWR4LCB4LCBsaXN0KSB7XG4gICAgICAgIHJldHVybiBhZGp1c3QoYWx3YXlzKHgpLCBpZHgsIGxpc3QpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQWNjZXB0cyBhIGZ1bmN0aW9uIGBmbmAgYW5kIGEgbGlzdCBvZiB0cmFuc2Zvcm1lciBmdW5jdGlvbnMgYW5kIHJldHVybnMgYVxuICAgICAqIG5ldyBjdXJyaWVkIGZ1bmN0aW9uLiBXaGVuIHRoZSBuZXcgZnVuY3Rpb24gaXMgaW52b2tlZCwgaXQgY2FsbHMgdGhlXG4gICAgICogZnVuY3Rpb24gYGZuYCB3aXRoIHBhcmFtZXRlcnMgY29uc2lzdGluZyBvZiB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgZWFjaFxuICAgICAqIHN1cHBsaWVkIGhhbmRsZXIgb24gc3VjY2Vzc2l2ZSBhcmd1bWVudHMgdG8gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIElmIG1vcmUgYXJndW1lbnRzIGFyZSBwYXNzZWQgdG8gdGhlIHJldHVybmVkIGZ1bmN0aW9uIHRoYW4gdHJhbnNmb3JtZXJcbiAgICAgKiBmdW5jdGlvbnMsIHRob3NlIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGRpcmVjdGx5IHRvIGBmbmAgYXMgYWRkaXRpb25hbFxuICAgICAqIHBhcmFtZXRlcnMuIElmIHlvdSBleHBlY3QgYWRkaXRpb25hbCBhcmd1bWVudHMgdGhhdCBkb24ndCBuZWVkIHRvIGJlXG4gICAgICogdHJhbnNmb3JtZWQsIGFsdGhvdWdoIHlvdSBjYW4gaWdub3JlIHRoZW0sIGl0J3MgYmVzdCB0byBwYXNzIGFuIGlkZW50aXR5XG4gICAgICogZnVuY3Rpb24gc28gdGhhdCB0aGUgbmV3IGZ1bmN0aW9uIHJlcG9ydHMgdGhlIGNvcnJlY3QgYXJpdHkuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBzaWcgKHgxIC0+IHgyIC0+IC4uLiAtPiB6KSAtPiBbKGEgLT4geDEpLCAoYiAtPiB4MiksIC4uLl0gLT4gKGEgLT4gYiAtPiAuLi4gLT4geilcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB0cmFuc2Zvcm1lcnMgQSBsaXN0IG9mIHRyYW5zZm9ybWVyIGZ1bmN0aW9uc1xuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLnVzZVdpdGgoTWF0aC5wb3csIFtSLmlkZW50aXR5LCBSLmlkZW50aXR5XSkoMywgNCk7IC8vPT4gODFcbiAgICAgKiAgICAgIFIudXNlV2l0aChNYXRoLnBvdywgW1IuaWRlbnRpdHksIFIuaWRlbnRpdHldKSgzKSg0KTsgLy89PiA4MVxuICAgICAqICAgICAgUi51c2VXaXRoKE1hdGgucG93LCBbUi5kZWMsIFIuaW5jXSkoMywgNCk7IC8vPT4gMzJcbiAgICAgKiAgICAgIFIudXNlV2l0aChNYXRoLnBvdywgW1IuZGVjLCBSLmluY10pKDMpKDQpOyAvLz0+IDMyXG4gICAgICovXG4gICAgdmFyIHVzZVdpdGggPSBfY3VycnkyKGZ1bmN0aW9uIHVzZVdpdGgoZm4sIHRyYW5zZm9ybWVycykge1xuICAgICAgICByZXR1cm4gY3VycnlOKHRyYW5zZm9ybWVycy5sZW5ndGgsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICB2YXIgaWR4ID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChpZHggPCB0cmFuc2Zvcm1lcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKHRyYW5zZm9ybWVyc1tpZHhdLmNhbGwodGhpcywgYXJndW1lbnRzW2lkeF0pKTtcbiAgICAgICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmdzLmNvbmNhdChfc2xpY2UoYXJndW1lbnRzLCB0cmFuc2Zvcm1lcnMubGVuZ3RoKSkpO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGFsbCB0aGUgZW51bWVyYWJsZSBvd24gcHJvcGVydGllcyBvZiB0aGUgc3VwcGxpZWQgb2JqZWN0LlxuICAgICAqIE5vdGUgdGhhdCB0aGUgb3JkZXIgb2YgdGhlIG91dHB1dCBhcnJheSBpcyBub3QgZ3VhcmFudGVlZCBhY3Jvc3MgZGlmZmVyZW50XG4gICAgICogSlMgcGxhdGZvcm1zLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHNpZyB7azogdn0gLT4gW3ZdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGV4dHJhY3QgdmFsdWVzIGZyb21cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgb2YgdGhlIHZhbHVlcyBvZiB0aGUgb2JqZWN0J3Mgb3duIHByb3BlcnRpZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi52YWx1ZXMoe2E6IDEsIGI6IDIsIGM6IDN9KTsgLy89PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICB2YXIgdmFsdWVzID0gX2N1cnJ5MShmdW5jdGlvbiB2YWx1ZXMob2JqKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IGtleXMob2JqKTtcbiAgICAgICAgdmFyIGxlbiA9IHByb3BzLmxlbmd0aDtcbiAgICAgICAgdmFyIHZhbHMgPSBbXTtcbiAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICAgICAgICAgIHZhbHNbaWR4XSA9IG9ialtwcm9wc1tpZHhdXTtcbiAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWxzO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgYWxsIHRoZSBwcm9wZXJ0aWVzLCBpbmNsdWRpbmcgcHJvdG90eXBlIHByb3BlcnRpZXMsIG9mIHRoZVxuICAgICAqIHN1cHBsaWVkIG9iamVjdC5cbiAgICAgKiBOb3RlIHRoYXQgdGhlIG9yZGVyIG9mIHRoZSBvdXRwdXQgYXJyYXkgaXMgbm90IGd1YXJhbnRlZWQgdG8gYmUgY29uc2lzdGVudFxuICAgICAqIGFjcm9zcyBkaWZmZXJlbnQgSlMgcGxhdGZvcm1zLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHNpZyB7azogdn0gLT4gW3ZdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGV4dHJhY3QgdmFsdWVzIGZyb21cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgb2YgdGhlIHZhbHVlcyBvZiB0aGUgb2JqZWN0J3Mgb3duIGFuZCBwcm90b3R5cGUgcHJvcGVydGllcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgRiA9IGZ1bmN0aW9uKCkgeyB0aGlzLnggPSAnWCc7IH07XG4gICAgICogICAgICBGLnByb3RvdHlwZS55ID0gJ1knO1xuICAgICAqICAgICAgdmFyIGYgPSBuZXcgRigpO1xuICAgICAqICAgICAgUi52YWx1ZXNJbihmKTsgLy89PiBbJ1gnLCAnWSddXG4gICAgICovXG4gICAgdmFyIHZhbHVlc0luID0gX2N1cnJ5MShmdW5jdGlvbiB2YWx1ZXNJbihvYmopIHtcbiAgICAgICAgdmFyIHByb3A7XG4gICAgICAgIHZhciB2cyA9IFtdO1xuICAgICAgICBmb3IgKHByb3AgaW4gb2JqKSB7XG4gICAgICAgICAgICB2c1t2cy5sZW5ndGhdID0gb2JqW3Byb3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2cztcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBcInZpZXdcIiBvZiB0aGUgZ2l2ZW4gZGF0YSBzdHJ1Y3R1cmUsIGRldGVybWluZWQgYnkgdGhlIGdpdmVuIGxlbnMuXG4gICAgICogVGhlIGxlbnMncyBmb2N1cyBkZXRlcm1pbmVzIHdoaWNoIHBvcnRpb24gb2YgdGhlIGRhdGEgc3RydWN0dXJlIGlzIHZpc2libGUuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjE2LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHR5cGVkZWZuIExlbnMgcyBhID0gRnVuY3RvciBmID0+IChhIC0+IGYgYSkgLT4gcyAtPiBmIHNcbiAgICAgKiBAc2lnIExlbnMgcyBhIC0+IHMgLT4gYVxuICAgICAqIEBwYXJhbSB7TGVuc30gbGVuc1xuICAgICAqIEBwYXJhbSB7Kn0geFxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICogQHNlZSBSLnByb3AsIFIubGVuc0luZGV4LCBSLmxlbnNQcm9wXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIHhMZW5zID0gUi5sZW5zUHJvcCgneCcpO1xuICAgICAqXG4gICAgICogICAgICBSLnZpZXcoeExlbnMsIHt4OiAxLCB5OiAyfSk7ICAvLz0+IDFcbiAgICAgKiAgICAgIFIudmlldyh4TGVucywge3g6IDQsIHk6IDJ9KTsgIC8vPT4gNFxuICAgICAqL1xuICAgIC8vIGBDb25zdGAgaXMgYSBmdW5jdG9yIHRoYXQgZWZmZWN0aXZlbHkgaWdub3JlcyB0aGUgZnVuY3Rpb24gZ2l2ZW4gdG8gYG1hcGAuXG4gICAgLy8gVXNpbmcgYENvbnN0YCBlZmZlY3RpdmVseSBpZ25vcmVzIHRoZSBzZXR0ZXIgZnVuY3Rpb24gb2YgdGhlIGBsZW5zYCxcbiAgICAvLyBsZWF2aW5nIHRoZSB2YWx1ZSByZXR1cm5lZCBieSB0aGUgZ2V0dGVyIGZ1bmN0aW9uIHVubW9kaWZpZWQuXG4gICAgdmFyIHZpZXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGBDb25zdGAgaXMgYSBmdW5jdG9yIHRoYXQgZWZmZWN0aXZlbHkgaWdub3JlcyB0aGUgZnVuY3Rpb24gZ2l2ZW4gdG8gYG1hcGAuXG4gICAgICAgIHZhciBDb25zdCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB4LFxuICAgICAgICAgICAgICAgIG1hcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX2N1cnJ5MihmdW5jdGlvbiB2aWV3KGxlbnMsIHgpIHtcbiAgICAgICAgICAgIC8vIFVzaW5nIGBDb25zdGAgZWZmZWN0aXZlbHkgaWdub3JlcyB0aGUgc2V0dGVyIGZ1bmN0aW9uIG9mIHRoZSBgbGVuc2AsXG4gICAgICAgICAgICAvLyBsZWF2aW5nIHRoZSB2YWx1ZSByZXR1cm5lZCBieSB0aGUgZ2V0dGVyIGZ1bmN0aW9uIHVubW9kaWZpZWQuXG4gICAgICAgICAgICByZXR1cm4gbGVucyhDb25zdCkoeCkudmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH0oKTtcblxuICAgIC8qKlxuICAgICAqIFRlc3RzIHRoZSBmaW5hbCBhcmd1bWVudCBieSBwYXNzaW5nIGl0IHRvIHRoZSBnaXZlbiBwcmVkaWNhdGUgZnVuY3Rpb24uIElmXG4gICAgICogdGhlIHByZWRpY2F0ZSBpcyBzYXRpc2ZpZWQsIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgcmVzdWx0IG9mIGNhbGxpbmdcbiAgICAgKiB0aGUgYHdoZW5UcnVlRm5gIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgYXJndW1lbnQuIElmIHRoZSBwcmVkaWNhdGUgaXMgbm90XG4gICAgICogc2F0aXNmaWVkLCB0aGUgYXJndW1lbnQgaXMgcmV0dXJuZWQgYXMgaXMuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjE4LjBcbiAgICAgKiBAY2F0ZWdvcnkgTG9naWNcbiAgICAgKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IChhIC0+IGEpIC0+IGEgLT4gYVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWQgICAgICAgQSBwcmVkaWNhdGUgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB3aGVuVHJ1ZUZuIEEgZnVuY3Rpb24gdG8gaW52b2tlIHdoZW4gdGhlIGBjb25kaXRpb25gXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmFsdWF0ZXMgdG8gYSB0cnV0aHkgdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSAgICAgICAgeCAgICAgICAgICBBbiBvYmplY3QgdG8gdGVzdCB3aXRoIHRoZSBgcHJlZGAgZnVuY3Rpb24gYW5kXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXNzIHRvIGB3aGVuVHJ1ZUZuYCBpZiBuZWNlc3NhcnkuXG4gICAgICogQHJldHVybiB7Kn0gRWl0aGVyIGB4YCBvciB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIGB4YCB0byBgd2hlblRydWVGbmAuXG4gICAgICogQHNlZSBSLmlmRWxzZSwgUi51bmxlc3NcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICAvLyB0cnVuY2F0ZSA6OiBTdHJpbmcgLT4gU3RyaW5nXG4gICAgICogICAgICB2YXIgdHJ1bmNhdGUgPSBSLndoZW4oXG4gICAgICogICAgICAgIFIucHJvcFNhdGlzZmllcyhSLmd0KFIuX18sIDEwKSwgJ2xlbmd0aCcpLFxuICAgICAqICAgICAgICBSLnBpcGUoUi50YWtlKDEwKSwgUi5hcHBlbmQoJ+KApicpLCBSLmpvaW4oJycpKVxuICAgICAqICAgICAgKTtcbiAgICAgKiAgICAgIHRydW5jYXRlKCcxMjM0NScpOyAgICAgICAgIC8vPT4gJzEyMzQ1J1xuICAgICAqICAgICAgdHJ1bmNhdGUoJzAxMjM0NTY3ODlBQkMnKTsgLy89PiAnMDEyMzQ1Njc4OeKApidcbiAgICAgKi9cbiAgICB2YXIgd2hlbiA9IF9jdXJyeTMoZnVuY3Rpb24gd2hlbihwcmVkLCB3aGVuVHJ1ZUZuLCB4KSB7XG4gICAgICAgIHJldHVybiBwcmVkKHgpID8gd2hlblRydWVGbih4KSA6IHg7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUYWtlcyBhIHNwZWMgb2JqZWN0IGFuZCBhIHRlc3Qgb2JqZWN0OyByZXR1cm5zIHRydWUgaWYgdGhlIHRlc3Qgc2F0aXNmaWVzXG4gICAgICogdGhlIHNwZWMuIEVhY2ggb2YgdGhlIHNwZWMncyBvd24gcHJvcGVydGllcyBtdXN0IGJlIGEgcHJlZGljYXRlIGZ1bmN0aW9uLlxuICAgICAqIEVhY2ggcHJlZGljYXRlIGlzIGFwcGxpZWQgdG8gdGhlIHZhbHVlIG9mIHRoZSBjb3JyZXNwb25kaW5nIHByb3BlcnR5IG9mIHRoZVxuICAgICAqIHRlc3Qgb2JqZWN0LiBgd2hlcmVgIHJldHVybnMgdHJ1ZSBpZiBhbGwgdGhlIHByZWRpY2F0ZXMgcmV0dXJuIHRydWUsIGZhbHNlXG4gICAgICogb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogYHdoZXJlYCBpcyB3ZWxsIHN1aXRlZCB0byBkZWNsYXJhdGl2ZWx5IGV4cHJlc3NpbmcgY29uc3RyYWludHMgZm9yIG90aGVyXG4gICAgICogZnVuY3Rpb25zIHN1Y2ggYXMgYGZpbHRlcmAgYW5kIGBmaW5kYC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4xXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBzaWcge1N0cmluZzogKCogLT4gQm9vbGVhbil9IC0+IHtTdHJpbmc6ICp9IC0+IEJvb2xlYW5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3BlY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0ZXN0T2JqXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICAvLyBwcmVkIDo6IE9iamVjdCAtPiBCb29sZWFuXG4gICAgICogICAgICB2YXIgcHJlZCA9IFIud2hlcmUoe1xuICAgICAqICAgICAgICBhOiBSLmVxdWFscygnZm9vJyksXG4gICAgICogICAgICAgIGI6IFIuY29tcGxlbWVudChSLmVxdWFscygnYmFyJykpLFxuICAgICAqICAgICAgICB4OiBSLmd0KF8sIDEwKSxcbiAgICAgKiAgICAgICAgeTogUi5sdChfLCAyMClcbiAgICAgKiAgICAgIH0pO1xuICAgICAqXG4gICAgICogICAgICBwcmVkKHthOiAnZm9vJywgYjogJ3h4eCcsIHg6IDExLCB5OiAxOX0pOyAvLz0+IHRydWVcbiAgICAgKiAgICAgIHByZWQoe2E6ICd4eHgnLCBiOiAneHh4JywgeDogMTEsIHk6IDE5fSk7IC8vPT4gZmFsc2VcbiAgICAgKiAgICAgIHByZWQoe2E6ICdmb28nLCBiOiAnYmFyJywgeDogMTEsIHk6IDE5fSk7IC8vPT4gZmFsc2VcbiAgICAgKiAgICAgIHByZWQoe2E6ICdmb28nLCBiOiAneHh4JywgeDogMTAsIHk6IDE5fSk7IC8vPT4gZmFsc2VcbiAgICAgKiAgICAgIHByZWQoe2E6ICdmb28nLCBiOiAneHh4JywgeDogMTEsIHk6IDIwfSk7IC8vPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgd2hlcmUgPSBfY3VycnkyKGZ1bmN0aW9uIHdoZXJlKHNwZWMsIHRlc3RPYmopIHtcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBzcGVjKSB7XG4gICAgICAgICAgICBpZiAoX2hhcyhwcm9wLCBzcGVjKSAmJiAhc3BlY1twcm9wXSh0ZXN0T2JqW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFdyYXAgYSBmdW5jdGlvbiBpbnNpZGUgYW5vdGhlciB0byBhbGxvdyB5b3UgdG8gbWFrZSBhZGp1c3RtZW50cyB0byB0aGVcbiAgICAgKiBwYXJhbWV0ZXJzLCBvciBkbyBvdGhlciBwcm9jZXNzaW5nIGVpdGhlciBiZWZvcmUgdGhlIGludGVybmFsIGZ1bmN0aW9uIGlzXG4gICAgICogY2FsbGVkIG9yIHdpdGggaXRzIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBzaWcgKGEuLi4gLT4gYikgLT4gKChhLi4uIC0+IGIpIC0+IGEuLi4gLT4gYykgLT4gKGEuLi4gLT4gYylcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB3cmFwcGVyIFRoZSB3cmFwcGVyIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgZ3JlZXQgPSBuYW1lID0+ICdIZWxsbyAnICsgbmFtZTtcbiAgICAgKlxuICAgICAqICAgICAgdmFyIHNob3V0ZWRHcmVldCA9IFIud3JhcChncmVldCwgKGdyLCBuYW1lKSA9PiBncihuYW1lKS50b1VwcGVyQ2FzZSgpKTtcbiAgICAgKlxuICAgICAqICAgICAgc2hvdXRlZEdyZWV0KFwiS2F0aHlcIik7IC8vPT4gXCJIRUxMTyBLQVRIWVwiXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBzaG9ydGVuZWRHcmVldCA9IFIud3JhcChncmVldCwgZnVuY3Rpb24oZ3IsIG5hbWUpIHtcbiAgICAgKiAgICAgICAgcmV0dXJuIGdyKG5hbWUuc3Vic3RyaW5nKDAsIDMpKTtcbiAgICAgKiAgICAgIH0pO1xuICAgICAqICAgICAgc2hvcnRlbmVkR3JlZXQoXCJSb2JlcnRcIik7IC8vPT4gXCJIZWxsbyBSb2JcIlxuICAgICAqL1xuICAgIHZhciB3cmFwID0gX2N1cnJ5MihmdW5jdGlvbiB3cmFwKGZuLCB3cmFwcGVyKSB7XG4gICAgICAgIHJldHVybiBjdXJyeU4oZm4ubGVuZ3RoLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gd3JhcHBlci5hcHBseSh0aGlzLCBfY29uY2F0KFtmbl0sIGFyZ3VtZW50cykpO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgbGlzdCBvdXQgb2YgdGhlIHR3byBzdXBwbGllZCBieSBjcmVhdGluZyBlYWNoIHBvc3NpYmxlIHBhaXJcbiAgICAgKiBmcm9tIHRoZSBsaXN0cy5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIFthXSAtPiBbYl0gLT4gW1thLGJdXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFzIFRoZSBmaXJzdCBsaXN0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGJzIFRoZSBzZWNvbmQgbGlzdC5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGxpc3QgbWFkZSBieSBjb21iaW5pbmcgZWFjaCBwb3NzaWJsZSBwYWlyIGZyb21cbiAgICAgKiAgICAgICAgIGBhc2AgYW5kIGBic2AgaW50byBwYWlycyAoYFthLCBiXWApLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIueHByb2QoWzEsIDJdLCBbJ2EnLCAnYiddKTsgLy89PiBbWzEsICdhJ10sIFsxLCAnYiddLCBbMiwgJ2EnXSwgWzIsICdiJ11dXG4gICAgICovXG4gICAgLy8gPSB4cHJvZFdpdGgocHJlcGVuZCk7ICh0YWtlcyBhYm91dCAzIHRpbWVzIGFzIGxvbmcuLi4pXG4gICAgdmFyIHhwcm9kID0gX2N1cnJ5MihmdW5jdGlvbiB4cHJvZChhLCBiKSB7XG4gICAgICAgIC8vID0geHByb2RXaXRoKHByZXBlbmQpOyAodGFrZXMgYWJvdXQgMyB0aW1lcyBhcyBsb25nLi4uKVxuICAgICAgICB2YXIgaWR4ID0gMDtcbiAgICAgICAgdmFyIGlsZW4gPSBhLmxlbmd0aDtcbiAgICAgICAgdmFyIGo7XG4gICAgICAgIHZhciBqbGVuID0gYi5sZW5ndGg7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgd2hpbGUgKGlkeCA8IGlsZW4pIHtcbiAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGogPCBqbGVuKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gW1xuICAgICAgICAgICAgICAgICAgICBhW2lkeF0sXG4gICAgICAgICAgICAgICAgICAgIGJbal1cbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIGogKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGxpc3Qgb3V0IG9mIHRoZSB0d28gc3VwcGxpZWQgYnkgcGFpcmluZyB1cCBlcXVhbGx5LXBvc2l0aW9uZWRcbiAgICAgKiBpdGVtcyBmcm9tIGJvdGggbGlzdHMuIFRoZSByZXR1cm5lZCBsaXN0IGlzIHRydW5jYXRlZCB0byB0aGUgbGVuZ3RoIG9mIHRoZVxuICAgICAqIHNob3J0ZXIgb2YgdGhlIHR3byBpbnB1dCBsaXN0cy5cbiAgICAgKiBOb3RlOiBgemlwYCBpcyBlcXVpdmFsZW50IHRvIGB6aXBXaXRoKGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIFthLCBiXSB9KWAuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyBbYV0gLT4gW2JdIC0+IFtbYSxiXV1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0MSBUaGUgZmlyc3QgYXJyYXkgdG8gY29uc2lkZXIuXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdDIgVGhlIHNlY29uZCBhcnJheSB0byBjb25zaWRlci5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGxpc3QgbWFkZSBieSBwYWlyaW5nIHVwIHNhbWUtaW5kZXhlZCBlbGVtZW50cyBvZiBgbGlzdDFgIGFuZCBgbGlzdDJgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuemlwKFsxLCAyLCAzXSwgWydhJywgJ2InLCAnYyddKTsgLy89PiBbWzEsICdhJ10sIFsyLCAnYiddLCBbMywgJ2MnXV1cbiAgICAgKi9cbiAgICB2YXIgemlwID0gX2N1cnJ5MihmdW5jdGlvbiB6aXAoYSwgYikge1xuICAgICAgICB2YXIgcnYgPSBbXTtcbiAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgIHZhciBsZW4gPSBNYXRoLm1pbihhLmxlbmd0aCwgYi5sZW5ndGgpO1xuICAgICAgICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgICAgICAgICBydltpZHhdID0gW1xuICAgICAgICAgICAgICAgIGFbaWR4XSxcbiAgICAgICAgICAgICAgICBiW2lkeF1cbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnY7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IG9iamVjdCBvdXQgb2YgYSBsaXN0IG9mIGtleXMgYW5kIGEgbGlzdCBvZiB2YWx1ZXMuXG4gICAgICogS2V5L3ZhbHVlIHBhaXJpbmcgaXMgdHJ1bmNhdGVkIHRvIHRoZSBsZW5ndGggb2YgdGhlIHNob3J0ZXIgb2YgdGhlIHR3byBsaXN0cy5cbiAgICAgKiBOb3RlOiBgemlwT2JqYCBpcyBlcXVpdmFsZW50IHRvIGBwaXBlKHppcFdpdGgocGFpciksIGZyb21QYWlycylgLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgW1N0cmluZ10gLT4gWypdIC0+IHtTdHJpbmc6ICp9XG4gICAgICogQHBhcmFtIHtBcnJheX0ga2V5cyBUaGUgYXJyYXkgdGhhdCB3aWxsIGJlIHByb3BlcnRpZXMgb24gdGhlIG91dHB1dCBvYmplY3QuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSBsaXN0IG9mIHZhbHVlcyBvbiB0aGUgb3V0cHV0IG9iamVjdC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBvYmplY3QgbWFkZSBieSBwYWlyaW5nIHVwIHNhbWUtaW5kZXhlZCBlbGVtZW50cyBvZiBga2V5c2AgYW5kIGB2YWx1ZXNgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuemlwT2JqKFsnYScsICdiJywgJ2MnXSwgWzEsIDIsIDNdKTsgLy89PiB7YTogMSwgYjogMiwgYzogM31cbiAgICAgKi9cbiAgICB2YXIgemlwT2JqID0gX2N1cnJ5MihmdW5jdGlvbiB6aXBPYmooa2V5cywgdmFsdWVzKSB7XG4gICAgICAgIHZhciBpZHggPSAwO1xuICAgICAgICB2YXIgbGVuID0gTWF0aC5taW4oa2V5cy5sZW5ndGgsIHZhbHVlcy5sZW5ndGgpO1xuICAgICAgICB2YXIgb3V0ID0ge307XG4gICAgICAgIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICAgICAgICAgIG91dFtrZXlzW2lkeF1dID0gdmFsdWVzW2lkeF07XG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBsaXN0IG91dCBvZiB0aGUgdHdvIHN1cHBsaWVkIGJ5IGFwcGx5aW5nIHRoZSBmdW5jdGlvbiB0byBlYWNoXG4gICAgICogZXF1YWxseS1wb3NpdGlvbmVkIHBhaXIgaW4gdGhlIGxpc3RzLiBUaGUgcmV0dXJuZWQgbGlzdCBpcyB0cnVuY2F0ZWQgdG8gdGhlXG4gICAgICogbGVuZ3RoIG9mIHRoZSBzaG9ydGVyIG9mIHRoZSB0d28gaW5wdXQgbGlzdHMuXG4gICAgICpcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgKGEsYiAtPiBjKSAtPiBbYV0gLT4gW2JdIC0+IFtjXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGNvbWJpbmUgdGhlIHR3byBlbGVtZW50cyBpbnRvIG9uZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0MSBUaGUgZmlyc3QgYXJyYXkgdG8gY29uc2lkZXIuXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdDIgVGhlIHNlY29uZCBhcnJheSB0byBjb25zaWRlci5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGxpc3QgbWFkZSBieSBjb21iaW5pbmcgc2FtZS1pbmRleGVkIGVsZW1lbnRzIG9mIGBsaXN0MWAgYW5kIGBsaXN0MmBcbiAgICAgKiAgICAgICAgIHVzaW5nIGBmbmAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGYgPSAoeCwgeSkgPT4ge1xuICAgICAqICAgICAgICAvLyAuLi5cbiAgICAgKiAgICAgIH07XG4gICAgICogICAgICBSLnppcFdpdGgoZiwgWzEsIDIsIDNdLCBbJ2EnLCAnYicsICdjJ10pO1xuICAgICAqICAgICAgLy89PiBbZigxLCAnYScpLCBmKDIsICdiJyksIGYoMywgJ2MnKV1cbiAgICAgKi9cbiAgICB2YXIgemlwV2l0aCA9IF9jdXJyeTMoZnVuY3Rpb24gemlwV2l0aChmbiwgYSwgYikge1xuICAgICAgICB2YXIgcnYgPSBbXTtcbiAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgIHZhciBsZW4gPSBNYXRoLm1pbihhLmxlbmd0aCwgYi5sZW5ndGgpO1xuICAgICAgICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgICAgICAgICBydltpZHhdID0gZm4oYVtpZHhdLCBiW2lkeF0pO1xuICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB0aGF0IGFsd2F5cyByZXR1cm5zIGBmYWxzZWAuIEFueSBwYXNzZWQgaW4gcGFyYW1ldGVycyBhcmUgaWdub3JlZC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuOS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHNpZyAqIC0+IEJvb2xlYW5cbiAgICAgKiBAcGFyYW0geyp9XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKiBAc2VlIFIuYWx3YXlzLCBSLlRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLkYoKTsgLy89PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBGID0gYWx3YXlzKGZhbHNlKTtcblxuICAgIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gdGhhdCBhbHdheXMgcmV0dXJucyBgdHJ1ZWAuIEFueSBwYXNzZWQgaW4gcGFyYW1ldGVycyBhcmUgaWdub3JlZC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuOS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHNpZyAqIC0+IEJvb2xlYW5cbiAgICAgKiBAcGFyYW0geyp9XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKiBAc2VlIFIuYWx3YXlzLCBSLkZcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLlQoKTsgLy89PiB0cnVlXG4gICAgICovXG4gICAgdmFyIFQgPSBhbHdheXModHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgYW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBiZSBjb3BpZWRcbiAgICAgKiBAcGFyYW0ge0FycmF5fSByZWZGcm9tIEFycmF5IGNvbnRhaW5pbmcgdGhlIHNvdXJjZSByZWZlcmVuY2VzXG4gICAgICogQHBhcmFtIHtBcnJheX0gcmVmVG8gQXJyYXkgY29udGFpbmluZyB0aGUgY29waWVkIHNvdXJjZSByZWZlcmVuY2VzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBkZWVwIFdoZXRoZXIgb3Igbm90IHRvIHBlcmZvcm0gZGVlcCBjbG9uaW5nLlxuICAgICAqIEByZXR1cm4geyp9IFRoZSBjb3BpZWQgdmFsdWUuXG4gICAgICovXG4gICAgdmFyIF9jbG9uZSA9IGZ1bmN0aW9uIF9jbG9uZSh2YWx1ZSwgcmVmRnJvbSwgcmVmVG8sIGRlZXApIHtcbiAgICAgICAgdmFyIGNvcHkgPSBmdW5jdGlvbiBjb3B5KGNvcGllZFZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gcmVmRnJvbS5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgaWR4ID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHJlZkZyb21baWR4XSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVmVG9baWR4XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWZGcm9tW2lkeCArIDFdID0gdmFsdWU7XG4gICAgICAgICAgICByZWZUb1tpZHggKyAxXSA9IGNvcGllZFZhbHVlO1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY29waWVkVmFsdWVba2V5XSA9IGRlZXAgPyBfY2xvbmUodmFsdWVba2V5XSwgcmVmRnJvbSwgcmVmVG8sIHRydWUpIDogdmFsdWVba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb3BpZWRWYWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgc3dpdGNoICh0eXBlKHZhbHVlKSkge1xuICAgICAgICBjYXNlICdPYmplY3QnOlxuICAgICAgICAgICAgcmV0dXJuIGNvcHkoe30pO1xuICAgICAgICBjYXNlICdBcnJheSc6XG4gICAgICAgICAgICByZXR1cm4gY29weShbXSk7XG4gICAgICAgIGNhc2UgJ0RhdGUnOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHZhbHVlLnZhbHVlT2YoKSk7XG4gICAgICAgIGNhc2UgJ1JlZ0V4cCc6XG4gICAgICAgICAgICByZXR1cm4gX2Nsb25lUmVnRXhwKHZhbHVlKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgX2NyZWF0ZVBhcnRpYWxBcHBsaWNhdG9yID0gZnVuY3Rpb24gX2NyZWF0ZVBhcnRpYWxBcHBsaWNhdG9yKGNvbmNhdCkge1xuICAgICAgICByZXR1cm4gX2N1cnJ5MihmdW5jdGlvbiAoZm4sIGFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBfYXJpdHkoTWF0aC5tYXgoMCwgZm4ubGVuZ3RoIC0gYXJncy5sZW5ndGgpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGNvbmNhdChhcmdzLCBhcmd1bWVudHMpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIF9kcm9wTGFzdCA9IGZ1bmN0aW9uIGRyb3BMYXN0KG4sIHhzKSB7XG4gICAgICAgIHJldHVybiB0YWtlKG4gPCB4cy5sZW5ndGggPyB4cy5sZW5ndGggLSBuIDogMCwgeHMpO1xuICAgIH07XG5cbiAgICAvLyBWYWx1ZXMgb2Ygb3RoZXIgdHlwZXMgYXJlIG9ubHkgZXF1YWwgaWYgaWRlbnRpY2FsLlxuICAgIHZhciBfZXF1YWxzID0gZnVuY3Rpb24gX2VxdWFscyhhLCBiLCBzdGFja0EsIHN0YWNrQikge1xuICAgICAgICBpZiAoaWRlbnRpY2FsKGEsIGIpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZShhKSAhPT0gdHlwZShiKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBhLmVxdWFscyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYi5lcXVhbHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYS5lcXVhbHMgPT09ICdmdW5jdGlvbicgJiYgYS5lcXVhbHMoYikgJiYgdHlwZW9mIGIuZXF1YWxzID09PSAnZnVuY3Rpb24nICYmIGIuZXF1YWxzKGEpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodHlwZShhKSkge1xuICAgICAgICBjYXNlICdBcmd1bWVudHMnOlxuICAgICAgICBjYXNlICdBcnJheSc6XG4gICAgICAgIGNhc2UgJ09iamVjdCc6XG4gICAgICAgICAgICBpZiAodHlwZW9mIGEuY29uc3RydWN0b3IgPT09ICdmdW5jdGlvbicgJiYgX2Z1bmN0aW9uTmFtZShhLmNvbnN0cnVjdG9yKSA9PT0gJ1Byb21pc2UnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEgPT09IGI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnQm9vbGVhbic6XG4gICAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICAgIGNhc2UgJ1N0cmluZyc6XG4gICAgICAgICAgICBpZiAoISh0eXBlb2YgYSA9PT0gdHlwZW9mIGIgJiYgaWRlbnRpY2FsKGEudmFsdWVPZigpLCBiLnZhbHVlT2YoKSkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0RhdGUnOlxuICAgICAgICAgICAgaWYgKCFpZGVudGljYWwoYS52YWx1ZU9mKCksIGIudmFsdWVPZigpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdFcnJvcic6XG4gICAgICAgICAgICByZXR1cm4gYS5uYW1lID09PSBiLm5hbWUgJiYgYS5tZXNzYWdlID09PSBiLm1lc3NhZ2U7XG4gICAgICAgIGNhc2UgJ1JlZ0V4cCc6XG4gICAgICAgICAgICBpZiAoIShhLnNvdXJjZSA9PT0gYi5zb3VyY2UgJiYgYS5nbG9iYWwgPT09IGIuZ2xvYmFsICYmIGEuaWdub3JlQ2FzZSA9PT0gYi5pZ25vcmVDYXNlICYmIGEubXVsdGlsaW5lID09PSBiLm11bHRpbGluZSAmJiBhLnN0aWNreSA9PT0gYi5zdGlja3kgJiYgYS51bmljb2RlID09PSBiLnVuaWNvZGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ01hcCc6XG4gICAgICAgIGNhc2UgJ1NldCc6XG4gICAgICAgICAgICBpZiAoIV9lcXVhbHMoX2FycmF5RnJvbUl0ZXJhdG9yKGEuZW50cmllcygpKSwgX2FycmF5RnJvbUl0ZXJhdG9yKGIuZW50cmllcygpKSwgc3RhY2tBLCBzdGFja0IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0ludDhBcnJheSc6XG4gICAgICAgIGNhc2UgJ1VpbnQ4QXJyYXknOlxuICAgICAgICBjYXNlICdVaW50OENsYW1wZWRBcnJheSc6XG4gICAgICAgIGNhc2UgJ0ludDE2QXJyYXknOlxuICAgICAgICBjYXNlICdVaW50MTZBcnJheSc6XG4gICAgICAgIGNhc2UgJ0ludDMyQXJyYXknOlxuICAgICAgICBjYXNlICdVaW50MzJBcnJheSc6XG4gICAgICAgIGNhc2UgJ0Zsb2F0MzJBcnJheSc6XG4gICAgICAgIGNhc2UgJ0Zsb2F0NjRBcnJheSc6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnQXJyYXlCdWZmZXInOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyBWYWx1ZXMgb2Ygb3RoZXIgdHlwZXMgYXJlIG9ubHkgZXF1YWwgaWYgaWRlbnRpY2FsLlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrZXlzQSA9IGtleXMoYSk7XG4gICAgICAgIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXMoYikubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlkeCA9IHN0YWNrQS5sZW5ndGggLSAxO1xuICAgICAgICB3aGlsZSAoaWR4ID49IDApIHtcbiAgICAgICAgICAgIGlmIChzdGFja0FbaWR4XSA9PT0gYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGFja0JbaWR4XSA9PT0gYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlkeCAtPSAxO1xuICAgICAgICB9XG4gICAgICAgIHN0YWNrQS5wdXNoKGEpO1xuICAgICAgICBzdGFja0IucHVzaChiKTtcbiAgICAgICAgaWR4ID0ga2V5c0EubGVuZ3RoIC0gMTtcbiAgICAgICAgd2hpbGUgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c0FbaWR4XTtcbiAgICAgICAgICAgIGlmICghKF9oYXMoa2V5LCBiKSAmJiBfZXF1YWxzKGJba2V5XSwgYVtrZXldLCBzdGFja0EsIHN0YWNrQikpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWR4IC09IDE7XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2tBLnBvcCgpO1xuICAgICAgICBzdGFja0IucG9wKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBgX21ha2VGbGF0YCBpcyBhIGhlbHBlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBvbmUtbGV2ZWwgb3IgZnVsbHkgcmVjdXJzaXZlXG4gICAgICogZnVuY3Rpb24gYmFzZWQgb24gdGhlIGZsYWcgcGFzc2VkIGluLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB2YXIgX21ha2VGbGF0ID0gZnVuY3Rpb24gX21ha2VGbGF0KHJlY3Vyc2l2ZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gZmxhdHQobGlzdCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlLCBqbGVuLCBqO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgICAgICB2YXIgaWxlbiA9IGxpc3QubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGlkeCA8IGlsZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNBcnJheUxpa2UobGlzdFtpZHhdKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlY3Vyc2l2ZSA/IGZsYXR0KGxpc3RbaWR4XSkgOiBsaXN0W2lkeF07XG4gICAgICAgICAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgICAgICAgICBqbGVuID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaiA8IGpsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHZhbHVlW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaiArPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gbGlzdFtpZHhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBfcmVkdWNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBfYXJyYXlSZWR1Y2UoeGYsIGFjYywgbGlzdCkge1xuICAgICAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgICAgICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgYWNjID0geGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10oYWNjLCBsaXN0W2lkeF0pO1xuICAgICAgICAgICAgICAgIGlmIChhY2MgJiYgYWNjWydAQHRyYW5zZHVjZXIvcmVkdWNlZCddKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjYyA9IGFjY1snQEB0cmFuc2R1Y2VyL3ZhbHVlJ107XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB4ZlsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKGFjYyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gX2l0ZXJhYmxlUmVkdWNlKHhmLCBhY2MsIGl0ZXIpIHtcbiAgICAgICAgICAgIHZhciBzdGVwID0gaXRlci5uZXh0KCk7XG4gICAgICAgICAgICB3aGlsZSAoIXN0ZXAuZG9uZSkge1xuICAgICAgICAgICAgICAgIGFjYyA9IHhmWydAQHRyYW5zZHVjZXIvc3RlcCddKGFjYywgc3RlcC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGFjYyAmJiBhY2NbJ0BAdHJhbnNkdWNlci9yZWR1Y2VkJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjID0gYWNjWydAQHRyYW5zZHVjZXIvdmFsdWUnXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0ZXAgPSBpdGVyLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB4ZlsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKGFjYyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gX21ldGhvZFJlZHVjZSh4ZiwgYWNjLCBvYmopIHtcbiAgICAgICAgICAgIHJldHVybiB4ZlsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKG9iai5yZWR1Y2UoYmluZCh4ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSwgeGYpLCBhY2MpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3ltSXRlcmF0b3IgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyA/IFN5bWJvbC5pdGVyYXRvciA6ICdAQGl0ZXJhdG9yJztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIF9yZWR1Y2UoZm4sIGFjYywgbGlzdCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGZuID0gX3h3cmFwKGZuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0FycmF5TGlrZShsaXN0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfYXJyYXlSZWR1Y2UoZm4sIGFjYywgbGlzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxpc3QucmVkdWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9tZXRob2RSZWR1Y2UoZm4sIGFjYywgbGlzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGlzdFtzeW1JdGVyYXRvcl0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfaXRlcmFibGVSZWR1Y2UoZm4sIGFjYywgbGlzdFtzeW1JdGVyYXRvcl0oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxpc3QubmV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBfaXRlcmFibGVSZWR1Y2UoZm4sIGFjYywgbGlzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdyZWR1Y2U6IGxpc3QgbXVzdCBiZSBhcnJheSBvciBpdGVyYWJsZScpO1xuICAgICAgICB9O1xuICAgIH0oKTtcblxuICAgIHZhciBfc3RlcENhdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9zdGVwQ2F0QXJyYXkgPSB7XG4gICAgICAgICAgICAnQEB0cmFuc2R1Y2VyL2luaXQnOiBBcnJheSxcbiAgICAgICAgICAgICdAQHRyYW5zZHVjZXIvc3RlcCc6IGZ1bmN0aW9uICh4cywgeCkge1xuICAgICAgICAgICAgICAgIHhzLnB1c2goeCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHhzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdAQHRyYW5zZHVjZXIvcmVzdWx0JzogX2lkZW50aXR5XG4gICAgICAgIH07XG4gICAgICAgIHZhciBfc3RlcENhdFN0cmluZyA9IHtcbiAgICAgICAgICAgICdAQHRyYW5zZHVjZXIvaW5pdCc6IFN0cmluZyxcbiAgICAgICAgICAgICdAQHRyYW5zZHVjZXIvc3RlcCc6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEgKyBiO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdAQHRyYW5zZHVjZXIvcmVzdWx0JzogX2lkZW50aXR5XG4gICAgICAgIH07XG4gICAgICAgIHZhciBfc3RlcENhdE9iamVjdCA9IHtcbiAgICAgICAgICAgICdAQHRyYW5zZHVjZXIvaW5pdCc6IE9iamVjdCxcbiAgICAgICAgICAgICdAQHRyYW5zZHVjZXIvc3RlcCc6IGZ1bmN0aW9uIChyZXN1bHQsIGlucHV0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9hc3NpZ24ocmVzdWx0LCBpc0FycmF5TGlrZShpbnB1dCkgPyBvYmpPZihpbnB1dFswXSwgaW5wdXRbMV0pIDogaW5wdXQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdAQHRyYW5zZHVjZXIvcmVzdWx0JzogX2lkZW50aXR5XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBfc3RlcENhdChvYmopIHtcbiAgICAgICAgICAgIGlmIChfaXNUcmFuc2Zvcm1lcihvYmopKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0FycmF5TGlrZShvYmopKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zdGVwQ2F0QXJyYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N0ZXBDYXRTdHJpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N0ZXBDYXRPYmplY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjcmVhdGUgdHJhbnNmb3JtZXIgZm9yICcgKyBvYmopO1xuICAgICAgICB9O1xuICAgIH0oKTtcblxuICAgIHZhciBfeGRyb3BMYXN0V2hpbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFhEcm9wTGFzdFdoaWxlKGZuLCB4Zikge1xuICAgICAgICAgICAgdGhpcy5mID0gZm47XG4gICAgICAgICAgICB0aGlzLnJldGFpbmVkID0gW107XG4gICAgICAgICAgICB0aGlzLnhmID0geGY7XG4gICAgICAgIH1cbiAgICAgICAgWERyb3BMYXN0V2hpbGUucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gX3hmQmFzZS5pbml0O1xuICAgICAgICBYRHJvcExhc3RXaGlsZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXMucmV0YWluZWQgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMueGZbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXShyZXN1bHQpO1xuICAgICAgICB9O1xuICAgICAgICBYRHJvcExhc3RXaGlsZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbiAocmVzdWx0LCBpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZihpbnB1dCkgPyB0aGlzLnJldGFpbihyZXN1bHQsIGlucHV0KSA6IHRoaXMuZmx1c2gocmVzdWx0LCBpbnB1dCk7XG4gICAgICAgIH07XG4gICAgICAgIFhEcm9wTGFzdFdoaWxlLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uIChyZXN1bHQsIGlucHV0KSB7XG4gICAgICAgICAgICByZXN1bHQgPSBfcmVkdWNlKHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10sIHJlc3VsdCwgdGhpcy5yZXRhaW5lZCk7XG4gICAgICAgICAgICB0aGlzLnJldGFpbmVkID0gW107XG4gICAgICAgICAgICByZXR1cm4gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIGlucHV0KTtcbiAgICAgICAgfTtcbiAgICAgICAgWERyb3BMYXN0V2hpbGUucHJvdG90eXBlLnJldGFpbiA9IGZ1bmN0aW9uIChyZXN1bHQsIGlucHV0KSB7XG4gICAgICAgICAgICB0aGlzLnJldGFpbmVkLnB1c2goaW5wdXQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF9jdXJyeTIoZnVuY3Rpb24gX3hkcm9wTGFzdFdoaWxlKGZuLCB4Zikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBYRHJvcExhc3RXaGlsZShmbiwgeGYpO1xuICAgICAgICB9KTtcbiAgICB9KCk7XG5cbiAgICB2YXIgX3hncm91cEJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBYR3JvdXBCeShmLCB4Zikge1xuICAgICAgICAgICAgdGhpcy54ZiA9IHhmO1xuICAgICAgICAgICAgdGhpcy5mID0gZjtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgWEdyb3VwQnkucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gX3hmQmFzZS5pbml0O1xuICAgICAgICBYR3JvdXBCeS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHZhciBrZXk7XG4gICAgICAgICAgICBmb3IgKGtleSBpbiB0aGlzLmlucHV0cykge1xuICAgICAgICAgICAgICAgIGlmIChfaGFzKGtleSwgdGhpcy5pbnB1dHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCB0aGlzLmlucHV0c1trZXldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdFsnQEB0cmFuc2R1Y2VyL3JlZHVjZWQnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0WydAQHRyYW5zZHVjZXIvdmFsdWUnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pbnB1dHMgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMueGZbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXShyZXN1bHQpO1xuICAgICAgICB9O1xuICAgICAgICBYR3JvdXBCeS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbiAocmVzdWx0LCBpbnB1dCkge1xuICAgICAgICAgICAgdmFyIGtleSA9IHRoaXMuZihpbnB1dCk7XG4gICAgICAgICAgICB0aGlzLmlucHV0c1trZXldID0gdGhpcy5pbnB1dHNba2V5XSB8fCBbXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIFtdXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgdGhpcy5pbnB1dHNba2V5XVsxXSA9IGFwcGVuZChpbnB1dCwgdGhpcy5pbnB1dHNba2V5XVsxXSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX2N1cnJ5MihmdW5jdGlvbiBfeGdyb3VwQnkoZiwgeGYpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgWEdyb3VwQnkoZiwgeGYpO1xuICAgICAgICB9KTtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGxpc3QgaXRlcmF0aW9uIGZ1bmN0aW9uIGZyb20gYW4gZXhpc3Rpbmcgb25lIGJ5IGFkZGluZyB0d28gbmV3XG4gICAgICogcGFyYW1ldGVycyB0byBpdHMgY2FsbGJhY2sgZnVuY3Rpb246IHRoZSBjdXJyZW50IGluZGV4LCBhbmQgdGhlIGVudGlyZSBsaXN0LlxuICAgICAqXG4gICAgICogVGhpcyB3b3VsZCB0dXJuLCBmb3IgaW5zdGFuY2UsIFJhbWRhJ3Mgc2ltcGxlIGBtYXBgIGZ1bmN0aW9uIGludG8gb25lIHRoYXRcbiAgICAgKiBtb3JlIGNsb3NlbHkgcmVzZW1ibGVzIGBBcnJheS5wcm90b3R5cGUubWFwYC4gTm90ZSB0aGF0IHRoaXMgd2lsbCBvbmx5IHdvcmtcbiAgICAgKiBmb3IgZnVuY3Rpb25zIGluIHdoaWNoIHRoZSBpdGVyYXRpb24gY2FsbGJhY2sgZnVuY3Rpb24gaXMgdGhlIGZpcnN0XG4gICAgICogcGFyYW1ldGVyLCBhbmQgd2hlcmUgdGhlIGxpc3QgaXMgdGhlIGxhc3QgcGFyYW1ldGVyLiAoVGhpcyBsYXR0ZXIgbWlnaHQgYmVcbiAgICAgKiB1bmltcG9ydGFudCBpZiB0aGUgbGlzdCBwYXJhbWV0ZXIgaXMgbm90IHVzZWQuKVxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xNS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnICgoYSAuLi4gLT4gYikgLi4uIC0+IFthXSAtPiAqKSAtPiAoYSAuLi4sIEludCwgW2FdIC0+IGIpIC4uLiAtPiBbYV0gLT4gKilcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBBIGxpc3QgaXRlcmF0aW9uIGZ1bmN0aW9uIHRoYXQgZG9lcyBub3QgcGFzcyBpbmRleCBvciBsaXN0IHRvIGl0cyBjYWxsYmFja1xuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBbiBhbHRlcmVkIGxpc3QgaXRlcmF0aW9uIGZ1bmN0aW9uIHRoYXQgcGFzc2VzIChpdGVtLCBpbmRleCwgbGlzdCkgdG8gaXRzIGNhbGxiYWNrXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIG1hcEluZGV4ZWQgPSBSLmFkZEluZGV4KFIubWFwKTtcbiAgICAgKiAgICAgIG1hcEluZGV4ZWQoKHZhbCwgaWR4KSA9PiBpZHggKyAnLScgKyB2YWwsIFsnZicsICdvJywgJ28nLCAnYicsICdhJywgJ3InXSk7XG4gICAgICogICAgICAvLz0+IFsnMC1mJywgJzEtbycsICcyLW8nLCAnMy1iJywgJzQtYScsICc1LXInXVxuICAgICAqL1xuICAgIHZhciBhZGRJbmRleCA9IF9jdXJyeTEoZnVuY3Rpb24gYWRkSW5kZXgoZm4pIHtcbiAgICAgICAgcmV0dXJuIGN1cnJ5Tihmbi5sZW5ndGgsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpZHggPSAwO1xuICAgICAgICAgICAgdmFyIG9yaWdGbiA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIHZhciBsaXN0ID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHZhciBhcmdzID0gX3NsaWNlKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBhcmdzWzBdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBvcmlnRm4uYXBwbHkodGhpcywgX2NvbmNhdChhcmd1bWVudHMsIFtcbiAgICAgICAgICAgICAgICAgICAgaWR4LFxuICAgICAgICAgICAgICAgICAgICBsaXN0XG4gICAgICAgICAgICAgICAgXSkpO1xuICAgICAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFdyYXBzIGEgZnVuY3Rpb24gb2YgYW55IGFyaXR5IChpbmNsdWRpbmcgbnVsbGFyeSkgaW4gYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHNcbiAgICAgKiBleGFjdGx5IDIgcGFyYW1ldGVycy4gQW55IGV4dHJhbmVvdXMgcGFyYW1ldGVycyB3aWxsIG5vdCBiZSBwYXNzZWQgdG8gdGhlXG4gICAgICogc3VwcGxpZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjIuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBzaWcgKCogLT4gYykgLT4gKGEsIGIgLT4gYylcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBuZXcgZnVuY3Rpb24gd3JhcHBpbmcgYGZuYC4gVGhlIG5ldyBmdW5jdGlvbiBpcyBndWFyYW50ZWVkIHRvIGJlIG9mXG4gICAgICogICAgICAgICBhcml0eSAyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciB0YWtlc1RocmVlQXJncyA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgKiAgICAgICAgcmV0dXJuIFthLCBiLCBjXTtcbiAgICAgKiAgICAgIH07XG4gICAgICogICAgICB0YWtlc1RocmVlQXJncy5sZW5ndGg7IC8vPT4gM1xuICAgICAqICAgICAgdGFrZXNUaHJlZUFyZ3MoMSwgMiwgMyk7IC8vPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiAgICAgIHZhciB0YWtlc1R3b0FyZ3MgPSBSLmJpbmFyeSh0YWtlc1RocmVlQXJncyk7XG4gICAgICogICAgICB0YWtlc1R3b0FyZ3MubGVuZ3RoOyAvLz0+IDJcbiAgICAgKiAgICAgIC8vIE9ubHkgMiBhcmd1bWVudHMgYXJlIHBhc3NlZCB0byB0aGUgd3JhcHBlZCBmdW5jdGlvblxuICAgICAqICAgICAgdGFrZXNUd29BcmdzKDEsIDIsIDMpOyAvLz0+IFsxLCAyLCB1bmRlZmluZWRdXG4gICAgICovXG4gICAgdmFyIGJpbmFyeSA9IF9jdXJyeTEoZnVuY3Rpb24gYmluYXJ5KGZuKSB7XG4gICAgICAgIHJldHVybiBuQXJ5KDIsIGZuKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkZWVwIGNvcHkgb2YgdGhlIHZhbHVlIHdoaWNoIG1heSBjb250YWluIChuZXN0ZWQpIGBBcnJheWBzIGFuZFxuICAgICAqIGBPYmplY3RgcywgYE51bWJlcmBzLCBgU3RyaW5nYHMsIGBCb29sZWFuYHMgYW5kIGBEYXRlYHMuIGBGdW5jdGlvbmBzIGFyZSBub3RcbiAgICAgKiBjb3BpZWQsIGJ1dCBhc3NpZ25lZCBieSB0aGVpciByZWZlcmVuY2UuXG4gICAgICpcbiAgICAgKiBEaXNwYXRjaGVzIHRvIGEgYGNsb25lYCBtZXRob2QgaWYgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBzaWcgeyp9IC0+IHsqfVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIG9iamVjdCBvciBhcnJheSB0byBjbG9uZVxuICAgICAqIEByZXR1cm4geyp9IEEgbmV3IG9iamVjdCBvciBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgb2JqZWN0cyA9IFt7fSwge30sIHt9XTtcbiAgICAgKiAgICAgIHZhciBvYmplY3RzQ2xvbmUgPSBSLmNsb25lKG9iamVjdHMpO1xuICAgICAqICAgICAgb2JqZWN0c1swXSA9PT0gb2JqZWN0c0Nsb25lWzBdOyAvLz0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGNsb25lID0gX2N1cnJ5MShmdW5jdGlvbiBjbG9uZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUuY2xvbmUgPT09ICdmdW5jdGlvbicgPyB2YWx1ZS5jbG9uZSgpIDogX2Nsb25lKHZhbHVlLCBbXSwgW10sIHRydWUpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGN1cnJpZWQgZXF1aXZhbGVudCBvZiB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uIFRoZSBjdXJyaWVkIGZ1bmN0aW9uXG4gICAgICogaGFzIHR3byB1bnVzdWFsIGNhcGFiaWxpdGllcy4gRmlyc3QsIGl0cyBhcmd1bWVudHMgbmVlZG4ndCBiZSBwcm92aWRlZCBvbmVcbiAgICAgKiBhdCBhIHRpbWUuIElmIGBmYCBpcyBhIHRlcm5hcnkgZnVuY3Rpb24gYW5kIGBnYCBpcyBgUi5jdXJyeShmKWAsIHRoZVxuICAgICAqIGZvbGxvd2luZyBhcmUgZXF1aXZhbGVudDpcbiAgICAgKlxuICAgICAqICAgLSBgZygxKSgyKSgzKWBcbiAgICAgKiAgIC0gYGcoMSkoMiwgMylgXG4gICAgICogICAtIGBnKDEsIDIpKDMpYFxuICAgICAqICAgLSBgZygxLCAyLCAzKWBcbiAgICAgKlxuICAgICAqIFNlY29uZGx5LCB0aGUgc3BlY2lhbCBwbGFjZWhvbGRlciB2YWx1ZSBgUi5fX2AgbWF5IGJlIHVzZWQgdG8gc3BlY2lmeVxuICAgICAqIFwiZ2Fwc1wiLCBhbGxvd2luZyBwYXJ0aWFsIGFwcGxpY2F0aW9uIG9mIGFueSBjb21iaW5hdGlvbiBvZiBhcmd1bWVudHMsXG4gICAgICogcmVnYXJkbGVzcyBvZiB0aGVpciBwb3NpdGlvbnMuIElmIGBnYCBpcyBhcyBhYm92ZSBhbmQgYF9gIGlzIGBSLl9fYCwgdGhlXG4gICAgICogZm9sbG93aW5nIGFyZSBlcXVpdmFsZW50OlxuICAgICAqXG4gICAgICogICAtIGBnKDEsIDIsIDMpYFxuICAgICAqICAgLSBgZyhfLCAyLCAzKSgxKWBcbiAgICAgKiAgIC0gYGcoXywgXywgMykoMSkoMilgXG4gICAgICogICAtIGBnKF8sIF8sIDMpKDEsIDIpYFxuICAgICAqICAgLSBgZyhfLCAyKSgxKSgzKWBcbiAgICAgKiAgIC0gYGcoXywgMikoMSwgMylgXG4gICAgICogICAtIGBnKF8sIDIpKF8sIDMpKDEpYFxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAc2lnICgqIC0+IGEpIC0+ICgqIC0+IGEpXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIG5ldywgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKiBAc2VlIFIuY3VycnlOXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGFkZEZvdXJOdW1iZXJzID0gKGEsIGIsIGMsIGQpID0+IGEgKyBiICsgYyArIGQ7XG4gICAgICpcbiAgICAgKiAgICAgIHZhciBjdXJyaWVkQWRkRm91ck51bWJlcnMgPSBSLmN1cnJ5KGFkZEZvdXJOdW1iZXJzKTtcbiAgICAgKiAgICAgIHZhciBmID0gY3VycmllZEFkZEZvdXJOdW1iZXJzKDEsIDIpO1xuICAgICAqICAgICAgdmFyIGcgPSBmKDMpO1xuICAgICAqICAgICAgZyg0KTsgLy89PiAxMFxuICAgICAqL1xuICAgIHZhciBjdXJyeSA9IF9jdXJyeTEoZnVuY3Rpb24gY3VycnkoZm4pIHtcbiAgICAgICAgcmV0dXJuIGN1cnJ5Tihmbi5sZW5ndGgsIGZuKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIGJ1dCB0aGUgZmlyc3QgYG5gIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBsaXN0LCBzdHJpbmcsIG9yXG4gICAgICogdHJhbnNkdWNlci90cmFuc2Zvcm1lciAob3Igb2JqZWN0IHdpdGggYSBgZHJvcGAgbWV0aG9kKS5cbiAgICAgKlxuICAgICAqIERpc3BhdGNoZXMgdG8gdGhlIGBkcm9wYCBtZXRob2Qgb2YgdGhlIHNlY29uZCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIE51bWJlciAtPiBbYV0gLT4gW2FdXG4gICAgICogQHNpZyBOdW1iZXIgLT4gU3RyaW5nIC0+IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gICAgICogQHBhcmFtIHsqfSBsaXN0XG4gICAgICogQHJldHVybiB7Kn1cbiAgICAgKiBAc2VlIFIudGFrZSwgUi50cmFuc2R1Y2VcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLmRyb3AoMSwgWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiBbJ2JhcicsICdiYXonXVxuICAgICAqICAgICAgUi5kcm9wKDIsIFsnZm9vJywgJ2JhcicsICdiYXonXSk7IC8vPT4gWydiYXonXVxuICAgICAqICAgICAgUi5kcm9wKDMsIFsnZm9vJywgJ2JhcicsICdiYXonXSk7IC8vPT4gW11cbiAgICAgKiAgICAgIFIuZHJvcCg0LCBbJ2ZvbycsICdiYXInLCAnYmF6J10pOyAvLz0+IFtdXG4gICAgICogICAgICBSLmRyb3AoMywgJ3JhbWRhJyk7ICAgICAgICAgICAgICAgLy89PiAnZGEnXG4gICAgICovXG4gICAgdmFyIGRyb3AgPSBfY3VycnkyKF9kaXNwYXRjaGFibGUoJ2Ryb3AnLCBfeGRyb3AsIGZ1bmN0aW9uIGRyb3AobiwgeHMpIHtcbiAgICAgICAgcmV0dXJuIHNsaWNlKE1hdGgubWF4KDAsIG4pLCBJbmZpbml0eSwgeHMpO1xuICAgIH0pKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IGNvbnRhaW5pbmcgYWxsIGJ1dCB0aGUgbGFzdCBgbmAgZWxlbWVudHMgb2YgdGhlIGdpdmVuIGBsaXN0YC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTYuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyBOdW1iZXIgLT4gW2FdIC0+IFthXVxuICAgICAqIEBzaWcgTnVtYmVyIC0+IFN0cmluZyAtPiBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIG9mIGB4c2AgdG8gc2tpcC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB4cyBUaGUgY29sbGVjdGlvbiB0byBjb25zaWRlci5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKiBAc2VlIFIudGFrZUxhc3RcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLmRyb3BMYXN0KDEsIFsnZm9vJywgJ2JhcicsICdiYXonXSk7IC8vPT4gWydmb28nLCAnYmFyJ11cbiAgICAgKiAgICAgIFIuZHJvcExhc3QoMiwgWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiBbJ2ZvbyddXG4gICAgICogICAgICBSLmRyb3BMYXN0KDMsIFsnZm9vJywgJ2JhcicsICdiYXonXSk7IC8vPT4gW11cbiAgICAgKiAgICAgIFIuZHJvcExhc3QoNCwgWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiBbXVxuICAgICAqICAgICAgUi5kcm9wTGFzdCgzLCAncmFtZGEnKTsgICAgICAgICAgICAgICAvLz0+ICdyYSdcbiAgICAgKi9cbiAgICB2YXIgZHJvcExhc3QgPSBfY3VycnkyKF9kaXNwYXRjaGFibGUoJ2Ryb3BMYXN0JywgX3hkcm9wTGFzdCwgX2Ryb3BMYXN0KSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IGxpc3QgY29udGFpbmluZyBhbGwgYnV0IGxhc3QgdGhlYG5gIGVsZW1lbnRzIG9mIGEgZ2l2ZW4gbGlzdCxcbiAgICAgKiBwYXNzaW5nIGVhY2ggdmFsdWUgZnJvbSB0aGUgcmlnaHQgdG8gdGhlIHN1cHBsaWVkIHByZWRpY2F0ZSBmdW5jdGlvbixcbiAgICAgKiBza2lwcGluZyBlbGVtZW50cyB3aGlsZSB0aGUgcHJlZGljYXRlIGZ1bmN0aW9uIHJldHVybnMgYHRydWVgLiBUaGUgcHJlZGljYXRlXG4gICAgICogZnVuY3Rpb24gaXMgcGFzc2VkIG9uZSBhcmd1bWVudDogKHZhbHVlKSouXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjE2LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gW2FdIC0+IFthXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gQSBuZXcgYXJyYXkuXG4gICAgICogQHNlZSBSLnRha2VMYXN0V2hpbGUsIFIuYWRkSW5kZXhcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgbHRlVGhyZWUgPSB4ID0+IHggPD0gMztcbiAgICAgKlxuICAgICAqICAgICAgUi5kcm9wTGFzdFdoaWxlKGx0ZVRocmVlLCBbMSwgMiwgMywgNCwgMywgMiwgMV0pOyAvLz0+IFsxLCAyLCAzLCA0XVxuICAgICAqL1xuICAgIHZhciBkcm9wTGFzdFdoaWxlID0gX2N1cnJ5MihfZGlzcGF0Y2hhYmxlKCdkcm9wTGFzdFdoaWxlJywgX3hkcm9wTGFzdFdoaWxlLCBfZHJvcExhc3RXaGlsZSkpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgaXRzIGFyZ3VtZW50cyBhcmUgZXF1aXZhbGVudCwgYGZhbHNlYCBvdGhlcndpc2UuIEhhbmRsZXNcbiAgICAgKiBjeWNsaWNhbCBkYXRhIHN0cnVjdHVyZXMuXG4gICAgICpcbiAgICAgKiBEaXNwYXRjaGVzIHN5bW1ldHJpY2FsbHkgdG8gdGhlIGBlcXVhbHNgIG1ldGhvZHMgb2YgYm90aCBhcmd1bWVudHMsIGlmXG4gICAgICogcHJlc2VudC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTUuMFxuICAgICAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICAgICAqIEBzaWcgYSAtPiBiIC0+IEJvb2xlYW5cbiAgICAgKiBAcGFyYW0geyp9IGFcbiAgICAgKiBAcGFyYW0geyp9IGJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuZXF1YWxzKDEsIDEpOyAvLz0+IHRydWVcbiAgICAgKiAgICAgIFIuZXF1YWxzKDEsICcxJyk7IC8vPT4gZmFsc2VcbiAgICAgKiAgICAgIFIuZXF1YWxzKFsxLCAyLCAzXSwgWzEsIDIsIDNdKTsgLy89PiB0cnVlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBhID0ge307IGEudiA9IGE7XG4gICAgICogICAgICB2YXIgYiA9IHt9OyBiLnYgPSBiO1xuICAgICAqICAgICAgUi5lcXVhbHMoYSwgYik7IC8vPT4gdHJ1ZVxuICAgICAqL1xuICAgIHZhciBlcXVhbHMgPSBfY3VycnkyKGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gICAgICAgIHJldHVybiBfZXF1YWxzKGEsIGIsIFtdLCBbXSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUYWtlcyBhIHByZWRpY2F0ZSBhbmQgYSBcImZpbHRlcmFibGVcIiwgYW5kIHJldHVybnMgYSBuZXcgZmlsdGVyYWJsZSBvZiB0aGVcbiAgICAgKiBzYW1lIHR5cGUgY29udGFpbmluZyB0aGUgbWVtYmVycyBvZiB0aGUgZ2l2ZW4gZmlsdGVyYWJsZSB3aGljaCBzYXRpc2Z5IHRoZVxuICAgICAqIGdpdmVuIHByZWRpY2F0ZS5cbiAgICAgKlxuICAgICAqIERpc3BhdGNoZXMgdG8gdGhlIGBmaWx0ZXJgIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICAgICAqXG4gICAgICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgRmlsdGVyYWJsZSBmID0+IChhIC0+IEJvb2xlYW4pIC0+IGYgYSAtPiBmIGFcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkXG4gICAgICogQHBhcmFtIHtBcnJheX0gZmlsdGVyYWJsZVxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqIEBzZWUgUi5yZWplY3QsIFIudHJhbnNkdWNlLCBSLmFkZEluZGV4XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGlzRXZlbiA9IG4gPT4gbiAlIDIgPT09IDA7XG4gICAgICpcbiAgICAgKiAgICAgIFIuZmlsdGVyKGlzRXZlbiwgWzEsIDIsIDMsIDRdKTsgLy89PiBbMiwgNF1cbiAgICAgKlxuICAgICAqICAgICAgUi5maWx0ZXIoaXNFdmVuLCB7YTogMSwgYjogMiwgYzogMywgZDogNH0pOyAvLz0+IHtiOiAyLCBkOiA0fVxuICAgICAqL1xuICAgIC8vIGVsc2VcbiAgICB2YXIgZmlsdGVyID0gX2N1cnJ5MihfZGlzcGF0Y2hhYmxlKCdmaWx0ZXInLCBfeGZpbHRlciwgZnVuY3Rpb24gKHByZWQsIGZpbHRlcmFibGUpIHtcbiAgICAgICAgcmV0dXJuIF9pc09iamVjdChmaWx0ZXJhYmxlKSA/IF9yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7XG4gICAgICAgICAgICBpZiAocHJlZChmaWx0ZXJhYmxlW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgYWNjW2tleV0gPSBmaWx0ZXJhYmxlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCB7fSwga2V5cyhmaWx0ZXJhYmxlKSkgOiAvLyBlbHNlXG4gICAgICAgIF9maWx0ZXIocHJlZCwgZmlsdGVyYWJsZSk7XG4gICAgfSkpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBsaXN0IGJ5IHB1bGxpbmcgZXZlcnkgaXRlbSBvdXQgb2YgaXQgKGFuZCBhbGwgaXRzIHN1Yi1hcnJheXMpXG4gICAgICogYW5kIHB1dHRpbmcgdGhlbSBpbiBhIG5ldyBhcnJheSwgZGVwdGgtZmlyc3QuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyBbYV0gLT4gW2JdXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gY29uc2lkZXIuXG4gICAgICogQHJldHVybiB7QXJyYXl9IFRoZSBmbGF0dGVuZWQgbGlzdC5cbiAgICAgKiBAc2VlIFIudW5uZXN0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5mbGF0dGVuKFsxLCAyLCBbMywgNF0sIDUsIFs2LCBbNywgOCwgWzksIFsxMCwgMTFdLCAxMl1dXV0pO1xuICAgICAqICAgICAgLy89PiBbMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMl1cbiAgICAgKi9cbiAgICB2YXIgZmxhdHRlbiA9IF9jdXJyeTEoX21ha2VGbGF0KHRydWUpKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgZnVuY3Rpb24gbXVjaCBsaWtlIHRoZSBzdXBwbGllZCBvbmUsIGV4Y2VwdCB0aGF0IHRoZSBmaXJzdCB0d29cbiAgICAgKiBhcmd1bWVudHMnIG9yZGVyIGlzIHJldmVyc2VkLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAc2lnIChhIC0+IGIgLT4gYyAtPiAuLi4gLT4geikgLT4gKGIgLT4gYSAtPiBjIC0+IC4uLiAtPiB6KVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBpbnZva2Ugd2l0aCBpdHMgZmlyc3QgdHdvIHBhcmFtZXRlcnMgcmV2ZXJzZWQuXG4gICAgICogQHJldHVybiB7Kn0gVGhlIHJlc3VsdCBvZiBpbnZva2luZyBgZm5gIHdpdGggaXRzIGZpcnN0IHR3byBwYXJhbWV0ZXJzJyBvcmRlciByZXZlcnNlZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgbWVyZ2VUaHJlZSA9IChhLCBiLCBjKSA9PiBbXS5jb25jYXQoYSwgYiwgYyk7XG4gICAgICpcbiAgICAgKiAgICAgIG1lcmdlVGhyZWUoMSwgMiwgMyk7IC8vPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiAgICAgIFIuZmxpcChtZXJnZVRocmVlKSgxLCAyLCAzKTsgLy89PiBbMiwgMSwgM11cbiAgICAgKi9cbiAgICB2YXIgZmxpcCA9IF9jdXJyeTEoZnVuY3Rpb24gZmxpcChmbikge1xuICAgICAgICByZXR1cm4gY3VycnkoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gX3NsaWNlKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBhcmdzWzBdID0gYjtcbiAgICAgICAgICAgIGFyZ3NbMV0gPSBhO1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGdpdmVuIGxpc3Qgb3Igc3RyaW5nLiBJbiBzb21lIGxpYnJhcmllc1xuICAgICAqIHRoaXMgZnVuY3Rpb24gaXMgbmFtZWQgYGZpcnN0YC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIFthXSAtPiBhIHwgVW5kZWZpbmVkXG4gICAgICogQHNpZyBTdHJpbmcgLT4gU3RyaW5nXG4gICAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IGxpc3RcbiAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAqIEBzZWUgUi50YWlsLCBSLmluaXQsIFIubGFzdFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuaGVhZChbJ2ZpJywgJ2ZvJywgJ2Z1bSddKTsgLy89PiAnZmknXG4gICAgICogICAgICBSLmhlYWQoW10pOyAvLz0+IHVuZGVmaW5lZFxuICAgICAqXG4gICAgICogICAgICBSLmhlYWQoJ2FiYycpOyAvLz0+ICdhJ1xuICAgICAqICAgICAgUi5oZWFkKCcnKTsgLy89PiAnJ1xuICAgICAqL1xuICAgIHZhciBoZWFkID0gbnRoKDApO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgYnV0IHRoZSBsYXN0IGVsZW1lbnQgb2YgdGhlIGdpdmVuIGxpc3Qgb3Igc3RyaW5nLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC45LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgW2FdIC0+IFthXVxuICAgICAqIEBzaWcgU3RyaW5nIC0+IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7Kn0gbGlzdFxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICogQHNlZSBSLmxhc3QsIFIuaGVhZCwgUi50YWlsXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5pbml0KFsxLCAyLCAzXSk7ICAvLz0+IFsxLCAyXVxuICAgICAqICAgICAgUi5pbml0KFsxLCAyXSk7ICAgICAvLz0+IFsxXVxuICAgICAqICAgICAgUi5pbml0KFsxXSk7ICAgICAgICAvLz0+IFtdXG4gICAgICogICAgICBSLmluaXQoW10pOyAgICAgICAgIC8vPT4gW11cbiAgICAgKlxuICAgICAqICAgICAgUi5pbml0KCdhYmMnKTsgIC8vPT4gJ2FiJ1xuICAgICAqICAgICAgUi5pbml0KCdhYicpOyAgIC8vPT4gJ2EnXG4gICAgICogICAgICBSLmluaXQoJ2EnKTsgICAgLy89PiAnJ1xuICAgICAqICAgICAgUi5pbml0KCcnKTsgICAgIC8vPT4gJydcbiAgICAgKi9cbiAgICB2YXIgaW5pdCA9IHNsaWNlKDAsIC0xKTtcblxuICAgIC8qKlxuICAgICAqIENvbWJpbmVzIHR3byBsaXN0cyBpbnRvIGEgc2V0IChpLmUuIG5vIGR1cGxpY2F0ZXMpIGNvbXBvc2VkIG9mIHRob3NlXG4gICAgICogZWxlbWVudHMgY29tbW9uIHRvIGJvdGggbGlzdHMuIER1cGxpY2F0aW9uIGlzIGRldGVybWluZWQgYWNjb3JkaW5nIHRvIHRoZVxuICAgICAqIHZhbHVlIHJldHVybmVkIGJ5IGFwcGx5aW5nIHRoZSBzdXBwbGllZCBwcmVkaWNhdGUgdG8gdHdvIGxpc3QgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICAgICAqIEBzaWcgKGEgLT4gYSAtPiBCb29sZWFuKSAtPiBbKl0gLT4gWypdIC0+IFsqXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWQgQSBwcmVkaWNhdGUgZnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXJcbiAgICAgKiAgICAgICAgdGhlIHR3byBzdXBwbGllZCBlbGVtZW50cyBhcmUgZXF1YWwuXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdDEgT25lIGxpc3Qgb2YgaXRlbXMgdG8gY29tcGFyZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QyIEEgc2Vjb25kIGxpc3Qgb2YgaXRlbXMgdG8gY29tcGFyZVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBBIG5ldyBsaXN0IGNvbnRhaW5pbmcgdGhvc2UgZWxlbWVudHMgY29tbW9uIHRvIGJvdGggbGlzdHMuXG4gICAgICogQHNlZSBSLmludGVyc2VjdGlvblxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBidWZmYWxvU3ByaW5nZmllbGQgPSBbXG4gICAgICogICAgICAgIHtpZDogODI0LCBuYW1lOiAnUmljaGllIEZ1cmF5J30sXG4gICAgICogICAgICAgIHtpZDogOTU2LCBuYW1lOiAnRGV3ZXkgTWFydGluJ30sXG4gICAgICogICAgICAgIHtpZDogMzEzLCBuYW1lOiAnQnJ1Y2UgUGFsbWVyJ30sXG4gICAgICogICAgICAgIHtpZDogNDU2LCBuYW1lOiAnU3RlcGhlbiBTdGlsbHMnfSxcbiAgICAgKiAgICAgICAge2lkOiAxNzcsIG5hbWU6ICdOZWlsIFlvdW5nJ31cbiAgICAgKiAgICAgIF07XG4gICAgICogICAgICB2YXIgY3NueSA9IFtcbiAgICAgKiAgICAgICAge2lkOiAyMDQsIG5hbWU6ICdEYXZpZCBDcm9zYnknfSxcbiAgICAgKiAgICAgICAge2lkOiA0NTYsIG5hbWU6ICdTdGVwaGVuIFN0aWxscyd9LFxuICAgICAqICAgICAgICB7aWQ6IDUzOSwgbmFtZTogJ0dyYWhhbSBOYXNoJ30sXG4gICAgICogICAgICAgIHtpZDogMTc3LCBuYW1lOiAnTmVpbCBZb3VuZyd9XG4gICAgICogICAgICBdO1xuICAgICAqXG4gICAgICogICAgICBSLmludGVyc2VjdGlvbldpdGgoUi5lcUJ5KFIucHJvcCgnaWQnKSksIGJ1ZmZhbG9TcHJpbmdmaWVsZCwgY3NueSk7XG4gICAgICogICAgICAvLz0+IFt7aWQ6IDQ1NiwgbmFtZTogJ1N0ZXBoZW4gU3RpbGxzJ30sIHtpZDogMTc3LCBuYW1lOiAnTmVpbCBZb3VuZyd9XVxuICAgICAqL1xuICAgIHZhciBpbnRlcnNlY3Rpb25XaXRoID0gX2N1cnJ5MyhmdW5jdGlvbiBpbnRlcnNlY3Rpb25XaXRoKHByZWQsIGxpc3QxLCBsaXN0Mikge1xuICAgICAgICB2YXIgbG9va3VwTGlzdCwgZmlsdGVyZWRMaXN0O1xuICAgICAgICBpZiAobGlzdDEubGVuZ3RoID4gbGlzdDIubGVuZ3RoKSB7XG4gICAgICAgICAgICBsb29rdXBMaXN0ID0gbGlzdDE7XG4gICAgICAgICAgICBmaWx0ZXJlZExpc3QgPSBsaXN0MjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvb2t1cExpc3QgPSBsaXN0MjtcbiAgICAgICAgICAgIGZpbHRlcmVkTGlzdCA9IGxpc3QxO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIHZhciBpZHggPSAwO1xuICAgICAgICB3aGlsZSAoaWR4IDwgZmlsdGVyZWRMaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKF9jb250YWluc1dpdGgocHJlZCwgZmlsdGVyZWRMaXN0W2lkeF0sIGxvb2t1cExpc3QpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0c1tyZXN1bHRzLmxlbmd0aF0gPSBmaWx0ZXJlZExpc3RbaWR4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmlxV2l0aChwcmVkLCByZXN1bHRzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgdGhlIGl0ZW1zIG9mIHRoZSBsaXN0IHdpdGggdGhlIHRyYW5zZHVjZXIgYW5kIGFwcGVuZHMgdGhlXG4gICAgICogdHJhbnNmb3JtZWQgaXRlbXMgdG8gdGhlIGFjY3VtdWxhdG9yIHVzaW5nIGFuIGFwcHJvcHJpYXRlIGl0ZXJhdG9yIGZ1bmN0aW9uXG4gICAgICogYmFzZWQgb24gdGhlIGFjY3VtdWxhdG9yIHR5cGUuXG4gICAgICpcbiAgICAgKiBUaGUgYWNjdW11bGF0b3IgY2FuIGJlIGFuIGFycmF5LCBzdHJpbmcsIG9iamVjdCBvciBhIHRyYW5zZm9ybWVyLiBJdGVyYXRlZFxuICAgICAqIGl0ZW1zIHdpbGwgYmUgYXBwZW5kZWQgdG8gYXJyYXlzIGFuZCBjb25jYXRlbmF0ZWQgdG8gc3RyaW5ncy4gT2JqZWN0cyB3aWxsXG4gICAgICogYmUgbWVyZ2VkIGRpcmVjdGx5IG9yIDItaXRlbSBhcnJheXMgd2lsbCBiZSBtZXJnZWQgYXMga2V5LCB2YWx1ZSBwYWlycy5cbiAgICAgKlxuICAgICAqIFRoZSBhY2N1bXVsYXRvciBjYW4gYWxzbyBiZSBhIHRyYW5zZm9ybWVyIG9iamVjdCB0aGF0IHByb3ZpZGVzIGEgMi1hcml0eVxuICAgICAqIHJlZHVjaW5nIGl0ZXJhdG9yIGZ1bmN0aW9uLCBzdGVwLCAwLWFyaXR5IGluaXRpYWwgdmFsdWUgZnVuY3Rpb24sIGluaXQsIGFuZFxuICAgICAqIDEtYXJpdHkgcmVzdWx0IGV4dHJhY3Rpb24gZnVuY3Rpb24gcmVzdWx0LiBUaGUgc3RlcCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZVxuICAgICAqIGl0ZXJhdG9yIGZ1bmN0aW9uIGluIHJlZHVjZS4gVGhlIHJlc3VsdCBmdW5jdGlvbiBpcyB1c2VkIHRvIGNvbnZlcnQgdGhlXG4gICAgICogZmluYWwgYWNjdW11bGF0b3IgaW50byB0aGUgcmV0dXJuIHR5cGUgYW5kIGluIG1vc3QgY2FzZXMgaXMgUi5pZGVudGl0eS4gVGhlXG4gICAgICogaW5pdCBmdW5jdGlvbiBpcyB1c2VkIHRvIHByb3ZpZGUgdGhlIGluaXRpYWwgYWNjdW11bGF0b3IuXG4gICAgICpcbiAgICAgKiBUaGUgaXRlcmF0aW9uIGlzIHBlcmZvcm1lZCB3aXRoIFIucmVkdWNlIGFmdGVyIGluaXRpYWxpemluZyB0aGUgdHJhbnNkdWNlci5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTIuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyBhIC0+IChiIC0+IGIpIC0+IFtjXSAtPiBhXG4gICAgICogQHBhcmFtIHsqfSBhY2MgVGhlIGluaXRpYWwgYWNjdW11bGF0b3IgdmFsdWUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0geGYgVGhlIHRyYW5zZHVjZXIgZnVuY3Rpb24uIFJlY2VpdmVzIGEgdHJhbnNmb3JtZXIgYW5kIHJldHVybnMgYSB0cmFuc2Zvcm1lci5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJuIHsqfSBUaGUgZmluYWwsIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBudW1iZXJzID0gWzEsIDIsIDMsIDRdO1xuICAgICAqICAgICAgdmFyIHRyYW5zZHVjZXIgPSBSLmNvbXBvc2UoUi5tYXAoUi5hZGQoMSkpLCBSLnRha2UoMikpO1xuICAgICAqXG4gICAgICogICAgICBSLmludG8oW10sIHRyYW5zZHVjZXIsIG51bWJlcnMpOyAvLz0+IFsyLCAzXVxuICAgICAqXG4gICAgICogICAgICB2YXIgaW50b0FycmF5ID0gUi5pbnRvKFtdKTtcbiAgICAgKiAgICAgIGludG9BcnJheSh0cmFuc2R1Y2VyLCBudW1iZXJzKTsgLy89PiBbMiwgM11cbiAgICAgKi9cbiAgICB2YXIgaW50byA9IF9jdXJyeTMoZnVuY3Rpb24gaW50byhhY2MsIHhmLCBsaXN0KSB7XG4gICAgICAgIHJldHVybiBfaXNUcmFuc2Zvcm1lcihhY2MpID8gX3JlZHVjZSh4ZihhY2MpLCBhY2NbJ0BAdHJhbnNkdWNlci9pbml0J10oKSwgbGlzdCkgOiBfcmVkdWNlKHhmKF9zdGVwQ2F0KGFjYykpLCBfY2xvbmUoYWNjLCBbXSwgW10sIGZhbHNlKSwgbGlzdCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBTYW1lIGFzIFIuaW52ZXJ0T2JqLCBob3dldmVyIHRoaXMgYWNjb3VudHMgZm9yIG9iamVjdHMgd2l0aCBkdXBsaWNhdGUgdmFsdWVzXG4gICAgICogYnkgcHV0dGluZyB0aGUgdmFsdWVzIGludG8gYW4gYXJyYXkuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjkuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAc2lnIHtzOiB4fSAtPiB7eDogWyBzLCAuLi4gXX1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3Qgb3IgYXJyYXkgdG8gaW52ZXJ0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvdXQgQSBuZXcgb2JqZWN0IHdpdGgga2V5c1xuICAgICAqIGluIGFuIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciByYWNlUmVzdWx0c0J5Rmlyc3ROYW1lID0ge1xuICAgICAqICAgICAgICBmaXJzdDogJ2FsaWNlJyxcbiAgICAgKiAgICAgICAgc2Vjb25kOiAnamFrZScsXG4gICAgICogICAgICAgIHRoaXJkOiAnYWxpY2UnLFxuICAgICAqICAgICAgfTtcbiAgICAgKiAgICAgIFIuaW52ZXJ0KHJhY2VSZXN1bHRzQnlGaXJzdE5hbWUpO1xuICAgICAqICAgICAgLy89PiB7ICdhbGljZSc6IFsnZmlyc3QnLCAndGhpcmQnXSwgJ2pha2UnOlsnc2Vjb25kJ10gfVxuICAgICAqL1xuICAgIHZhciBpbnZlcnQgPSBfY3VycnkxKGZ1bmN0aW9uIGludmVydChvYmopIHtcbiAgICAgICAgdmFyIHByb3BzID0ga2V5cyhvYmopO1xuICAgICAgICB2YXIgbGVuID0gcHJvcHMubGVuZ3RoO1xuICAgICAgICB2YXIgaWR4ID0gMDtcbiAgICAgICAgdmFyIG91dCA9IHt9O1xuICAgICAgICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gcHJvcHNbaWR4XTtcbiAgICAgICAgICAgIHZhciB2YWwgPSBvYmpba2V5XTtcbiAgICAgICAgICAgIHZhciBsaXN0ID0gX2hhcyh2YWwsIG91dCkgPyBvdXRbdmFsXSA6IG91dFt2YWxdID0gW107XG4gICAgICAgICAgICBsaXN0W2xpc3QubGVuZ3RoXSA9IGtleTtcbiAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBrZXlzIG9mIHRoZSBnaXZlbiBvYmplY3QgYXMgdmFsdWVzLCBhbmQgdGhlXG4gICAgICogdmFsdWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsIHdoaWNoIGFyZSBjb2VyY2VkIHRvIHN0cmluZ3MsIGFzIGtleXMuIE5vdGVcbiAgICAgKiB0aGF0IHRoZSBsYXN0IGtleSBmb3VuZCBpcyBwcmVmZXJyZWQgd2hlbiBoYW5kbGluZyB0aGUgc2FtZSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuOS4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBzaWcge3M6IHh9IC0+IHt4OiBzfVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCBvciBhcnJheSB0byBpbnZlcnRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG91dCBBIG5ldyBvYmplY3RcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgcmFjZVJlc3VsdHMgPSB7XG4gICAgICogICAgICAgIGZpcnN0OiAnYWxpY2UnLFxuICAgICAqICAgICAgICBzZWNvbmQ6ICdqYWtlJ1xuICAgICAqICAgICAgfTtcbiAgICAgKiAgICAgIFIuaW52ZXJ0T2JqKHJhY2VSZXN1bHRzKTtcbiAgICAgKiAgICAgIC8vPT4geyAnYWxpY2UnOiAnZmlyc3QnLCAnamFrZSc6J3NlY29uZCcgfVxuICAgICAqXG4gICAgICogICAgICAvLyBBbHRlcm5hdGl2ZWx5OlxuICAgICAqICAgICAgdmFyIHJhY2VSZXN1bHRzID0gWydhbGljZScsICdqYWtlJ107XG4gICAgICogICAgICBSLmludmVydE9iaihyYWNlUmVzdWx0cyk7XG4gICAgICogICAgICAvLz0+IHsgJ2FsaWNlJzogJzAnLCAnamFrZSc6JzEnIH1cbiAgICAgKi9cbiAgICB2YXIgaW52ZXJ0T2JqID0gX2N1cnJ5MShmdW5jdGlvbiBpbnZlcnRPYmoob2JqKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IGtleXMob2JqKTtcbiAgICAgICAgdmFyIGxlbiA9IHByb3BzLmxlbmd0aDtcbiAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgIHZhciBvdXQgPSB7fTtcbiAgICAgICAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgICAgICAgICAgdmFyIGtleSA9IHByb3BzW2lkeF07XG4gICAgICAgICAgICBvdXRbb2JqW2tleV1dID0ga2V5O1xuICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBpdHMgdHlwZSdzIGVtcHR5IHZhbHVlOyBgZmFsc2VgXG4gICAgICogb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTG9naWNcbiAgICAgKiBAc2lnIGEgLT4gQm9vbGVhblxuICAgICAqIEBwYXJhbSB7Kn0geFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICogQHNlZSBSLmVtcHR5XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5pc0VtcHR5KFsxLCAyLCAzXSk7ICAgLy89PiBmYWxzZVxuICAgICAqICAgICAgUi5pc0VtcHR5KFtdKTsgICAgICAgICAgLy89PiB0cnVlXG4gICAgICogICAgICBSLmlzRW1wdHkoJycpOyAgICAgICAgICAvLz0+IHRydWVcbiAgICAgKiAgICAgIFIuaXNFbXB0eShudWxsKTsgICAgICAgIC8vPT4gZmFsc2VcbiAgICAgKiAgICAgIFIuaXNFbXB0eSh7fSk7ICAgICAgICAgIC8vPT4gdHJ1ZVxuICAgICAqICAgICAgUi5pc0VtcHR5KHtsZW5ndGg6IDB9KTsgLy89PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc0VtcHR5ID0gX2N1cnJ5MShmdW5jdGlvbiBpc0VtcHR5KHgpIHtcbiAgICAgICAgcmV0dXJuIHggIT0gbnVsbCAmJiBlcXVhbHMoeCwgZW1wdHkoeCkpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGFzdCBlbGVtZW50IG9mIHRoZSBnaXZlbiBsaXN0IG9yIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS40XG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIFthXSAtPiBhIHwgVW5kZWZpbmVkXG4gICAgICogQHNpZyBTdHJpbmcgLT4gU3RyaW5nXG4gICAgICogQHBhcmFtIHsqfSBsaXN0XG4gICAgICogQHJldHVybiB7Kn1cbiAgICAgKiBAc2VlIFIuaW5pdCwgUi5oZWFkLCBSLnRhaWxcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLmxhc3QoWydmaScsICdmbycsICdmdW0nXSk7IC8vPT4gJ2Z1bSdcbiAgICAgKiAgICAgIFIubGFzdChbXSk7IC8vPT4gdW5kZWZpbmVkXG4gICAgICpcbiAgICAgKiAgICAgIFIubGFzdCgnYWJjJyk7IC8vPT4gJ2MnXG4gICAgICogICAgICBSLmxhc3QoJycpOyAvLz0+ICcnXG4gICAgICovXG4gICAgdmFyIGxhc3QgPSBudGgoLTEpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhlIGxhc3Qgb2NjdXJyZW5jZSBvZiBhbiBpdGVtIGluIGFuIGFycmF5LCBvciAtMSBpZlxuICAgICAqIHRoZSBpdGVtIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgYXJyYXkuIGBSLmVxdWFsc2AgaXMgdXNlZCB0byBkZXRlcm1pbmVcbiAgICAgKiBlcXVhbGl0eS5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIGEgLT4gW2FdIC0+IE51bWJlclxuICAgICAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSBpdGVtIHRvIGZpbmQuXG4gICAgICogQHBhcmFtIHtBcnJheX0geHMgVGhlIGFycmF5IHRvIHNlYXJjaCBpbi5cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBpbmRleCBvZiB0aGUgdGFyZ2V0LCBvciAtMSBpZiB0aGUgdGFyZ2V0IGlzIG5vdCBmb3VuZC5cbiAgICAgKiBAc2VlIFIuaW5kZXhPZlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIubGFzdEluZGV4T2YoMywgWy0xLDMsMywwLDEsMiwzLDRdKTsgLy89PiA2XG4gICAgICogICAgICBSLmxhc3RJbmRleE9mKDEwLCBbMSwyLDMsNF0pOyAvLz0+IC0xXG4gICAgICovXG4gICAgdmFyIGxhc3RJbmRleE9mID0gX2N1cnJ5MihmdW5jdGlvbiBsYXN0SW5kZXhPZih0YXJnZXQsIHhzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgeHMubGFzdEluZGV4T2YgPT09ICdmdW5jdGlvbicgJiYgIV9pc0FycmF5KHhzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHhzLmxhc3RJbmRleE9mKHRhcmdldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaWR4ID0geHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHdoaWxlIChpZHggPj0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChlcXVhbHMoeHNbaWR4XSwgdGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWR4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZHggLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGFrZXMgYSBmdW5jdGlvbiBhbmRcbiAgICAgKiBhIFtmdW5jdG9yXShodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2Z1bmN0b3IpLFxuICAgICAqIGFwcGxpZXMgdGhlIGZ1bmN0aW9uIHRvIGVhY2ggb2YgdGhlIGZ1bmN0b3IncyB2YWx1ZXMsIGFuZCByZXR1cm5zXG4gICAgICogYSBmdW5jdG9yIG9mIHRoZSBzYW1lIHNoYXBlLlxuICAgICAqXG4gICAgICogUmFtZGEgcHJvdmlkZXMgc3VpdGFibGUgYG1hcGAgaW1wbGVtZW50YXRpb25zIGZvciBgQXJyYXlgIGFuZCBgT2JqZWN0YCxcbiAgICAgKiBzbyB0aGlzIGZ1bmN0aW9uIG1heSBiZSBhcHBsaWVkIHRvIGBbMSwgMiwgM11gIG9yIGB7eDogMSwgeTogMiwgejogM31gLlxuICAgICAqXG4gICAgICogRGlzcGF0Y2hlcyB0byB0aGUgYG1hcGAgbWV0aG9kIG9mIHRoZSBzZWNvbmQgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gICAgICpcbiAgICAgKiBBY3RzIGFzIGEgdHJhbnNkdWNlciBpZiBhIHRyYW5zZm9ybWVyIGlzIGdpdmVuIGluIGxpc3QgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBBbHNvIHRyZWF0cyBmdW5jdGlvbnMgYXMgZnVuY3RvcnMgYW5kIHdpbGwgY29tcG9zZSB0aGVtIHRvZ2V0aGVyLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgRnVuY3RvciBmID0+IChhIC0+IGIpIC0+IGYgYSAtPiBmIGJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGV2ZXJ5IGVsZW1lbnQgb2YgdGhlIGlucHV0IGBsaXN0YC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIGJlIGl0ZXJhdGVkIG92ZXIuXG4gICAgICogQHJldHVybiB7QXJyYXl9IFRoZSBuZXcgbGlzdC5cbiAgICAgKiBAc2VlIFIudHJhbnNkdWNlLCBSLmFkZEluZGV4XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGRvdWJsZSA9IHggPT4geCAqIDI7XG4gICAgICpcbiAgICAgKiAgICAgIFIubWFwKGRvdWJsZSwgWzEsIDIsIDNdKTsgLy89PiBbMiwgNCwgNl1cbiAgICAgKlxuICAgICAqICAgICAgUi5tYXAoZG91YmxlLCB7eDogMSwgeTogMiwgejogM30pOyAvLz0+IHt4OiAyLCB5OiA0LCB6OiA2fVxuICAgICAqL1xuICAgIHZhciBtYXAgPSBfY3VycnkyKF9kaXNwYXRjaGFibGUoJ21hcCcsIF94bWFwLCBmdW5jdGlvbiBtYXAoZm4sIGZ1bmN0b3IpIHtcbiAgICAgICAgc3dpdGNoIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZnVuY3RvcikpIHtcbiAgICAgICAgY2FzZSAnW29iamVjdCBGdW5jdGlvbl0nOlxuICAgICAgICAgICAgcmV0dXJuIGN1cnJ5TihmdW5jdG9yLmxlbmd0aCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGZ1bmN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2FzZSAnW29iamVjdCBPYmplY3RdJzpcbiAgICAgICAgICAgIHJldHVybiBfcmVkdWNlKGZ1bmN0aW9uIChhY2MsIGtleSkge1xuICAgICAgICAgICAgICAgIGFjY1trZXldID0gZm4oZnVuY3RvcltrZXldKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwge30sIGtleXMoZnVuY3RvcikpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIF9tYXAoZm4sIGZ1bmN0b3IpO1xuICAgICAgICB9XG4gICAgfSkpO1xuXG4gICAgLyoqXG4gICAgICogQW4gT2JqZWN0LXNwZWNpZmljIHZlcnNpb24gb2YgYG1hcGAuIFRoZSBmdW5jdGlvbiBpcyBhcHBsaWVkIHRvIHRocmVlXG4gICAgICogYXJndW1lbnRzOiAqKHZhbHVlLCBrZXksIG9iaikqLiBJZiBvbmx5IHRoZSB2YWx1ZSBpcyBzaWduaWZpY2FudCwgdXNlXG4gICAgICogYG1hcGAgaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuOS4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBzaWcgKCgqLCBTdHJpbmcsIE9iamVjdCkgLT4gKikgLT4gT2JqZWN0IC0+IE9iamVjdFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9ialxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKiBAc2VlIFIubWFwXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIHZhbHVlcyA9IHsgeDogMSwgeTogMiwgejogMyB9O1xuICAgICAqICAgICAgdmFyIHByZXBlbmRLZXlBbmREb3VibGUgPSAobnVtLCBrZXksIG9iaikgPT4ga2V5ICsgKG51bSAqIDIpO1xuICAgICAqXG4gICAgICogICAgICBSLm1hcE9iakluZGV4ZWQocHJlcGVuZEtleUFuZERvdWJsZSwgdmFsdWVzKTsgLy89PiB7IHg6ICd4MicsIHk6ICd5NCcsIHo6ICd6NicgfVxuICAgICAqL1xuICAgIHZhciBtYXBPYmpJbmRleGVkID0gX2N1cnJ5MihmdW5jdGlvbiBtYXBPYmpJbmRleGVkKGZuLCBvYmopIHtcbiAgICAgICAgcmV0dXJuIF9yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7XG4gICAgICAgICAgICBhY2Nba2V5XSA9IGZuKG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCB7fSwga2V5cyhvYmopKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgb2JqZWN0IHdpdGggdGhlIG93biBwcm9wZXJ0aWVzIG9mIHRoZSB0d28gcHJvdmlkZWQgb2JqZWN0cy4gSWZcbiAgICAgKiBhIGtleSBleGlzdHMgaW4gYm90aCBvYmplY3RzLCB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gaXMgYXBwbGllZCB0byB0aGUgdmFsdWVzXG4gICAgICogYXNzb2NpYXRlZCB3aXRoIHRoZSBrZXkgaW4gZWFjaCBvYmplY3QsIHdpdGggdGhlIHJlc3VsdCBiZWluZyB1c2VkIGFzIHRoZVxuICAgICAqIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUga2V5IGluIHRoZSByZXR1cm5lZCBvYmplY3QuIFRoZSBrZXkgd2lsbCBiZVxuICAgICAqIGV4Y2x1ZGVkIGZyb20gdGhlIHJldHVybmVkIG9iamVjdCBpZiB0aGUgcmVzdWx0aW5nIHZhbHVlIGlzIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xOS4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBzaWcgKGEgLT4gYSAtPiBhKSAtPiB7YX0gLT4ge2F9IC0+IHthfVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gclxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKiBAc2VlIFIubWVyZ2UsIFIubWVyZ2VXaXRoS2V5XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5tZXJnZVdpdGgoUi5jb25jYXQsXG4gICAgICogICAgICAgICAgICAgICAgICB7IGE6IHRydWUsIHZhbHVlczogWzEwLCAyMF0gfSxcbiAgICAgKiAgICAgICAgICAgICAgICAgIHsgYjogdHJ1ZSwgdmFsdWVzOiBbMTUsIDM1XSB9KTtcbiAgICAgKiAgICAgIC8vPT4geyBhOiB0cnVlLCBiOiB0cnVlLCB2YWx1ZXM6IFsxMCwgMjAsIDE1LCAzNV0gfVxuICAgICAqL1xuICAgIHZhciBtZXJnZVdpdGggPSBfY3VycnkzKGZ1bmN0aW9uIG1lcmdlV2l0aChmbiwgbCwgcikge1xuICAgICAgICByZXR1cm4gbWVyZ2VXaXRoS2V5KGZ1bmN0aW9uIChfLCBfbCwgX3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmbihfbCwgX3IpO1xuICAgICAgICB9LCBsLCByKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRha2VzIGEgZnVuY3Rpb24gYGZgIGFuZCBhIGxpc3Qgb2YgYXJndW1lbnRzLCBhbmQgcmV0dXJucyBhIGZ1bmN0aW9uIGBnYC5cbiAgICAgKiBXaGVuIGFwcGxpZWQsIGBnYCByZXR1cm5zIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgYGZgIHRvIHRoZSBhcmd1bWVudHNcbiAgICAgKiBwcm92aWRlZCBpbml0aWFsbHkgZm9sbG93ZWQgYnkgdGhlIGFyZ3VtZW50cyBwcm92aWRlZCB0byBgZ2AuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAc2lnICgoYSwgYiwgYywgLi4uLCBuKSAtPiB4KSAtPiBbYSwgYiwgYywgLi4uXSAtPiAoKGQsIGUsIGYsIC4uLiwgbikgLT4geClcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJnc1xuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgICAqIEBzZWUgUi5wYXJ0aWFsUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgbXVsdGlwbHkgPSAoYSwgYikgPT4gYSAqIGI7XG4gICAgICogICAgICB2YXIgZG91YmxlID0gUi5wYXJ0aWFsKG11bHRpcGx5LCBbMl0pO1xuICAgICAqICAgICAgZG91YmxlKDIpOyAvLz0+IDRcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGdyZWV0ID0gKHNhbHV0YXRpb24sIHRpdGxlLCBmaXJzdE5hbWUsIGxhc3ROYW1lKSA9PlxuICAgICAqICAgICAgICBzYWx1dGF0aW9uICsgJywgJyArIHRpdGxlICsgJyAnICsgZmlyc3ROYW1lICsgJyAnICsgbGFzdE5hbWUgKyAnISc7XG4gICAgICpcbiAgICAgKiAgICAgIHZhciBzYXlIZWxsbyA9IFIucGFydGlhbChncmVldCwgWydIZWxsbyddKTtcbiAgICAgKiAgICAgIHZhciBzYXlIZWxsb1RvTXMgPSBSLnBhcnRpYWwoc2F5SGVsbG8sIFsnTXMuJ10pO1xuICAgICAqICAgICAgc2F5SGVsbG9Ub01zKCdKYW5lJywgJ0pvbmVzJyk7IC8vPT4gJ0hlbGxvLCBNcy4gSmFuZSBKb25lcyEnXG4gICAgICovXG4gICAgdmFyIHBhcnRpYWwgPSBfY3JlYXRlUGFydGlhbEFwcGxpY2F0b3IoX2NvbmNhdCk7XG5cbiAgICAvKipcbiAgICAgKiBUYWtlcyBhIGZ1bmN0aW9uIGBmYCBhbmQgYSBsaXN0IG9mIGFyZ3VtZW50cywgYW5kIHJldHVybnMgYSBmdW5jdGlvbiBgZ2AuXG4gICAgICogV2hlbiBhcHBsaWVkLCBgZ2AgcmV0dXJucyB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIGBmYCB0byB0aGUgYXJndW1lbnRzXG4gICAgICogcHJvdmlkZWQgdG8gYGdgIGZvbGxvd2VkIGJ5IHRoZSBhcmd1bWVudHMgcHJvdmlkZWQgaW5pdGlhbGx5LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHNpZyAoKGEsIGIsIGMsIC4uLiwgbikgLT4geCkgLT4gW2QsIGUsIGYsIC4uLiwgbl0gLT4gKChhLCBiLCBjLCAuLi4pIC0+IHgpXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3NcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICAgKiBAc2VlIFIucGFydGlhbFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBncmVldCA9IChzYWx1dGF0aW9uLCB0aXRsZSwgZmlyc3ROYW1lLCBsYXN0TmFtZSkgPT5cbiAgICAgKiAgICAgICAgc2FsdXRhdGlvbiArICcsICcgKyB0aXRsZSArICcgJyArIGZpcnN0TmFtZSArICcgJyArIGxhc3ROYW1lICsgJyEnO1xuICAgICAqXG4gICAgICogICAgICB2YXIgZ3JlZXRNc0phbmVKb25lcyA9IFIucGFydGlhbFJpZ2h0KGdyZWV0LCBbJ01zLicsICdKYW5lJywgJ0pvbmVzJ10pO1xuICAgICAqXG4gICAgICogICAgICBncmVldE1zSmFuZUpvbmVzKCdIZWxsbycpOyAvLz0+ICdIZWxsbywgTXMuIEphbmUgSm9uZXMhJ1xuICAgICAqL1xuICAgIHZhciBwYXJ0aWFsUmlnaHQgPSBfY3JlYXRlUGFydGlhbEFwcGxpY2F0b3IoZmxpcChfY29uY2F0KSk7XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBuZXN0ZWQgcGF0aCBvbiBhbiBvYmplY3QgaGFzIGEgc3BlY2lmaWMgdmFsdWUsIGluXG4gICAgICogYFIuZXF1YWxzYCB0ZXJtcy4gTW9zdCBsaWtlbHkgdXNlZCB0byBmaWx0ZXIgYSBsaXN0LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAgICAgKiBAc2lnIFtTdHJpbmddIC0+ICogLT4ge1N0cmluZzogKn0gLT4gQm9vbGVhblxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggVGhlIHBhdGggb2YgdGhlIG5lc3RlZCBwcm9wZXJ0eSB0byB1c2VcbiAgICAgKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gY29tcGFyZSB0aGUgbmVzdGVkIHByb3BlcnR5IHdpdGhcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gY2hlY2sgdGhlIG5lc3RlZCBwcm9wZXJ0eSBpblxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmFsdWUgZXF1YWxzIHRoZSBuZXN0ZWQgb2JqZWN0IHByb3BlcnR5LFxuICAgICAqICAgICAgICAgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIHVzZXIxID0geyBhZGRyZXNzOiB7IHppcENvZGU6IDkwMjEwIH0gfTtcbiAgICAgKiAgICAgIHZhciB1c2VyMiA9IHsgYWRkcmVzczogeyB6aXBDb2RlOiA1NTU1NSB9IH07XG4gICAgICogICAgICB2YXIgdXNlcjMgPSB7IG5hbWU6ICdCb2InIH07XG4gICAgICogICAgICB2YXIgdXNlcnMgPSBbIHVzZXIxLCB1c2VyMiwgdXNlcjMgXTtcbiAgICAgKiAgICAgIHZhciBpc0ZhbW91cyA9IFIucGF0aEVxKFsnYWRkcmVzcycsICd6aXBDb2RlJ10sIDkwMjEwKTtcbiAgICAgKiAgICAgIFIuZmlsdGVyKGlzRmFtb3VzLCB1c2Vycyk7IC8vPT4gWyB1c2VyMSBdXG4gICAgICovXG4gICAgdmFyIHBhdGhFcSA9IF9jdXJyeTMoZnVuY3Rpb24gcGF0aEVxKF9wYXRoLCB2YWwsIG9iaikge1xuICAgICAgICByZXR1cm4gZXF1YWxzKHBhdGgoX3BhdGgsIG9iaiksIHZhbCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IGxpc3QgYnkgcGx1Y2tpbmcgdGhlIHNhbWUgbmFtZWQgcHJvcGVydHkgb2ZmIGFsbCBvYmplY3RzIGluXG4gICAgICogdGhlIGxpc3Qgc3VwcGxpZWQuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyBrIC0+IFt7azogdn1dIC0+IFt2XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30ga2V5IFRoZSBrZXkgbmFtZSB0byBwbHVjayBvZmYgb2YgZWFjaCBvYmplY3QuXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gY29uc2lkZXIuXG4gICAgICogQHJldHVybiB7QXJyYXl9IFRoZSBsaXN0IG9mIHZhbHVlcyBmb3IgdGhlIGdpdmVuIGtleS5cbiAgICAgKiBAc2VlIFIucHJvcHNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLnBsdWNrKCdhJykoW3thOiAxfSwge2E6IDJ9XSk7IC8vPT4gWzEsIDJdXG4gICAgICogICAgICBSLnBsdWNrKDApKFtbMSwgMl0sIFszLCA0XV0pOyAgIC8vPT4gWzEsIDNdXG4gICAgICovXG4gICAgdmFyIHBsdWNrID0gX2N1cnJ5MihmdW5jdGlvbiBwbHVjayhwLCBsaXN0KSB7XG4gICAgICAgIHJldHVybiBtYXAocHJvcChwKSwgbGlzdCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZWFzb25hYmxlIGFuYWxvZyB0byBTUUwgYHNlbGVjdGAgc3RhdGVtZW50LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gICAgICogQHNpZyBba10gLT4gW3trOiB2fV0gLT4gW3trOiB2fV1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gcHJvamVjdFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9ianMgVGhlIG9iamVjdHMgdG8gcXVlcnlcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIGp1c3QgdGhlIGBwcm9wc2AgcHJvcGVydGllcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgYWJieSA9IHtuYW1lOiAnQWJieScsIGFnZTogNywgaGFpcjogJ2Jsb25kJywgZ3JhZGU6IDJ9O1xuICAgICAqICAgICAgdmFyIGZyZWQgPSB7bmFtZTogJ0ZyZWQnLCBhZ2U6IDEyLCBoYWlyOiAnYnJvd24nLCBncmFkZTogN307XG4gICAgICogICAgICB2YXIga2lkcyA9IFthYmJ5LCBmcmVkXTtcbiAgICAgKiAgICAgIFIucHJvamVjdChbJ25hbWUnLCAnZ3JhZGUnXSwga2lkcyk7IC8vPT4gW3tuYW1lOiAnQWJieScsIGdyYWRlOiAyfSwge25hbWU6ICdGcmVkJywgZ3JhZGU6IDd9XVxuICAgICAqL1xuICAgIC8vIHBhc3NpbmcgYGlkZW50aXR5YCBnaXZlcyBjb3JyZWN0IGFyaXR5XG4gICAgdmFyIHByb2plY3QgPSB1c2VXaXRoKF9tYXAsIFtcbiAgICAgICAgcGlja0FsbCxcbiAgICAgICAgaWRlbnRpdHlcbiAgICBdKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBzcGVjaWZpZWQgb2JqZWN0IHByb3BlcnR5IGlzIGVxdWFsLCBpbiBgUi5lcXVhbHNgXG4gICAgICogdGVybXMsIHRvIHRoZSBnaXZlbiB2YWx1ZTsgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICAgICAqIEBzaWcgU3RyaW5nIC0+IGEgLT4gT2JqZWN0IC0+IEJvb2xlYW5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsXG4gICAgICogQHBhcmFtIHsqfSBvYmpcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqIEBzZWUgUi5lcXVhbHMsIFIucHJvcFNhdGlzZmllc1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBhYmJ5ID0ge25hbWU6ICdBYmJ5JywgYWdlOiA3LCBoYWlyOiAnYmxvbmQnfTtcbiAgICAgKiAgICAgIHZhciBmcmVkID0ge25hbWU6ICdGcmVkJywgYWdlOiAxMiwgaGFpcjogJ2Jyb3duJ307XG4gICAgICogICAgICB2YXIgcnVzdHkgPSB7bmFtZTogJ1J1c3R5JywgYWdlOiAxMCwgaGFpcjogJ2Jyb3duJ307XG4gICAgICogICAgICB2YXIgYWxvaXMgPSB7bmFtZTogJ0Fsb2lzJywgYWdlOiAxNSwgZGlzcG9zaXRpb246ICdzdXJseSd9O1xuICAgICAqICAgICAgdmFyIGtpZHMgPSBbYWJieSwgZnJlZCwgcnVzdHksIGFsb2lzXTtcbiAgICAgKiAgICAgIHZhciBoYXNCcm93bkhhaXIgPSBSLnByb3BFcSgnaGFpcicsICdicm93bicpO1xuICAgICAqICAgICAgUi5maWx0ZXIoaGFzQnJvd25IYWlyLCBraWRzKTsgLy89PiBbZnJlZCwgcnVzdHldXG4gICAgICovXG4gICAgdmFyIHByb3BFcSA9IF9jdXJyeTMoZnVuY3Rpb24gcHJvcEVxKG5hbWUsIHZhbCwgb2JqKSB7XG4gICAgICAgIHJldHVybiBwcm9wU2F0aXNmaWVzKGVxdWFscyh2YWwpLCBuYW1lLCBvYmopO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHNwZWNpZmllZCBvYmplY3QgcHJvcGVydHkgaXMgb2YgdGhlIGdpdmVuIHR5cGU7XG4gICAgICogYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjE2LjBcbiAgICAgKiBAY2F0ZWdvcnkgVHlwZVxuICAgICAqIEBzaWcgVHlwZSAtPiBTdHJpbmcgLT4gT2JqZWN0IC0+IEJvb2xlYW5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0geyp9IG9ialxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICogQHNlZSBSLmlzLCBSLnByb3BTYXRpc2ZpZXNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLnByb3BJcyhOdW1iZXIsICd4Jywge3g6IDEsIHk6IDJ9KTsgIC8vPT4gdHJ1ZVxuICAgICAqICAgICAgUi5wcm9wSXMoTnVtYmVyLCAneCcsIHt4OiAnZm9vJ30pOyAgICAvLz0+IGZhbHNlXG4gICAgICogICAgICBSLnByb3BJcyhOdW1iZXIsICd4Jywge30pOyAgICAgICAgICAgIC8vPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgcHJvcElzID0gX2N1cnJ5MyhmdW5jdGlvbiBwcm9wSXModHlwZSwgbmFtZSwgb2JqKSB7XG4gICAgICAgIHJldHVybiBwcm9wU2F0aXNmaWVzKGlzKHR5cGUpLCBuYW1lLCBvYmopO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHNpbmdsZSBpdGVtIGJ5IGl0ZXJhdGluZyB0aHJvdWdoIHRoZSBsaXN0LCBzdWNjZXNzaXZlbHkgY2FsbGluZ1xuICAgICAqIHRoZSBpdGVyYXRvciBmdW5jdGlvbiBhbmQgcGFzc2luZyBpdCBhbiBhY2N1bXVsYXRvciB2YWx1ZSBhbmQgdGhlIGN1cnJlbnRcbiAgICAgKiB2YWx1ZSBmcm9tIHRoZSBhcnJheSwgYW5kIHRoZW4gcGFzc2luZyB0aGUgcmVzdWx0IHRvIHRoZSBuZXh0IGNhbGwuXG4gICAgICpcbiAgICAgKiBUaGUgaXRlcmF0b3IgZnVuY3Rpb24gcmVjZWl2ZXMgdHdvIHZhbHVlczogKihhY2MsIHZhbHVlKSouIEl0IG1heSB1c2VcbiAgICAgKiBgUi5yZWR1Y2VkYCB0byBzaG9ydGN1dCB0aGUgaXRlcmF0aW9uLlxuICAgICAqXG4gICAgICogTm90ZTogYFIucmVkdWNlYCBkb2VzIG5vdCBza2lwIGRlbGV0ZWQgb3IgdW5hc3NpZ25lZCBpbmRpY2VzIChzcGFyc2VcbiAgICAgKiBhcnJheXMpLCB1bmxpa2UgdGhlIG5hdGl2ZSBgQXJyYXkucHJvdG90eXBlLnJlZHVjZWAgbWV0aG9kLiBGb3IgbW9yZSBkZXRhaWxzXG4gICAgICogb24gdGhpcyBiZWhhdmlvciwgc2VlOlxuICAgICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3JlZHVjZSNEZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogRGlzcGF0Y2hlcyB0byB0aGUgYHJlZHVjZWAgbWV0aG9kIG9mIHRoZSB0aGlyZCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnICgoYSwgYikgLT4gYSkgLT4gYSAtPiBbYl0gLT4gYVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBpdGVyYXRvciBmdW5jdGlvbi4gUmVjZWl2ZXMgdHdvIHZhbHVlcywgdGhlIGFjY3VtdWxhdG9yIGFuZCB0aGVcbiAgICAgKiAgICAgICAgY3VycmVudCBlbGVtZW50IGZyb20gdGhlIGFycmF5LlxuICAgICAqIEBwYXJhbSB7Kn0gYWNjIFRoZSBhY2N1bXVsYXRvciB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJuIHsqfSBUaGUgZmluYWwsIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBzZWUgUi5yZWR1Y2VkLCBSLmFkZEluZGV4XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIG51bWJlcnMgPSBbMSwgMiwgM107XG4gICAgICogICAgICB2YXIgYWRkID0gKGEsIGIpID0+IGEgKyBiO1xuICAgICAqXG4gICAgICogICAgICBSLnJlZHVjZShhZGQsIDEwLCBudW1iZXJzKTsgLy89PiAxNlxuICAgICAqL1xuICAgIHZhciByZWR1Y2UgPSBfY3VycnkzKF9yZWR1Y2UpO1xuXG4gICAgLyoqXG4gICAgICogR3JvdXBzIHRoZSBlbGVtZW50cyBvZiB0aGUgbGlzdCBhY2NvcmRpbmcgdG8gdGhlIHJlc3VsdCBvZiBjYWxsaW5nXG4gICAgICogdGhlIFN0cmluZy1yZXR1cm5pbmcgZnVuY3Rpb24gYGtleUZuYCBvbiBlYWNoIGVsZW1lbnQgYW5kIHJlZHVjZXMgdGhlIGVsZW1lbnRzXG4gICAgICogb2YgZWFjaCBncm91cCB0byBhIHNpbmdsZSB2YWx1ZSB2aWEgdGhlIHJlZHVjZXIgZnVuY3Rpb24gYHZhbHVlRm5gLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBiYXNpY2FsbHkgYSBtb3JlIGdlbmVyYWwgYGdyb3VwQnlgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4yMC4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnICgoYSwgYikgLT4gYSkgLT4gYSAtPiAoYiAtPiBTdHJpbmcpIC0+IFtiXSAtPiB7U3RyaW5nOiBhfVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHZhbHVlRm4gVGhlIGZ1bmN0aW9uIHRoYXQgcmVkdWNlcyB0aGUgZWxlbWVudHMgb2YgZWFjaCBncm91cCB0byBhIHNpbmdsZVxuICAgICAqICAgICAgICB2YWx1ZS4gUmVjZWl2ZXMgdHdvIHZhbHVlcywgYWNjdW11bGF0b3IgZm9yIGEgcGFydGljdWxhciBncm91cCBhbmQgdGhlIGN1cnJlbnQgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0geyp9IGFjYyBUaGUgKGluaXRpYWwpIGFjY3VtdWxhdG9yIHZhbHVlIGZvciBlYWNoIGdyb3VwLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleUZuIFRoZSBmdW5jdGlvbiB0aGF0IG1hcHMgdGhlIGxpc3QncyBlbGVtZW50IGludG8gYSBrZXkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gZ3JvdXAuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCB0aGUgb3V0cHV0IG9mIGBrZXlGbmAgZm9yIGtleXMsIG1hcHBlZCB0byB0aGUgb3V0cHV0IG9mXG4gICAgICogICAgICAgICBgdmFsdWVGbmAgZm9yIGVsZW1lbnRzIHdoaWNoIHByb2R1Y2VkIHRoYXQga2V5IHdoZW4gcGFzc2VkIHRvIGBrZXlGbmAuXG4gICAgICogQHNlZSBSLmdyb3VwQnksIFIucmVkdWNlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIHJlZHVjZVRvTmFtZXNCeSA9IFIucmVkdWNlQnkoKGFjYywgc3R1ZGVudCkgPT4gYWNjLmNvbmNhdChzdHVkZW50Lm5hbWUpLCBbXSk7XG4gICAgICogICAgICB2YXIgbmFtZXNCeUdyYWRlID0gcmVkdWNlVG9OYW1lc0J5KGZ1bmN0aW9uKHN0dWRlbnQpIHtcbiAgICAgKiAgICAgICAgdmFyIHNjb3JlID0gc3R1ZGVudC5zY29yZTtcbiAgICAgKiAgICAgICAgcmV0dXJuIHNjb3JlIDwgNjUgPyAnRicgOlxuICAgICAqICAgICAgICAgICAgICAgc2NvcmUgPCA3MCA/ICdEJyA6XG4gICAgICogICAgICAgICAgICAgICBzY29yZSA8IDgwID8gJ0MnIDpcbiAgICAgKiAgICAgICAgICAgICAgIHNjb3JlIDwgOTAgPyAnQicgOiAnQSc7XG4gICAgICogICAgICB9KTtcbiAgICAgKiAgICAgIHZhciBzdHVkZW50cyA9IFt7bmFtZTogJ0x1Y3knLCBzY29yZTogOTJ9LFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAnRHJldycsIHNjb3JlOiA4NX0sXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgLy8gLi4uXG4gICAgICogICAgICAgICAgICAgICAgICAgICAge25hbWU6ICdCYXJ0Jywgc2NvcmU6IDYyfV07XG4gICAgICogICAgICBuYW1lc0J5R3JhZGUoc3R1ZGVudHMpO1xuICAgICAqICAgICAgLy8ge1xuICAgICAqICAgICAgLy8gICAnQSc6IFsnTHVjeSddLFxuICAgICAqICAgICAgLy8gICAnQic6IFsnRHJldyddXG4gICAgICogICAgICAvLyAgIC8vIC4uLixcbiAgICAgKiAgICAgIC8vICAgJ0YnOiBbJ0JhcnQnXVxuICAgICAqICAgICAgLy8gfVxuICAgICAqL1xuICAgIHZhciByZWR1Y2VCeSA9IF9jdXJyeU4oNCwgW10sIGZ1bmN0aW9uIHJlZHVjZUJ5KHZhbHVlRm4sIHZhbHVlQWNjLCBrZXlGbiwgbGlzdCkge1xuICAgICAgICByZXR1cm4gX3JlZHVjZShmdW5jdGlvbiAoYWNjLCBlbHQpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlGbihlbHQpO1xuICAgICAgICAgICAgYWNjW2tleV0gPSB2YWx1ZUZuKF9oYXMoa2V5LCBhY2MpID8gYWNjW2tleV0gOiB2YWx1ZUFjYywgZWx0KTtcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIHt9LCBsaXN0KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb21wbGVtZW50IG9mIGBmaWx0ZXJgLlxuICAgICAqXG4gICAgICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgRmlsdGVyYWJsZSBmID0+IChhIC0+IEJvb2xlYW4pIC0+IGYgYSAtPiBmIGFcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkXG4gICAgICogQHBhcmFtIHtBcnJheX0gZmlsdGVyYWJsZVxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqIEBzZWUgUi5maWx0ZXIsIFIudHJhbnNkdWNlLCBSLmFkZEluZGV4XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGlzT2RkID0gKG4pID0+IG4gJSAyID09PSAxO1xuICAgICAqXG4gICAgICogICAgICBSLnJlamVjdChpc09kZCwgWzEsIDIsIDMsIDRdKTsgLy89PiBbMiwgNF1cbiAgICAgKlxuICAgICAqICAgICAgUi5yZWplY3QoaXNPZGQsIHthOiAxLCBiOiAyLCBjOiAzLCBkOiA0fSk7IC8vPT4ge2I6IDIsIGQ6IDR9XG4gICAgICovXG4gICAgdmFyIHJlamVjdCA9IF9jdXJyeTIoZnVuY3Rpb24gcmVqZWN0KHByZWQsIGZpbHRlcmFibGUpIHtcbiAgICAgICAgcmV0dXJuIGZpbHRlcihfY29tcGxlbWVudChwcmVkKSwgZmlsdGVyYWJsZSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZml4ZWQgbGlzdCBvZiBzaXplIGBuYCBjb250YWluaW5nIGEgc3BlY2lmaWVkIGlkZW50aWNhbCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4xXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIGEgLT4gbiAtPiBbYV1cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXBlYXQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG4gVGhlIGRlc2lyZWQgc2l6ZSBvZiB0aGUgb3V0cHV0IGxpc3QuXG4gICAgICogQHJldHVybiB7QXJyYXl9IEEgbmV3IGFycmF5IGNvbnRhaW5pbmcgYG5gIGB2YWx1ZWBzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIucmVwZWF0KCdoaScsIDUpOyAvLz0+IFsnaGknLCAnaGknLCAnaGknLCAnaGknLCAnaGknXVxuICAgICAqXG4gICAgICogICAgICB2YXIgb2JqID0ge307XG4gICAgICogICAgICB2YXIgcmVwZWF0ZWRPYmpzID0gUi5yZXBlYXQob2JqLCA1KTsgLy89PiBbe30sIHt9LCB7fSwge30sIHt9XVxuICAgICAqICAgICAgcmVwZWF0ZWRPYmpzWzBdID09PSByZXBlYXRlZE9ianNbMV07IC8vPT4gdHJ1ZVxuICAgICAqL1xuICAgIHZhciByZXBlYXQgPSBfY3VycnkyKGZ1bmN0aW9uIHJlcGVhdCh2YWx1ZSwgbikge1xuICAgICAgICByZXR1cm4gdGltZXMoYWx3YXlzKHZhbHVlKSwgbik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHRvZ2V0aGVyIGFsbCB0aGUgZWxlbWVudHMgb2YgYSBsaXN0LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBzaWcgW051bWJlcl0gLT4gTnVtYmVyXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBBbiBhcnJheSBvZiBudW1iZXJzXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgc3VtIG9mIGFsbCB0aGUgbnVtYmVycyBpbiB0aGUgbGlzdC5cbiAgICAgKiBAc2VlIFIucmVkdWNlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5zdW0oWzIsNCw2LDgsMTAwLDFdKTsgLy89PiAxMjFcbiAgICAgKi9cbiAgICB2YXIgc3VtID0gcmVkdWNlKGFkZCwgMCk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IGxpc3QgY29udGFpbmluZyB0aGUgbGFzdCBgbmAgZWxlbWVudHMgb2YgdGhlIGdpdmVuIGxpc3QuXG4gICAgICogSWYgYG4gPiBsaXN0Lmxlbmd0aGAsIHJldHVybnMgYSBsaXN0IG9mIGBsaXN0Lmxlbmd0aGAgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjE2LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgTnVtYmVyIC0+IFthXSAtPiBbYV1cbiAgICAgKiBAc2lnIE51bWJlciAtPiBTdHJpbmcgLT4gU3RyaW5nXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG4gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byByZXR1cm4uXG4gICAgICogQHBhcmFtIHtBcnJheX0geHMgVGhlIGNvbGxlY3Rpb24gdG8gY29uc2lkZXIuXG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICogQHNlZSBSLmRyb3BMYXN0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi50YWtlTGFzdCgxLCBbJ2ZvbycsICdiYXInLCAnYmF6J10pOyAvLz0+IFsnYmF6J11cbiAgICAgKiAgICAgIFIudGFrZUxhc3QoMiwgWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiBbJ2JhcicsICdiYXonXVxuICAgICAqICAgICAgUi50YWtlTGFzdCgzLCBbJ2ZvbycsICdiYXInLCAnYmF6J10pOyAvLz0+IFsnZm9vJywgJ2JhcicsICdiYXonXVxuICAgICAqICAgICAgUi50YWtlTGFzdCg0LCBbJ2ZvbycsICdiYXInLCAnYmF6J10pOyAvLz0+IFsnZm9vJywgJ2JhcicsICdiYXonXVxuICAgICAqICAgICAgUi50YWtlTGFzdCgzLCAncmFtZGEnKTsgICAgICAgICAgICAgICAvLz0+ICdtZGEnXG4gICAgICovXG4gICAgdmFyIHRha2VMYXN0ID0gX2N1cnJ5MihmdW5jdGlvbiB0YWtlTGFzdChuLCB4cykge1xuICAgICAgICByZXR1cm4gZHJvcChuID49IDAgPyB4cy5sZW5ndGggLSBuIDogMCwgeHMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYSB0cmFuc2R1Y2VyIHVzaW5nIHN1cHBsaWVkIGl0ZXJhdG9yIGZ1bmN0aW9uLiBSZXR1cm5zIGEgc2luZ2xlXG4gICAgICogaXRlbSBieSBpdGVyYXRpbmcgdGhyb3VnaCB0aGUgbGlzdCwgc3VjY2Vzc2l2ZWx5IGNhbGxpbmcgdGhlIHRyYW5zZm9ybWVkXG4gICAgICogaXRlcmF0b3IgZnVuY3Rpb24gYW5kIHBhc3NpbmcgaXQgYW4gYWNjdW11bGF0b3IgdmFsdWUgYW5kIHRoZSBjdXJyZW50IHZhbHVlXG4gICAgICogZnJvbSB0aGUgYXJyYXksIGFuZCB0aGVuIHBhc3NpbmcgdGhlIHJlc3VsdCB0byB0aGUgbmV4dCBjYWxsLlxuICAgICAqXG4gICAgICogVGhlIGl0ZXJhdG9yIGZ1bmN0aW9uIHJlY2VpdmVzIHR3byB2YWx1ZXM6ICooYWNjLCB2YWx1ZSkqLiBJdCB3aWxsIGJlXG4gICAgICogd3JhcHBlZCBhcyBhIHRyYW5zZm9ybWVyIHRvIGluaXRpYWxpemUgdGhlIHRyYW5zZHVjZXIuIEEgdHJhbnNmb3JtZXIgY2FuIGJlXG4gICAgICogcGFzc2VkIGRpcmVjdGx5IGluIHBsYWNlIG9mIGFuIGl0ZXJhdG9yIGZ1bmN0aW9uLiBJbiBib3RoIGNhc2VzLCBpdGVyYXRpb25cbiAgICAgKiBtYXkgYmUgc3RvcHBlZCBlYXJseSB3aXRoIHRoZSBgUi5yZWR1Y2VkYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEEgdHJhbnNkdWNlciBpcyBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBhIHRyYW5zZm9ybWVyIGFuZCByZXR1cm5zIGFcbiAgICAgKiB0cmFuc2Zvcm1lciBhbmQgY2FuIGJlIGNvbXBvc2VkIGRpcmVjdGx5LlxuICAgICAqXG4gICAgICogQSB0cmFuc2Zvcm1lciBpcyBhbiBhbiBvYmplY3QgdGhhdCBwcm92aWRlcyBhIDItYXJpdHkgcmVkdWNpbmcgaXRlcmF0b3JcbiAgICAgKiBmdW5jdGlvbiwgc3RlcCwgMC1hcml0eSBpbml0aWFsIHZhbHVlIGZ1bmN0aW9uLCBpbml0LCBhbmQgMS1hcml0eSByZXN1bHRcbiAgICAgKiBleHRyYWN0aW9uIGZ1bmN0aW9uLCByZXN1bHQuIFRoZSBzdGVwIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIGl0ZXJhdG9yXG4gICAgICogZnVuY3Rpb24gaW4gcmVkdWNlLiBUaGUgcmVzdWx0IGZ1bmN0aW9uIGlzIHVzZWQgdG8gY29udmVydCB0aGUgZmluYWxcbiAgICAgKiBhY2N1bXVsYXRvciBpbnRvIHRoZSByZXR1cm4gdHlwZSBhbmQgaW4gbW9zdCBjYXNlcyBpcyBSLmlkZW50aXR5LiBUaGUgaW5pdFxuICAgICAqIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIHRvIHByb3ZpZGUgYW4gaW5pdGlhbCBhY2N1bXVsYXRvciwgYnV0IGlzIGlnbm9yZWQgYnlcbiAgICAgKiB0cmFuc2R1Y2UuXG4gICAgICpcbiAgICAgKiBUaGUgaXRlcmF0aW9uIGlzIHBlcmZvcm1lZCB3aXRoIFIucmVkdWNlIGFmdGVyIGluaXRpYWxpemluZyB0aGUgdHJhbnNkdWNlci5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTIuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyAoYyAtPiBjKSAtPiAoYSxiIC0+IGEpIC0+IGEgLT4gW2JdIC0+IGFcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB4ZiBUaGUgdHJhbnNkdWNlciBmdW5jdGlvbi4gUmVjZWl2ZXMgYSB0cmFuc2Zvcm1lciBhbmQgcmV0dXJucyBhIHRyYW5zZm9ybWVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBpdGVyYXRvciBmdW5jdGlvbi4gUmVjZWl2ZXMgdHdvIHZhbHVlcywgdGhlIGFjY3VtdWxhdG9yIGFuZCB0aGVcbiAgICAgKiAgICAgICAgY3VycmVudCBlbGVtZW50IGZyb20gdGhlIGFycmF5LiBXcmFwcGVkIGFzIHRyYW5zZm9ybWVyLCBpZiBuZWNlc3NhcnksIGFuZCB1c2VkIHRvXG4gICAgICogICAgICAgIGluaXRpYWxpemUgdGhlIHRyYW5zZHVjZXJcbiAgICAgKiBAcGFyYW0geyp9IGFjYyBUaGUgaW5pdGlhbCBhY2N1bXVsYXRvciB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJuIHsqfSBUaGUgZmluYWwsIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBzZWUgUi5yZWR1Y2UsIFIucmVkdWNlZCwgUi5pbnRvXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIG51bWJlcnMgPSBbMSwgMiwgMywgNF07XG4gICAgICogICAgICB2YXIgdHJhbnNkdWNlciA9IFIuY29tcG9zZShSLm1hcChSLmFkZCgxKSksIFIudGFrZSgyKSk7XG4gICAgICpcbiAgICAgKiAgICAgIFIudHJhbnNkdWNlKHRyYW5zZHVjZXIsIFIuZmxpcChSLmFwcGVuZCksIFtdLCBudW1iZXJzKTsgLy89PiBbMiwgM11cbiAgICAgKi9cbiAgICB2YXIgdHJhbnNkdWNlID0gY3VycnlOKDQsIGZ1bmN0aW9uIHRyYW5zZHVjZSh4ZiwgZm4sIGFjYywgbGlzdCkge1xuICAgICAgICByZXR1cm4gX3JlZHVjZSh4Zih0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicgPyBfeHdyYXAoZm4pIDogZm4pLCBhY2MsIGxpc3QpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29tYmluZXMgdHdvIGxpc3RzIGludG8gYSBzZXQgKGkuZS4gbm8gZHVwbGljYXRlcykgY29tcG9zZWQgb2YgdGhlIGVsZW1lbnRzXG4gICAgICogb2YgZWFjaCBsaXN0LiBEdXBsaWNhdGlvbiBpcyBkZXRlcm1pbmVkIGFjY29yZGluZyB0byB0aGUgdmFsdWUgcmV0dXJuZWQgYnlcbiAgICAgKiBhcHBseWluZyB0aGUgc3VwcGxpZWQgcHJlZGljYXRlIHRvIHR3byBsaXN0IGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAgICAgKiBAc2lnIChhIC0+IGEgLT4gQm9vbGVhbikgLT4gWypdIC0+IFsqXSAtPiBbKl1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkIEEgcHJlZGljYXRlIHVzZWQgdG8gdGVzdCB3aGV0aGVyIHR3byBpdGVtcyBhcmUgZXF1YWwuXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdDEgVGhlIGZpcnN0IGxpc3QuXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdDIgVGhlIHNlY29uZCBsaXN0LlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBUaGUgZmlyc3QgYW5kIHNlY29uZCBsaXN0cyBjb25jYXRlbmF0ZWQsIHdpdGhcbiAgICAgKiAgICAgICAgIGR1cGxpY2F0ZXMgcmVtb3ZlZC5cbiAgICAgKiBAc2VlIFIudW5pb25cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgbDEgPSBbe2E6IDF9LCB7YTogMn1dO1xuICAgICAqICAgICAgdmFyIGwyID0gW3thOiAxfSwge2E6IDR9XTtcbiAgICAgKiAgICAgIFIudW5pb25XaXRoKFIuZXFCeShSLnByb3AoJ2EnKSksIGwxLCBsMik7IC8vPT4gW3thOiAxfSwge2E6IDJ9LCB7YTogNH1dXG4gICAgICovXG4gICAgdmFyIHVuaW9uV2l0aCA9IF9jdXJyeTMoZnVuY3Rpb24gdW5pb25XaXRoKHByZWQsIGxpc3QxLCBsaXN0Mikge1xuICAgICAgICByZXR1cm4gdW5pcVdpdGgocHJlZCwgX2NvbmNhdChsaXN0MSwgbGlzdDIpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRha2VzIGEgc3BlYyBvYmplY3QgYW5kIGEgdGVzdCBvYmplY3Q7IHJldHVybnMgdHJ1ZSBpZiB0aGUgdGVzdCBzYXRpc2ZpZXNcbiAgICAgKiB0aGUgc3BlYywgZmFsc2Ugb3RoZXJ3aXNlLiBBbiBvYmplY3Qgc2F0aXNmaWVzIHRoZSBzcGVjIGlmLCBmb3IgZWFjaCBvZiB0aGVcbiAgICAgKiBzcGVjJ3Mgb3duIHByb3BlcnRpZXMsIGFjY2Vzc2luZyB0aGF0IHByb3BlcnR5IG9mIHRoZSBvYmplY3QgZ2l2ZXMgdGhlIHNhbWVcbiAgICAgKiB2YWx1ZSAoaW4gYFIuZXF1YWxzYCB0ZXJtcykgYXMgYWNjZXNzaW5nIHRoYXQgcHJvcGVydHkgb2YgdGhlIHNwZWMuXG4gICAgICpcbiAgICAgKiBgd2hlcmVFcWAgaXMgYSBzcGVjaWFsaXphdGlvbiBvZiBbYHdoZXJlYF0oI3doZXJlKS5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTQuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAc2lnIHtTdHJpbmc6ICp9IC0+IHtTdHJpbmc6ICp9IC0+IEJvb2xlYW5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3BlY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0ZXN0T2JqXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKiBAc2VlIFIud2hlcmVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICAvLyBwcmVkIDo6IE9iamVjdCAtPiBCb29sZWFuXG4gICAgICogICAgICB2YXIgcHJlZCA9IFIud2hlcmVFcSh7YTogMSwgYjogMn0pO1xuICAgICAqXG4gICAgICogICAgICBwcmVkKHthOiAxfSk7ICAgICAgICAgICAgICAvLz0+IGZhbHNlXG4gICAgICogICAgICBwcmVkKHthOiAxLCBiOiAyfSk7ICAgICAgICAvLz0+IHRydWVcbiAgICAgKiAgICAgIHByZWQoe2E6IDEsIGI6IDIsIGM6IDN9KTsgIC8vPT4gdHJ1ZVxuICAgICAqICAgICAgcHJlZCh7YTogMSwgYjogMX0pOyAgICAgICAgLy89PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciB3aGVyZUVxID0gX2N1cnJ5MihmdW5jdGlvbiB3aGVyZUVxKHNwZWMsIHRlc3RPYmopIHtcbiAgICAgICAgcmV0dXJuIHdoZXJlKG1hcChlcXVhbHMsIHNwZWMpLCB0ZXN0T2JqKTtcbiAgICB9KTtcblxuICAgIHZhciBfZmxhdENhdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByZXNlcnZpbmdSZWR1Y2VkID0gZnVuY3Rpb24gKHhmKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICdAQHRyYW5zZHVjZXIvaW5pdCc6IF94ZkJhc2UuaW5pdCxcbiAgICAgICAgICAgICAgICAnQEB0cmFuc2R1Y2VyL3Jlc3VsdCc6IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHhmWydAQHRyYW5zZHVjZXIvcmVzdWx0J10ocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdAQHRyYW5zZHVjZXIvc3RlcCc6IGZ1bmN0aW9uIChyZXN1bHQsIGlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSB4ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIGlucHV0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldFsnQEB0cmFuc2R1Y2VyL3JlZHVjZWQnXSA/IF9mb3JjZVJlZHVjZWQocmV0KSA6IHJldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gX3hjYXQoeGYpIHtcbiAgICAgICAgICAgIHZhciByeGYgPSBwcmVzZXJ2aW5nUmVkdWNlZCh4Zik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICdAQHRyYW5zZHVjZXIvaW5pdCc6IF94ZkJhc2UuaW5pdCxcbiAgICAgICAgICAgICAgICAnQEB0cmFuc2R1Y2VyL3Jlc3VsdCc6IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ4ZlsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnQEB0cmFuc2R1Y2VyL3N0ZXAnOiBmdW5jdGlvbiAocmVzdWx0LCBpbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWlzQXJyYXlMaWtlKGlucHV0KSA/IF9yZWR1Y2UocnhmLCByZXN1bHQsIFtpbnB1dF0pIDogX3JlZHVjZShyeGYsIHJlc3VsdCwgaW5wdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfSgpO1xuXG4gICAgLy8gQXJyYXkucHJvdG90eXBlLmluZGV4T2YgZG9lc24ndCBleGlzdCBiZWxvdyBJRTlcbiAgICAvLyBtYW51YWxseSBjcmF3bCB0aGUgbGlzdCB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuICswIGFuZCAtMFxuICAgIC8vIE5hTlxuICAgIC8vIG5vbi16ZXJvIG51bWJlcnMgY2FuIHV0aWxpc2UgU2V0XG4gICAgLy8gYWxsIHRoZXNlIHR5cGVzIGNhbiB1dGlsaXNlIFNldFxuICAgIC8vIG51bGwgY2FuIHV0aWxpc2UgU2V0XG4gICAgLy8gYW55dGhpbmcgZWxzZSBub3QgY292ZXJlZCBhYm92ZSwgZGVmZXIgdG8gUi5lcXVhbHNcbiAgICB2YXIgX2luZGV4T2YgPSBmdW5jdGlvbiBfaW5kZXhPZihsaXN0LCBhLCBpZHgpIHtcbiAgICAgICAgdmFyIGluZiwgaXRlbTtcbiAgICAgICAgLy8gQXJyYXkucHJvdG90eXBlLmluZGV4T2YgZG9lc24ndCBleGlzdCBiZWxvdyBJRTlcbiAgICAgICAgaWYgKHR5cGVvZiBsaXN0LmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGEpIHtcbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgaWYgKGEgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWFudWFsbHkgY3Jhd2wgdGhlIGxpc3QgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiArMCBhbmQgLTBcbiAgICAgICAgICAgICAgICAgICAgaW5mID0gMSAvIGE7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpZHggPCBsaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSA9IGxpc3RbaWR4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtID09PSAwICYmIDEgLyBpdGVtID09PSBpbmYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWR4O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYSAhPT0gYSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBOYU5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGlkeCA8IGxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtID0gbGlzdFtpZHhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSAnbnVtYmVyJyAmJiBpdGVtICE9PSBpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlkeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gbm9uLXplcm8gbnVtYmVycyBjYW4gdXRpbGlzZSBTZXRcbiAgICAgICAgICAgICAgICByZXR1cm4gbGlzdC5pbmRleE9mKGEsIGlkeCk7XG4gICAgICAgICAgICAvLyBhbGwgdGhlc2UgdHlwZXMgY2FuIHV0aWxpc2UgU2V0XG4gICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBsaXN0LmluZGV4T2YoYSwgaWR4KTtcbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgaWYgKGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbnVsbCBjYW4gdXRpbGlzZSBTZXRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpc3QuaW5kZXhPZihhLCBpZHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBhbnl0aGluZyBlbHNlIG5vdCBjb3ZlcmVkIGFib3ZlLCBkZWZlciB0byBSLmVxdWFsc1xuICAgICAgICB3aGlsZSAoaWR4IDwgbGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChlcXVhbHMobGlzdFtpZHhdLCBhKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpZHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcblxuICAgIHZhciBfeGNoYWluID0gX2N1cnJ5MihmdW5jdGlvbiBfeGNoYWluKGYsIHhmKSB7XG4gICAgICAgIHJldHVybiBtYXAoZiwgX2ZsYXRDYXQoeGYpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRha2VzIGEgbGlzdCBvZiBwcmVkaWNhdGVzIGFuZCByZXR1cm5zIGEgcHJlZGljYXRlIHRoYXQgcmV0dXJucyB0cnVlIGZvciBhXG4gICAgICogZ2l2ZW4gbGlzdCBvZiBhcmd1bWVudHMgaWYgZXZlcnkgb25lIG9mIHRoZSBwcm92aWRlZCBwcmVkaWNhdGVzIGlzIHNhdGlzZmllZFxuICAgICAqIGJ5IHRob3NlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIFRoZSBmdW5jdGlvbiByZXR1cm5lZCBpcyBhIGN1cnJpZWQgZnVuY3Rpb24gd2hvc2UgYXJpdHkgbWF0Y2hlcyB0aGF0IG9mIHRoZVxuICAgICAqIGhpZ2hlc3QtYXJpdHkgcHJlZGljYXRlLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC45LjBcbiAgICAgKiBAY2F0ZWdvcnkgTG9naWNcbiAgICAgKiBAc2lnIFsoKi4uLiAtPiBCb29sZWFuKV0gLT4gKCouLi4gLT4gQm9vbGVhbilcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwcmVkc1xuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgICAqIEBzZWUgUi5hbnlQYXNzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGlzUXVlZW4gPSBSLnByb3BFcSgncmFuaycsICdRJyk7XG4gICAgICogICAgICB2YXIgaXNTcGFkZSA9IFIucHJvcEVxKCdzdWl0JywgJ+KZoO+4jicpO1xuICAgICAqICAgICAgdmFyIGlzUXVlZW5PZlNwYWRlcyA9IFIuYWxsUGFzcyhbaXNRdWVlbiwgaXNTcGFkZV0pO1xuICAgICAqXG4gICAgICogICAgICBpc1F1ZWVuT2ZTcGFkZXMoe3Jhbms6ICdRJywgc3VpdDogJ+KZo++4jid9KTsgLy89PiBmYWxzZVxuICAgICAqICAgICAgaXNRdWVlbk9mU3BhZGVzKHtyYW5rOiAnUScsIHN1aXQ6ICfimaDvuI4nfSk7IC8vPT4gdHJ1ZVxuICAgICAqL1xuICAgIHZhciBhbGxQYXNzID0gX2N1cnJ5MShmdW5jdGlvbiBhbGxQYXNzKHByZWRzKSB7XG4gICAgICAgIHJldHVybiBjdXJyeU4ocmVkdWNlKG1heCwgMCwgcGx1Y2soJ2xlbmd0aCcsIHByZWRzKSksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpZHggPSAwO1xuICAgICAgICAgICAgdmFyIGxlbiA9IHByZWRzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoIXByZWRzW2lkeF0uYXBwbHkodGhpcywgYXJndW1lbnRzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIGFyZSB1bmlxdWUsIGluIGBSLmVxdWFsc2AgdGVybXMsIG90aGVyd2lzZVxuICAgICAqIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjE4LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgW2FdIC0+IEJvb2xlYW5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBjb25zaWRlci5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIGFyZSB1bmlxdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2MC4yMC4wXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5hbGxVbmlxKFsnMScsIDFdKTsgLy89PiB0cnVlXG4gICAgICogICAgICBSLmFsbFVuaXEoWzEsIDFdKTsgICAvLz0+IGZhbHNlXG4gICAgICogICAgICBSLmFsbFVuaXEoW1s0Ml0sIFs0Ml1dKTsgLy89PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBhbGxVbmlxID0gX2N1cnJ5MShmdW5jdGlvbiBhbGxVbmlxKGxpc3QpIHtcbiAgICAgICAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICAgICAgICB2YXIgaWR4ID0gMDtcbiAgICAgICAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKF9pbmRleE9mKGxpc3QsIGxpc3RbaWR4XSwgaWR4ICsgMSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGFrZXMgYSBsaXN0IG9mIHByZWRpY2F0ZXMgYW5kIHJldHVybnMgYSBwcmVkaWNhdGUgdGhhdCByZXR1cm5zIHRydWUgZm9yIGFcbiAgICAgKiBnaXZlbiBsaXN0IG9mIGFyZ3VtZW50cyBpZiBhdCBsZWFzdCBvbmUgb2YgdGhlIHByb3ZpZGVkIHByZWRpY2F0ZXMgaXNcbiAgICAgKiBzYXRpc2ZpZWQgYnkgdGhvc2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogVGhlIGZ1bmN0aW9uIHJldHVybmVkIGlzIGEgY3VycmllZCBmdW5jdGlvbiB3aG9zZSBhcml0eSBtYXRjaGVzIHRoYXQgb2YgdGhlXG4gICAgICogaGlnaGVzdC1hcml0eSBwcmVkaWNhdGUuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjkuMFxuICAgICAqIEBjYXRlZ29yeSBMb2dpY1xuICAgICAqIEBzaWcgWygqLi4uIC0+IEJvb2xlYW4pXSAtPiAoKi4uLiAtPiBCb29sZWFuKVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHByZWRzXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAgICogQHNlZSBSLmFsbFBhc3NcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgZ3RlID0gUi5hbnlQYXNzKFtSLmd0LCBSLmVxdWFsc10pO1xuICAgICAqXG4gICAgICogICAgICBndGUoMywgMik7IC8vPT4gdHJ1ZVxuICAgICAqICAgICAgZ3RlKDIsIDIpOyAvLz0+IHRydWVcbiAgICAgKiAgICAgIGd0ZSgyLCAzKTsgLy89PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBhbnlQYXNzID0gX2N1cnJ5MShmdW5jdGlvbiBhbnlQYXNzKHByZWRzKSB7XG4gICAgICAgIHJldHVybiBjdXJyeU4ocmVkdWNlKG1heCwgMCwgcGx1Y2soJ2xlbmd0aCcsIHByZWRzKSksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpZHggPSAwO1xuICAgICAgICAgICAgdmFyIGxlbiA9IHByZWRzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAocHJlZHNbaWR4XS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBhcCBhcHBsaWVzIGEgbGlzdCBvZiBmdW5jdGlvbnMgdG8gYSBsaXN0IG9mIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIERpc3BhdGNoZXMgdG8gdGhlIGBhcGAgbWV0aG9kIG9mIHRoZSBzZWNvbmQgYXJndW1lbnQsIGlmIHByZXNlbnQuIEFsc29cbiAgICAgKiB0cmVhdHMgZnVuY3Rpb25zIGFzIGFwcGxpY2F0aXZlcy5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMy4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHNpZyBbZl0gLT4gW2FdIC0+IFtmIGFdXG4gICAgICogQHBhcmFtIHtBcnJheX0gZm5zIEFuIGFycmF5IG9mIGZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZzIEFuIGFycmF5IG9mIHZhbHVlc1xuICAgICAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvZiByZXN1bHRzIG9mIGFwcGx5aW5nIGVhY2ggb2YgYGZuc2AgdG8gYWxsIG9mIGB2c2AgaW4gdHVybi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLmFwKFtSLm11bHRpcGx5KDIpLCBSLmFkZCgzKV0sIFsxLDIsM10pOyAvLz0+IFsyLCA0LCA2LCA0LCA1LCA2XVxuICAgICAqL1xuICAgIC8vIGVsc2VcbiAgICB2YXIgYXAgPSBfY3VycnkyKGZ1bmN0aW9uIGFwKGFwcGxpY2F0aXZlLCBmbikge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGFwcGxpY2F0aXZlLmFwID09PSAnZnVuY3Rpb24nID8gYXBwbGljYXRpdmUuYXAoZm4pIDogdHlwZW9mIGFwcGxpY2F0aXZlID09PSAnZnVuY3Rpb24nID8gY3VycnlOKE1hdGgubWF4KGFwcGxpY2F0aXZlLmxlbmd0aCwgZm4ubGVuZ3RoKSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGFwcGxpY2F0aXZlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykoZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICAgIH0pIDogLy8gZWxzZVxuICAgICAgICBfcmVkdWNlKGZ1bmN0aW9uIChhY2MsIGYpIHtcbiAgICAgICAgICAgIHJldHVybiBfY29uY2F0KGFjYywgbWFwKGYsIGZuKSk7XG4gICAgICAgIH0sIFtdLCBhcHBsaWNhdGl2ZSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIHNwZWMgb2JqZWN0IHJlY3Vyc2l2ZWx5IG1hcHBpbmcgcHJvcGVydGllcyB0byBmdW5jdGlvbnMsIGNyZWF0ZXMgYVxuICAgICAqIGZ1bmN0aW9uIHByb2R1Y2luZyBhbiBvYmplY3Qgb2YgdGhlIHNhbWUgc3RydWN0dXJlLCBieSBtYXBwaW5nIGVhY2ggcHJvcGVydHlcbiAgICAgKiB0byB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgaXRzIGFzc29jaWF0ZWQgZnVuY3Rpb24gd2l0aCB0aGUgc3VwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4yMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHNpZyB7azogKChhLCBiLCAuLi4sIG0pIC0+IHYpfSAtPiAoKGEsIGIsIC4uLiwgbSkgLT4ge2s6IHZ9KVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzcGVjIGFuIG9iamVjdCByZWN1cnNpdmVseSBtYXBwaW5nIHByb3BlcnRpZXMgdG8gZnVuY3Rpb25zIGZvclxuICAgICAqICAgICAgICBwcm9kdWNpbmcgdGhlIHZhbHVlcyBmb3IgdGhlc2UgcHJvcGVydGllcy5cbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gb2JqZWN0IG9mIHRoZSBzYW1lIHN0cnVjdHVyZVxuICAgICAqIGFzIGBzcGVjJywgd2l0aCBlYWNoIHByb3BlcnR5IHNldCB0byB0aGUgdmFsdWUgcmV0dXJuZWQgYnkgY2FsbGluZyBpdHNcbiAgICAgKiBhc3NvY2lhdGVkIGZ1bmN0aW9uIHdpdGggdGhlIHN1cHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKiBAc2VlIFIuanV4dFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBnZXRNZXRyaWNzID0gUi5hcHBseVNwZWMoe1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdW06IFIuYWRkLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXN0ZWQ6IHsgbXVsOiBSLm11bHRpcGx5IH1cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICogICAgICBnZXRNZXRyaWNzKDIsIDQpOyAvLyA9PiB7IHN1bTogNiwgbmVzdGVkOiB7IG11bDogOCB9IH1cbiAgICAgKi9cbiAgICB2YXIgYXBwbHlTcGVjID0gX2N1cnJ5MShmdW5jdGlvbiBhcHBseVNwZWMoc3BlYykge1xuICAgICAgICBzcGVjID0gbWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHYgPT0gJ2Z1bmN0aW9uJyA/IHYgOiBhcHBseVNwZWModik7XG4gICAgICAgIH0sIHNwZWMpO1xuICAgICAgICByZXR1cm4gY3VycnlOKHJlZHVjZShtYXgsIDAsIHBsdWNrKCdsZW5ndGgnLCB2YWx1ZXMoc3BlYykpKSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICByZXR1cm4gbWFwKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcGx5KGYsIGFyZ3MpO1xuICAgICAgICAgICAgfSwgc3BlYyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgaXRzIGZpcnN0IGFyZ3VtZW50IHdpdGggdGhlIHJlbWFpbmluZ1xuICAgICAqIGFyZ3VtZW50cy4gVGhpcyBpcyBvY2Nhc2lvbmFsbHkgdXNlZnVsIGFzIGEgY29udmVyZ2luZyBmdW5jdGlvbiBmb3JcbiAgICAgKiBgUi5jb252ZXJnZWA6IHRoZSBsZWZ0IGJyYW5jaCBjYW4gcHJvZHVjZSBhIGZ1bmN0aW9uIHdoaWxlIHRoZSByaWdodCBicmFuY2hcbiAgICAgKiBwcm9kdWNlcyBhIHZhbHVlIHRvIGJlIHBhc3NlZCB0byB0aGF0IGZ1bmN0aW9uIGFzIGFuIGFyZ3VtZW50LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC45LjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAc2lnICgqLi4uIC0+IGEpLCouLi4gLT4gYVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBhcHBseSB0byB0aGUgcmVtYWluaW5nIGFyZ3VtZW50cy5cbiAgICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgQW55IG51bWJlciBvZiBwb3NpdGlvbmFsIGFyZ3VtZW50cy5cbiAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAqIEBzZWUgUi5hcHBseVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBpbmRlbnROID0gUi5waXBlKFIudGltZXMoUi5hbHdheXMoJyAnKSksXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBSLmpvaW4oJycpLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgUi5yZXBsYWNlKC9eKD8hJCkvZ20pKTtcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGZvcm1hdCA9IFIuY29udmVyZ2UoUi5jYWxsLCBbXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUi5waXBlKFIucHJvcCgnaW5kZW50JyksIGluZGVudE4pLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFIucHJvcCgndmFsdWUnKVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICpcbiAgICAgKiAgICAgIGZvcm1hdCh7aW5kZW50OiAyLCB2YWx1ZTogJ2Zvb1xcbmJhclxcbmJhelxcbid9KTsgLy89PiAnICBmb29cXG4gIGJhclxcbiAgYmF6XFxuJ1xuICAgICAqL1xuICAgIHZhciBjYWxsID0gY3VycnkoZnVuY3Rpb24gY2FsbChmbikge1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgX3NsaWNlKGFyZ3VtZW50cywgMSkpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogYGNoYWluYCBtYXBzIGEgZnVuY3Rpb24gb3ZlciBhIGxpc3QgYW5kIGNvbmNhdGVuYXRlcyB0aGUgcmVzdWx0cy4gYGNoYWluYFxuICAgICAqIGlzIGFsc28ga25vd24gYXMgYGZsYXRNYXBgIGluIHNvbWUgbGlicmFyaWVzXG4gICAgICpcbiAgICAgKiBEaXNwYXRjaGVzIHRvIHRoZSBgY2hhaW5gIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgKGEgLT4gW2JdKSAtPiBbYV0gLT4gW2JdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0XG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGR1cGxpY2F0ZSA9IG4gPT4gW24sIG5dO1xuICAgICAqICAgICAgUi5jaGFpbihkdXBsaWNhdGUsIFsxLCAyLCAzXSk7IC8vPT4gWzEsIDEsIDIsIDIsIDMsIDNdXG4gICAgICovXG4gICAgdmFyIGNoYWluID0gX2N1cnJ5MihfZGlzcGF0Y2hhYmxlKCdjaGFpbicsIF94Y2hhaW4sIGZ1bmN0aW9uIGNoYWluKGZuLCBtb25hZCkge1xuICAgICAgICBpZiAodHlwZW9mIG1vbmFkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb25hZC5jYWxsKHRoaXMsIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfbWFrZUZsYXQoZmFsc2UpKG1hcChmbiwgbW9uYWQpKTtcbiAgICB9KSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24sIGBmbmAsIHdoaWNoIGVuY2Fwc3VsYXRlcyBpZi9lbHNlLWlmL2Vsc2UgbG9naWMuXG4gICAgICogYFIuY29uZGAgdGFrZXMgYSBsaXN0IG9mIFtwcmVkaWNhdGUsIHRyYW5zZm9ybV0gcGFpcnMuIEFsbCBvZiB0aGUgYXJndW1lbnRzXG4gICAgICogdG8gYGZuYCBhcmUgYXBwbGllZCB0byBlYWNoIG9mIHRoZSBwcmVkaWNhdGVzIGluIHR1cm4gdW50aWwgb25lIHJldHVybnMgYVxuICAgICAqIFwidHJ1dGh5XCIgdmFsdWUsIGF0IHdoaWNoIHBvaW50IGBmbmAgcmV0dXJucyB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIGl0c1xuICAgICAqIGFyZ3VtZW50cyB0byB0aGUgY29ycmVzcG9uZGluZyB0cmFuc2Zvcm1lci4gSWYgbm9uZSBvZiB0aGUgcHJlZGljYXRlc1xuICAgICAqIG1hdGNoZXMsIGBmbmAgcmV0dXJucyB1bmRlZmluZWQuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjYuMFxuICAgICAqIEBjYXRlZ29yeSBMb2dpY1xuICAgICAqIEBzaWcgW1soKi4uLiAtPiBCb29sZWFuKSwoKi4uLiAtPiAqKV1dIC0+ICgqLi4uIC0+ICopXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFpcnNcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgZm4gPSBSLmNvbmQoW1xuICAgICAqICAgICAgICBbUi5lcXVhbHMoMCksICAgUi5hbHdheXMoJ3dhdGVyIGZyZWV6ZXMgYXQgMMKwQycpXSxcbiAgICAgKiAgICAgICAgW1IuZXF1YWxzKDEwMCksIFIuYWx3YXlzKCd3YXRlciBib2lscyBhdCAxMDDCsEMnKV0sXG4gICAgICogICAgICAgIFtSLlQsICAgICAgICAgICB0ZW1wID0+ICdub3RoaW5nIHNwZWNpYWwgaGFwcGVucyBhdCAnICsgdGVtcCArICfCsEMnXVxuICAgICAqICAgICAgXSk7XG4gICAgICogICAgICBmbigwKTsgLy89PiAnd2F0ZXIgZnJlZXplcyBhdCAwwrBDJ1xuICAgICAqICAgICAgZm4oNTApOyAvLz0+ICdub3RoaW5nIHNwZWNpYWwgaGFwcGVucyBhdCA1MMKwQydcbiAgICAgKiAgICAgIGZuKDEwMCk7IC8vPT4gJ3dhdGVyIGJvaWxzIGF0IDEwMMKwQydcbiAgICAgKi9cbiAgICB2YXIgY29uZCA9IF9jdXJyeTEoZnVuY3Rpb24gY29uZChwYWlycykge1xuICAgICAgICB2YXIgYXJpdHkgPSByZWR1Y2UobWF4LCAwLCBtYXAoZnVuY3Rpb24gKHBhaXIpIHtcbiAgICAgICAgICAgIHJldHVybiBwYWlyWzBdLmxlbmd0aDtcbiAgICAgICAgfSwgcGFpcnMpKTtcbiAgICAgICAgcmV0dXJuIF9hcml0eShhcml0eSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoaWR4IDwgcGFpcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhaXJzW2lkeF1bMF0uYXBwbHkodGhpcywgYXJndW1lbnRzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFpcnNbaWR4XVsxXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBXcmFwcyBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGluc2lkZSBhIGN1cnJpZWQgZnVuY3Rpb24gdGhhdCBjYW4gYmUgY2FsbGVkXG4gICAgICogd2l0aCB0aGUgc2FtZSBhcmd1bWVudHMgYW5kIHJldHVybnMgdGhlIHNhbWUgdHlwZS4gVGhlIGFyaXR5IG9mIHRoZSBmdW5jdGlvblxuICAgICAqIHJldHVybmVkIGlzIHNwZWNpZmllZCB0byBhbGxvdyB1c2luZyB2YXJpYWRpYyBjb25zdHJ1Y3RvciBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjQuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBzaWcgTnVtYmVyIC0+ICgqIC0+IHsqfSkgLT4gKCogLT4geyp9KVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuIFRoZSBhcml0eSBvZiB0aGUgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gRm4gVGhlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IEEgd3JhcHBlZCwgY3VycmllZCBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICAvLyBWYXJpYWRpYyBjb25zdHJ1Y3RvciBmdW5jdGlvblxuICAgICAqICAgICAgdmFyIFdpZGdldCA9ICgpID0+IHtcbiAgICAgKiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICogICAgICAgIC8vIC4uLlxuICAgICAqICAgICAgfTtcbiAgICAgKiAgICAgIFdpZGdldC5wcm90b3R5cGUgPSB7XG4gICAgICogICAgICAgIC8vIC4uLlxuICAgICAqICAgICAgfTtcbiAgICAgKiAgICAgIHZhciBhbGxDb25maWdzID0gW1xuICAgICAqICAgICAgICAvLyAuLi5cbiAgICAgKiAgICAgIF07XG4gICAgICogICAgICBSLm1hcChSLmNvbnN0cnVjdE4oMSwgV2lkZ2V0KSwgYWxsQ29uZmlncyk7IC8vIGEgbGlzdCBvZiBXaWRnZXRzXG4gICAgICovXG4gICAgdmFyIGNvbnN0cnVjdE4gPSBfY3VycnkyKGZ1bmN0aW9uIGNvbnN0cnVjdE4obiwgRm4pIHtcbiAgICAgICAgaWYgKG4gPiAxMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb25zdHJ1Y3RvciB3aXRoIGdyZWF0ZXIgdGhhbiB0ZW4gYXJndW1lbnRzJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGbigpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VycnkobkFyeShuLCBmdW5jdGlvbiAoJDAsICQxLCAkMiwgJDMsICQ0LCAkNSwgJDYsICQ3LCAkOCwgJDkpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRm4oJDApO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRm4oJDAsICQxKTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZuKCQwLCAkMSwgJDIpO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRm4oJDAsICQxLCAkMiwgJDMpO1xuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRm4oJDAsICQxLCAkMiwgJDMsICQ0KTtcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZuKCQwLCAkMSwgJDIsICQzLCAkNCwgJDUpO1xuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRm4oJDAsICQxLCAkMiwgJDMsICQ0LCAkNSwgJDYpO1xuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRm4oJDAsICQxLCAkMiwgJDMsICQ0LCAkNSwgJDYsICQ3KTtcbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZuKCQwLCAkMSwgJDIsICQzLCAkNCwgJDUsICQ2LCAkNywgJDgpO1xuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZuKCQwLCAkMSwgJDIsICQzLCAkNCwgJDUsICQ2LCAkNywgJDgsICQ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQWNjZXB0cyBhIGNvbnZlcmdpbmcgZnVuY3Rpb24gYW5kIGEgbGlzdCBvZiBicmFuY2hpbmcgZnVuY3Rpb25zIGFuZCByZXR1cm5zXG4gICAgICogYSBuZXcgZnVuY3Rpb24uIFdoZW4gaW52b2tlZCwgdGhpcyBuZXcgZnVuY3Rpb24gaXMgYXBwbGllZCB0byBzb21lXG4gICAgICogYXJndW1lbnRzLCBlYWNoIGJyYW5jaGluZyBmdW5jdGlvbiBpcyBhcHBsaWVkIHRvIHRob3NlIHNhbWUgYXJndW1lbnRzLiBUaGVcbiAgICAgKiByZXN1bHRzIG9mIGVhY2ggYnJhbmNoaW5nIGZ1bmN0aW9uIGFyZSBwYXNzZWQgYXMgYXJndW1lbnRzIHRvIHRoZSBjb252ZXJnaW5nXG4gICAgICogZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgcmV0dXJuIHZhbHVlLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC40LjJcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAc2lnICh4MSAtPiB4MiAtPiAuLi4gLT4geikgLT4gWyhhIC0+IGIgLT4gLi4uIC0+IHgxKSwgKGEgLT4gYiAtPiAuLi4gLT4geDIpLCAuLi5dIC0+IChhIC0+IGIgLT4gLi4uIC0+IHopXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYWZ0ZXIgQSBmdW5jdGlvbi4gYGFmdGVyYCB3aWxsIGJlIGludm9rZWQgd2l0aCB0aGUgcmV0dXJuIHZhbHVlcyBvZlxuICAgICAqICAgICAgICBgZm4xYCBhbmQgYGZuMmAgYXMgaXRzIGFyZ3VtZW50cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBmdW5jdGlvbnMgQSBsaXN0IG9mIGZ1bmN0aW9ucy5cbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGFkZCA9IChhLCBiKSA9PiBhICsgYjtcbiAgICAgKiAgICAgIHZhciBtdWx0aXBseSA9IChhLCBiKSA9PiBhICogYjtcbiAgICAgKiAgICAgIHZhciBzdWJ0cmFjdCA9IChhLCBiKSA9PiBhIC0gYjtcbiAgICAgKlxuICAgICAqICAgICAgLy/iiYUgbXVsdGlwbHkoIGFkZCgxLCAyKSwgc3VidHJhY3QoMSwgMikgKTtcbiAgICAgKiAgICAgIFIuY29udmVyZ2UobXVsdGlwbHksIFthZGQsIHN1YnRyYWN0XSkoMSwgMik7IC8vPT4gLTNcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGFkZDMgPSAoYSwgYiwgYykgPT4gYSArIGIgKyBjO1xuICAgICAqICAgICAgUi5jb252ZXJnZShhZGQzLCBbbXVsdGlwbHksIGFkZCwgc3VidHJhY3RdKSgxLCAyKTsgLy89PiA0XG4gICAgICovXG4gICAgdmFyIGNvbnZlcmdlID0gX2N1cnJ5MihmdW5jdGlvbiBjb252ZXJnZShhZnRlciwgZm5zKSB7XG4gICAgICAgIHJldHVybiBjdXJyeU4ocmVkdWNlKG1heCwgMCwgcGx1Y2soJ2xlbmd0aCcsIGZucykpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBhZnRlci5hcHBseShjb250ZXh0LCBfbWFwKGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICAgIH0sIGZucykpO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvdW50cyB0aGUgZWxlbWVudHMgb2YgYSBsaXN0IGFjY29yZGluZyB0byBob3cgbWFueSBtYXRjaCBlYWNoIHZhbHVlIG9mIGFcbiAgICAgKiBrZXkgZ2VuZXJhdGVkIGJ5IHRoZSBzdXBwbGllZCBmdW5jdGlvbi4gUmV0dXJucyBhbiBvYmplY3QgbWFwcGluZyB0aGUga2V5c1xuICAgICAqIHByb2R1Y2VkIGJ5IGBmbmAgdG8gdGhlIG51bWJlciBvZiBvY2N1cnJlbmNlcyBpbiB0aGUgbGlzdC4gTm90ZSB0aGF0IGFsbFxuICAgICAqIGtleXMgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncyBiZWNhdXNlIG9mIGhvdyBKYXZhU2NyaXB0IG9iamVjdHMgd29yay5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gICAgICogQHNpZyAoYSAtPiBTdHJpbmcpIC0+IFthXSAtPiB7Kn1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdXNlZCB0byBtYXAgdmFsdWVzIHRvIGtleXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byBjb3VudCBlbGVtZW50cyBmcm9tLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IG1hcHBpbmcga2V5cyB0byBudW1iZXIgb2Ygb2NjdXJyZW5jZXMgaW4gdGhlIGxpc3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIG51bWJlcnMgPSBbMS4wLCAxLjEsIDEuMiwgMi4wLCAzLjAsIDIuMl07XG4gICAgICogICAgICB2YXIgbGV0dGVycyA9IFIuc3BsaXQoJycsICdhYmNBQkNhYWFCQmMnKTtcbiAgICAgKiAgICAgIFIuY291bnRCeShNYXRoLmZsb29yKShudW1iZXJzKTsgICAgLy89PiB7JzEnOiAzLCAnMic6IDIsICczJzogMX1cbiAgICAgKiAgICAgIFIuY291bnRCeShSLnRvTG93ZXIpKGxldHRlcnMpOyAgIC8vPT4geydhJzogNSwgJ2InOiA0LCAnYyc6IDN9XG4gICAgICovXG4gICAgdmFyIGNvdW50QnkgPSByZWR1Y2VCeShmdW5jdGlvbiAoYWNjLCBlbGVtKSB7XG4gICAgICAgIHJldHVybiBhY2MgKyAxO1xuICAgIH0sIDApO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBsaXN0IHdpdGhvdXQgYW55IGNvbnNlY3V0aXZlbHkgcmVwZWF0aW5nIGVsZW1lbnRzLiBFcXVhbGl0eSBpc1xuICAgICAqIGRldGVybWluZWQgYnkgYXBwbHlpbmcgdGhlIHN1cHBsaWVkIHByZWRpY2F0ZSB0d28gY29uc2VjdXRpdmUgZWxlbWVudHMuIFRoZVxuICAgICAqIGZpcnN0IGVsZW1lbnQgaW4gYSBzZXJpZXMgb2YgZXF1YWwgZWxlbWVudCBpcyB0aGUgb25lIGJlaW5nIHByZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIERpc3BhdGNoZXMgdG8gdGhlIGBkcm9wUmVwZWF0c1dpdGhgIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICAgICAqXG4gICAgICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xNC4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIChhLCBhIC0+IEJvb2xlYW4pIC0+IFthXSAtPiBbYV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkIEEgcHJlZGljYXRlIHVzZWQgdG8gdGVzdCB3aGV0aGVyIHR3byBpdGVtcyBhcmUgZXF1YWwuXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gY29uc2lkZXIuXG4gICAgICogQHJldHVybiB7QXJyYXl9IGBsaXN0YCB3aXRob3V0IHJlcGVhdGluZyBlbGVtZW50cy5cbiAgICAgKiBAc2VlIFIudHJhbnNkdWNlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGwgPSBbMSwgLTEsIDEsIDMsIDQsIC00LCAtNCwgLTUsIDUsIDMsIDNdO1xuICAgICAqICAgICAgUi5kcm9wUmVwZWF0c1dpdGgoUi5lcUJ5KE1hdGguYWJzKSwgbCk7IC8vPT4gWzEsIDMsIDQsIC01LCAzXVxuICAgICAqL1xuICAgIHZhciBkcm9wUmVwZWF0c1dpdGggPSBfY3VycnkyKF9kaXNwYXRjaGFibGUoJ2Ryb3BSZXBlYXRzV2l0aCcsIF94ZHJvcFJlcGVhdHNXaXRoLCBmdW5jdGlvbiBkcm9wUmVwZWF0c1dpdGgocHJlZCwgbGlzdCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHZhciBpZHggPSAxO1xuICAgICAgICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gIT09IDApIHtcbiAgICAgICAgICAgIHJlc3VsdFswXSA9IGxpc3RbMF07XG4gICAgICAgICAgICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcmVkKGxhc3QocmVzdWx0KSwgbGlzdFtpZHhdKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSBsaXN0W2lkeF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSkpO1xuXG4gICAgLyoqXG4gICAgICogVGFrZXMgYSBmdW5jdGlvbiBhbmQgdHdvIHZhbHVlcyBpbiBpdHMgZG9tYWluIGFuZCByZXR1cm5zIGB0cnVlYCBpZiB0aGVcbiAgICAgKiB2YWx1ZXMgbWFwIHRvIHRoZSBzYW1lIHZhbHVlIGluIHRoZSBjb2RvbWFpbjsgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjE4LjBcbiAgICAgKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAgICAgKiBAc2lnIChhIC0+IGIpIC0+IGEgLT4gYSAtPiBCb29sZWFuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZlxuICAgICAqIEBwYXJhbSB7Kn0geFxuICAgICAqIEBwYXJhbSB7Kn0geVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5lcUJ5KE1hdGguYWJzLCA1LCAtNSk7IC8vPT4gdHJ1ZVxuICAgICAqL1xuICAgIHZhciBlcUJ5ID0gX2N1cnJ5MyhmdW5jdGlvbiBlcUJ5KGYsIHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIGVxdWFscyhmKHgpLCBmKHkpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJlcG9ydHMgd2hldGhlciB0d28gb2JqZWN0cyBoYXZlIHRoZSBzYW1lIHZhbHVlLCBpbiBgUi5lcXVhbHNgIHRlcm1zLCBmb3JcbiAgICAgKiB0aGUgc3BlY2lmaWVkIHByb3BlcnR5LiBVc2VmdWwgYXMgYSBjdXJyaWVkIHByZWRpY2F0ZS5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBzaWcgayAtPiB7azogdn0gLT4ge2s6IHZ9IC0+IEJvb2xlYW5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcCBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gY29tcGFyZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmoxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iajJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIG8xID0geyBhOiAxLCBiOiAyLCBjOiAzLCBkOiA0IH07XG4gICAgICogICAgICB2YXIgbzIgPSB7IGE6IDEwLCBiOiAyMCwgYzogMywgZDogNDAgfTtcbiAgICAgKiAgICAgIFIuZXFQcm9wcygnYScsIG8xLCBvMik7IC8vPT4gZmFsc2VcbiAgICAgKiAgICAgIFIuZXFQcm9wcygnYycsIG8xLCBvMik7IC8vPT4gdHJ1ZVxuICAgICAqL1xuICAgIHZhciBlcVByb3BzID0gX2N1cnJ5MyhmdW5jdGlvbiBlcVByb3BzKHByb3AsIG9iajEsIG9iajIpIHtcbiAgICAgICAgcmV0dXJuIGVxdWFscyhvYmoxW3Byb3BdLCBvYmoyW3Byb3BdKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFNwbGl0cyBhIGxpc3QgaW50byBzdWItbGlzdHMgc3RvcmVkIGluIGFuIG9iamVjdCwgYmFzZWQgb24gdGhlIHJlc3VsdCBvZlxuICAgICAqIGNhbGxpbmcgYSBTdHJpbmctcmV0dXJuaW5nIGZ1bmN0aW9uIG9uIGVhY2ggZWxlbWVudCwgYW5kIGdyb3VwaW5nIHRoZVxuICAgICAqIHJlc3VsdHMgYWNjb3JkaW5nIHRvIHZhbHVlcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIERpc3BhdGNoZXMgdG8gdGhlIGBncm91cEJ5YCBtZXRob2Qgb2YgdGhlIHNlY29uZCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIEFjdHMgYXMgYSB0cmFuc2R1Y2VyIGlmIGEgdHJhbnNmb3JtZXIgaXMgZ2l2ZW4gaW4gbGlzdCBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIChhIC0+IFN0cmluZykgLT4gW2FdIC0+IHtTdHJpbmc6IFthXX1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiA6OiBhIC0+IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGdyb3VwXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCB0aGUgb3V0cHV0IG9mIGBmbmAgZm9yIGtleXMsIG1hcHBlZCB0byBhcnJheXMgb2YgZWxlbWVudHNcbiAgICAgKiAgICAgICAgIHRoYXQgcHJvZHVjZWQgdGhhdCBrZXkgd2hlbiBwYXNzZWQgdG8gYGZuYC5cbiAgICAgKiBAc2VlIFIudHJhbnNkdWNlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGJ5R3JhZGUgPSBSLmdyb3VwQnkoZnVuY3Rpb24oc3R1ZGVudCkge1xuICAgICAqICAgICAgICB2YXIgc2NvcmUgPSBzdHVkZW50LnNjb3JlO1xuICAgICAqICAgICAgICByZXR1cm4gc2NvcmUgPCA2NSA/ICdGJyA6XG4gICAgICogICAgICAgICAgICAgICBzY29yZSA8IDcwID8gJ0QnIDpcbiAgICAgKiAgICAgICAgICAgICAgIHNjb3JlIDwgODAgPyAnQycgOlxuICAgICAqICAgICAgICAgICAgICAgc2NvcmUgPCA5MCA/ICdCJyA6ICdBJztcbiAgICAgKiAgICAgIH0pO1xuICAgICAqICAgICAgdmFyIHN0dWRlbnRzID0gW3tuYW1lOiAnQWJieScsIHNjb3JlOiA4NH0sXG4gICAgICogICAgICAgICAgICAgICAgICAgICAge25hbWU6ICdFZGR5Jywgc2NvcmU6IDU4fSxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAvLyAuLi5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ0phY2snLCBzY29yZTogNjl9XTtcbiAgICAgKiAgICAgIGJ5R3JhZGUoc3R1ZGVudHMpO1xuICAgICAqICAgICAgLy8ge1xuICAgICAqICAgICAgLy8gICAnQSc6IFt7bmFtZTogJ0RpYW5uZScsIHNjb3JlOiA5OX1dLFxuICAgICAqICAgICAgLy8gICAnQic6IFt7bmFtZTogJ0FiYnknLCBzY29yZTogODR9XVxuICAgICAqICAgICAgLy8gICAvLyAuLi4sXG4gICAgICogICAgICAvLyAgICdGJzogW3tuYW1lOiAnRWRkeScsIHNjb3JlOiA1OH1dXG4gICAgICogICAgICAvLyB9XG4gICAgICovXG4gICAgdmFyIGdyb3VwQnkgPSBfY3VycnkyKF9kaXNwYXRjaGFibGUoJ2dyb3VwQnknLCBfeGdyb3VwQnksIHJlZHVjZUJ5KGZ1bmN0aW9uIChhY2MsIGl0ZW0pIHtcbiAgICAgICAgaWYgKGFjYyA9PSBudWxsKSB7XG4gICAgICAgICAgICBhY2MgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBhY2MucHVzaChpdGVtKTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBudWxsKSkpO1xuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBmdW5jdGlvbiB0aGF0IGdlbmVyYXRlcyBhIGtleSwgdHVybnMgYSBsaXN0IG9mIG9iamVjdHMgaW50byBhblxuICAgICAqIG9iamVjdCBpbmRleGluZyB0aGUgb2JqZWN0cyBieSB0aGUgZ2l2ZW4ga2V5LiBOb3RlIHRoYXQgaWYgbXVsdGlwbGVcbiAgICAgKiBvYmplY3RzIGdlbmVyYXRlIHRoZSBzYW1lIHZhbHVlIGZvciB0aGUgaW5kZXhpbmcga2V5IG9ubHkgdGhlIGxhc3QgdmFsdWVcbiAgICAgKiB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSBnZW5lcmF0ZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xOS4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIChhIC0+IFN0cmluZykgLT4gW3trOiB2fV0gLT4ge2s6IHtrOiB2fX1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiA6OiBhIC0+IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSBvZiBvYmplY3RzIHRvIGluZGV4XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3QgaW5kZXhpbmcgZWFjaCBhcnJheSBlbGVtZW50IGJ5IHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgbGlzdCA9IFt7aWQ6ICd4eXonLCB0aXRsZTogJ0EnfSwge2lkOiAnYWJjJywgdGl0bGU6ICdCJ31dO1xuICAgICAqICAgICAgUi5pbmRleEJ5KFIucHJvcCgnaWQnKSwgbGlzdCk7XG4gICAgICogICAgICAvLz0+IHthYmM6IHtpZDogJ2FiYycsIHRpdGxlOiAnQid9LCB4eXo6IHtpZDogJ3h5eicsIHRpdGxlOiAnQSd9fVxuICAgICAqL1xuICAgIHZhciBpbmRleEJ5ID0gcmVkdWNlQnkoZnVuY3Rpb24gKGFjYywgZWxlbSkge1xuICAgICAgICByZXR1cm4gZWxlbTtcbiAgICB9LCBudWxsKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGFuIGl0ZW0gaW4gYW4gYXJyYXksIG9yIC0xXG4gICAgICogaWYgdGhlIGl0ZW0gaXMgbm90IGluY2x1ZGVkIGluIHRoZSBhcnJheS4gYFIuZXF1YWxzYCBpcyB1c2VkIHRvIGRldGVybWluZVxuICAgICAqIGVxdWFsaXR5LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgYSAtPiBbYV0gLT4gTnVtYmVyXG4gICAgICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIGl0ZW0gdG8gZmluZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB4cyBUaGUgYXJyYXkgdG8gc2VhcmNoIGluLlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gdGhlIGluZGV4IG9mIHRoZSB0YXJnZXQsIG9yIC0xIGlmIHRoZSB0YXJnZXQgaXMgbm90IGZvdW5kLlxuICAgICAqIEBzZWUgUi5sYXN0SW5kZXhPZlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuaW5kZXhPZigzLCBbMSwyLDMsNF0pOyAvLz0+IDJcbiAgICAgKiAgICAgIFIuaW5kZXhPZigxMCwgWzEsMiwzLDRdKTsgLy89PiAtMVxuICAgICAqL1xuICAgIHZhciBpbmRleE9mID0gX2N1cnJ5MihmdW5jdGlvbiBpbmRleE9mKHRhcmdldCwgeHMpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB4cy5pbmRleE9mID09PSAnZnVuY3Rpb24nICYmICFfaXNBcnJheSh4cykgPyB4cy5pbmRleE9mKHRhcmdldCkgOiBfaW5kZXhPZih4cywgdGFyZ2V0LCAwKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIGp1eHQgYXBwbGllcyBhIGxpc3Qgb2YgZnVuY3Rpb25zIHRvIGEgbGlzdCBvZiB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjE5LjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAc2lnIFsoYSwgYiwgLi4uLCBtKSAtPiBuXSAtPiAoKGEsIGIsIC4uLiwgbSkgLT4gW25dKVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGZucyBBbiBhcnJheSBvZiBmdW5jdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBsaXN0IG9mIHZhbHVlcyBhZnRlciBhcHBseWluZyBlYWNoIG9mIHRoZSBvcmlnaW5hbCBgZm5zYCB0byBpdHMgcGFyYW1ldGVycy5cbiAgICAgKiBAc2VlIFIuYXBwbHlTcGVjXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIHJhbmdlID0gUi5qdXh0KFtNYXRoLm1pbiwgTWF0aC5tYXhdKTtcbiAgICAgKiAgICAgIHJhbmdlKDMsIDQsIDksIC0zKTsgLy89PiBbLTMsIDldXG4gICAgICovXG4gICAgdmFyIGp1eHQgPSBfY3VycnkxKGZ1bmN0aW9uIGp1eHQoZm5zKSB7XG4gICAgICAgIHJldHVybiBjb252ZXJnZShfYXJyYXlPZiwgZm5zKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsZW5zIGZvciB0aGUgZ2l2ZW4gZ2V0dGVyIGFuZCBzZXR0ZXIgZnVuY3Rpb25zLiBUaGUgZ2V0dGVyIFwiZ2V0c1wiXG4gICAgICogdGhlIHZhbHVlIG9mIHRoZSBmb2N1czsgdGhlIHNldHRlciBcInNldHNcIiB0aGUgdmFsdWUgb2YgdGhlIGZvY3VzLiBUaGUgc2V0dGVyXG4gICAgICogc2hvdWxkIG5vdCBtdXRhdGUgdGhlIGRhdGEgc3RydWN0dXJlLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC44LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHR5cGVkZWZuIExlbnMgcyBhID0gRnVuY3RvciBmID0+IChhIC0+IGYgYSkgLT4gcyAtPiBmIHNcbiAgICAgKiBAc2lnIChzIC0+IGEpIC0+ICgoYSwgcykgLT4gcykgLT4gTGVucyBzIGFcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXR0ZXJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXJcbiAgICAgKiBAcmV0dXJuIHtMZW5zfVxuICAgICAqIEBzZWUgUi52aWV3LCBSLnNldCwgUi5vdmVyLCBSLmxlbnNJbmRleCwgUi5sZW5zUHJvcFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciB4TGVucyA9IFIubGVucyhSLnByb3AoJ3gnKSwgUi5hc3NvYygneCcpKTtcbiAgICAgKlxuICAgICAqICAgICAgUi52aWV3KHhMZW5zLCB7eDogMSwgeTogMn0pOyAgICAgICAgICAgIC8vPT4gMVxuICAgICAqICAgICAgUi5zZXQoeExlbnMsIDQsIHt4OiAxLCB5OiAyfSk7ICAgICAgICAgIC8vPT4ge3g6IDQsIHk6IDJ9XG4gICAgICogICAgICBSLm92ZXIoeExlbnMsIFIubmVnYXRlLCB7eDogMSwgeTogMn0pOyAgLy89PiB7eDogLTEsIHk6IDJ9XG4gICAgICovXG4gICAgdmFyIGxlbnMgPSBfY3VycnkyKGZ1bmN0aW9uIGxlbnMoZ2V0dGVyLCBzZXR0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0b0Z1bmN0b3JGbikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFwKGZ1bmN0aW9uIChmb2N1cykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0dGVyKGZvY3VzLCB0YXJnZXQpO1xuICAgICAgICAgICAgICAgIH0sIHRvRnVuY3RvckZuKGdldHRlcih0YXJnZXQpKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxlbnMgd2hvc2UgZm9jdXMgaXMgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTQuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAdHlwZWRlZm4gTGVucyBzIGEgPSBGdW5jdG9yIGYgPT4gKGEgLT4gZiBhKSAtPiBzIC0+IGYgc1xuICAgICAqIEBzaWcgTnVtYmVyIC0+IExlbnMgcyBhXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAgICAgKiBAcmV0dXJuIHtMZW5zfVxuICAgICAqIEBzZWUgUi52aWV3LCBSLnNldCwgUi5vdmVyXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGhlYWRMZW5zID0gUi5sZW5zSW5kZXgoMCk7XG4gICAgICpcbiAgICAgKiAgICAgIFIudmlldyhoZWFkTGVucywgWydhJywgJ2InLCAnYyddKTsgICAgICAgICAgICAvLz0+ICdhJ1xuICAgICAqICAgICAgUi5zZXQoaGVhZExlbnMsICd4JywgWydhJywgJ2InLCAnYyddKTsgICAgICAgIC8vPT4gWyd4JywgJ2InLCAnYyddXG4gICAgICogICAgICBSLm92ZXIoaGVhZExlbnMsIFIudG9VcHBlciwgWydhJywgJ2InLCAnYyddKTsgLy89PiBbJ0EnLCAnYicsICdjJ11cbiAgICAgKi9cbiAgICB2YXIgbGVuc0luZGV4ID0gX2N1cnJ5MShmdW5jdGlvbiBsZW5zSW5kZXgobikge1xuICAgICAgICByZXR1cm4gbGVucyhudGgobiksIHVwZGF0ZShuKSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGVucyB3aG9zZSBmb2N1cyBpcyB0aGUgc3BlY2lmaWVkIHBhdGguXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjE5LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHR5cGVkZWZuIExlbnMgcyBhID0gRnVuY3RvciBmID0+IChhIC0+IGYgYSkgLT4gcyAtPiBmIHNcbiAgICAgKiBAc2lnIFtTdHJpbmddIC0+IExlbnMgcyBhXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCBUaGUgcGF0aCB0byB1c2UuXG4gICAgICogQHJldHVybiB7TGVuc31cbiAgICAgKiBAc2VlIFIudmlldywgUi5zZXQsIFIub3ZlclxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciB4eUxlbnMgPSBSLmxlbnNQYXRoKFsneCcsICd5J10pO1xuICAgICAqXG4gICAgICogICAgICBSLnZpZXcoeHlMZW5zLCB7eDoge3k6IDIsIHo6IDN9fSk7ICAgICAgICAgICAgLy89PiAyXG4gICAgICogICAgICBSLnNldCh4eUxlbnMsIDQsIHt4OiB7eTogMiwgejogM319KTsgICAgICAgICAgLy89PiB7eDoge3k6IDQsIHo6IDN9fVxuICAgICAqICAgICAgUi5vdmVyKHh5TGVucywgUi5uZWdhdGUsIHt4OiB7eTogMiwgejogM319KTsgIC8vPT4ge3g6IHt5OiAtMiwgejogM319XG4gICAgICovXG4gICAgdmFyIGxlbnNQYXRoID0gX2N1cnJ5MShmdW5jdGlvbiBsZW5zUGF0aChwKSB7XG4gICAgICAgIHJldHVybiBsZW5zKHBhdGgocCksIGFzc29jUGF0aChwKSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGVucyB3aG9zZSBmb2N1cyBpcyB0aGUgc3BlY2lmaWVkIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xNC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEB0eXBlZGVmbiBMZW5zIHMgYSA9IEZ1bmN0b3IgZiA9PiAoYSAtPiBmIGEpIC0+IHMgLT4gZiBzXG4gICAgICogQHNpZyBTdHJpbmcgLT4gTGVucyBzIGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga1xuICAgICAqIEByZXR1cm4ge0xlbnN9XG4gICAgICogQHNlZSBSLnZpZXcsIFIuc2V0LCBSLm92ZXJcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgeExlbnMgPSBSLmxlbnNQcm9wKCd4Jyk7XG4gICAgICpcbiAgICAgKiAgICAgIFIudmlldyh4TGVucywge3g6IDEsIHk6IDJ9KTsgICAgICAgICAgICAvLz0+IDFcbiAgICAgKiAgICAgIFIuc2V0KHhMZW5zLCA0LCB7eDogMSwgeTogMn0pOyAgICAgICAgICAvLz0+IHt4OiA0LCB5OiAyfVxuICAgICAqICAgICAgUi5vdmVyKHhMZW5zLCBSLm5lZ2F0ZSwge3g6IDEsIHk6IDJ9KTsgIC8vPT4ge3g6IC0xLCB5OiAyfVxuICAgICAqL1xuICAgIHZhciBsZW5zUHJvcCA9IF9jdXJyeTEoZnVuY3Rpb24gbGVuc1Byb3Aoaykge1xuICAgICAgICByZXR1cm4gbGVucyhwcm9wKGspLCBhc3NvYyhrKSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBcImxpZnRzXCIgYSBmdW5jdGlvbiB0byBiZSB0aGUgc3BlY2lmaWVkIGFyaXR5LCBzbyB0aGF0IGl0IG1heSBcIm1hcCBvdmVyXCIgdGhhdFxuICAgICAqIG1hbnkgbGlzdHMsIEZ1bmN0aW9ucyBvciBvdGhlciBvYmplY3RzIHRoYXQgc2F0aXNmeSB0aGUgW0ZhbnRhc3lMYW5kIEFwcGx5IHNwZWNdKGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjYXBwbHkpLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAc2lnIE51bWJlciAtPiAoKi4uLiAtPiAqKSAtPiAoWypdLi4uIC0+IFsqXSlcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbGlmdCBpbnRvIGhpZ2hlciBjb250ZXh0XG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBsaWZ0ZWQgZnVuY3Rpb24uXG4gICAgICogQHNlZSBSLmxpZnQsIFIuYXBcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgbWFkZDMgPSBSLmxpZnROKDMsIFIuY3VycnlOKDMsICguLi5hcmdzKSA9PiBSLnN1bShhcmdzKSkpO1xuICAgICAqICAgICAgbWFkZDMoWzEsMiwzXSwgWzEsMiwzXSwgWzFdKTsgLy89PiBbMywgNCwgNSwgNCwgNSwgNiwgNSwgNiwgN11cbiAgICAgKi9cbiAgICB2YXIgbGlmdE4gPSBfY3VycnkyKGZ1bmN0aW9uIGxpZnROKGFyaXR5LCBmbikge1xuICAgICAgICB2YXIgbGlmdGVkID0gY3VycnlOKGFyaXR5LCBmbik7XG4gICAgICAgIHJldHVybiBjdXJyeU4oYXJpdHksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVkdWNlKGFwLCBtYXAobGlmdGVkLCBhcmd1bWVudHNbMF0pLCBfc2xpY2UoYXJndW1lbnRzLCAxKSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbWVhbiBvZiB0aGUgZ2l2ZW4gbGlzdCBvZiBudW1iZXJzLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xNC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAc2lnIFtOdW1iZXJdIC0+IE51bWJlclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3RcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5tZWFuKFsyLCA3LCA5XSk7IC8vPT4gNlxuICAgICAqICAgICAgUi5tZWFuKFtdKTsgLy89PiBOYU5cbiAgICAgKi9cbiAgICB2YXIgbWVhbiA9IF9jdXJyeTEoZnVuY3Rpb24gbWVhbihsaXN0KSB7XG4gICAgICAgIHJldHVybiBzdW0obGlzdCkgLyBsaXN0Lmxlbmd0aDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1lZGlhbiBvZiB0aGUgZ2l2ZW4gbGlzdCBvZiBudW1iZXJzLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xNC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAc2lnIFtOdW1iZXJdIC0+IE51bWJlclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3RcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5tZWRpYW4oWzIsIDksIDddKTsgLy89PiA3XG4gICAgICogICAgICBSLm1lZGlhbihbNywgMiwgMTAsIDldKTsgLy89PiA4XG4gICAgICogICAgICBSLm1lZGlhbihbXSk7IC8vPT4gTmFOXG4gICAgICovXG4gICAgdmFyIG1lZGlhbiA9IF9jdXJyeTEoZnVuY3Rpb24gbWVkaWFuKGxpc3QpIHtcbiAgICAgICAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICAgICAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3aWR0aCA9IDIgLSBsZW4gJSAyO1xuICAgICAgICB2YXIgaWR4ID0gKGxlbiAtIHdpZHRoKSAvIDI7XG4gICAgICAgIHJldHVybiBtZWFuKF9zbGljZShsaXN0KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IDA7XG4gICAgICAgIH0pLnNsaWNlKGlkeCwgaWR4ICsgd2lkdGgpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRha2VzIGEgcHJlZGljYXRlIGFuZCBhIGxpc3Qgb3Igb3RoZXIgXCJmaWx0ZXJhYmxlXCIgb2JqZWN0IGFuZCByZXR1cm5zIHRoZVxuICAgICAqIHBhaXIgb2YgZmlsdGVyYWJsZSBvYmplY3RzIG9mIHRoZSBzYW1lIHR5cGUgb2YgZWxlbWVudHMgd2hpY2ggZG8gYW5kIGRvIG5vdFxuICAgICAqIHNhdGlzZnksIHRoZSBwcmVkaWNhdGUsIHJlc3BlY3RpdmVseS5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS40XG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIEZpbHRlcmFibGUgZiA9PiAoYSAtPiBCb29sZWFuKSAtPiBmIGEgLT4gW2YgYSwgZiBhXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWQgQSBwcmVkaWNhdGUgdG8gZGV0ZXJtaW5lIHdoaWNoIHNpZGUgdGhlIGVsZW1lbnQgYmVsb25ncyB0by5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBmaWx0ZXJhYmxlIHRoZSBsaXN0IChvciBvdGhlciBmaWx0ZXJhYmxlKSB0byBwYXJ0aXRpb24uXG4gICAgICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5LCBjb250YWluaW5nIGZpcnN0IHRoZSBzdWJzZXQgb2YgZWxlbWVudHMgdGhhdCBzYXRpc2Z5IHRoZVxuICAgICAqICAgICAgICAgcHJlZGljYXRlLCBhbmQgc2Vjb25kIHRoZSBzdWJzZXQgb2YgZWxlbWVudHMgdGhhdCBkbyBub3Qgc2F0aXNmeS5cbiAgICAgKiBAc2VlIFIuZmlsdGVyLCBSLnJlamVjdFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIucGFydGl0aW9uKFIuY29udGFpbnMoJ3MnKSwgWydzc3MnLCAndHR0JywgJ2ZvbycsICdiYXJzJ10pO1xuICAgICAqICAgICAgLy8gPT4gWyBbICdzc3MnLCAnYmFycycgXSwgIFsgJ3R0dCcsICdmb28nIF0gXVxuICAgICAqXG4gICAgICogICAgICBSLnBhcnRpdGlvbihSLmNvbnRhaW5zKCdzJyksIHsgYTogJ3NzcycsIGI6ICd0dHQnLCBmb286ICdiYXJzJyB9KTtcbiAgICAgKiAgICAgIC8vID0+IFsgeyBhOiAnc3NzJywgZm9vOiAnYmFycycgfSwgeyBiOiAndHR0JyB9ICBdXG4gICAgICovXG4gICAgdmFyIHBhcnRpdGlvbiA9IGp1eHQoW1xuICAgICAgICBmaWx0ZXIsXG4gICAgICAgIHJlamVjdFxuICAgIF0pO1xuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgbGVmdC10by1yaWdodCBmdW5jdGlvbiBjb21wb3NpdGlvbi4gVGhlIGxlZnRtb3N0IGZ1bmN0aW9uIG1heSBoYXZlXG4gICAgICogYW55IGFyaXR5OyB0aGUgcmVtYWluaW5nIGZ1bmN0aW9ucyBtdXN0IGJlIHVuYXJ5LlxuICAgICAqXG4gICAgICogSW4gc29tZSBsaWJyYXJpZXMgdGhpcyBmdW5jdGlvbiBpcyBuYW1lZCBgc2VxdWVuY2VgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoZSByZXN1bHQgb2YgcGlwZSBpcyBub3QgYXV0b21hdGljYWxseSBjdXJyaWVkLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAc2lnICgoKGEsIGIsIC4uLiwgbikgLT4gbyksIChvIC0+IHApLCAuLi4sICh4IC0+IHkpLCAoeSAtPiB6KSkgLT4gKChhLCBiLCAuLi4sIG4pIC0+IHopXG4gICAgICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gZnVuY3Rpb25zXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAgICogQHNlZSBSLmNvbXBvc2VcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgZiA9IFIucGlwZShNYXRoLnBvdywgUi5uZWdhdGUsIFIuaW5jKTtcbiAgICAgKlxuICAgICAqICAgICAgZigzLCA0KTsgLy8gLSgzXjQpICsgMVxuICAgICAqL1xuICAgIHZhciBwaXBlID0gZnVuY3Rpb24gcGlwZSgpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGlwZSByZXF1aXJlcyBhdCBsZWFzdCBvbmUgYXJndW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2FyaXR5KGFyZ3VtZW50c1swXS5sZW5ndGgsIHJlZHVjZShfcGlwZSwgYXJndW1lbnRzWzBdLCB0YWlsKGFyZ3VtZW50cykpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgbGVmdC10by1yaWdodCBjb21wb3NpdGlvbiBvZiBvbmUgb3IgbW9yZSBQcm9taXNlLXJldHVybmluZ1xuICAgICAqIGZ1bmN0aW9ucy4gVGhlIGxlZnRtb3N0IGZ1bmN0aW9uIG1heSBoYXZlIGFueSBhcml0eTsgdGhlIHJlbWFpbmluZyBmdW5jdGlvbnNcbiAgICAgKiBtdXN0IGJlIHVuYXJ5LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHNpZyAoKGEgLT4gUHJvbWlzZSBiKSwgKGIgLT4gUHJvbWlzZSBjKSwgLi4uLCAoeSAtPiBQcm9taXNlIHopKSAtPiAoYSAtPiBQcm9taXNlIHopXG4gICAgICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gZnVuY3Rpb25zXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAgICogQHNlZSBSLmNvbXBvc2VQXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgLy8gIGZvbGxvd2Vyc0ZvclVzZXIgOjogU3RyaW5nIC0+IFByb21pc2UgW1VzZXJdXG4gICAgICogICAgICB2YXIgZm9sbG93ZXJzRm9yVXNlciA9IFIucGlwZVAoZGIuZ2V0VXNlckJ5SWQsIGRiLmdldEZvbGxvd2Vycyk7XG4gICAgICovXG4gICAgdmFyIHBpcGVQID0gZnVuY3Rpb24gcGlwZVAoKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BpcGVQIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBhcmd1bWVudCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfYXJpdHkoYXJndW1lbnRzWzBdLmxlbmd0aCwgcmVkdWNlKF9waXBlUCwgYXJndW1lbnRzWzBdLCB0YWlsKGFyZ3VtZW50cykpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyB0b2dldGhlciBhbGwgdGhlIGVsZW1lbnRzIG9mIGEgbGlzdC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAc2lnIFtOdW1iZXJdIC0+IE51bWJlclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgQW4gYXJyYXkgb2YgbnVtYmVyc1xuICAgICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHByb2R1Y3Qgb2YgYWxsIHRoZSBudW1iZXJzIGluIHRoZSBsaXN0LlxuICAgICAqIEBzZWUgUi5yZWR1Y2VcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLnByb2R1Y3QoWzIsNCw2LDgsMTAwLDFdKTsgLy89PiAzODQwMFxuICAgICAqL1xuICAgIHZhciBwcm9kdWN0ID0gcmVkdWNlKG11bHRpcGx5LCAxKTtcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgYSBbVHJhdmVyc2FibGVdKGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjdHJhdmVyc2FibGUpXG4gICAgICogb2YgW0FwcGxpY2F0aXZlXShodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2FwcGxpY2F0aXZlKSBpbnRvIGFuXG4gICAgICogQXBwbGljYXRpdmUgb2YgVHJhdmVyc2FibGUuXG4gICAgICpcbiAgICAgKiBEaXNwYXRjaGVzIHRvIHRoZSBgc2VxdWVuY2VgIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xOS4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIChBcHBsaWNhdGl2ZSBmLCBUcmF2ZXJzYWJsZSB0KSA9PiAoYSAtPiBmIGEpIC0+IHQgKGYgYSkgLT4gZiAodCBhKVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9mXG4gICAgICogQHBhcmFtIHsqfSB0cmF2ZXJzYWJsZVxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICogQHNlZSBSLnRyYXZlcnNlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5zZXF1ZW5jZShNYXliZS5vZiwgW0p1c3QoMSksIEp1c3QoMiksIEp1c3QoMyldKTsgICAvLz0+IEp1c3QoWzEsIDIsIDNdKVxuICAgICAqICAgICAgUi5zZXF1ZW5jZShNYXliZS5vZiwgW0p1c3QoMSksIEp1c3QoMiksIE5vdGhpbmcoKV0pOyAvLz0+IE5vdGhpbmcoKVxuICAgICAqXG4gICAgICogICAgICBSLnNlcXVlbmNlKFIub2YsIEp1c3QoWzEsIDIsIDNdKSk7IC8vPT4gW0p1c3QoMSksIEp1c3QoMiksIEp1c3QoMyldXG4gICAgICogICAgICBSLnNlcXVlbmNlKFIub2YsIE5vdGhpbmcoKSk7ICAgICAgIC8vPT4gW05vdGhpbmcoKV1cbiAgICAgKi9cbiAgICB2YXIgc2VxdWVuY2UgPSBfY3VycnkyKGZ1bmN0aW9uIHNlcXVlbmNlKG9mLCB0cmF2ZXJzYWJsZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHRyYXZlcnNhYmxlLnNlcXVlbmNlID09PSAnZnVuY3Rpb24nID8gdHJhdmVyc2FibGUuc2VxdWVuY2Uob2YpIDogcmVkdWNlUmlnaHQoZnVuY3Rpb24gKGFjYywgeCkge1xuICAgICAgICAgICAgcmV0dXJuIGFwKG1hcChwcmVwZW5kLCB4KSwgYWNjKTtcbiAgICAgICAgfSwgb2YoW10pLCB0cmF2ZXJzYWJsZSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBNYXBzIGFuIFtBcHBsaWNhdGl2ZV0oaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNhcHBsaWNhdGl2ZSktcmV0dXJuaW5nXG4gICAgICogZnVuY3Rpb24gb3ZlciBhIFtUcmF2ZXJzYWJsZV0oaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCN0cmF2ZXJzYWJsZSksXG4gICAgICogdGhlbiB1c2VzIFtgc2VxdWVuY2VgXSgjc2VxdWVuY2UpIHRvIHRyYW5zZm9ybSB0aGUgcmVzdWx0aW5nIFRyYXZlcnNhYmxlIG9mIEFwcGxpY2F0aXZlXG4gICAgICogaW50byBhbiBBcHBsaWNhdGl2ZSBvZiBUcmF2ZXJzYWJsZS5cbiAgICAgKlxuICAgICAqIERpc3BhdGNoZXMgdG8gdGhlIGBzZXF1ZW5jZWAgbWV0aG9kIG9mIHRoZSB0aGlyZCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTkuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyAoQXBwbGljYXRpdmUgZiwgVHJhdmVyc2FibGUgdCkgPT4gKGEgLT4gZiBhKSAtPiAoYSAtPiBmIGIpIC0+IHQgYSAtPiBmICh0IGIpXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb2ZcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmXG4gICAgICogQHBhcmFtIHsqfSB0cmF2ZXJzYWJsZVxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICogQHNlZSBSLnNlcXVlbmNlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgLy8gUmV0dXJucyBgTm90aGluZ2AgaWYgdGhlIGdpdmVuIGRpdmlzb3IgaXMgYDBgXG4gICAgICogICAgICBzYWZlRGl2ID0gbiA9PiBkID0+IGQgPT09IDAgPyBOb3RoaW5nKCkgOiBKdXN0KG4gLyBkKVxuICAgICAqXG4gICAgICogICAgICBSLnRyYXZlcnNlKE1heWJlLm9mLCBzYWZlRGl2KDEwKSwgWzIsIDQsIDVdKTsgLy89PiBKdXN0KFs1LCAyLjUsIDJdKVxuICAgICAqICAgICAgUi50cmF2ZXJzZShNYXliZS5vZiwgc2FmZURpdigxMCksIFsyLCAwLCA1XSk7IC8vPT4gTm90aGluZ1xuICAgICAqL1xuICAgIHZhciB0cmF2ZXJzZSA9IF9jdXJyeTMoZnVuY3Rpb24gdHJhdmVyc2Uob2YsIGYsIHRyYXZlcnNhYmxlKSB7XG4gICAgICAgIHJldHVybiBzZXF1ZW5jZShvZiwgbWFwKGYsIHRyYXZlcnNhYmxlKSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBTaG9ydGhhbmQgZm9yIGBSLmNoYWluKFIuaWRlbnRpdHkpYCwgd2hpY2ggcmVtb3ZlcyBvbmUgbGV2ZWwgb2YgbmVzdGluZyBmcm9tXG4gICAgICogYW55IFtDaGFpbl0oaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNjaGFpbikuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjMuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyBDaGFpbiBjID0+IGMgKGMgYSkgLT4gYyBhXG4gICAgICogQHBhcmFtIHsqfSBsaXN0XG4gICAgICogQHJldHVybiB7Kn1cbiAgICAgKiBAc2VlIFIuZmxhdHRlbiwgUi5jaGFpblxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIudW5uZXN0KFsxLCBbMl0sIFtbM11dXSk7IC8vPT4gWzEsIDIsIFszXV1cbiAgICAgKiAgICAgIFIudW5uZXN0KFtbMSwgMl0sIFszLCA0XSwgWzUsIDZdXSk7IC8vPT4gWzEsIDIsIDMsIDQsIDUsIDZdXG4gICAgICovXG4gICAgdmFyIHVubmVzdCA9IGNoYWluKF9pZGVudGl0eSk7XG5cbiAgICB2YXIgX2NvbnRhaW5zID0gZnVuY3Rpb24gX2NvbnRhaW5zKGEsIGxpc3QpIHtcbiAgICAgICAgcmV0dXJuIF9pbmRleE9mKGxpc3QsIGEsIDApID49IDA7XG4gICAgfTtcblxuICAgIC8vICBtYXBQYWlycyA6OiAoT2JqZWN0LCBbU3RyaW5nXSkgLT4gW1N0cmluZ11cbiAgICB2YXIgX3RvU3RyaW5nID0gZnVuY3Rpb24gX3RvU3RyaW5nKHgsIHNlZW4pIHtcbiAgICAgICAgdmFyIHJlY3VyID0gZnVuY3Rpb24gcmVjdXIoeSkge1xuICAgICAgICAgICAgdmFyIHhzID0gc2Vlbi5jb25jYXQoW3hdKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGFpbnMoeSwgeHMpID8gJzxDaXJjdWxhcj4nIDogX3RvU3RyaW5nKHksIHhzKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gIG1hcFBhaXJzIDo6IChPYmplY3QsIFtTdHJpbmddKSAtPiBbU3RyaW5nXVxuICAgICAgICB2YXIgbWFwUGFpcnMgPSBmdW5jdGlvbiAob2JqLCBrZXlzKSB7XG4gICAgICAgICAgICByZXR1cm4gX21hcChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBfcXVvdGUoaykgKyAnOiAnICsgcmVjdXIob2JqW2tdKTtcbiAgICAgICAgICAgIH0sIGtleXMuc2xpY2UoKS5zb3J0KCkpO1xuICAgICAgICB9O1xuICAgICAgICBzd2l0Y2ggKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSkge1xuICAgICAgICBjYXNlICdbb2JqZWN0IEFyZ3VtZW50c10nOlxuICAgICAgICAgICAgcmV0dXJuICcoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oJyArIF9tYXAocmVjdXIsIHgpLmpvaW4oJywgJykgKyAnKSknO1xuICAgICAgICBjYXNlICdbb2JqZWN0IEFycmF5XSc6XG4gICAgICAgICAgICByZXR1cm4gJ1snICsgX21hcChyZWN1ciwgeCkuY29uY2F0KG1hcFBhaXJzKHgsIHJlamVjdChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgICAgIHJldHVybiAvXlxcZCskLy50ZXN0KGspO1xuICAgICAgICAgICAgfSwga2V5cyh4KSkpKS5qb2luKCcsICcpICsgJ10nO1xuICAgICAgICBjYXNlICdbb2JqZWN0IEJvb2xlYW5dJzpcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ29iamVjdCcgPyAnbmV3IEJvb2xlYW4oJyArIHJlY3VyKHgudmFsdWVPZigpKSArICcpJyA6IHgudG9TdHJpbmcoKTtcbiAgICAgICAgY2FzZSAnW29iamVjdCBEYXRlXSc6XG4gICAgICAgICAgICByZXR1cm4gJ25ldyBEYXRlKCcgKyAoaXNOYU4oeC52YWx1ZU9mKCkpID8gcmVjdXIoTmFOKSA6IF9xdW90ZShfdG9JU09TdHJpbmcoeCkpKSArICcpJztcbiAgICAgICAgY2FzZSAnW29iamVjdCBOdWxsXSc6XG4gICAgICAgICAgICByZXR1cm4gJ251bGwnO1xuICAgICAgICBjYXNlICdbb2JqZWN0IE51bWJlcl0nOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnb2JqZWN0JyA/ICduZXcgTnVtYmVyKCcgKyByZWN1cih4LnZhbHVlT2YoKSkgKyAnKScgOiAxIC8geCA9PT0gLUluZmluaXR5ID8gJy0wJyA6IHgudG9TdHJpbmcoMTApO1xuICAgICAgICBjYXNlICdbb2JqZWN0IFN0cmluZ10nOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnb2JqZWN0JyA/ICduZXcgU3RyaW5nKCcgKyByZWN1cih4LnZhbHVlT2YoKSkgKyAnKScgOiBfcXVvdGUoeCk7XG4gICAgICAgIGNhc2UgJ1tvYmplY3QgVW5kZWZpbmVkXSc6XG4gICAgICAgICAgICByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAodHlwZW9mIHgudG9TdHJpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVwciA9IHgudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBpZiAocmVwciAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcHI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICd7JyArIG1hcFBhaXJzKHgsIGtleXMoeCkpLmpvaW4oJywgJykgKyAnfSc7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgcmlnaHQtdG8tbGVmdCBmdW5jdGlvbiBjb21wb3NpdGlvbi4gVGhlIHJpZ2h0bW9zdCBmdW5jdGlvbiBtYXkgaGF2ZVxuICAgICAqIGFueSBhcml0eTsgdGhlIHJlbWFpbmluZyBmdW5jdGlvbnMgbXVzdCBiZSB1bmFyeS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGUgcmVzdWx0IG9mIGNvbXBvc2UgaXMgbm90IGF1dG9tYXRpY2FsbHkgY3VycmllZC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHNpZyAoKHkgLT4geiksICh4IC0+IHkpLCAuLi4sIChvIC0+IHApLCAoKGEsIGIsIC4uLiwgbikgLT4gbykpIC0+ICgoYSwgYiwgLi4uLCBuKSAtPiB6KVxuICAgICAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IGZ1bmN0aW9uc1xuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgICAqIEBzZWUgUi5waXBlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGYgPSBSLmNvbXBvc2UoUi5pbmMsIFIubmVnYXRlLCBNYXRoLnBvdyk7XG4gICAgICpcbiAgICAgKiAgICAgIGYoMywgNCk7IC8vIC0oM140KSArIDFcbiAgICAgKi9cbiAgICB2YXIgY29tcG9zZSA9IGZ1bmN0aW9uIGNvbXBvc2UoKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbXBvc2UgcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGFyZ3VtZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBpcGUuYXBwbHkodGhpcywgcmV2ZXJzZShhcmd1bWVudHMpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcmlnaHQtdG8tbGVmdCBLbGVpc2xpIGNvbXBvc2l0aW9uIG9mIHRoZSBwcm92aWRlZCBmdW5jdGlvbnMsXG4gICAgICogZWFjaCBvZiB3aGljaCBtdXN0IHJldHVybiBhIHZhbHVlIG9mIGEgdHlwZSBzdXBwb3J0ZWQgYnkgW2BjaGFpbmBdKCNjaGFpbikuXG4gICAgICpcbiAgICAgKiBgUi5jb21wb3NlSyhoLCBnLCBmKWAgaXMgZXF1aXZhbGVudCB0byBgUi5jb21wb3NlKFIuY2hhaW4oaCksIFIuY2hhaW4oZyksIFIuY2hhaW4oZikpYC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTYuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBzaWcgQ2hhaW4gbSA9PiAoKHkgLT4gbSB6KSwgKHggLT4gbSB5KSwgLi4uLCAoYSAtPiBtIGIpKSAtPiAobSBhIC0+IG0geilcbiAgICAgKiBAcGFyYW0gey4uLkZ1bmN0aW9ufVxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgICAqIEBzZWUgUi5waXBlS1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIC8vICBwYXJzZUpzb24gOjogU3RyaW5nIC0+IE1heWJlICpcbiAgICAgKiAgICAgIC8vICBnZXQgOjogU3RyaW5nIC0+IE9iamVjdCAtPiBNYXliZSAqXG4gICAgICpcbiAgICAgKiAgICAgIC8vICBnZXRTdGF0ZUNvZGUgOjogTWF5YmUgU3RyaW5nIC0+IE1heWJlIFN0cmluZ1xuICAgICAqICAgICAgdmFyIGdldFN0YXRlQ29kZSA9IFIuY29tcG9zZUsoXG4gICAgICogICAgICAgIFIuY29tcG9zZShNYXliZS5vZiwgUi50b1VwcGVyKSxcbiAgICAgKiAgICAgICAgZ2V0KCdzdGF0ZScpLFxuICAgICAqICAgICAgICBnZXQoJ2FkZHJlc3MnKSxcbiAgICAgKiAgICAgICAgZ2V0KCd1c2VyJyksXG4gICAgICogICAgICAgIHBhcnNlSnNvblxuICAgICAqICAgICAgKTtcbiAgICAgKlxuICAgICAqICAgICAgZ2V0U3RhdGVDb2RlKE1heWJlLm9mKCd7XCJ1c2VyXCI6e1wiYWRkcmVzc1wiOntcInN0YXRlXCI6XCJueVwifX19JykpO1xuICAgICAqICAgICAgLy89PiBKdXN0KCdOWScpXG4gICAgICogICAgICBnZXRTdGF0ZUNvZGUoTWF5YmUub2YoJ1tJbnZhbGlkIEpTT05dJykpO1xuICAgICAqICAgICAgLy89PiBOb3RoaW5nKClcbiAgICAgKi9cbiAgICB2YXIgY29tcG9zZUsgPSBmdW5jdGlvbiBjb21wb3NlSygpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBvc2UuYXBwbHkodGhpcywgcHJlcGVuZChpZGVudGl0eSwgbWFwKGNoYWluLCBhcmd1bWVudHMpKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIHJpZ2h0LXRvLWxlZnQgY29tcG9zaXRpb24gb2Ygb25lIG9yIG1vcmUgUHJvbWlzZS1yZXR1cm5pbmdcbiAgICAgKiBmdW5jdGlvbnMuIFRoZSByaWdodG1vc3QgZnVuY3Rpb24gbWF5IGhhdmUgYW55IGFyaXR5OyB0aGUgcmVtYWluaW5nXG4gICAgICogZnVuY3Rpb25zIG11c3QgYmUgdW5hcnkuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAc2lnICgoeSAtPiBQcm9taXNlIHopLCAoeCAtPiBQcm9taXNlIHkpLCAuLi4sIChhIC0+IFByb21pc2UgYikpIC0+IChhIC0+IFByb21pc2UgeilcbiAgICAgKiBAcGFyYW0gey4uLkZ1bmN0aW9ufSBmdW5jdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICAgKiBAc2VlIFIucGlwZVBcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICAvLyAgZm9sbG93ZXJzRm9yVXNlciA6OiBTdHJpbmcgLT4gUHJvbWlzZSBbVXNlcl1cbiAgICAgKiAgICAgIHZhciBmb2xsb3dlcnNGb3JVc2VyID0gUi5jb21wb3NlUChkYi5nZXRGb2xsb3dlcnMsIGRiLmdldFVzZXJCeUlkKTtcbiAgICAgKi9cbiAgICB2YXIgY29tcG9zZVAgPSBmdW5jdGlvbiBjb21wb3NlUCgpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY29tcG9zZVAgcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGFyZ3VtZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBpcGVQLmFwcGx5KHRoaXMsIHJldmVyc2UoYXJndW1lbnRzKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFdyYXBzIGEgY29uc3RydWN0b3IgZnVuY3Rpb24gaW5zaWRlIGEgY3VycmllZCBmdW5jdGlvbiB0aGF0IGNhbiBiZSBjYWxsZWRcbiAgICAgKiB3aXRoIHRoZSBzYW1lIGFyZ3VtZW50cyBhbmQgcmV0dXJucyB0aGUgc2FtZSB0eXBlLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAc2lnICgqIC0+IHsqfSkgLT4gKCogLT4geyp9KVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IEZuIFRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIHdyYXBwZWQsIGN1cnJpZWQgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgLy8gQ29uc3RydWN0b3IgZnVuY3Rpb25cbiAgICAgKiAgICAgIHZhciBXaWRnZXQgPSBjb25maWcgPT4ge1xuICAgICAqICAgICAgICAvLyAuLi5cbiAgICAgKiAgICAgIH07XG4gICAgICogICAgICBXaWRnZXQucHJvdG90eXBlID0ge1xuICAgICAqICAgICAgICAvLyAuLi5cbiAgICAgKiAgICAgIH07XG4gICAgICogICAgICB2YXIgYWxsQ29uZmlncyA9IFtcbiAgICAgKiAgICAgICAgLy8gLi4uXG4gICAgICogICAgICBdO1xuICAgICAqICAgICAgUi5tYXAoUi5jb25zdHJ1Y3QoV2lkZ2V0KSwgYWxsQ29uZmlncyk7IC8vIGEgbGlzdCBvZiBXaWRnZXRzXG4gICAgICovXG4gICAgdmFyIGNvbnN0cnVjdCA9IF9jdXJyeTEoZnVuY3Rpb24gY29uc3RydWN0KEZuKSB7XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3ROKEZuLmxlbmd0aCwgRm4pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBlcXVhbCwgaW4gYFIuZXF1YWxzYCB0ZXJtcywgdG8gYXRcbiAgICAgKiBsZWFzdCBvbmUgZWxlbWVudCBvZiB0aGUgZ2l2ZW4gbGlzdDsgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyBhIC0+IFthXSAtPiBCb29sZWFuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGEgVGhlIGl0ZW0gdG8gY29tcGFyZSBhZ2FpbnN0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGNvbnNpZGVyLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgaXRlbSBpcyBpbiB0aGUgbGlzdCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICogQHNlZSBSLmFueVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuY29udGFpbnMoMywgWzEsIDIsIDNdKTsgLy89PiB0cnVlXG4gICAgICogICAgICBSLmNvbnRhaW5zKDQsIFsxLCAyLCAzXSk7IC8vPT4gZmFsc2VcbiAgICAgKiAgICAgIFIuY29udGFpbnMoWzQyXSwgW1s0Ml1dKTsgLy89PiB0cnVlXG4gICAgICovXG4gICAgdmFyIGNvbnRhaW5zID0gX2N1cnJ5MihfY29udGFpbnMpO1xuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIHNldCAoaS5lLiBubyBkdXBsaWNhdGVzKSBvZiBhbGwgZWxlbWVudHMgaW4gdGhlIGZpcnN0IGxpc3Qgbm90XG4gICAgICogY29udGFpbmVkIGluIHRoZSBzZWNvbmQgbGlzdC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gICAgICogQHNpZyBbKl0gLT4gWypdIC0+IFsqXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QxIFRoZSBmaXJzdCBsaXN0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QyIFRoZSBzZWNvbmQgbGlzdC5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGVsZW1lbnRzIGluIGBsaXN0MWAgdGhhdCBhcmUgbm90IGluIGBsaXN0MmAuXG4gICAgICogQHNlZSBSLmRpZmZlcmVuY2VXaXRoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5kaWZmZXJlbmNlKFsxLDIsMyw0XSwgWzcsNiw1LDQsM10pOyAvLz0+IFsxLDJdXG4gICAgICogICAgICBSLmRpZmZlcmVuY2UoWzcsNiw1LDQsM10sIFsxLDIsMyw0XSk7IC8vPT4gWzcsNiw1XVxuICAgICAqL1xuICAgIHZhciBkaWZmZXJlbmNlID0gX2N1cnJ5MihmdW5jdGlvbiBkaWZmZXJlbmNlKGZpcnN0LCBzZWNvbmQpIHtcbiAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICB2YXIgaWR4ID0gMDtcbiAgICAgICAgdmFyIGZpcnN0TGVuID0gZmlyc3QubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaWR4IDwgZmlyc3RMZW4pIHtcbiAgICAgICAgICAgIGlmICghX2NvbnRhaW5zKGZpcnN0W2lkeF0sIHNlY29uZCkgJiYgIV9jb250YWlucyhmaXJzdFtpZHhdLCBvdXQpKSB7XG4gICAgICAgICAgICAgICAgb3V0W291dC5sZW5ndGhdID0gZmlyc3RbaWR4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IGxpc3Qgd2l0aG91dCBhbnkgY29uc2VjdXRpdmVseSByZXBlYXRpbmcgZWxlbWVudHMuIGBSLmVxdWFsc2BcbiAgICAgKiBpcyB1c2VkIHRvIGRldGVybWluZSBlcXVhbGl0eS5cbiAgICAgKlxuICAgICAqIERpc3BhdGNoZXMgdG8gdGhlIGBkcm9wUmVwZWF0c2AgbWV0aG9kIG9mIHRoZSBmaXJzdCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIEFjdHMgYXMgYSB0cmFuc2R1Y2VyIGlmIGEgdHJhbnNmb3JtZXIgaXMgZ2l2ZW4gaW4gbGlzdCBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTQuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyBbYV0gLT4gW2FdXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gY29uc2lkZXIuXG4gICAgICogQHJldHVybiB7QXJyYXl9IGBsaXN0YCB3aXRob3V0IHJlcGVhdGluZyBlbGVtZW50cy5cbiAgICAgKiBAc2VlIFIudHJhbnNkdWNlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICBSLmRyb3BSZXBlYXRzKFsxLCAxLCAxLCAyLCAzLCA0LCA0LCAyLCAyXSk7IC8vPT4gWzEsIDIsIDMsIDQsIDJdXG4gICAgICovXG4gICAgdmFyIGRyb3BSZXBlYXRzID0gX2N1cnJ5MShfZGlzcGF0Y2hhYmxlKCdkcm9wUmVwZWF0cycsIF94ZHJvcFJlcGVhdHNXaXRoKGVxdWFscyksIGRyb3BSZXBlYXRzV2l0aChlcXVhbHMpKSk7XG5cbiAgICAvKipcbiAgICAgKiBcImxpZnRzXCIgYSBmdW5jdGlvbiBvZiBhcml0eSA+IDEgc28gdGhhdCBpdCBtYXkgXCJtYXAgb3ZlclwiIGEgbGlzdCwgRnVuY3Rpb24gb3Igb3RoZXJcbiAgICAgKiBvYmplY3QgdGhhdCBzYXRpc2ZpZXMgdGhlIFtGYW50YXN5TGFuZCBBcHBseSBzcGVjXShodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2FwcGx5KS5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuNy4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHNpZyAoKi4uLiAtPiAqKSAtPiAoWypdLi4uIC0+IFsqXSlcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbGlmdCBpbnRvIGhpZ2hlciBjb250ZXh0XG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBsaWZ0ZWQgZnVuY3Rpb24uXG4gICAgICogQHNlZSBSLmxpZnROXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIG1hZGQzID0gUi5saWZ0KFIuY3VycnkoKGEsIGIsIGMpID0+IGEgKyBiICsgYykpO1xuICAgICAqXG4gICAgICogICAgICBtYWRkMyhbMSwyLDNdLCBbMSwyLDNdLCBbMV0pOyAvLz0+IFszLCA0LCA1LCA0LCA1LCA2LCA1LCA2LCA3XVxuICAgICAqXG4gICAgICogICAgICB2YXIgbWFkZDUgPSBSLmxpZnQoUi5jdXJyeSgoYSwgYiwgYywgZCwgZSkgPT4gYSArIGIgKyBjICsgZCArIGUpKTtcbiAgICAgKlxuICAgICAqICAgICAgbWFkZDUoWzEsMl0sIFszXSwgWzQsIDVdLCBbNl0sIFs3LCA4XSk7IC8vPT4gWzIxLCAyMiwgMjIsIDIzLCAyMiwgMjMsIDIzLCAyNF1cbiAgICAgKi9cbiAgICB2YXIgbGlmdCA9IF9jdXJyeTEoZnVuY3Rpb24gbGlmdChmbikge1xuICAgICAgICByZXR1cm4gbGlmdE4oZm4ubGVuZ3RoLCBmbik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcGFydGlhbCBjb3B5IG9mIGFuIG9iamVjdCBvbWl0dGluZyB0aGUga2V5cyBzcGVjaWZpZWQuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAc2lnIFtTdHJpbmddIC0+IHtTdHJpbmc6ICp9IC0+IHtTdHJpbmc6ICp9XG4gICAgICogQHBhcmFtIHtBcnJheX0gbmFtZXMgYW4gYXJyYXkgb2YgU3RyaW5nIHByb3BlcnR5IG5hbWVzIHRvIG9taXQgZnJvbSB0aGUgbmV3IG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBjb3B5IGZyb21cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEEgbmV3IG9iamVjdCB3aXRoIHByb3BlcnRpZXMgZnJvbSBgbmFtZXNgIG5vdCBvbiBpdC5cbiAgICAgKiBAc2VlIFIucGlja1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIub21pdChbJ2EnLCAnZCddLCB7YTogMSwgYjogMiwgYzogMywgZDogNH0pOyAvLz0+IHtiOiAyLCBjOiAzfVxuICAgICAqL1xuICAgIHZhciBvbWl0ID0gX2N1cnJ5MihmdW5jdGlvbiBvbWl0KG5hbWVzLCBvYmopIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKCFfY29udGFpbnMocHJvcCwgbmFtZXMpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W3Byb3BdID0gb2JqW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsZWZ0LXRvLXJpZ2h0IEtsZWlzbGkgY29tcG9zaXRpb24gb2YgdGhlIHByb3ZpZGVkIGZ1bmN0aW9ucyxcbiAgICAgKiBlYWNoIG9mIHdoaWNoIG11c3QgcmV0dXJuIGEgdmFsdWUgb2YgYSB0eXBlIHN1cHBvcnRlZCBieSBbYGNoYWluYF0oI2NoYWluKS5cbiAgICAgKlxuICAgICAqIGBSLnBpcGVLKGYsIGcsIGgpYCBpcyBlcXVpdmFsZW50IHRvIGBSLnBpcGUoUi5jaGFpbihmKSwgUi5jaGFpbihnKSwgUi5jaGFpbihoKSlgLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xNi4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHNpZyBDaGFpbiBtID0+ICgoYSAtPiBtIGIpLCAoYiAtPiBtIGMpLCAuLi4sICh5IC0+IG0geikpIC0+IChtIGEgLT4gbSB6KVxuICAgICAqIEBwYXJhbSB7Li4uRnVuY3Rpb259XG4gICAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAgICogQHNlZSBSLmNvbXBvc2VLXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgLy8gIHBhcnNlSnNvbiA6OiBTdHJpbmcgLT4gTWF5YmUgKlxuICAgICAqICAgICAgLy8gIGdldCA6OiBTdHJpbmcgLT4gT2JqZWN0IC0+IE1heWJlICpcbiAgICAgKlxuICAgICAqICAgICAgLy8gIGdldFN0YXRlQ29kZSA6OiBNYXliZSBTdHJpbmcgLT4gTWF5YmUgU3RyaW5nXG4gICAgICogICAgICB2YXIgZ2V0U3RhdGVDb2RlID0gUi5waXBlSyhcbiAgICAgKiAgICAgICAgcGFyc2VKc29uLFxuICAgICAqICAgICAgICBnZXQoJ3VzZXInKSxcbiAgICAgKiAgICAgICAgZ2V0KCdhZGRyZXNzJyksXG4gICAgICogICAgICAgIGdldCgnc3RhdGUnKSxcbiAgICAgKiAgICAgICAgUi5jb21wb3NlKE1heWJlLm9mLCBSLnRvVXBwZXIpXG4gICAgICogICAgICApO1xuICAgICAqXG4gICAgICogICAgICBnZXRTdGF0ZUNvZGUoTWF5YmUub2YoJ3tcInVzZXJcIjp7XCJhZGRyZXNzXCI6e1wic3RhdGVcIjpcIm55XCJ9fX0nKSk7XG4gICAgICogICAgICAvLz0+IEp1c3QoJ05ZJylcbiAgICAgKiAgICAgIGdldFN0YXRlQ29kZShNYXliZS5vZignW0ludmFsaWQgSlNPTl0nKSk7XG4gICAgICogICAgICAvLz0+IE5vdGhpbmcoKVxuICAgICAqL1xuICAgIHZhciBwaXBlSyA9IGZ1bmN0aW9uIHBpcGVLKCkge1xuICAgICAgICByZXR1cm4gY29tcG9zZUsuYXBwbHkodGhpcywgcmV2ZXJzZShhcmd1bWVudHMpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiB2YWx1ZS4gYGV2YWxgJ2luZyB0aGUgb3V0cHV0XG4gICAgICogc2hvdWxkIHJlc3VsdCBpbiBhIHZhbHVlIGVxdWl2YWxlbnQgdG8gdGhlIGlucHV0IHZhbHVlLiBNYW55IG9mIHRoZSBidWlsdC1pblxuICAgICAqIGB0b1N0cmluZ2AgbWV0aG9kcyBkbyBub3Qgc2F0aXNmeSB0aGlzIHJlcXVpcmVtZW50LlxuICAgICAqXG4gICAgICogSWYgdGhlIGdpdmVuIHZhbHVlIGlzIGFuIGBbb2JqZWN0IE9iamVjdF1gIHdpdGggYSBgdG9TdHJpbmdgIG1ldGhvZCBvdGhlclxuICAgICAqIHRoYW4gYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLCB0aGlzIG1ldGhvZCBpcyBpbnZva2VkIHdpdGggbm8gYXJndW1lbnRzXG4gICAgICogdG8gcHJvZHVjZSB0aGUgcmV0dXJuIHZhbHVlLiBUaGlzIG1lYW5zIHVzZXItZGVmaW5lZCBjb25zdHJ1Y3RvciBmdW5jdGlvbnNcbiAgICAgKiBjYW4gcHJvdmlkZSBhIHN1aXRhYmxlIGB0b1N0cmluZ2AgbWV0aG9kLiBGb3IgZXhhbXBsZTpcbiAgICAgKlxuICAgICAqICAgICBmdW5jdGlvbiBQb2ludCh4LCB5KSB7XG4gICAgICogICAgICAgdGhpcy54ID0geDtcbiAgICAgKiAgICAgICB0aGlzLnkgPSB5O1xuICAgICAqICAgICB9XG4gICAgICpcbiAgICAgKiAgICAgUG9pbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICogICAgICAgcmV0dXJuICduZXcgUG9pbnQoJyArIHRoaXMueCArICcsICcgKyB0aGlzLnkgKyAnKSc7XG4gICAgICogICAgIH07XG4gICAgICpcbiAgICAgKiAgICAgUi50b1N0cmluZyhuZXcgUG9pbnQoMSwgMikpOyAvLz0+ICduZXcgUG9pbnQoMSwgMiknXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjE0LjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHNpZyAqIC0+IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIudG9TdHJpbmcoNDIpOyAvLz0+ICc0MidcbiAgICAgKiAgICAgIFIudG9TdHJpbmcoJ2FiYycpOyAvLz0+ICdcImFiY1wiJ1xuICAgICAqICAgICAgUi50b1N0cmluZyhbMSwgMiwgM10pOyAvLz0+ICdbMSwgMiwgM10nXG4gICAgICogICAgICBSLnRvU3RyaW5nKHtmb286IDEsIGJhcjogMiwgYmF6OiAzfSk7IC8vPT4gJ3tcImJhclwiOiAyLCBcImJhelwiOiAzLCBcImZvb1wiOiAxfSdcbiAgICAgKiAgICAgIFIudG9TdHJpbmcobmV3IERhdGUoJzIwMDEtMDItMDNUMDQ6MDU6MDZaJykpOyAvLz0+ICduZXcgRGF0ZShcIjIwMDEtMDItMDNUMDQ6MDU6MDYuMDAwWlwiKSdcbiAgICAgKi9cbiAgICB2YXIgdG9TdHJpbmcgPSBfY3VycnkxKGZ1bmN0aW9uIHRvU3RyaW5nKHZhbCkge1xuICAgICAgICByZXR1cm4gX3RvU3RyaW5nKHZhbCwgW10pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBsaXN0IHdpdGhvdXQgdmFsdWVzIGluIHRoZSBmaXJzdCBhcmd1bWVudC5cbiAgICAgKiBgUi5lcXVhbHNgIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGVxdWFsaXR5LlxuICAgICAqXG4gICAgICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xOS4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIFthXSAtPiBbYV0gLT4gW2FdXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdDEgVGhlIHZhbHVlcyB0byBiZSByZW1vdmVkIGZyb20gYGxpc3QyYC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0MiBUaGUgYXJyYXkgdG8gcmVtb3ZlIHZhbHVlcyBmcm9tLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBUaGUgbmV3IGFycmF5IHdpdGhvdXQgdmFsdWVzIGluIGBsaXN0MWAuXG4gICAgICogQHNlZSBSLnRyYW5zZHVjZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIud2l0aG91dChbMSwgMl0sIFsxLCAyLCAxLCAzLCA0XSk7IC8vPT4gWzMsIDRdXG4gICAgICovXG4gICAgdmFyIHdpdGhvdXQgPSBfY3VycnkyKGZ1bmN0aW9uICh4cywgbGlzdCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGZsaXAoX2NvbnRhaW5zKSh4cyksIGxpc3QpO1xuICAgIH0pO1xuXG4gICAgLy8gQSBzaW1wbGUgU2V0IHR5cGUgdGhhdCBob25vdXJzIFIuZXF1YWxzIHNlbWFudGljc1xuICAgIC8qIGdsb2JhbHMgU2V0ICovXG4gICAgLyoqXG4gICAgICAgKiBDb21iaW5lcyB0aGUgbG9naWMgZm9yIGNoZWNraW5nIHdoZXRoZXIgYW4gaXRlbSBpcyBhIG1lbWJlciBvZiB0aGUgc2V0IGFuZFxuICAgICAgICogZm9yIGFkZGluZyBhIG5ldyBpdGVtIHRvIHRoZSBzZXQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIGl0ZW0gICAgICAgVGhlIGl0ZW0gdG8gY2hlY2sgb3IgYWRkIHRvIHRoZSBTZXQgaW5zdGFuY2UuXG4gICAgICAgKiBAcGFyYW0gc2hvdWxkQWRkICBJZiB0cnVlLCB0aGUgaXRlbSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBzZXQgaWYgaXQgZG9lc24ndFxuICAgICAgICogICAgICAgICAgICAgICAgICAgYWxyZWFkeSBleGlzdC5cbiAgICAgICAqIEBwYXJhbSBzZXQgICAgICAgIFRoZSBzZXQgaW5zdGFuY2UgdG8gY2hlY2sgb3IgYWRkIHRvLlxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hlbiBzaG91bGRBZGQgaXMgdHJ1ZSwgdGhpcyB3aWxsIHJldHVybiB0cnVlIHdoZW4gYSBuZXdcbiAgICAgICAqICAgICAgICAgICAgICAgICAgIGl0ZW0gd2FzIGFkZGVkIG90aGVyd2lzZSBmYWxzZS4gV2hlbiBzaG91bGRBZGQgaXMgZmFsc2UsXG4gICAgICAgKiAgICAgICAgICAgICAgICAgICB0aGlzIHdpbGwgcmV0dXJuIHRydWUgaWYgdGhlIGl0ZW0gYWxyZWFkeSBleGlzdHMsIG90aGVyd2lzZVxuICAgICAgICogICAgICAgICAgICAgICAgICAgZmFsc2UuXG4gICAgICAgKi9cbiAgICAvLyBkaXN0aW5ndWlzaCBiZXR3ZWVuICswIGFuZCAtMFxuICAgIC8vIHRoZXNlIHR5cGVzIGNhbiBhbGwgdXRpbGlzZSBTZXRcbiAgICAvLyBzZXQuX2l0ZW1zWydib29sZWFuJ10gaG9sZHMgYSB0d28gZWxlbWVudCBhcnJheVxuICAgIC8vIHJlcHJlc2VudGluZyBbIGZhbHNlRXhpc3RzLCB0cnVlRXhpc3RzIF1cbiAgICAvLyBjb21wYXJlIGZ1bmN0aW9ucyBmb3IgcmVmZXJlbmNlIGVxdWFsaXR5XG4gICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIC8vIHJlZHVjZSB0aGUgc2VhcmNoIHNpemUgb2YgaGV0ZXJvZ2VuZW91cyBzZXRzIGJ5IGNyZWF0aW5nIGJ1Y2tldHNcbiAgICAvLyBmb3IgZWFjaCB0eXBlLlxuICAgIC8vIHNjYW4gdGhyb3VnaCBhbGwgcHJldmlvdXNseSBhcHBsaWVkIGl0ZW1zXG4gICAgdmFyIF9TZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIF9TZXQoKSB7XG4gICAgICAgICAgICAvKiBnbG9iYWxzIFNldCAqL1xuICAgICAgICAgICAgdGhpcy5fbmF0aXZlU2V0ID0gdHlwZW9mIFNldCA9PT0gJ2Z1bmN0aW9uJyA/IG5ldyBTZXQoKSA6IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9pdGVtcyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIF9TZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFzT3JBZGQoaXRlbSwgdHJ1ZSwgdGhpcyk7XG4gICAgICAgIH07XG4gICAgICAgIF9TZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFzT3JBZGQoaXRlbSwgZmFsc2UsIHRoaXMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAqIENvbWJpbmVzIHRoZSBsb2dpYyBmb3IgY2hlY2tpbmcgd2hldGhlciBhbiBpdGVtIGlzIGEgbWVtYmVyIG9mIHRoZSBzZXQgYW5kXG4gICAgICAgKiBmb3IgYWRkaW5nIGEgbmV3IGl0ZW0gdG8gdGhlIHNldC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gaXRlbSAgICAgICBUaGUgaXRlbSB0byBjaGVjayBvciBhZGQgdG8gdGhlIFNldCBpbnN0YW5jZS5cbiAgICAgICAqIEBwYXJhbSBzaG91bGRBZGQgIElmIHRydWUsIHRoZSBpdGVtIHdpbGwgYmUgYWRkZWQgdG8gdGhlIHNldCBpZiBpdCBkb2Vzbid0XG4gICAgICAgKiAgICAgICAgICAgICAgICAgICBhbHJlYWR5IGV4aXN0LlxuICAgICAgICogQHBhcmFtIHNldCAgICAgICAgVGhlIHNldCBpbnN0YW5jZSB0byBjaGVjayBvciBhZGQgdG8uXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGVuIHNob3VsZEFkZCBpcyB0cnVlLCB0aGlzIHdpbGwgcmV0dXJuIHRydWUgd2hlbiBhIG5ld1xuICAgICAgICogICAgICAgICAgICAgICAgICAgaXRlbSB3YXMgYWRkZWQgb3RoZXJ3aXNlIGZhbHNlLiBXaGVuIHNob3VsZEFkZCBpcyBmYWxzZSxcbiAgICAgICAqICAgICAgICAgICAgICAgICAgIHRoaXMgd2lsbCByZXR1cm4gdHJ1ZSBpZiB0aGUgaXRlbSBhbHJlYWR5IGV4aXN0cywgb3RoZXJ3aXNlXG4gICAgICAgKiAgICAgICAgICAgICAgICAgICBmYWxzZS5cbiAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBoYXNPckFkZChpdGVtLCBzaG91bGRBZGQsIHNldCkge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgaXRlbTtcbiAgICAgICAgICAgIHZhciBwcmV2U2l6ZSwgbmV3U2l6ZTtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgLy8gZGlzdGluZ3Vpc2ggYmV0d2VlbiArMCBhbmQgLTBcbiAgICAgICAgICAgICAgICBpZiAoaXRlbSA9PT0gMCAmJiAhc2V0Ll9pdGVtc1snLTAnXSAmJiAxIC8gaXRlbSA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRBZGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldC5faXRlbXNbJy0wJ10gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaG91bGRBZGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHRoZXNlIHR5cGVzIGNhbiBhbGwgdXRpbGlzZSBTZXRcbiAgICAgICAgICAgICAgICBpZiAoc2V0Ll9uYXRpdmVTZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZEFkZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldlNpemUgPSBzZXQuX25hdGl2ZVNldC5zaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0Ll9uYXRpdmVTZXQuYWRkKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2l6ZSA9IHNldC5fbmF0aXZlU2V0LnNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3U2l6ZSA+IHByZXZTaXplO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldC5fbmF0aXZlU2V0LmhhcyhpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHR5cGUgaW4gc2V0Ll9pdGVtcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRBZGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXQuX2l0ZW1zW3R5cGVdID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0Ll9pdGVtc1t0eXBlXVtpdGVtXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2hvdWxkQWRkO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0gaW4gc2V0Ll9pdGVtc1t0eXBlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFzaG91bGRBZGQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkQWRkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0Ll9pdGVtc1t0eXBlXVtpdGVtXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2hvdWxkQWRkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgLy8gc2V0Ll9pdGVtc1snYm9vbGVhbiddIGhvbGRzIGEgdHdvIGVsZW1lbnQgYXJyYXlcbiAgICAgICAgICAgICAgICAvLyByZXByZXNlbnRpbmcgWyBmYWxzZUV4aXN0cywgdHJ1ZUV4aXN0cyBdXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgaW4gc2V0Ll9pdGVtcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYklkeCA9IGl0ZW0gPyAxIDogMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldC5faXRlbXNbdHlwZV1bYklkeF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhc2hvdWxkQWRkO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZEFkZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldC5faXRlbXNbdHlwZV1bYklkeF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNob3VsZEFkZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRBZGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldC5faXRlbXNbdHlwZV0gPSBpdGVtID8gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIF0gOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2hvdWxkQWRkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICAgICAgICAvLyBjb21wYXJlIGZ1bmN0aW9ucyBmb3IgcmVmZXJlbmNlIGVxdWFsaXR5XG4gICAgICAgICAgICAgICAgaWYgKHNldC5fbmF0aXZlU2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRBZGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZTaXplID0gc2V0Ll9uYXRpdmVTZXQuc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldC5fbmF0aXZlU2V0LmFkZChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1NpemUgPSBzZXQuX25hdGl2ZVNldC5zaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld1NpemUgPiBwcmV2U2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXQuX25hdGl2ZVNldC5oYXMoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoISh0eXBlIGluIHNldC5faXRlbXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkQWRkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0Ll9pdGVtc1t0eXBlXSA9IFtpdGVtXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzaG91bGRBZGQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfY29udGFpbnMoaXRlbSwgc2V0Ll9pdGVtc1t0eXBlXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRBZGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXQuX2l0ZW1zW3R5cGVdLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2hvdWxkQWRkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAhc2hvdWxkQWRkO1xuICAgICAgICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgICAgICAgICBpZiAoc2V0Ll9pdGVtc1t0eXBlXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIXNob3VsZEFkZDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkQWRkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXQuX2l0ZW1zW3R5cGVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2hvdWxkQWRkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZXQuX2l0ZW1zWydudWxsJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRBZGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXQuX2l0ZW1zWydudWxsJ10gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNob3VsZEFkZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIXNob3VsZEFkZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIHJlZHVjZSB0aGUgc2VhcmNoIHNpemUgb2YgaGV0ZXJvZ2VuZW91cyBzZXRzIGJ5IGNyZWF0aW5nIGJ1Y2tldHNcbiAgICAgICAgICAgICAgICAvLyBmb3IgZWFjaCB0eXBlLlxuICAgICAgICAgICAgICAgIHR5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaXRlbSk7XG4gICAgICAgICAgICAgICAgaWYgKCEodHlwZSBpbiBzZXQuX2l0ZW1zKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkQWRkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXQuX2l0ZW1zW3R5cGVdID0gW2l0ZW1dO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaG91bGRBZGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHNjYW4gdGhyb3VnaCBhbGwgcHJldmlvdXNseSBhcHBsaWVkIGl0ZW1zXG4gICAgICAgICAgICAgICAgaWYgKCFfY29udGFpbnMoaXRlbSwgc2V0Ll9pdGVtc1t0eXBlXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZEFkZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0Ll9pdGVtc1t0eXBlXS5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaG91bGRBZGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAhc2hvdWxkQWRkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfU2V0O1xuICAgIH0oKTtcblxuICAgIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gd3JhcHBpbmcgY2FsbHMgdG8gdGhlIHR3byBmdW5jdGlvbnMgaW4gYW4gYCYmYCBvcGVyYXRpb24sXG4gICAgICogcmV0dXJuaW5nIHRoZSByZXN1bHQgb2YgdGhlIGZpcnN0IGZ1bmN0aW9uIGlmIGl0IGlzIGZhbHNlLXkgYW5kIHRoZSByZXN1bHRcbiAgICAgKiBvZiB0aGUgc2Vjb25kIGZ1bmN0aW9uIG90aGVyd2lzZS4gTm90ZSB0aGF0IHRoaXMgaXMgc2hvcnQtY2lyY3VpdGVkLFxuICAgICAqIG1lYW5pbmcgdGhhdCB0aGUgc2Vjb25kIGZ1bmN0aW9uIHdpbGwgbm90IGJlIGludm9rZWQgaWYgdGhlIGZpcnN0IHJldHVybnMgYVxuICAgICAqIGZhbHNlLXkgdmFsdWUuXG4gICAgICpcbiAgICAgKiBJbiBhZGRpdGlvbiB0byBmdW5jdGlvbnMsIGBSLmJvdGhgIGFsc28gYWNjZXB0cyBhbnkgZmFudGFzeS1sYW5kIGNvbXBhdGlibGVcbiAgICAgKiBhcHBsaWNhdGl2ZSBmdW5jdG9yLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xMi4wXG4gICAgICogQGNhdGVnb3J5IExvZ2ljXG4gICAgICogQHNpZyAoKi4uLiAtPiBCb29sZWFuKSAtPiAoKi4uLiAtPiBCb29sZWFuKSAtPiAoKi4uLiAtPiBCb29sZWFuKVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGYgYSBwcmVkaWNhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBnIGFub3RoZXIgcHJlZGljYXRlXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IGEgZnVuY3Rpb24gdGhhdCBhcHBsaWVzIGl0cyBhcmd1bWVudHMgdG8gYGZgIGFuZCBgZ2AgYW5kIGAmJmBzIHRoZWlyIG91dHB1dHMgdG9nZXRoZXIuXG4gICAgICogQHNlZSBSLmFuZFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBndDEwID0geCA9PiB4ID4gMTA7XG4gICAgICogICAgICB2YXIgZXZlbiA9IHggPT4geCAlIDIgPT09IDA7XG4gICAgICogICAgICB2YXIgZiA9IFIuYm90aChndDEwLCBldmVuKTtcbiAgICAgKiAgICAgIGYoMTAwKTsgLy89PiB0cnVlXG4gICAgICogICAgICBmKDEwMSk7IC8vPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgYm90aCA9IF9jdXJyeTIoZnVuY3Rpb24gYm90aChmLCBnKSB7XG4gICAgICAgIHJldHVybiBfaXNGdW5jdGlvbihmKSA/IGZ1bmN0aW9uIF9ib3RoKCkge1xuICAgICAgICAgICAgcmV0dXJuIGYuYXBwbHkodGhpcywgYXJndW1lbnRzKSAmJiBnLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0gOiBsaWZ0KGFuZCkoZiwgZyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUYWtlcyBhIGZ1bmN0aW9uIGBmYCBhbmQgcmV0dXJucyBhIGZ1bmN0aW9uIGBnYCBzdWNoIHRoYXQ6XG4gICAgICpcbiAgICAgKiAgIC0gYXBwbHlpbmcgYGdgIHRvIHplcm8gb3IgbW9yZSBhcmd1bWVudHMgd2lsbCBnaXZlIF9fdHJ1ZV9fIGlmIGFwcGx5aW5nXG4gICAgICogICAgIHRoZSBzYW1lIGFyZ3VtZW50cyB0byBgZmAgZ2l2ZXMgYSBsb2dpY2FsIF9fZmFsc2VfXyB2YWx1ZTsgYW5kXG4gICAgICpcbiAgICAgKiAgIC0gYXBwbHlpbmcgYGdgIHRvIHplcm8gb3IgbW9yZSBhcmd1bWVudHMgd2lsbCBnaXZlIF9fZmFsc2VfXyBpZiBhcHBseWluZ1xuICAgICAqICAgICB0aGUgc2FtZSBhcmd1bWVudHMgdG8gYGZgIGdpdmVzIGEgbG9naWNhbCBfX3RydWVfXyB2YWx1ZS5cbiAgICAgKlxuICAgICAqIGBSLmNvbXBsZW1lbnRgIHdpbGwgd29yayBvbiBhbGwgb3RoZXIgZnVuY3RvcnMgYXMgd2VsbC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTIuMFxuICAgICAqIEBjYXRlZ29yeSBMb2dpY1xuICAgICAqIEBzaWcgKCouLi4gLT4gKikgLT4gKCouLi4gLT4gQm9vbGVhbilcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAgICogQHNlZSBSLm5vdFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBpc0V2ZW4gPSBuID0+IG4gJSAyID09PSAwO1xuICAgICAqICAgICAgdmFyIGlzT2RkID0gUi5jb21wbGVtZW50KGlzRXZlbik7XG4gICAgICogICAgICBpc09kZCgyMSk7IC8vPT4gdHJ1ZVxuICAgICAqICAgICAgaXNPZGQoNDIpOyAvLz0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGNvbXBsZW1lbnQgPSBsaWZ0KG5vdCk7XG5cbiAgICAvKipcbiAgICAgKiBBIGZ1bmN0aW9uIHdyYXBwaW5nIGNhbGxzIHRvIHRoZSB0d28gZnVuY3Rpb25zIGluIGFuIGB8fGAgb3BlcmF0aW9uLFxuICAgICAqIHJldHVybmluZyB0aGUgcmVzdWx0IG9mIHRoZSBmaXJzdCBmdW5jdGlvbiBpZiBpdCBpcyB0cnV0aC15IGFuZCB0aGUgcmVzdWx0XG4gICAgICogb2YgdGhlIHNlY29uZCBmdW5jdGlvbiBvdGhlcndpc2UuIE5vdGUgdGhhdCB0aGlzIGlzIHNob3J0LWNpcmN1aXRlZCxcbiAgICAgKiBtZWFuaW5nIHRoYXQgdGhlIHNlY29uZCBmdW5jdGlvbiB3aWxsIG5vdCBiZSBpbnZva2VkIGlmIHRoZSBmaXJzdCByZXR1cm5zIGFcbiAgICAgKiB0cnV0aC15IHZhbHVlLlxuICAgICAqXG4gICAgICogSW4gYWRkaXRpb24gdG8gZnVuY3Rpb25zLCBgUi5laXRoZXJgIGFsc28gYWNjZXB0cyBhbnkgZmFudGFzeS1sYW5kIGNvbXBhdGlibGVcbiAgICAgKiBhcHBsaWNhdGl2ZSBmdW5jdG9yLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xMi4wXG4gICAgICogQGNhdGVnb3J5IExvZ2ljXG4gICAgICogQHNpZyAoKi4uLiAtPiBCb29sZWFuKSAtPiAoKi4uLiAtPiBCb29sZWFuKSAtPiAoKi4uLiAtPiBCb29sZWFuKVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGYgYSBwcmVkaWNhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBnIGFub3RoZXIgcHJlZGljYXRlXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IGEgZnVuY3Rpb24gdGhhdCBhcHBsaWVzIGl0cyBhcmd1bWVudHMgdG8gYGZgIGFuZCBgZ2AgYW5kIGB8fGBzIHRoZWlyIG91dHB1dHMgdG9nZXRoZXIuXG4gICAgICogQHNlZSBSLm9yXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGd0MTAgPSB4ID0+IHggPiAxMDtcbiAgICAgKiAgICAgIHZhciBldmVuID0geCA9PiB4ICUgMiA9PT0gMDtcbiAgICAgKiAgICAgIHZhciBmID0gUi5laXRoZXIoZ3QxMCwgZXZlbik7XG4gICAgICogICAgICBmKDEwMSk7IC8vPT4gdHJ1ZVxuICAgICAqICAgICAgZig4KTsgLy89PiB0cnVlXG4gICAgICovXG4gICAgdmFyIGVpdGhlciA9IF9jdXJyeTIoZnVuY3Rpb24gZWl0aGVyKGYsIGcpIHtcbiAgICAgICAgcmV0dXJuIF9pc0Z1bmN0aW9uKGYpID8gZnVuY3Rpb24gX2VpdGhlcigpIHtcbiAgICAgICAgICAgIHJldHVybiBmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9IDogbGlmdChvcikoZiwgZyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUdXJucyBhIG5hbWVkIG1ldGhvZCB3aXRoIGEgc3BlY2lmaWVkIGFyaXR5IGludG8gYSBmdW5jdGlvbiB0aGF0IGNhbiBiZVxuICAgICAqIGNhbGxlZCBkaXJlY3RseSBzdXBwbGllZCB3aXRoIGFyZ3VtZW50cyBhbmQgYSB0YXJnZXQgb2JqZWN0LlxuICAgICAqXG4gICAgICogVGhlIHJldHVybmVkIGZ1bmN0aW9uIGlzIGN1cnJpZWQgYW5kIGFjY2VwdHMgYGFyaXR5ICsgMWAgcGFyYW1ldGVycyB3aGVyZVxuICAgICAqIHRoZSBmaW5hbCBwYXJhbWV0ZXIgaXMgdGhlIHRhcmdldCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBzaWcgTnVtYmVyIC0+IFN0cmluZyAtPiAoYSAtPiBiIC0+IC4uLiAtPiBuIC0+IE9iamVjdCAtPiAqKVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcml0eSBOdW1iZXIgb2YgYXJndW1lbnRzIHRoZSByZXR1cm5lZCBmdW5jdGlvbiBzaG91bGQgdGFrZVxuICAgICAqICAgICAgICBiZWZvcmUgdGhlIHRhcmdldCBvYmplY3QuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZCBOYW1lIG9mIHRoZSBtZXRob2QgdG8gY2FsbC5cbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBuZXcgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgc2xpY2VGcm9tID0gUi5pbnZva2VyKDEsICdzbGljZScpO1xuICAgICAqICAgICAgc2xpY2VGcm9tKDYsICdhYmNkZWZnaGlqa2xtJyk7IC8vPT4gJ2doaWprbG0nXG4gICAgICogICAgICB2YXIgc2xpY2VGcm9tNiA9IFIuaW52b2tlcigyLCAnc2xpY2UnKSg2KTtcbiAgICAgKiAgICAgIHNsaWNlRnJvbTYoOCwgJ2FiY2RlZmdoaWprbG0nKTsgLy89PiAnZ2gnXG4gICAgICovXG4gICAgdmFyIGludm9rZXIgPSBfY3VycnkyKGZ1bmN0aW9uIGludm9rZXIoYXJpdHksIG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gY3VycnlOKGFyaXR5ICsgMSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IGFyZ3VtZW50c1thcml0eV07XG4gICAgICAgICAgICBpZiAodGFyZ2V0ICE9IG51bGwgJiYgaXMoRnVuY3Rpb24sIHRhcmdldFttZXRob2RdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRbbWV0aG9kXS5hcHBseSh0YXJnZXQsIF9zbGljZShhcmd1bWVudHMsIDAsIGFyaXR5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHRvU3RyaW5nKHRhcmdldCkgKyAnIGRvZXMgbm90IGhhdmUgYSBtZXRob2QgbmFtZWQgXCInICsgbWV0aG9kICsgJ1wiJyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyBtYWRlIGJ5IGluc2VydGluZyB0aGUgYHNlcGFyYXRvcmAgYmV0d2VlbiBlYWNoIGVsZW1lbnQgYW5kXG4gICAgICogY29uY2F0ZW5hdGluZyBhbGwgdGhlIGVsZW1lbnRzIGludG8gYSBzaW5nbGUgc3RyaW5nLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgU3RyaW5nIC0+IFthXSAtPiBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHNlcGFyYXRvciBUaGUgc3RyaW5nIHVzZWQgdG8gc2VwYXJhdGUgdGhlIGVsZW1lbnRzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHhzIFRoZSBlbGVtZW50cyB0byBqb2luIGludG8gYSBzdHJpbmcuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyBtYWRlIGJ5IGNvbmNhdGVuYXRpbmcgYHhzYCB3aXRoIGBzZXBhcmF0b3JgLlxuICAgICAqIEBzZWUgUi5zcGxpdFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBzcGFjZXIgPSBSLmpvaW4oJyAnKTtcbiAgICAgKiAgICAgIHNwYWNlcihbJ2EnLCAyLCAzLjRdKTsgICAvLz0+ICdhIDIgMy40J1xuICAgICAqICAgICAgUi5qb2luKCd8JywgWzEsIDIsIDNdKTsgICAgLy89PiAnMXwyfDMnXG4gICAgICovXG4gICAgdmFyIGpvaW4gPSBpbnZva2VyKDEsICdqb2luJyk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGZ1bmN0aW9uIHRoYXQsIHdoZW4gaW52b2tlZCwgY2FjaGVzIHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZm5gXG4gICAgICogZm9yIGEgZ2l2ZW4gYXJndW1lbnQgc2V0IGFuZCByZXR1cm5zIHRoZSByZXN1bHQuIFN1YnNlcXVlbnQgY2FsbHMgdG8gdGhlXG4gICAgICogbWVtb2l6ZWQgYGZuYCB3aXRoIHRoZSBzYW1lIGFyZ3VtZW50IHNldCB3aWxsIG5vdCByZXN1bHQgaW4gYW4gYWRkaXRpb25hbFxuICAgICAqIGNhbGwgdG8gYGZuYDsgaW5zdGVhZCwgdGhlIGNhY2hlZCByZXN1bHQgZm9yIHRoYXQgc2V0IG9mIGFyZ3VtZW50cyB3aWxsIGJlXG4gICAgICogcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBzaWcgKCouLi4gLT4gYSkgLT4gKCouLi4gLT4gYSlcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbWVtb2l6ZS5cbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gTWVtb2l6ZWQgdmVyc2lvbiBvZiBgZm5gLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICogICAgICB2YXIgZmFjdG9yaWFsID0gUi5tZW1vaXplKG4gPT4ge1xuICAgICAqICAgICAgICBjb3VudCArPSAxO1xuICAgICAqICAgICAgICByZXR1cm4gUi5wcm9kdWN0KFIucmFuZ2UoMSwgbiArIDEpKTtcbiAgICAgKiAgICAgIH0pO1xuICAgICAqICAgICAgZmFjdG9yaWFsKDUpOyAvLz0+IDEyMFxuICAgICAqICAgICAgZmFjdG9yaWFsKDUpOyAvLz0+IDEyMFxuICAgICAqICAgICAgZmFjdG9yaWFsKDUpOyAvLz0+IDEyMFxuICAgICAqICAgICAgY291bnQ7IC8vPT4gMVxuICAgICAqL1xuICAgIHZhciBtZW1vaXplID0gX2N1cnJ5MShmdW5jdGlvbiBtZW1vaXplKGZuKSB7XG4gICAgICAgIHZhciBjYWNoZSA9IHt9O1xuICAgICAgICByZXR1cm4gX2FyaXR5KGZuLmxlbmd0aCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGtleSA9IHRvU3RyaW5nKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBpZiAoIV9oYXMoa2V5LCBjYWNoZSkpIHtcbiAgICAgICAgICAgICAgICBjYWNoZVtrZXldID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjYWNoZVtrZXldO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFNwbGl0cyBhIHN0cmluZyBpbnRvIGFuIGFycmF5IG9mIHN0cmluZ3MgYmFzZWQgb24gdGhlIGdpdmVuXG4gICAgICogc2VwYXJhdG9yLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHNpZyAoU3RyaW5nIHwgUmVnRXhwKSAtPiBTdHJpbmcgLT4gW1N0cmluZ11cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IHNlcCBUaGUgcGF0dGVybi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gc2VwYXJhdGUgaW50byBhbiBhcnJheS5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGFycmF5IG9mIHN0cmluZ3MgZnJvbSBgc3RyYCBzZXBhcmF0ZWQgYnkgYHN0cmAuXG4gICAgICogQHNlZSBSLmpvaW5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgcGF0aENvbXBvbmVudHMgPSBSLnNwbGl0KCcvJyk7XG4gICAgICogICAgICBSLnRhaWwocGF0aENvbXBvbmVudHMoJy91c3IvbG9jYWwvYmluL25vZGUnKSk7IC8vPT4gWyd1c3InLCAnbG9jYWwnLCAnYmluJywgJ25vZGUnXVxuICAgICAqXG4gICAgICogICAgICBSLnNwbGl0KCcuJywgJ2EuYi5jLnh5ei5kJyk7IC8vPT4gWydhJywgJ2InLCAnYycsICd4eXonLCAnZCddXG4gICAgICovXG4gICAgdmFyIHNwbGl0ID0gaW52b2tlcigxLCAnc3BsaXQnKTtcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciBhIGdpdmVuIHN0cmluZyBtYXRjaGVzIGEgZ2l2ZW4gcmVndWxhciBleHByZXNzaW9uLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xMi4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBzaWcgUmVnRXhwIC0+IFN0cmluZyAtPiBCb29sZWFuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IHBhdHRlcm5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKiBAc2VlIFIubWF0Y2hcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLnRlc3QoL154LywgJ3h5eicpOyAvLz0+IHRydWVcbiAgICAgKiAgICAgIFIudGVzdCgvXnkvLCAneHl6Jyk7IC8vPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgdGVzdCA9IF9jdXJyeTIoZnVuY3Rpb24gdGVzdChwYXR0ZXJuLCBzdHIpIHtcbiAgICAgICAgaWYgKCFfaXNSZWdFeHAocGF0dGVybikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcdTIwMTh0ZXN0XFx1MjAxOSByZXF1aXJlcyBhIHZhbHVlIG9mIHR5cGUgUmVnRXhwIGFzIGl0cyBmaXJzdCBhcmd1bWVudDsgcmVjZWl2ZWQgJyArIHRvU3RyaW5nKHBhdHRlcm4pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2Nsb25lUmVnRXhwKHBhdHRlcm4pLnRlc3Qoc3RyKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsb3dlciBjYXNlIHZlcnNpb24gb2YgYSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjkuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAc2lnIFN0cmluZyAtPiBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gbG93ZXIgY2FzZS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBsb3dlciBjYXNlIHZlcnNpb24gb2YgYHN0cmAuXG4gICAgICogQHNlZSBSLnRvVXBwZXJcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLnRvTG93ZXIoJ1hZWicpOyAvLz0+ICd4eXonXG4gICAgICovXG4gICAgdmFyIHRvTG93ZXIgPSBpbnZva2VyKDAsICd0b0xvd2VyQ2FzZScpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHVwcGVyIGNhc2UgdmVyc2lvbiBvZiBhIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuOS4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBzaWcgU3RyaW5nIC0+IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byB1cHBlciBjYXNlLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHVwcGVyIGNhc2UgdmVyc2lvbiBvZiBgc3RyYC5cbiAgICAgKiBAc2VlIFIudG9Mb3dlclxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIudG9VcHBlcignYWJjJyk7IC8vPT4gJ0FCQydcbiAgICAgKi9cbiAgICB2YXIgdG9VcHBlciA9IGludm9rZXIoMCwgJ3RvVXBwZXJDYXNlJyk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IGxpc3QgY29udGFpbmluZyBvbmx5IG9uZSBjb3B5IG9mIGVhY2ggZWxlbWVudCBpbiB0aGUgb3JpZ2luYWxcbiAgICAgKiBsaXN0LCBiYXNlZCB1cG9uIHRoZSB2YWx1ZSByZXR1cm5lZCBieSBhcHBseWluZyB0aGUgc3VwcGxpZWQgZnVuY3Rpb24gdG9cbiAgICAgKiBlYWNoIGxpc3QgZWxlbWVudC4gUHJlZmVycyB0aGUgZmlyc3QgaXRlbSBpZiB0aGUgc3VwcGxpZWQgZnVuY3Rpb24gcHJvZHVjZXNcbiAgICAgKiB0aGUgc2FtZSB2YWx1ZSBvbiB0d28gaXRlbXMuIGBSLmVxdWFsc2AgaXMgdXNlZCBmb3IgY29tcGFyaXNvbi5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTYuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyAoYSAtPiBiKSAtPiBbYV0gLT4gW2FdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gQSBmdW5jdGlvbiB1c2VkIHRvIHByb2R1Y2UgYSB2YWx1ZSB0byB1c2UgZHVyaW5nIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGNvbnNpZGVyLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBUaGUgbGlzdCBvZiB1bmlxdWUgaXRlbXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi51bmlxQnkoTWF0aC5hYnMsIFstMSwgLTUsIDIsIDEwLCAxLCAyXSk7IC8vPT4gWy0xLCAtNSwgMiwgMTBdXG4gICAgICovXG4gICAgdmFyIHVuaXFCeSA9IF9jdXJyeTIoZnVuY3Rpb24gdW5pcUJ5KGZuLCBsaXN0KSB7XG4gICAgICAgIHZhciBzZXQgPSBuZXcgX1NldCgpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHZhciBpZHggPSAwO1xuICAgICAgICB2YXIgYXBwbGllZEl0ZW0sIGl0ZW07XG4gICAgICAgIHdoaWxlIChpZHggPCBsaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgaXRlbSA9IGxpc3RbaWR4XTtcbiAgICAgICAgICAgIGFwcGxpZWRJdGVtID0gZm4oaXRlbSk7XG4gICAgICAgICAgICBpZiAoc2V0LmFkZChhcHBsaWVkSXRlbSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSByZXN1bHQgb2YgY29uY2F0ZW5hdGluZyB0aGUgZ2l2ZW4gbGlzdHMgb3Igc3RyaW5ncy5cbiAgICAgKlxuICAgICAqIERpc3BhdGNoZXMgdG8gdGhlIGBjb25jYXRgIG1ldGhvZCBvZiB0aGUgZmlyc3QgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyBbYV0gLT4gW2FdIC0+IFthXVxuICAgICAqIEBzaWcgU3RyaW5nIC0+IFN0cmluZyAtPiBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gYVxuICAgICAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBiXG4gICAgICogQHJldHVybiB7QXJyYXl8U3RyaW5nfVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5jb25jYXQoW10sIFtdKTsgLy89PiBbXVxuICAgICAqICAgICAgUi5jb25jYXQoWzQsIDUsIDZdLCBbMSwgMiwgM10pOyAvLz0+IFs0LCA1LCA2LCAxLCAyLCAzXVxuICAgICAqICAgICAgUi5jb25jYXQoJ0FCQycsICdERUYnKTsgLy8gJ0FCQ0RFRidcbiAgICAgKi9cbiAgICB2YXIgY29uY2F0ID0gZmxpcChpbnZva2VyKDEsICdjb25jYXQnKSk7XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgc2V0IChpLmUuIG5vIGR1cGxpY2F0ZXMpIG9mIGFsbCBlbGVtZW50cyBjb250YWluZWQgaW4gdGhlIGZpcnN0IG9yXG4gICAgICogc2Vjb25kIGxpc3QsIGJ1dCBub3QgYm90aC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTkuMFxuICAgICAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICAgICAqIEBzaWcgWypdIC0+IFsqXSAtPiBbKl1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0MSBUaGUgZmlyc3QgbGlzdC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0MiBUaGUgc2Vjb25kIGxpc3QuXG4gICAgICogQHJldHVybiB7QXJyYXl9IFRoZSBlbGVtZW50cyBpbiBgbGlzdDFgIG9yIGBsaXN0MmAsIGJ1dCBub3QgYm90aC5cbiAgICAgKiBAc2VlIFIuc3ltbWV0cmljRGlmZmVyZW5jZVdpdGhcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLnN5bW1ldHJpY0RpZmZlcmVuY2UoWzEsMiwzLDRdLCBbNyw2LDUsNCwzXSk7IC8vPT4gWzEsMiw3LDYsNV1cbiAgICAgKiAgICAgIFIuc3ltbWV0cmljRGlmZmVyZW5jZShbNyw2LDUsNCwzXSwgWzEsMiwzLDRdKTsgLy89PiBbNyw2LDUsMSwyXVxuICAgICAqL1xuICAgIHZhciBzeW1tZXRyaWNEaWZmZXJlbmNlID0gX2N1cnJ5MihmdW5jdGlvbiBzeW1tZXRyaWNEaWZmZXJlbmNlKGxpc3QxLCBsaXN0Mikge1xuICAgICAgICByZXR1cm4gY29uY2F0KGRpZmZlcmVuY2UobGlzdDEsIGxpc3QyKSwgZGlmZmVyZW5jZShsaXN0MiwgbGlzdDEpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBzZXQgKGkuZS4gbm8gZHVwbGljYXRlcykgb2YgYWxsIGVsZW1lbnRzIGNvbnRhaW5lZCBpbiB0aGUgZmlyc3Qgb3JcbiAgICAgKiBzZWNvbmQgbGlzdCwgYnV0IG5vdCBib3RoLiBEdXBsaWNhdGlvbiBpcyBkZXRlcm1pbmVkIGFjY29yZGluZyB0byB0aGUgdmFsdWVcbiAgICAgKiByZXR1cm5lZCBieSBhcHBseWluZyB0aGUgc3VwcGxpZWQgcHJlZGljYXRlIHRvIHR3byBsaXN0IGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xOS4wXG4gICAgICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gICAgICogQHNpZyAoYSAtPiBhIC0+IEJvb2xlYW4pIC0+IFthXSAtPiBbYV0gLT4gW2FdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZCBBIHByZWRpY2F0ZSB1c2VkIHRvIHRlc3Qgd2hldGhlciB0d28gaXRlbXMgYXJlIGVxdWFsLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QxIFRoZSBmaXJzdCBsaXN0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QyIFRoZSBzZWNvbmQgbGlzdC5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGVsZW1lbnRzIGluIGBsaXN0MWAgb3IgYGxpc3QyYCwgYnV0IG5vdCBib3RoLlxuICAgICAqIEBzZWUgUi5zeW1tZXRyaWNEaWZmZXJlbmNlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGVxQSA9IFIuZXFCeShSLnByb3AoJ2EnKSk7XG4gICAgICogICAgICB2YXIgbDEgPSBbe2E6IDF9LCB7YTogMn0sIHthOiAzfSwge2E6IDR9XTtcbiAgICAgKiAgICAgIHZhciBsMiA9IFt7YTogM30sIHthOiA0fSwge2E6IDV9LCB7YTogNn1dO1xuICAgICAqICAgICAgUi5zeW1tZXRyaWNEaWZmZXJlbmNlV2l0aChlcUEsIGwxLCBsMik7IC8vPT4gW3thOiAxfSwge2E6IDJ9LCB7YTogNX0sIHthOiA2fV1cbiAgICAgKi9cbiAgICB2YXIgc3ltbWV0cmljRGlmZmVyZW5jZVdpdGggPSBfY3VycnkzKGZ1bmN0aW9uIHN5bW1ldHJpY0RpZmZlcmVuY2VXaXRoKHByZWQsIGxpc3QxLCBsaXN0Mikge1xuICAgICAgICByZXR1cm4gY29uY2F0KGRpZmZlcmVuY2VXaXRoKHByZWQsIGxpc3QxLCBsaXN0MiksIGRpZmZlcmVuY2VXaXRoKHByZWQsIGxpc3QyLCBsaXN0MSkpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBsaXN0IGNvbnRhaW5pbmcgb25seSBvbmUgY29weSBvZiBlYWNoIGVsZW1lbnQgaW4gdGhlIG9yaWdpbmFsXG4gICAgICogbGlzdC4gYFIuZXF1YWxzYCBpcyB1c2VkIHRvIGRldGVybWluZSBlcXVhbGl0eS5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIFthXSAtPiBbYV1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBjb25zaWRlci5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGxpc3Qgb2YgdW5pcXVlIGl0ZW1zLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIudW5pcShbMSwgMSwgMiwgMV0pOyAvLz0+IFsxLCAyXVxuICAgICAqICAgICAgUi51bmlxKFsxLCAnMSddKTsgICAgIC8vPT4gWzEsICcxJ11cbiAgICAgKiAgICAgIFIudW5pcShbWzQyXSwgWzQyXV0pOyAvLz0+IFtbNDJdXVxuICAgICAqL1xuICAgIHZhciB1bmlxID0gdW5pcUJ5KGlkZW50aXR5KTtcblxuICAgIC8qKlxuICAgICAqIENvbWJpbmVzIHR3byBsaXN0cyBpbnRvIGEgc2V0IChpLmUuIG5vIGR1cGxpY2F0ZXMpIGNvbXBvc2VkIG9mIHRob3NlXG4gICAgICogZWxlbWVudHMgY29tbW9uIHRvIGJvdGggbGlzdHMuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICAgICAqIEBzaWcgWypdIC0+IFsqXSAtPiBbKl1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0MSBUaGUgZmlyc3QgbGlzdC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0MiBUaGUgc2Vjb25kIGxpc3QuXG4gICAgICogQHJldHVybiB7QXJyYXl9IFRoZSBsaXN0IG9mIGVsZW1lbnRzIGZvdW5kIGluIGJvdGggYGxpc3QxYCBhbmQgYGxpc3QyYC5cbiAgICAgKiBAc2VlIFIuaW50ZXJzZWN0aW9uV2l0aFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuaW50ZXJzZWN0aW9uKFsxLDIsMyw0XSwgWzcsNiw1LDQsM10pOyAvLz0+IFs0LCAzXVxuICAgICAqL1xuICAgIHZhciBpbnRlcnNlY3Rpb24gPSBfY3VycnkyKGZ1bmN0aW9uIGludGVyc2VjdGlvbihsaXN0MSwgbGlzdDIpIHtcbiAgICAgICAgdmFyIGxvb2t1cExpc3QsIGZpbHRlcmVkTGlzdDtcbiAgICAgICAgaWYgKGxpc3QxLmxlbmd0aCA+IGxpc3QyLmxlbmd0aCkge1xuICAgICAgICAgICAgbG9va3VwTGlzdCA9IGxpc3QxO1xuICAgICAgICAgICAgZmlsdGVyZWRMaXN0ID0gbGlzdDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb29rdXBMaXN0ID0gbGlzdDI7XG4gICAgICAgICAgICBmaWx0ZXJlZExpc3QgPSBsaXN0MTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5pcShfZmlsdGVyKGZsaXAoX2NvbnRhaW5zKShsb29rdXBMaXN0KSwgZmlsdGVyZWRMaXN0KSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb21iaW5lcyB0d28gbGlzdHMgaW50byBhIHNldCAoaS5lLiBubyBkdXBsaWNhdGVzKSBjb21wb3NlZCBvZiB0aGUgZWxlbWVudHNcbiAgICAgKiBvZiBlYWNoIGxpc3QuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICAgICAqIEBzaWcgWypdIC0+IFsqXSAtPiBbKl1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcyBUaGUgZmlyc3QgbGlzdC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBicyBUaGUgc2Vjb25kIGxpc3QuXG4gICAgICogQHJldHVybiB7QXJyYXl9IFRoZSBmaXJzdCBhbmQgc2Vjb25kIGxpc3RzIGNvbmNhdGVuYXRlZCwgd2l0aFxuICAgICAqICAgICAgICAgZHVwbGljYXRlcyByZW1vdmVkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIudW5pb24oWzEsIDIsIDNdLCBbMiwgMywgNF0pOyAvLz0+IFsxLCAyLCAzLCA0XVxuICAgICAqL1xuICAgIHZhciB1bmlvbiA9IF9jdXJyeTIoY29tcG9zZSh1bmlxLCBfY29uY2F0KSk7XG5cbiAgICB2YXIgUiA9IHtcbiAgICAgICAgRjogRixcbiAgICAgICAgVDogVCxcbiAgICAgICAgX186IF9fLFxuICAgICAgICBhZGQ6IGFkZCxcbiAgICAgICAgYWRkSW5kZXg6IGFkZEluZGV4LFxuICAgICAgICBhZGp1c3Q6IGFkanVzdCxcbiAgICAgICAgYWxsOiBhbGwsXG4gICAgICAgIGFsbFBhc3M6IGFsbFBhc3MsXG4gICAgICAgIGFsbFVuaXE6IGFsbFVuaXEsXG4gICAgICAgIGFsd2F5czogYWx3YXlzLFxuICAgICAgICBhbmQ6IGFuZCxcbiAgICAgICAgYW55OiBhbnksXG4gICAgICAgIGFueVBhc3M6IGFueVBhc3MsXG4gICAgICAgIGFwOiBhcCxcbiAgICAgICAgYXBlcnR1cmU6IGFwZXJ0dXJlLFxuICAgICAgICBhcHBlbmQ6IGFwcGVuZCxcbiAgICAgICAgYXBwbHk6IGFwcGx5LFxuICAgICAgICBhcHBseVNwZWM6IGFwcGx5U3BlYyxcbiAgICAgICAgYXNzb2M6IGFzc29jLFxuICAgICAgICBhc3NvY1BhdGg6IGFzc29jUGF0aCxcbiAgICAgICAgYmluYXJ5OiBiaW5hcnksXG4gICAgICAgIGJpbmQ6IGJpbmQsXG4gICAgICAgIGJvdGg6IGJvdGgsXG4gICAgICAgIGNhbGw6IGNhbGwsXG4gICAgICAgIGNoYWluOiBjaGFpbixcbiAgICAgICAgY2xhbXA6IGNsYW1wLFxuICAgICAgICBjbG9uZTogY2xvbmUsXG4gICAgICAgIGNvbXBhcmF0b3I6IGNvbXBhcmF0b3IsXG4gICAgICAgIGNvbXBsZW1lbnQ6IGNvbXBsZW1lbnQsXG4gICAgICAgIGNvbXBvc2U6IGNvbXBvc2UsXG4gICAgICAgIGNvbXBvc2VLOiBjb21wb3NlSyxcbiAgICAgICAgY29tcG9zZVA6IGNvbXBvc2VQLFxuICAgICAgICBjb25jYXQ6IGNvbmNhdCxcbiAgICAgICAgY29uZDogY29uZCxcbiAgICAgICAgY29uc3RydWN0OiBjb25zdHJ1Y3QsXG4gICAgICAgIGNvbnN0cnVjdE46IGNvbnN0cnVjdE4sXG4gICAgICAgIGNvbnRhaW5zOiBjb250YWlucyxcbiAgICAgICAgY29udmVyZ2U6IGNvbnZlcmdlLFxuICAgICAgICBjb3VudEJ5OiBjb3VudEJ5LFxuICAgICAgICBjdXJyeTogY3VycnksXG4gICAgICAgIGN1cnJ5TjogY3VycnlOLFxuICAgICAgICBkZWM6IGRlYyxcbiAgICAgICAgZGVmYXVsdFRvOiBkZWZhdWx0VG8sXG4gICAgICAgIGRpZmZlcmVuY2U6IGRpZmZlcmVuY2UsXG4gICAgICAgIGRpZmZlcmVuY2VXaXRoOiBkaWZmZXJlbmNlV2l0aCxcbiAgICAgICAgZGlzc29jOiBkaXNzb2MsXG4gICAgICAgIGRpc3NvY1BhdGg6IGRpc3NvY1BhdGgsXG4gICAgICAgIGRpdmlkZTogZGl2aWRlLFxuICAgICAgICBkcm9wOiBkcm9wLFxuICAgICAgICBkcm9wTGFzdDogZHJvcExhc3QsXG4gICAgICAgIGRyb3BMYXN0V2hpbGU6IGRyb3BMYXN0V2hpbGUsXG4gICAgICAgIGRyb3BSZXBlYXRzOiBkcm9wUmVwZWF0cyxcbiAgICAgICAgZHJvcFJlcGVhdHNXaXRoOiBkcm9wUmVwZWF0c1dpdGgsXG4gICAgICAgIGRyb3BXaGlsZTogZHJvcFdoaWxlLFxuICAgICAgICBlaXRoZXI6IGVpdGhlcixcbiAgICAgICAgZW1wdHk6IGVtcHR5LFxuICAgICAgICBlcUJ5OiBlcUJ5LFxuICAgICAgICBlcVByb3BzOiBlcVByb3BzLFxuICAgICAgICBlcXVhbHM6IGVxdWFscyxcbiAgICAgICAgZXZvbHZlOiBldm9sdmUsXG4gICAgICAgIGZpbHRlcjogZmlsdGVyLFxuICAgICAgICBmaW5kOiBmaW5kLFxuICAgICAgICBmaW5kSW5kZXg6IGZpbmRJbmRleCxcbiAgICAgICAgZmluZExhc3Q6IGZpbmRMYXN0LFxuICAgICAgICBmaW5kTGFzdEluZGV4OiBmaW5kTGFzdEluZGV4LFxuICAgICAgICBmbGF0dGVuOiBmbGF0dGVuLFxuICAgICAgICBmbGlwOiBmbGlwLFxuICAgICAgICBmb3JFYWNoOiBmb3JFYWNoLFxuICAgICAgICBmcm9tUGFpcnM6IGZyb21QYWlycyxcbiAgICAgICAgZ3JvdXBCeTogZ3JvdXBCeSxcbiAgICAgICAgZ3JvdXBXaXRoOiBncm91cFdpdGgsXG4gICAgICAgIGd0OiBndCxcbiAgICAgICAgZ3RlOiBndGUsXG4gICAgICAgIGhhczogaGFzLFxuICAgICAgICBoYXNJbjogaGFzSW4sXG4gICAgICAgIGhlYWQ6IGhlYWQsXG4gICAgICAgIGlkZW50aWNhbDogaWRlbnRpY2FsLFxuICAgICAgICBpZGVudGl0eTogaWRlbnRpdHksXG4gICAgICAgIGlmRWxzZTogaWZFbHNlLFxuICAgICAgICBpbmM6IGluYyxcbiAgICAgICAgaW5kZXhCeTogaW5kZXhCeSxcbiAgICAgICAgaW5kZXhPZjogaW5kZXhPZixcbiAgICAgICAgaW5pdDogaW5pdCxcbiAgICAgICAgaW5zZXJ0OiBpbnNlcnQsXG4gICAgICAgIGluc2VydEFsbDogaW5zZXJ0QWxsLFxuICAgICAgICBpbnRlcnNlY3Rpb246IGludGVyc2VjdGlvbixcbiAgICAgICAgaW50ZXJzZWN0aW9uV2l0aDogaW50ZXJzZWN0aW9uV2l0aCxcbiAgICAgICAgaW50ZXJzcGVyc2U6IGludGVyc3BlcnNlLFxuICAgICAgICBpbnRvOiBpbnRvLFxuICAgICAgICBpbnZlcnQ6IGludmVydCxcbiAgICAgICAgaW52ZXJ0T2JqOiBpbnZlcnRPYmosXG4gICAgICAgIGludm9rZXI6IGludm9rZXIsXG4gICAgICAgIGlzOiBpcyxcbiAgICAgICAgaXNBcnJheUxpa2U6IGlzQXJyYXlMaWtlLFxuICAgICAgICBpc0VtcHR5OiBpc0VtcHR5LFxuICAgICAgICBpc05pbDogaXNOaWwsXG4gICAgICAgIGpvaW46IGpvaW4sXG4gICAgICAgIGp1eHQ6IGp1eHQsXG4gICAgICAgIGtleXM6IGtleXMsXG4gICAgICAgIGtleXNJbjoga2V5c0luLFxuICAgICAgICBsYXN0OiBsYXN0LFxuICAgICAgICBsYXN0SW5kZXhPZjogbGFzdEluZGV4T2YsXG4gICAgICAgIGxlbmd0aDogbGVuZ3RoLFxuICAgICAgICBsZW5zOiBsZW5zLFxuICAgICAgICBsZW5zSW5kZXg6IGxlbnNJbmRleCxcbiAgICAgICAgbGVuc1BhdGg6IGxlbnNQYXRoLFxuICAgICAgICBsZW5zUHJvcDogbGVuc1Byb3AsXG4gICAgICAgIGxpZnQ6IGxpZnQsXG4gICAgICAgIGxpZnROOiBsaWZ0TixcbiAgICAgICAgbHQ6IGx0LFxuICAgICAgICBsdGU6IGx0ZSxcbiAgICAgICAgbWFwOiBtYXAsXG4gICAgICAgIG1hcEFjY3VtOiBtYXBBY2N1bSxcbiAgICAgICAgbWFwQWNjdW1SaWdodDogbWFwQWNjdW1SaWdodCxcbiAgICAgICAgbWFwT2JqSW5kZXhlZDogbWFwT2JqSW5kZXhlZCxcbiAgICAgICAgbWF0Y2g6IG1hdGNoLFxuICAgICAgICBtYXRoTW9kOiBtYXRoTW9kLFxuICAgICAgICBtYXg6IG1heCxcbiAgICAgICAgbWF4Qnk6IG1heEJ5LFxuICAgICAgICBtZWFuOiBtZWFuLFxuICAgICAgICBtZWRpYW46IG1lZGlhbixcbiAgICAgICAgbWVtb2l6ZTogbWVtb2l6ZSxcbiAgICAgICAgbWVyZ2U6IG1lcmdlLFxuICAgICAgICBtZXJnZUFsbDogbWVyZ2VBbGwsXG4gICAgICAgIG1lcmdlV2l0aDogbWVyZ2VXaXRoLFxuICAgICAgICBtZXJnZVdpdGhLZXk6IG1lcmdlV2l0aEtleSxcbiAgICAgICAgbWluOiBtaW4sXG4gICAgICAgIG1pbkJ5OiBtaW5CeSxcbiAgICAgICAgbW9kdWxvOiBtb2R1bG8sXG4gICAgICAgIG11bHRpcGx5OiBtdWx0aXBseSxcbiAgICAgICAgbkFyeTogbkFyeSxcbiAgICAgICAgbmVnYXRlOiBuZWdhdGUsXG4gICAgICAgIG5vbmU6IG5vbmUsXG4gICAgICAgIG5vdDogbm90LFxuICAgICAgICBudGg6IG50aCxcbiAgICAgICAgbnRoQXJnOiBudGhBcmcsXG4gICAgICAgIG9iak9mOiBvYmpPZixcbiAgICAgICAgb2Y6IG9mLFxuICAgICAgICBvbWl0OiBvbWl0LFxuICAgICAgICBvbmNlOiBvbmNlLFxuICAgICAgICBvcjogb3IsXG4gICAgICAgIG92ZXI6IG92ZXIsXG4gICAgICAgIHBhaXI6IHBhaXIsXG4gICAgICAgIHBhcnRpYWw6IHBhcnRpYWwsXG4gICAgICAgIHBhcnRpYWxSaWdodDogcGFydGlhbFJpZ2h0LFxuICAgICAgICBwYXJ0aXRpb246IHBhcnRpdGlvbixcbiAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgcGF0aEVxOiBwYXRoRXEsXG4gICAgICAgIHBhdGhPcjogcGF0aE9yLFxuICAgICAgICBwYXRoU2F0aXNmaWVzOiBwYXRoU2F0aXNmaWVzLFxuICAgICAgICBwaWNrOiBwaWNrLFxuICAgICAgICBwaWNrQWxsOiBwaWNrQWxsLFxuICAgICAgICBwaWNrQnk6IHBpY2tCeSxcbiAgICAgICAgcGlwZTogcGlwZSxcbiAgICAgICAgcGlwZUs6IHBpcGVLLFxuICAgICAgICBwaXBlUDogcGlwZVAsXG4gICAgICAgIHBsdWNrOiBwbHVjayxcbiAgICAgICAgcHJlcGVuZDogcHJlcGVuZCxcbiAgICAgICAgcHJvZHVjdDogcHJvZHVjdCxcbiAgICAgICAgcHJvamVjdDogcHJvamVjdCxcbiAgICAgICAgcHJvcDogcHJvcCxcbiAgICAgICAgcHJvcEVxOiBwcm9wRXEsXG4gICAgICAgIHByb3BJczogcHJvcElzLFxuICAgICAgICBwcm9wT3I6IHByb3BPcixcbiAgICAgICAgcHJvcFNhdGlzZmllczogcHJvcFNhdGlzZmllcyxcbiAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICByYW5nZTogcmFuZ2UsXG4gICAgICAgIHJlZHVjZTogcmVkdWNlLFxuICAgICAgICByZWR1Y2VCeTogcmVkdWNlQnksXG4gICAgICAgIHJlZHVjZVJpZ2h0OiByZWR1Y2VSaWdodCxcbiAgICAgICAgcmVkdWNlZDogcmVkdWNlZCxcbiAgICAgICAgcmVqZWN0OiByZWplY3QsXG4gICAgICAgIHJlbW92ZTogcmVtb3ZlLFxuICAgICAgICByZXBlYXQ6IHJlcGVhdCxcbiAgICAgICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICAgICAgcmV2ZXJzZTogcmV2ZXJzZSxcbiAgICAgICAgc2Nhbjogc2NhbixcbiAgICAgICAgc2VxdWVuY2U6IHNlcXVlbmNlLFxuICAgICAgICBzZXQ6IHNldCxcbiAgICAgICAgc2xpY2U6IHNsaWNlLFxuICAgICAgICBzb3J0OiBzb3J0LFxuICAgICAgICBzb3J0Qnk6IHNvcnRCeSxcbiAgICAgICAgc3BsaXQ6IHNwbGl0LFxuICAgICAgICBzcGxpdEF0OiBzcGxpdEF0LFxuICAgICAgICBzcGxpdEV2ZXJ5OiBzcGxpdEV2ZXJ5LFxuICAgICAgICBzcGxpdFdoZW46IHNwbGl0V2hlbixcbiAgICAgICAgc3VidHJhY3Q6IHN1YnRyYWN0LFxuICAgICAgICBzdW06IHN1bSxcbiAgICAgICAgc3ltbWV0cmljRGlmZmVyZW5jZTogc3ltbWV0cmljRGlmZmVyZW5jZSxcbiAgICAgICAgc3ltbWV0cmljRGlmZmVyZW5jZVdpdGg6IHN5bW1ldHJpY0RpZmZlcmVuY2VXaXRoLFxuICAgICAgICB0YWlsOiB0YWlsLFxuICAgICAgICB0YWtlOiB0YWtlLFxuICAgICAgICB0YWtlTGFzdDogdGFrZUxhc3QsXG4gICAgICAgIHRha2VMYXN0V2hpbGU6IHRha2VMYXN0V2hpbGUsXG4gICAgICAgIHRha2VXaGlsZTogdGFrZVdoaWxlLFxuICAgICAgICB0YXA6IHRhcCxcbiAgICAgICAgdGVzdDogdGVzdCxcbiAgICAgICAgdGltZXM6IHRpbWVzLFxuICAgICAgICB0b0xvd2VyOiB0b0xvd2VyLFxuICAgICAgICB0b1BhaXJzOiB0b1BhaXJzLFxuICAgICAgICB0b1BhaXJzSW46IHRvUGFpcnNJbixcbiAgICAgICAgdG9TdHJpbmc6IHRvU3RyaW5nLFxuICAgICAgICB0b1VwcGVyOiB0b1VwcGVyLFxuICAgICAgICB0cmFuc2R1Y2U6IHRyYW5zZHVjZSxcbiAgICAgICAgdHJhbnNwb3NlOiB0cmFuc3Bvc2UsXG4gICAgICAgIHRyYXZlcnNlOiB0cmF2ZXJzZSxcbiAgICAgICAgdHJpbTogdHJpbSxcbiAgICAgICAgdHJ5Q2F0Y2g6IHRyeUNhdGNoLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICB1bmFwcGx5OiB1bmFwcGx5LFxuICAgICAgICB1bmFyeTogdW5hcnksXG4gICAgICAgIHVuY3VycnlOOiB1bmN1cnJ5TixcbiAgICAgICAgdW5mb2xkOiB1bmZvbGQsXG4gICAgICAgIHVuaW9uOiB1bmlvbixcbiAgICAgICAgdW5pb25XaXRoOiB1bmlvbldpdGgsXG4gICAgICAgIHVuaXE6IHVuaXEsXG4gICAgICAgIHVuaXFCeTogdW5pcUJ5LFxuICAgICAgICB1bmlxV2l0aDogdW5pcVdpdGgsXG4gICAgICAgIHVubGVzczogdW5sZXNzLFxuICAgICAgICB1bm5lc3Q6IHVubmVzdCxcbiAgICAgICAgdW50aWw6IHVudGlsLFxuICAgICAgICB1cGRhdGU6IHVwZGF0ZSxcbiAgICAgICAgdXNlV2l0aDogdXNlV2l0aCxcbiAgICAgICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgICAgIHZhbHVlc0luOiB2YWx1ZXNJbixcbiAgICAgICAgdmlldzogdmlldyxcbiAgICAgICAgd2hlbjogd2hlbixcbiAgICAgICAgd2hlcmU6IHdoZXJlLFxuICAgICAgICB3aGVyZUVxOiB3aGVyZUVxLFxuICAgICAgICB3aXRob3V0OiB3aXRob3V0LFxuICAgICAgICB3cmFwOiB3cmFwLFxuICAgICAgICB4cHJvZDogeHByb2QsXG4gICAgICAgIHppcDogemlwLFxuICAgICAgICB6aXBPYmo6IHppcE9iaixcbiAgICAgICAgemlwV2l0aDogemlwV2l0aFxuICAgIH07XG4gIC8qIGVzbGludC1lbnYgYW1kICovXG5cbiAgLyogVEVTVF9FTlRSWV9QT0lOVCAqL1xuXG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFI7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gUjsgfSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5SID0gUjtcbiAgfVxuXG59LmNhbGwodGhpcykpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmFtZGEvZGlzdC9yYW1kYS5qc1xuICoqIG1vZHVsZSBpZCA9IDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar curryN = __webpack_require__(3);\n\n// Utility\nfunction isFunction(obj) {\n  return !!(obj && obj.constructor && obj.call && obj.apply);\n}\nfunction trueFn() { return true; }\n\n// Globals\nvar toUpdate = [];\nvar inStream;\nvar order = [];\nvar orderNextIdx = -1;\nvar flushing = false;\n\n/** @namespace */\nvar flyd = {}\n\n// /////////////////////////// API ///////////////////////////////// //\n\n/**\n * Creates a new stream\n *\n * __Signature__: `a -> Stream a`\n *\n * @name flyd.stream\n * @param {*} initialValue - (Optional) the initial value of the stream\n * @return {stream} the stream\n *\n * @example\n * var n = flyd.stream(1); // Stream with initial value `1`\n * var s = flyd.stream(); // Stream with no initial value\n */\nflyd.stream = function(initialValue) {\n  var endStream = createDependentStream([], trueFn);\n  var s = createStream();\n  s.end = endStream;\n  s.fnArgs = [];\n  endStream.listeners.push(s);\n  if (arguments.length > 0) s(initialValue);\n  return s;\n}\n\n/**\n * Create a new dependent stream\n *\n * __Signature__: `(...Stream * -> Stream b -> b) -> [Stream *] -> Stream b`\n *\n * @name flyd.combine\n * @param {Function} fn - the function used to combine the streams\n * @param {Array<stream>} dependencies - the streams that this one depends on\n * @return {stream} the dependent stream\n *\n * @example\n * var n1 = flyd.stream(0);\n * var n2 = flyd.stream(0);\n * var max = flyd.combine(function(n1, n2, self, changed) {\n *   return n1() > n2() ? n1() : n2();\n * }, [n1, n2]);\n */\nflyd.combine = curryN(2, combine);\nfunction combine(fn, streams) {\n  var i, s, deps, depEndStreams;\n  var endStream = createDependentStream([], trueFn);\n  deps = []; depEndStreams = [];\n  for (i = 0; i < streams.length; ++i) {\n    if (streams[i] !== undefined) {\n      deps.push(streams[i]);\n      if (streams[i].end !== undefined) depEndStreams.push(streams[i].end);\n    }\n  }\n  s = createDependentStream(deps, fn);\n  s.depsChanged = [];\n  s.fnArgs = s.deps.concat([s, s.depsChanged]);\n  s.end = endStream;\n  endStream.listeners.push(s);\n  addListeners(depEndStreams, endStream);\n  endStream.deps = depEndStreams;\n  updateStream(s);\n  return s;\n}\n\n/**\n * Returns `true` if the supplied argument is a Flyd stream and `false` otherwise.\n *\n * __Signature__: `* -> Boolean`\n *\n * @name flyd.isStream\n * @param {*} value - the value to test\n * @return {Boolean} `true` if is a Flyd streamn, `false` otherwise\n *\n * @example\n * var s = flyd.stream(1);\n * var n = 1;\n * flyd.isStream(s); //=> true\n * flyd.isStream(n); //=> false\n */\nflyd.isStream = function(stream) {\n  return isFunction(stream) && 'hasVal' in stream;\n}\n\n/**\n * Invokes the body (the function to calculate the value) of a dependent stream\n *\n * By default the body of a dependent stream is only called when all the streams\n * upon which it depends has a value. `immediate` can circumvent this behaviour.\n * It immediately invokes the body of a dependent stream.\n *\n * __Signature__: `Stream a -> Stream a`\n *\n * @name flyd.immediate\n * @param {stream} stream - the dependent stream\n * @return {stream} the same stream\n *\n * @example\n * var s = flyd.stream();\n * var hasItems = flyd.immediate(flyd.combine(function(s) {\n *   return s() !== undefined && s().length > 0;\n * }, [s]);\n * console.log(hasItems()); // logs `false`. Had `immediate` not been\n *                          // used `hasItems()` would've returned `undefined`\n * s([1]);\n * console.log(hasItems()); // logs `true`.\n * s([]);\n * console.log(hasItems()); // logs `false`.\n */\nflyd.immediate = function(s) {\n  if (s.depsMet === false) {\n    s.depsMet = true;\n    updateStream(s);\n  }\n  return s;\n}\n\n/**\n * Changes which `endsStream` should trigger the ending of `s`.\n *\n * __Signature__: `Stream a -> Stream b -> Stream b`\n *\n * @name flyd.endsOn\n * @param {stream} endStream - the stream to trigger the ending\n * @param {stream} stream - the stream to be ended by the endStream\n * @param {stream} the stream modified to be ended by endStream\n *\n * @example\n * var n = flyd.stream(1);\n * var killer = flyd.stream();\n * // `double` ends when `n` ends or when `killer` emits any value\n * var double = flyd.endsOn(flyd.merge(n.end, killer), flyd.combine(function(n) {\n *   return 2 * n();\n * }, [n]);\n*/\nflyd.endsOn = function(endS, s) {\n  detachDeps(s.end);\n  endS.listeners.push(s.end);\n  s.end.deps.push(endS);\n  return s;\n}\n\n/**\n * Map a stream\n *\n * Returns a new stream consisting of every value from `s` passed through\n * `fn`. I.e. `map` creates a new stream that listens to `s` and\n * applies `fn` to every new value.\n * __Signature__: `(a -> result) -> Stream a -> Stream result`\n *\n * @name flyd.map\n * @param {Function} fn - the function that produces the elements of the new stream\n * @param {stream} stream - the stream to map\n * @return {stream} a new stream with the mapped values\n *\n * @example\n * var numbers = flyd.stream(0);\n * var squaredNumbers = flyd.map(function(n) { return n*n; }, numbers);\n */\n// Library functions use self callback to accept (null, undefined) update triggers.\nflyd.map = curryN(2, function(f, s) {\n  return combine(function(s, self) { self(f(s.val)); }, [s]);\n})\n\n/**\n * Listen to stream events\n *\n * Similar to `map` except that the returned stream is empty. Use `on` for doing\n * side effects in reaction to stream changes. Use the returned stream only if you\n * need to manually end it.\n *\n * __Signature__: `(a -> result) -> Stream a -> Stream undefined`\n *\n * @name flyd.on\n * @param {Function} cb - the callback\n * @param {stream} stream - the stream\n * @return {stream} an empty stream (can be ended)\n */\nflyd.on = curryN(2, function(f, s) {\n  return combine(function(s) { f(s.val); }, [s]);\n})\n\n/**\n * Creates a new stream with the results of calling the function on every incoming\n * stream with and accumulator and the incoming value.\n *\n * __Signature__: `(a -> b -> a) -> a -> Stream b -> Stream a`\n *\n * @name flyd.scan\n * @param {Function} fn - the function to call\n * @param {*} val - the initial value of the accumulator\n * @param {stream} stream - the stream source\n * @return {stream} the new stream\n *\n * @example\n * var numbers = flyd.stream();\n * var sum = flyd.scan(function(sum, n) { return sum+n; }, 0, numbers);\n * numbers(2)(3)(5);\n * sum(); // 10\n */\nflyd.scan = curryN(3, function(f, acc, s) {\n  var ns = combine(function(s, self) {\n    self(acc = f(acc, s.val));\n  }, [s]);\n  if (!ns.hasVal) ns(acc);\n  return ns;\n});\n\n/**\n * Creates a new stream down which all values from both `stream1` and `stream2`\n * will be sent.\n *\n * __Signature__: `Stream a -> Stream a -> Stream a`\n *\n * @name flyd.merge\n * @param {stream} source1 - one stream to be merged\n * @param {stream} source2 - the other stream to be merged\n * @return {stream} a stream with the values from both sources\n *\n * @example\n * var btn1Clicks = flyd.stream();\n * button1Elm.addEventListener(btn1Clicks);\n * var btn2Clicks = flyd.stream();\n * button2Elm.addEventListener(btn2Clicks);\n * var allClicks = flyd.merge(btn1Clicks, btn2Clicks);\n */\nflyd.merge = curryN(2, function(s1, s2) {\n  var s = flyd.immediate(combine(function(s1, s2, self, changed) {\n    if (changed[0]) {\n      self(changed[0]());\n    } else if (s1.hasVal) {\n      self(s1.val);\n    } else if (s2.hasVal) {\n      self(s2.val);\n    }\n  }, [s1, s2]));\n  flyd.endsOn(combine(function() {\n    return true;\n  }, [s1.end, s2.end]), s);\n  return s;\n});\n\n/**\n * Creates a new stream resulting from applying `transducer` to `stream`.\n *\n * __Signature__: `Transducer -> Stream a -> Stream b`\n *\n * @name flyd.transduce\n * @param {Transducer} xform - the transducer transformation\n * @param {stream} source - the stream source\n * @return {stream} the new stream\n *\n * @example\n * var t = require('transducers.js');\n *\n * var results = [];\n * var s1 = flyd.stream();\n * var tx = t.compose(t.map(function(x) { return x * 2; }), t.dedupe());\n * var s2 = flyd.transduce(tx, s1);\n * flyd.combine(function(s2) { results.push(s2()); }, [s2]);\n * s1(1)(1)(2)(3)(3)(3)(4);\n * results; // => [2, 4, 6, 8]\n */\nflyd.transduce = curryN(2, function(xform, source) {\n  xform = xform(new StreamTransformer());\n  return combine(function(source, self) {\n    var res = xform['@@transducer/step'](undefined, source.val);\n    if (res && res['@@transducer/reduced'] === true) {\n      self.end(true);\n      return res['@@transducer/value'];\n    } else {\n      return res;\n    }\n  }, [source]);\n});\n\n/**\n * Returns `fn` curried to `n`. Use this function to curry functions exposed by\n * modules for Flyd.\n *\n * @name flyd.curryN\n * @function\n * @param {Integer} arity - the function arity\n * @param {Function} fn - the function to curry\n * @return {Function} the curried function\n *\n * @example\n * function add(x, y) { return x + y; };\n * var a = flyd.curryN(2, add);\n * a(2)(4) // => 6\n */\nflyd.curryN = curryN\n\n/**\n * Returns a new stream identical to the original except every\n * value will be passed through `f`.\n *\n * _Note:_ This function is included in order to support the fantasy land\n * specification.\n *\n * __Signature__: Called bound to `Stream a`: `(a -> b) -> Stream b`\n *\n * @name stream.map\n * @param {Function} function - the function to apply\n * @return {stream} a new stream with the values mapped\n *\n * @example\n * var numbers = flyd.stream(0);\n * var squaredNumbers = numbers.map(function(n) { return n*n; });\n */\nfunction boundMap(f) { return flyd.map(f, this); }\n\n/**\n * Returns a new stream which is the result of applying the\n * functions from `this` stream to the values in `stream` parameter.\n *\n * `this` stream must be a stream of functions.\n *\n * _Note:_ This function is included in order to support the fantasy land\n * specification.\n *\n * __Signature__: Called bound to `Stream (a -> b)`: `a -> Stream b`\n *\n * @name stream.ap\n * @param {stream} stream - the values stream\n * @return {stream} a new stram with the functions applied to values\n *\n * @example\n * var add = flyd.curryN(2, function(x, y) { return x + y; });\n * var numbers1 = flyd.stream();\n * var numbers2 = flyd.stream();\n * var addToNumbers1 = flyd.map(add, numbers1);\n * var added = addToNumbers1.ap(numbers2);\n */\nfunction ap(s2) {\n  var s1 = this;\n  return combine(function(s1, s2, self) { self(s1.val(s2.val)); }, [s1, s2]);\n}\n\n/**\n * Get a human readable view of a stream\n * @name stream.toString\n * @return {String} the stream string representation\n */\nfunction streamToString() {\n  return 'stream(' + this.val + ')';\n}\n\n/**\n * @name stream.end\n * @memberof stream\n * A stream that emits `true` when the stream ends. If `true` is pushed down the\n * stream the parent stream ends.\n */\n\n/**\n * @name stream.of\n * @function\n * @memberof stream\n * Returns a new stream with `value` as its initial value. It is identical to\n * calling `flyd.stream` with one argument.\n *\n * __Signature__: Called bound to `Stream (a)`: `b -> Stream b`\n *\n * @param {*} value - the initial value\n * @return {stream} the new stream\n *\n * @example\n * var n = flyd.stream(1);\n * var m = n.of(1);\n */\n\n// /////////////////////////// PRIVATE ///////////////////////////////// //\n/**\n * @private\n * Create a stream with no dependencies and no value\n * @return {Function} a flyd stream\n */\nfunction createStream() {\n  function s(n) {\n    if (arguments.length === 0) return s.val\n    updateStreamValue(s, n)\n    return s\n  }\n  s.hasVal = false;\n  s.val = undefined;\n  s.vals = [];\n  s.listeners = [];\n  s.queued = false;\n  s.end = undefined;\n  s.map = boundMap;\n  s.ap = ap;\n  s.of = flyd.stream;\n  s.toString = streamToString;\n  return s;\n}\n\n/**\n * @private\n * Create a dependent stream\n * @param {Array<stream>} dependencies - an array of the streams\n * @param {Function} fn - the function used to calculate the new stream value\n * from the dependencies\n * @return {stream} the created stream\n */\nfunction createDependentStream(deps, fn) {\n  var s = createStream();\n  s.fn = fn;\n  s.deps = deps;\n  s.depsMet = false;\n  s.depsChanged = deps.length > 0 ? [] : undefined;\n  s.shouldUpdate = false;\n  addListeners(deps, s);\n  return s;\n}\n\n/**\n * @private\n * Check if all the dependencies have values\n * @param {stream} stream - the stream to check depencencies from\n * @return {Boolean} `true` if all dependencies have vales, `false` otherwise\n */\nfunction initialDepsNotMet(stream) {\n  stream.depsMet = stream.deps.every(function(s) {\n    return s.hasVal;\n  });\n  return !stream.depsMet;\n}\n\n/**\n * @private\n * Update a dependent stream using its dependencies in an atomic way\n * @param {stream} stream - the stream to update\n */\nfunction updateStream(s) {\n  if ((s.depsMet !== true && initialDepsNotMet(s)) ||\n      (s.end !== undefined && s.end.val === true)) return;\n  if (inStream !== undefined) {\n    toUpdate.push(s);\n    return;\n  }\n  inStream = s;\n  if (s.depsChanged) s.fnArgs[s.fnArgs.length - 1] = s.depsChanged;\n  var returnVal = s.fn.apply(s.fn, s.fnArgs);\n  if (returnVal !== undefined) {\n    s(returnVal);\n  }\n  inStream = undefined;\n  if (s.depsChanged !== undefined) s.depsChanged = [];\n  s.shouldUpdate = false;\n  if (flushing === false) flushUpdate();\n}\n\n/**\n * @private\n * Update the dependencies of a stream\n * @param {stream} stream\n */\nfunction updateDeps(s) {\n  var i, o, list\n  var listeners = s.listeners;\n  for (i = 0; i < listeners.length; ++i) {\n    list = listeners[i];\n    if (list.end === s) {\n      endStream(list);\n    } else {\n      if (list.depsChanged !== undefined) list.depsChanged.push(s);\n      list.shouldUpdate = true;\n      findDeps(list);\n    }\n  }\n  for (; orderNextIdx >= 0; --orderNextIdx) {\n    o = order[orderNextIdx];\n    if (o.shouldUpdate === true) updateStream(o);\n    o.queued = false;\n  }\n}\n\n/**\n * @private\n * Add stream dependencies to the global `order` queue.\n * @param {stream} stream\n * @see updateDeps\n */\nfunction findDeps(s) {\n  var i\n  var listeners = s.listeners;\n  if (s.queued === false) {\n    s.queued = true;\n    for (i = 0; i < listeners.length; ++i) {\n      findDeps(listeners[i]);\n    }\n    order[++orderNextIdx] = s;\n  }\n}\n\n/**\n * @private\n */\nfunction flushUpdate() {\n  flushing = true;\n  while (toUpdate.length > 0) {\n    var s = toUpdate.shift();\n    if (s.vals.length > 0) s.val = s.vals.shift();\n    updateDeps(s);\n  }\n  flushing = false;\n}\n\n/**\n * @private\n * Push down a value into a stream\n * @param {stream} stream\n * @param {*} value\n */\nfunction updateStreamValue(s, n) {\n  if (n !== undefined && n !== null && isFunction(n.then)) {\n    n.then(s);\n    return;\n  }\n  s.val = n;\n  s.hasVal = true;\n  if (inStream === undefined) {\n    flushing = true;\n    updateDeps(s);\n    if (toUpdate.length > 0) flushUpdate(); else flushing = false;\n  } else if (inStream === s) {\n    markListeners(s, s.listeners);\n  } else {\n    s.vals.push(n);\n    toUpdate.push(s);\n  }\n}\n\n/**\n * @private\n */\nfunction markListeners(s, lists) {\n  var i, list;\n  for (i = 0; i < lists.length; ++i) {\n    list = lists[i];\n    if (list.end !== s) {\n      if (list.depsChanged !== undefined) {\n        list.depsChanged.push(s);\n      }\n      list.shouldUpdate = true;\n    } else {\n      endStream(list);\n    }\n  }\n}\n\n/**\n * @private\n * Add dependencies to a stream\n * @param {Array<stream>} dependencies\n * @param {stream} stream\n */\nfunction addListeners(deps, s) {\n  for (var i = 0; i < deps.length; ++i) {\n    deps[i].listeners.push(s);\n  }\n}\n\n/**\n * @private\n * Removes an stream from a dependency array\n * @param {stream} stream\n * @param {Array<stream>} dependencies\n */\nfunction removeListener(s, listeners) {\n  var idx = listeners.indexOf(s);\n  listeners[idx] = listeners[listeners.length - 1];\n  listeners.length--;\n}\n\n/**\n * @private\n * Detach a stream from its dependencies\n * @param {stream} stream\n */\nfunction detachDeps(s) {\n  for (var i = 0; i < s.deps.length; ++i) {\n    removeListener(s, s.deps[i].listeners);\n  }\n  s.deps.length = 0;\n}\n\n/**\n * @private\n * Ends a stream\n */\nfunction endStream(s) {\n  if (s.deps !== undefined) detachDeps(s);\n  if (s.end !== undefined) detachDeps(s.end);\n}\n\n/**\n * @private\n * transducer stream transformer\n */\nfunction StreamTransformer() { }\nStreamTransformer.prototype['@@transducer/init'] = function() { };\nStreamTransformer.prototype['@@transducer/result'] = function() { };\nStreamTransformer.prototype['@@transducer/step'] = function(s, v) { return v; };\n\nmodule.exports = flyd;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2ZseWQvbGliL2luZGV4LmpzPzJhMjkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsYUFBYTs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLGNBQWM7QUFDekIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLCtEQUErRDtBQUMvRCxpRUFBaUU7QUFDakUsbUVBQW1FLFVBQVU7O0FBRTdFIiwiZmlsZSI6IjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBjdXJyeU4gPSByZXF1aXJlKCdyYW1kYS9zcmMvY3VycnlOJyk7XG5cbi8vIFV0aWxpdHlcbmZ1bmN0aW9uIGlzRnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiAhIShvYmogJiYgb2JqLmNvbnN0cnVjdG9yICYmIG9iai5jYWxsICYmIG9iai5hcHBseSk7XG59XG5mdW5jdGlvbiB0cnVlRm4oKSB7IHJldHVybiB0cnVlOyB9XG5cbi8vIEdsb2JhbHNcbnZhciB0b1VwZGF0ZSA9IFtdO1xudmFyIGluU3RyZWFtO1xudmFyIG9yZGVyID0gW107XG52YXIgb3JkZXJOZXh0SWR4ID0gLTE7XG52YXIgZmx1c2hpbmcgPSBmYWxzZTtcblxuLyoqIEBuYW1lc3BhY2UgKi9cbnZhciBmbHlkID0ge31cblxuLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vIEFQSSAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8gLy9cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHN0cmVhbVxuICpcbiAqIF9fU2lnbmF0dXJlX186IGBhIC0+IFN0cmVhbSBhYFxuICpcbiAqIEBuYW1lIGZseWQuc3RyZWFtXG4gKiBAcGFyYW0geyp9IGluaXRpYWxWYWx1ZSAtIChPcHRpb25hbCkgdGhlIGluaXRpYWwgdmFsdWUgb2YgdGhlIHN0cmVhbVxuICogQHJldHVybiB7c3RyZWFtfSB0aGUgc3RyZWFtXG4gKlxuICogQGV4YW1wbGVcbiAqIHZhciBuID0gZmx5ZC5zdHJlYW0oMSk7IC8vIFN0cmVhbSB3aXRoIGluaXRpYWwgdmFsdWUgYDFgXG4gKiB2YXIgcyA9IGZseWQuc3RyZWFtKCk7IC8vIFN0cmVhbSB3aXRoIG5vIGluaXRpYWwgdmFsdWVcbiAqL1xuZmx5ZC5zdHJlYW0gPSBmdW5jdGlvbihpbml0aWFsVmFsdWUpIHtcbiAgdmFyIGVuZFN0cmVhbSA9IGNyZWF0ZURlcGVuZGVudFN0cmVhbShbXSwgdHJ1ZUZuKTtcbiAgdmFyIHMgPSBjcmVhdGVTdHJlYW0oKTtcbiAgcy5lbmQgPSBlbmRTdHJlYW07XG4gIHMuZm5BcmdzID0gW107XG4gIGVuZFN0cmVhbS5saXN0ZW5lcnMucHVzaChzKTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSBzKGluaXRpYWxWYWx1ZSk7XG4gIHJldHVybiBzO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBkZXBlbmRlbnQgc3RyZWFtXG4gKlxuICogX19TaWduYXR1cmVfXzogYCguLi5TdHJlYW0gKiAtPiBTdHJlYW0gYiAtPiBiKSAtPiBbU3RyZWFtICpdIC0+IFN0cmVhbSBiYFxuICpcbiAqIEBuYW1lIGZseWQuY29tYmluZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSB0aGUgZnVuY3Rpb24gdXNlZCB0byBjb21iaW5lIHRoZSBzdHJlYW1zXG4gKiBAcGFyYW0ge0FycmF5PHN0cmVhbT59IGRlcGVuZGVuY2llcyAtIHRoZSBzdHJlYW1zIHRoYXQgdGhpcyBvbmUgZGVwZW5kcyBvblxuICogQHJldHVybiB7c3RyZWFtfSB0aGUgZGVwZW5kZW50IHN0cmVhbVxuICpcbiAqIEBleGFtcGxlXG4gKiB2YXIgbjEgPSBmbHlkLnN0cmVhbSgwKTtcbiAqIHZhciBuMiA9IGZseWQuc3RyZWFtKDApO1xuICogdmFyIG1heCA9IGZseWQuY29tYmluZShmdW5jdGlvbihuMSwgbjIsIHNlbGYsIGNoYW5nZWQpIHtcbiAqICAgcmV0dXJuIG4xKCkgPiBuMigpID8gbjEoKSA6IG4yKCk7XG4gKiB9LCBbbjEsIG4yXSk7XG4gKi9cbmZseWQuY29tYmluZSA9IGN1cnJ5TigyLCBjb21iaW5lKTtcbmZ1bmN0aW9uIGNvbWJpbmUoZm4sIHN0cmVhbXMpIHtcbiAgdmFyIGksIHMsIGRlcHMsIGRlcEVuZFN0cmVhbXM7XG4gIHZhciBlbmRTdHJlYW0gPSBjcmVhdGVEZXBlbmRlbnRTdHJlYW0oW10sIHRydWVGbik7XG4gIGRlcHMgPSBbXTsgZGVwRW5kU3RyZWFtcyA9IFtdO1xuICBmb3IgKGkgPSAwOyBpIDwgc3RyZWFtcy5sZW5ndGg7ICsraSkge1xuICAgIGlmIChzdHJlYW1zW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGRlcHMucHVzaChzdHJlYW1zW2ldKTtcbiAgICAgIGlmIChzdHJlYW1zW2ldLmVuZCAhPT0gdW5kZWZpbmVkKSBkZXBFbmRTdHJlYW1zLnB1c2goc3RyZWFtc1tpXS5lbmQpO1xuICAgIH1cbiAgfVxuICBzID0gY3JlYXRlRGVwZW5kZW50U3RyZWFtKGRlcHMsIGZuKTtcbiAgcy5kZXBzQ2hhbmdlZCA9IFtdO1xuICBzLmZuQXJncyA9IHMuZGVwcy5jb25jYXQoW3MsIHMuZGVwc0NoYW5nZWRdKTtcbiAgcy5lbmQgPSBlbmRTdHJlYW07XG4gIGVuZFN0cmVhbS5saXN0ZW5lcnMucHVzaChzKTtcbiAgYWRkTGlzdGVuZXJzKGRlcEVuZFN0cmVhbXMsIGVuZFN0cmVhbSk7XG4gIGVuZFN0cmVhbS5kZXBzID0gZGVwRW5kU3RyZWFtcztcbiAgdXBkYXRlU3RyZWFtKHMpO1xuICByZXR1cm4gcztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgc3VwcGxpZWQgYXJndW1lbnQgaXMgYSBGbHlkIHN0cmVhbSBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXG4gKlxuICogX19TaWduYXR1cmVfXzogYCogLT4gQm9vbGVhbmBcbiAqXG4gKiBAbmFtZSBmbHlkLmlzU3RyZWFtXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gdGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiBpcyBhIEZseWQgc3RyZWFtbiwgYGZhbHNlYCBvdGhlcndpc2VcbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIHMgPSBmbHlkLnN0cmVhbSgxKTtcbiAqIHZhciBuID0gMTtcbiAqIGZseWQuaXNTdHJlYW0ocyk7IC8vPT4gdHJ1ZVxuICogZmx5ZC5pc1N0cmVhbShuKTsgLy89PiBmYWxzZVxuICovXG5mbHlkLmlzU3RyZWFtID0gZnVuY3Rpb24oc3RyZWFtKSB7XG4gIHJldHVybiBpc0Z1bmN0aW9uKHN0cmVhbSkgJiYgJ2hhc1ZhbCcgaW4gc3RyZWFtO1xufVxuXG4vKipcbiAqIEludm9rZXMgdGhlIGJvZHkgKHRoZSBmdW5jdGlvbiB0byBjYWxjdWxhdGUgdGhlIHZhbHVlKSBvZiBhIGRlcGVuZGVudCBzdHJlYW1cbiAqXG4gKiBCeSBkZWZhdWx0IHRoZSBib2R5IG9mIGEgZGVwZW5kZW50IHN0cmVhbSBpcyBvbmx5IGNhbGxlZCB3aGVuIGFsbCB0aGUgc3RyZWFtc1xuICogdXBvbiB3aGljaCBpdCBkZXBlbmRzIGhhcyBhIHZhbHVlLiBgaW1tZWRpYXRlYCBjYW4gY2lyY3VtdmVudCB0aGlzIGJlaGF2aW91ci5cbiAqIEl0IGltbWVkaWF0ZWx5IGludm9rZXMgdGhlIGJvZHkgb2YgYSBkZXBlbmRlbnQgc3RyZWFtLlxuICpcbiAqIF9fU2lnbmF0dXJlX186IGBTdHJlYW0gYSAtPiBTdHJlYW0gYWBcbiAqXG4gKiBAbmFtZSBmbHlkLmltbWVkaWF0ZVxuICogQHBhcmFtIHtzdHJlYW19IHN0cmVhbSAtIHRoZSBkZXBlbmRlbnQgc3RyZWFtXG4gKiBAcmV0dXJuIHtzdHJlYW19IHRoZSBzYW1lIHN0cmVhbVxuICpcbiAqIEBleGFtcGxlXG4gKiB2YXIgcyA9IGZseWQuc3RyZWFtKCk7XG4gKiB2YXIgaGFzSXRlbXMgPSBmbHlkLmltbWVkaWF0ZShmbHlkLmNvbWJpbmUoZnVuY3Rpb24ocykge1xuICogICByZXR1cm4gcygpICE9PSB1bmRlZmluZWQgJiYgcygpLmxlbmd0aCA+IDA7XG4gKiB9LCBbc10pO1xuICogY29uc29sZS5sb2coaGFzSXRlbXMoKSk7IC8vIGxvZ3MgYGZhbHNlYC4gSGFkIGBpbW1lZGlhdGVgIG5vdCBiZWVuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXNlZCBgaGFzSXRlbXMoKWAgd291bGQndmUgcmV0dXJuZWQgYHVuZGVmaW5lZGBcbiAqIHMoWzFdKTtcbiAqIGNvbnNvbGUubG9nKGhhc0l0ZW1zKCkpOyAvLyBsb2dzIGB0cnVlYC5cbiAqIHMoW10pO1xuICogY29uc29sZS5sb2coaGFzSXRlbXMoKSk7IC8vIGxvZ3MgYGZhbHNlYC5cbiAqL1xuZmx5ZC5pbW1lZGlhdGUgPSBmdW5jdGlvbihzKSB7XG4gIGlmIChzLmRlcHNNZXQgPT09IGZhbHNlKSB7XG4gICAgcy5kZXBzTWV0ID0gdHJ1ZTtcbiAgICB1cGRhdGVTdHJlYW0ocyk7XG4gIH1cbiAgcmV0dXJuIHM7XG59XG5cbi8qKlxuICogQ2hhbmdlcyB3aGljaCBgZW5kc1N0cmVhbWAgc2hvdWxkIHRyaWdnZXIgdGhlIGVuZGluZyBvZiBgc2AuXG4gKlxuICogX19TaWduYXR1cmVfXzogYFN0cmVhbSBhIC0+IFN0cmVhbSBiIC0+IFN0cmVhbSBiYFxuICpcbiAqIEBuYW1lIGZseWQuZW5kc09uXG4gKiBAcGFyYW0ge3N0cmVhbX0gZW5kU3RyZWFtIC0gdGhlIHN0cmVhbSB0byB0cmlnZ2VyIHRoZSBlbmRpbmdcbiAqIEBwYXJhbSB7c3RyZWFtfSBzdHJlYW0gLSB0aGUgc3RyZWFtIHRvIGJlIGVuZGVkIGJ5IHRoZSBlbmRTdHJlYW1cbiAqIEBwYXJhbSB7c3RyZWFtfSB0aGUgc3RyZWFtIG1vZGlmaWVkIHRvIGJlIGVuZGVkIGJ5IGVuZFN0cmVhbVxuICpcbiAqIEBleGFtcGxlXG4gKiB2YXIgbiA9IGZseWQuc3RyZWFtKDEpO1xuICogdmFyIGtpbGxlciA9IGZseWQuc3RyZWFtKCk7XG4gKiAvLyBgZG91YmxlYCBlbmRzIHdoZW4gYG5gIGVuZHMgb3Igd2hlbiBga2lsbGVyYCBlbWl0cyBhbnkgdmFsdWVcbiAqIHZhciBkb3VibGUgPSBmbHlkLmVuZHNPbihmbHlkLm1lcmdlKG4uZW5kLCBraWxsZXIpLCBmbHlkLmNvbWJpbmUoZnVuY3Rpb24obikge1xuICogICByZXR1cm4gMiAqIG4oKTtcbiAqIH0sIFtuXSk7XG4qL1xuZmx5ZC5lbmRzT24gPSBmdW5jdGlvbihlbmRTLCBzKSB7XG4gIGRldGFjaERlcHMocy5lbmQpO1xuICBlbmRTLmxpc3RlbmVycy5wdXNoKHMuZW5kKTtcbiAgcy5lbmQuZGVwcy5wdXNoKGVuZFMpO1xuICByZXR1cm4gcztcbn1cblxuLyoqXG4gKiBNYXAgYSBzdHJlYW1cbiAqXG4gKiBSZXR1cm5zIGEgbmV3IHN0cmVhbSBjb25zaXN0aW5nIG9mIGV2ZXJ5IHZhbHVlIGZyb20gYHNgIHBhc3NlZCB0aHJvdWdoXG4gKiBgZm5gLiBJLmUuIGBtYXBgIGNyZWF0ZXMgYSBuZXcgc3RyZWFtIHRoYXQgbGlzdGVucyB0byBgc2AgYW5kXG4gKiBhcHBsaWVzIGBmbmAgdG8gZXZlcnkgbmV3IHZhbHVlLlxuICogX19TaWduYXR1cmVfXzogYChhIC0+IHJlc3VsdCkgLT4gU3RyZWFtIGEgLT4gU3RyZWFtIHJlc3VsdGBcbiAqXG4gKiBAbmFtZSBmbHlkLm1hcFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSB0aGUgZnVuY3Rpb24gdGhhdCBwcm9kdWNlcyB0aGUgZWxlbWVudHMgb2YgdGhlIG5ldyBzdHJlYW1cbiAqIEBwYXJhbSB7c3RyZWFtfSBzdHJlYW0gLSB0aGUgc3RyZWFtIHRvIG1hcFxuICogQHJldHVybiB7c3RyZWFtfSBhIG5ldyBzdHJlYW0gd2l0aCB0aGUgbWFwcGVkIHZhbHVlc1xuICpcbiAqIEBleGFtcGxlXG4gKiB2YXIgbnVtYmVycyA9IGZseWQuc3RyZWFtKDApO1xuICogdmFyIHNxdWFyZWROdW1iZXJzID0gZmx5ZC5tYXAoZnVuY3Rpb24obikgeyByZXR1cm4gbipuOyB9LCBudW1iZXJzKTtcbiAqL1xuLy8gTGlicmFyeSBmdW5jdGlvbnMgdXNlIHNlbGYgY2FsbGJhY2sgdG8gYWNjZXB0IChudWxsLCB1bmRlZmluZWQpIHVwZGF0ZSB0cmlnZ2Vycy5cbmZseWQubWFwID0gY3VycnlOKDIsIGZ1bmN0aW9uKGYsIHMpIHtcbiAgcmV0dXJuIGNvbWJpbmUoZnVuY3Rpb24ocywgc2VsZikgeyBzZWxmKGYocy52YWwpKTsgfSwgW3NdKTtcbn0pXG5cbi8qKlxuICogTGlzdGVuIHRvIHN0cmVhbSBldmVudHNcbiAqXG4gKiBTaW1pbGFyIHRvIGBtYXBgIGV4Y2VwdCB0aGF0IHRoZSByZXR1cm5lZCBzdHJlYW0gaXMgZW1wdHkuIFVzZSBgb25gIGZvciBkb2luZ1xuICogc2lkZSBlZmZlY3RzIGluIHJlYWN0aW9uIHRvIHN0cmVhbSBjaGFuZ2VzLiBVc2UgdGhlIHJldHVybmVkIHN0cmVhbSBvbmx5IGlmIHlvdVxuICogbmVlZCB0byBtYW51YWxseSBlbmQgaXQuXG4gKlxuICogX19TaWduYXR1cmVfXzogYChhIC0+IHJlc3VsdCkgLT4gU3RyZWFtIGEgLT4gU3RyZWFtIHVuZGVmaW5lZGBcbiAqXG4gKiBAbmFtZSBmbHlkLm9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIHRoZSBjYWxsYmFja1xuICogQHBhcmFtIHtzdHJlYW19IHN0cmVhbSAtIHRoZSBzdHJlYW1cbiAqIEByZXR1cm4ge3N0cmVhbX0gYW4gZW1wdHkgc3RyZWFtIChjYW4gYmUgZW5kZWQpXG4gKi9cbmZseWQub24gPSBjdXJyeU4oMiwgZnVuY3Rpb24oZiwgcykge1xuICByZXR1cm4gY29tYmluZShmdW5jdGlvbihzKSB7IGYocy52YWwpOyB9LCBbc10pO1xufSlcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHN0cmVhbSB3aXRoIHRoZSByZXN1bHRzIG9mIGNhbGxpbmcgdGhlIGZ1bmN0aW9uIG9uIGV2ZXJ5IGluY29taW5nXG4gKiBzdHJlYW0gd2l0aCBhbmQgYWNjdW11bGF0b3IgYW5kIHRoZSBpbmNvbWluZyB2YWx1ZS5cbiAqXG4gKiBfX1NpZ25hdHVyZV9fOiBgKGEgLT4gYiAtPiBhKSAtPiBhIC0+IFN0cmVhbSBiIC0+IFN0cmVhbSBhYFxuICpcbiAqIEBuYW1lIGZseWQuc2NhblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSB0aGUgZnVuY3Rpb24gdG8gY2FsbFxuICogQHBhcmFtIHsqfSB2YWwgLSB0aGUgaW5pdGlhbCB2YWx1ZSBvZiB0aGUgYWNjdW11bGF0b3JcbiAqIEBwYXJhbSB7c3RyZWFtfSBzdHJlYW0gLSB0aGUgc3RyZWFtIHNvdXJjZVxuICogQHJldHVybiB7c3RyZWFtfSB0aGUgbmV3IHN0cmVhbVxuICpcbiAqIEBleGFtcGxlXG4gKiB2YXIgbnVtYmVycyA9IGZseWQuc3RyZWFtKCk7XG4gKiB2YXIgc3VtID0gZmx5ZC5zY2FuKGZ1bmN0aW9uKHN1bSwgbikgeyByZXR1cm4gc3VtK247IH0sIDAsIG51bWJlcnMpO1xuICogbnVtYmVycygyKSgzKSg1KTtcbiAqIHN1bSgpOyAvLyAxMFxuICovXG5mbHlkLnNjYW4gPSBjdXJyeU4oMywgZnVuY3Rpb24oZiwgYWNjLCBzKSB7XG4gIHZhciBucyA9IGNvbWJpbmUoZnVuY3Rpb24ocywgc2VsZikge1xuICAgIHNlbGYoYWNjID0gZihhY2MsIHMudmFsKSk7XG4gIH0sIFtzXSk7XG4gIGlmICghbnMuaGFzVmFsKSBucyhhY2MpO1xuICByZXR1cm4gbnM7XG59KTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHN0cmVhbSBkb3duIHdoaWNoIGFsbCB2YWx1ZXMgZnJvbSBib3RoIGBzdHJlYW0xYCBhbmQgYHN0cmVhbTJgXG4gKiB3aWxsIGJlIHNlbnQuXG4gKlxuICogX19TaWduYXR1cmVfXzogYFN0cmVhbSBhIC0+IFN0cmVhbSBhIC0+IFN0cmVhbSBhYFxuICpcbiAqIEBuYW1lIGZseWQubWVyZ2VcbiAqIEBwYXJhbSB7c3RyZWFtfSBzb3VyY2UxIC0gb25lIHN0cmVhbSB0byBiZSBtZXJnZWRcbiAqIEBwYXJhbSB7c3RyZWFtfSBzb3VyY2UyIC0gdGhlIG90aGVyIHN0cmVhbSB0byBiZSBtZXJnZWRcbiAqIEByZXR1cm4ge3N0cmVhbX0gYSBzdHJlYW0gd2l0aCB0aGUgdmFsdWVzIGZyb20gYm90aCBzb3VyY2VzXG4gKlxuICogQGV4YW1wbGVcbiAqIHZhciBidG4xQ2xpY2tzID0gZmx5ZC5zdHJlYW0oKTtcbiAqIGJ1dHRvbjFFbG0uYWRkRXZlbnRMaXN0ZW5lcihidG4xQ2xpY2tzKTtcbiAqIHZhciBidG4yQ2xpY2tzID0gZmx5ZC5zdHJlYW0oKTtcbiAqIGJ1dHRvbjJFbG0uYWRkRXZlbnRMaXN0ZW5lcihidG4yQ2xpY2tzKTtcbiAqIHZhciBhbGxDbGlja3MgPSBmbHlkLm1lcmdlKGJ0bjFDbGlja3MsIGJ0bjJDbGlja3MpO1xuICovXG5mbHlkLm1lcmdlID0gY3VycnlOKDIsIGZ1bmN0aW9uKHMxLCBzMikge1xuICB2YXIgcyA9IGZseWQuaW1tZWRpYXRlKGNvbWJpbmUoZnVuY3Rpb24oczEsIHMyLCBzZWxmLCBjaGFuZ2VkKSB7XG4gICAgaWYgKGNoYW5nZWRbMF0pIHtcbiAgICAgIHNlbGYoY2hhbmdlZFswXSgpKTtcbiAgICB9IGVsc2UgaWYgKHMxLmhhc1ZhbCkge1xuICAgICAgc2VsZihzMS52YWwpO1xuICAgIH0gZWxzZSBpZiAoczIuaGFzVmFsKSB7XG4gICAgICBzZWxmKHMyLnZhbCk7XG4gICAgfVxuICB9LCBbczEsIHMyXSkpO1xuICBmbHlkLmVuZHNPbihjb21iaW5lKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBbczEuZW5kLCBzMi5lbmRdKSwgcyk7XG4gIHJldHVybiBzO1xufSk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBzdHJlYW0gcmVzdWx0aW5nIGZyb20gYXBwbHlpbmcgYHRyYW5zZHVjZXJgIHRvIGBzdHJlYW1gLlxuICpcbiAqIF9fU2lnbmF0dXJlX186IGBUcmFuc2R1Y2VyIC0+IFN0cmVhbSBhIC0+IFN0cmVhbSBiYFxuICpcbiAqIEBuYW1lIGZseWQudHJhbnNkdWNlXG4gKiBAcGFyYW0ge1RyYW5zZHVjZXJ9IHhmb3JtIC0gdGhlIHRyYW5zZHVjZXIgdHJhbnNmb3JtYXRpb25cbiAqIEBwYXJhbSB7c3RyZWFtfSBzb3VyY2UgLSB0aGUgc3RyZWFtIHNvdXJjZVxuICogQHJldHVybiB7c3RyZWFtfSB0aGUgbmV3IHN0cmVhbVxuICpcbiAqIEBleGFtcGxlXG4gKiB2YXIgdCA9IHJlcXVpcmUoJ3RyYW5zZHVjZXJzLmpzJyk7XG4gKlxuICogdmFyIHJlc3VsdHMgPSBbXTtcbiAqIHZhciBzMSA9IGZseWQuc3RyZWFtKCk7XG4gKiB2YXIgdHggPSB0LmNvbXBvc2UodC5tYXAoZnVuY3Rpb24oeCkgeyByZXR1cm4geCAqIDI7IH0pLCB0LmRlZHVwZSgpKTtcbiAqIHZhciBzMiA9IGZseWQudHJhbnNkdWNlKHR4LCBzMSk7XG4gKiBmbHlkLmNvbWJpbmUoZnVuY3Rpb24oczIpIHsgcmVzdWx0cy5wdXNoKHMyKCkpOyB9LCBbczJdKTtcbiAqIHMxKDEpKDEpKDIpKDMpKDMpKDMpKDQpO1xuICogcmVzdWx0czsgLy8gPT4gWzIsIDQsIDYsIDhdXG4gKi9cbmZseWQudHJhbnNkdWNlID0gY3VycnlOKDIsIGZ1bmN0aW9uKHhmb3JtLCBzb3VyY2UpIHtcbiAgeGZvcm0gPSB4Zm9ybShuZXcgU3RyZWFtVHJhbnNmb3JtZXIoKSk7XG4gIHJldHVybiBjb21iaW5lKGZ1bmN0aW9uKHNvdXJjZSwgc2VsZikge1xuICAgIHZhciByZXMgPSB4Zm9ybVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSh1bmRlZmluZWQsIHNvdXJjZS52YWwpO1xuICAgIGlmIChyZXMgJiYgcmVzWydAQHRyYW5zZHVjZXIvcmVkdWNlZCddID09PSB0cnVlKSB7XG4gICAgICBzZWxmLmVuZCh0cnVlKTtcbiAgICAgIHJldHVybiByZXNbJ0BAdHJhbnNkdWNlci92YWx1ZSddO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgfSwgW3NvdXJjZV0pO1xufSk7XG5cbi8qKlxuICogUmV0dXJucyBgZm5gIGN1cnJpZWQgdG8gYG5gLiBVc2UgdGhpcyBmdW5jdGlvbiB0byBjdXJyeSBmdW5jdGlvbnMgZXhwb3NlZCBieVxuICogbW9kdWxlcyBmb3IgRmx5ZC5cbiAqXG4gKiBAbmFtZSBmbHlkLmN1cnJ5TlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0ludGVnZXJ9IGFyaXR5IC0gdGhlIGZ1bmN0aW9uIGFyaXR5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIHRoZSBmdW5jdGlvbiB0byBjdXJyeVxuICogQHJldHVybiB7RnVuY3Rpb259IHRoZSBjdXJyaWVkIGZ1bmN0aW9uXG4gKlxuICogQGV4YW1wbGVcbiAqIGZ1bmN0aW9uIGFkZCh4LCB5KSB7IHJldHVybiB4ICsgeTsgfTtcbiAqIHZhciBhID0gZmx5ZC5jdXJyeU4oMiwgYWRkKTtcbiAqIGEoMikoNCkgLy8gPT4gNlxuICovXG5mbHlkLmN1cnJ5TiA9IGN1cnJ5TlxuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgc3RyZWFtIGlkZW50aWNhbCB0byB0aGUgb3JpZ2luYWwgZXhjZXB0IGV2ZXJ5XG4gKiB2YWx1ZSB3aWxsIGJlIHBhc3NlZCB0aHJvdWdoIGBmYC5cbiAqXG4gKiBfTm90ZTpfIFRoaXMgZnVuY3Rpb24gaXMgaW5jbHVkZWQgaW4gb3JkZXIgdG8gc3VwcG9ydCB0aGUgZmFudGFzeSBsYW5kXG4gKiBzcGVjaWZpY2F0aW9uLlxuICpcbiAqIF9fU2lnbmF0dXJlX186IENhbGxlZCBib3VuZCB0byBgU3RyZWFtIGFgOiBgKGEgLT4gYikgLT4gU3RyZWFtIGJgXG4gKlxuICogQG5hbWUgc3RyZWFtLm1hcFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY3Rpb24gLSB0aGUgZnVuY3Rpb24gdG8gYXBwbHlcbiAqIEByZXR1cm4ge3N0cmVhbX0gYSBuZXcgc3RyZWFtIHdpdGggdGhlIHZhbHVlcyBtYXBwZWRcbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIG51bWJlcnMgPSBmbHlkLnN0cmVhbSgwKTtcbiAqIHZhciBzcXVhcmVkTnVtYmVycyA9IG51bWJlcnMubWFwKGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4qbjsgfSk7XG4gKi9cbmZ1bmN0aW9uIGJvdW5kTWFwKGYpIHsgcmV0dXJuIGZseWQubWFwKGYsIHRoaXMpOyB9XG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBzdHJlYW0gd2hpY2ggaXMgdGhlIHJlc3VsdCBvZiBhcHBseWluZyB0aGVcbiAqIGZ1bmN0aW9ucyBmcm9tIGB0aGlzYCBzdHJlYW0gdG8gdGhlIHZhbHVlcyBpbiBgc3RyZWFtYCBwYXJhbWV0ZXIuXG4gKlxuICogYHRoaXNgIHN0cmVhbSBtdXN0IGJlIGEgc3RyZWFtIG9mIGZ1bmN0aW9ucy5cbiAqXG4gKiBfTm90ZTpfIFRoaXMgZnVuY3Rpb24gaXMgaW5jbHVkZWQgaW4gb3JkZXIgdG8gc3VwcG9ydCB0aGUgZmFudGFzeSBsYW5kXG4gKiBzcGVjaWZpY2F0aW9uLlxuICpcbiAqIF9fU2lnbmF0dXJlX186IENhbGxlZCBib3VuZCB0byBgU3RyZWFtIChhIC0+IGIpYDogYGEgLT4gU3RyZWFtIGJgXG4gKlxuICogQG5hbWUgc3RyZWFtLmFwXG4gKiBAcGFyYW0ge3N0cmVhbX0gc3RyZWFtIC0gdGhlIHZhbHVlcyBzdHJlYW1cbiAqIEByZXR1cm4ge3N0cmVhbX0gYSBuZXcgc3RyYW0gd2l0aCB0aGUgZnVuY3Rpb25zIGFwcGxpZWQgdG8gdmFsdWVzXG4gKlxuICogQGV4YW1wbGVcbiAqIHZhciBhZGQgPSBmbHlkLmN1cnJ5TigyLCBmdW5jdGlvbih4LCB5KSB7IHJldHVybiB4ICsgeTsgfSk7XG4gKiB2YXIgbnVtYmVyczEgPSBmbHlkLnN0cmVhbSgpO1xuICogdmFyIG51bWJlcnMyID0gZmx5ZC5zdHJlYW0oKTtcbiAqIHZhciBhZGRUb051bWJlcnMxID0gZmx5ZC5tYXAoYWRkLCBudW1iZXJzMSk7XG4gKiB2YXIgYWRkZWQgPSBhZGRUb051bWJlcnMxLmFwKG51bWJlcnMyKTtcbiAqL1xuZnVuY3Rpb24gYXAoczIpIHtcbiAgdmFyIHMxID0gdGhpcztcbiAgcmV0dXJuIGNvbWJpbmUoZnVuY3Rpb24oczEsIHMyLCBzZWxmKSB7IHNlbGYoczEudmFsKHMyLnZhbCkpOyB9LCBbczEsIHMyXSk7XG59XG5cbi8qKlxuICogR2V0IGEgaHVtYW4gcmVhZGFibGUgdmlldyBvZiBhIHN0cmVhbVxuICogQG5hbWUgc3RyZWFtLnRvU3RyaW5nXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBzdHJlYW0gc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gKi9cbmZ1bmN0aW9uIHN0cmVhbVRvU3RyaW5nKCkge1xuICByZXR1cm4gJ3N0cmVhbSgnICsgdGhpcy52YWwgKyAnKSc7XG59XG5cbi8qKlxuICogQG5hbWUgc3RyZWFtLmVuZFxuICogQG1lbWJlcm9mIHN0cmVhbVxuICogQSBzdHJlYW0gdGhhdCBlbWl0cyBgdHJ1ZWAgd2hlbiB0aGUgc3RyZWFtIGVuZHMuIElmIGB0cnVlYCBpcyBwdXNoZWQgZG93biB0aGVcbiAqIHN0cmVhbSB0aGUgcGFyZW50IHN0cmVhbSBlbmRzLlxuICovXG5cbi8qKlxuICogQG5hbWUgc3RyZWFtLm9mXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBzdHJlYW1cbiAqIFJldHVybnMgYSBuZXcgc3RyZWFtIHdpdGggYHZhbHVlYCBhcyBpdHMgaW5pdGlhbCB2YWx1ZS4gSXQgaXMgaWRlbnRpY2FsIHRvXG4gKiBjYWxsaW5nIGBmbHlkLnN0cmVhbWAgd2l0aCBvbmUgYXJndW1lbnQuXG4gKlxuICogX19TaWduYXR1cmVfXzogQ2FsbGVkIGJvdW5kIHRvIGBTdHJlYW0gKGEpYDogYGIgLT4gU3RyZWFtIGJgXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIHRoZSBpbml0aWFsIHZhbHVlXG4gKiBAcmV0dXJuIHtzdHJlYW19IHRoZSBuZXcgc3RyZWFtXG4gKlxuICogQGV4YW1wbGVcbiAqIHZhciBuID0gZmx5ZC5zdHJlYW0oMSk7XG4gKiB2YXIgbSA9IG4ub2YoMSk7XG4gKi9cblxuLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vIFBSSVZBVEUgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vIC8vXG4vKipcbiAqIEBwcml2YXRlXG4gKiBDcmVhdGUgYSBzdHJlYW0gd2l0aCBubyBkZXBlbmRlbmNpZXMgYW5kIG5vIHZhbHVlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gYSBmbHlkIHN0cmVhbVxuICovXG5mdW5jdGlvbiBjcmVhdGVTdHJlYW0oKSB7XG4gIGZ1bmN0aW9uIHMobikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gcy52YWxcbiAgICB1cGRhdGVTdHJlYW1WYWx1ZShzLCBuKVxuICAgIHJldHVybiBzXG4gIH1cbiAgcy5oYXNWYWwgPSBmYWxzZTtcbiAgcy52YWwgPSB1bmRlZmluZWQ7XG4gIHMudmFscyA9IFtdO1xuICBzLmxpc3RlbmVycyA9IFtdO1xuICBzLnF1ZXVlZCA9IGZhbHNlO1xuICBzLmVuZCA9IHVuZGVmaW5lZDtcbiAgcy5tYXAgPSBib3VuZE1hcDtcbiAgcy5hcCA9IGFwO1xuICBzLm9mID0gZmx5ZC5zdHJlYW07XG4gIHMudG9TdHJpbmcgPSBzdHJlYW1Ub1N0cmluZztcbiAgcmV0dXJuIHM7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIENyZWF0ZSBhIGRlcGVuZGVudCBzdHJlYW1cbiAqIEBwYXJhbSB7QXJyYXk8c3RyZWFtPn0gZGVwZW5kZW5jaWVzIC0gYW4gYXJyYXkgb2YgdGhlIHN0cmVhbXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gdGhlIGZ1bmN0aW9uIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBuZXcgc3RyZWFtIHZhbHVlXG4gKiBmcm9tIHRoZSBkZXBlbmRlbmNpZXNcbiAqIEByZXR1cm4ge3N0cmVhbX0gdGhlIGNyZWF0ZWQgc3RyZWFtXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURlcGVuZGVudFN0cmVhbShkZXBzLCBmbikge1xuICB2YXIgcyA9IGNyZWF0ZVN0cmVhbSgpO1xuICBzLmZuID0gZm47XG4gIHMuZGVwcyA9IGRlcHM7XG4gIHMuZGVwc01ldCA9IGZhbHNlO1xuICBzLmRlcHNDaGFuZ2VkID0gZGVwcy5sZW5ndGggPiAwID8gW10gOiB1bmRlZmluZWQ7XG4gIHMuc2hvdWxkVXBkYXRlID0gZmFsc2U7XG4gIGFkZExpc3RlbmVycyhkZXBzLCBzKTtcbiAgcmV0dXJuIHM7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIENoZWNrIGlmIGFsbCB0aGUgZGVwZW5kZW5jaWVzIGhhdmUgdmFsdWVzXG4gKiBAcGFyYW0ge3N0cmVhbX0gc3RyZWFtIC0gdGhlIHN0cmVhbSB0byBjaGVjayBkZXBlbmNlbmNpZXMgZnJvbVxuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIGFsbCBkZXBlbmRlbmNpZXMgaGF2ZSB2YWxlcywgYGZhbHNlYCBvdGhlcndpc2VcbiAqL1xuZnVuY3Rpb24gaW5pdGlhbERlcHNOb3RNZXQoc3RyZWFtKSB7XG4gIHN0cmVhbS5kZXBzTWV0ID0gc3RyZWFtLmRlcHMuZXZlcnkoZnVuY3Rpb24ocykge1xuICAgIHJldHVybiBzLmhhc1ZhbDtcbiAgfSk7XG4gIHJldHVybiAhc3RyZWFtLmRlcHNNZXQ7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIFVwZGF0ZSBhIGRlcGVuZGVudCBzdHJlYW0gdXNpbmcgaXRzIGRlcGVuZGVuY2llcyBpbiBhbiBhdG9taWMgd2F5XG4gKiBAcGFyYW0ge3N0cmVhbX0gc3RyZWFtIC0gdGhlIHN0cmVhbSB0byB1cGRhdGVcbiAqL1xuZnVuY3Rpb24gdXBkYXRlU3RyZWFtKHMpIHtcbiAgaWYgKChzLmRlcHNNZXQgIT09IHRydWUgJiYgaW5pdGlhbERlcHNOb3RNZXQocykpIHx8XG4gICAgICAocy5lbmQgIT09IHVuZGVmaW5lZCAmJiBzLmVuZC52YWwgPT09IHRydWUpKSByZXR1cm47XG4gIGlmIChpblN0cmVhbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdG9VcGRhdGUucHVzaChzKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaW5TdHJlYW0gPSBzO1xuICBpZiAocy5kZXBzQ2hhbmdlZCkgcy5mbkFyZ3Nbcy5mbkFyZ3MubGVuZ3RoIC0gMV0gPSBzLmRlcHNDaGFuZ2VkO1xuICB2YXIgcmV0dXJuVmFsID0gcy5mbi5hcHBseShzLmZuLCBzLmZuQXJncyk7XG4gIGlmIChyZXR1cm5WYWwgIT09IHVuZGVmaW5lZCkge1xuICAgIHMocmV0dXJuVmFsKTtcbiAgfVxuICBpblN0cmVhbSA9IHVuZGVmaW5lZDtcbiAgaWYgKHMuZGVwc0NoYW5nZWQgIT09IHVuZGVmaW5lZCkgcy5kZXBzQ2hhbmdlZCA9IFtdO1xuICBzLnNob3VsZFVwZGF0ZSA9IGZhbHNlO1xuICBpZiAoZmx1c2hpbmcgPT09IGZhbHNlKSBmbHVzaFVwZGF0ZSgpO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBVcGRhdGUgdGhlIGRlcGVuZGVuY2llcyBvZiBhIHN0cmVhbVxuICogQHBhcmFtIHtzdHJlYW19IHN0cmVhbVxuICovXG5mdW5jdGlvbiB1cGRhdGVEZXBzKHMpIHtcbiAgdmFyIGksIG8sIGxpc3RcbiAgdmFyIGxpc3RlbmVycyA9IHMubGlzdGVuZXJzO1xuICBmb3IgKGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgbGlzdCA9IGxpc3RlbmVyc1tpXTtcbiAgICBpZiAobGlzdC5lbmQgPT09IHMpIHtcbiAgICAgIGVuZFN0cmVhbShsaXN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGxpc3QuZGVwc0NoYW5nZWQgIT09IHVuZGVmaW5lZCkgbGlzdC5kZXBzQ2hhbmdlZC5wdXNoKHMpO1xuICAgICAgbGlzdC5zaG91bGRVcGRhdGUgPSB0cnVlO1xuICAgICAgZmluZERlcHMobGlzdCk7XG4gICAgfVxuICB9XG4gIGZvciAoOyBvcmRlck5leHRJZHggPj0gMDsgLS1vcmRlck5leHRJZHgpIHtcbiAgICBvID0gb3JkZXJbb3JkZXJOZXh0SWR4XTtcbiAgICBpZiAoby5zaG91bGRVcGRhdGUgPT09IHRydWUpIHVwZGF0ZVN0cmVhbShvKTtcbiAgICBvLnF1ZXVlZCA9IGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEFkZCBzdHJlYW0gZGVwZW5kZW5jaWVzIHRvIHRoZSBnbG9iYWwgYG9yZGVyYCBxdWV1ZS5cbiAqIEBwYXJhbSB7c3RyZWFtfSBzdHJlYW1cbiAqIEBzZWUgdXBkYXRlRGVwc1xuICovXG5mdW5jdGlvbiBmaW5kRGVwcyhzKSB7XG4gIHZhciBpXG4gIHZhciBsaXN0ZW5lcnMgPSBzLmxpc3RlbmVycztcbiAgaWYgKHMucXVldWVkID09PSBmYWxzZSkge1xuICAgIHMucXVldWVkID0gdHJ1ZTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICBmaW5kRGVwcyhsaXN0ZW5lcnNbaV0pO1xuICAgIH1cbiAgICBvcmRlclsrK29yZGVyTmV4dElkeF0gPSBzO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZmx1c2hVcGRhdGUoKSB7XG4gIGZsdXNoaW5nID0gdHJ1ZTtcbiAgd2hpbGUgKHRvVXBkYXRlLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgcyA9IHRvVXBkYXRlLnNoaWZ0KCk7XG4gICAgaWYgKHMudmFscy5sZW5ndGggPiAwKSBzLnZhbCA9IHMudmFscy5zaGlmdCgpO1xuICAgIHVwZGF0ZURlcHMocyk7XG4gIH1cbiAgZmx1c2hpbmcgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogUHVzaCBkb3duIGEgdmFsdWUgaW50byBhIHN0cmVhbVxuICogQHBhcmFtIHtzdHJlYW19IHN0cmVhbVxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICovXG5mdW5jdGlvbiB1cGRhdGVTdHJlYW1WYWx1ZShzLCBuKSB7XG4gIGlmIChuICE9PSB1bmRlZmluZWQgJiYgbiAhPT0gbnVsbCAmJiBpc0Z1bmN0aW9uKG4udGhlbikpIHtcbiAgICBuLnRoZW4ocyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHMudmFsID0gbjtcbiAgcy5oYXNWYWwgPSB0cnVlO1xuICBpZiAoaW5TdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgIGZsdXNoaW5nID0gdHJ1ZTtcbiAgICB1cGRhdGVEZXBzKHMpO1xuICAgIGlmICh0b1VwZGF0ZS5sZW5ndGggPiAwKSBmbHVzaFVwZGF0ZSgpOyBlbHNlIGZsdXNoaW5nID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAoaW5TdHJlYW0gPT09IHMpIHtcbiAgICBtYXJrTGlzdGVuZXJzKHMsIHMubGlzdGVuZXJzKTtcbiAgfSBlbHNlIHtcbiAgICBzLnZhbHMucHVzaChuKTtcbiAgICB0b1VwZGF0ZS5wdXNoKHMpO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbWFya0xpc3RlbmVycyhzLCBsaXN0cykge1xuICB2YXIgaSwgbGlzdDtcbiAgZm9yIChpID0gMDsgaSA8IGxpc3RzLmxlbmd0aDsgKytpKSB7XG4gICAgbGlzdCA9IGxpc3RzW2ldO1xuICAgIGlmIChsaXN0LmVuZCAhPT0gcykge1xuICAgICAgaWYgKGxpc3QuZGVwc0NoYW5nZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsaXN0LmRlcHNDaGFuZ2VkLnB1c2gocyk7XG4gICAgICB9XG4gICAgICBsaXN0LnNob3VsZFVwZGF0ZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVuZFN0cmVhbShsaXN0KTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQWRkIGRlcGVuZGVuY2llcyB0byBhIHN0cmVhbVxuICogQHBhcmFtIHtBcnJheTxzdHJlYW0+fSBkZXBlbmRlbmNpZXNcbiAqIEBwYXJhbSB7c3RyZWFtfSBzdHJlYW1cbiAqL1xuZnVuY3Rpb24gYWRkTGlzdGVuZXJzKGRlcHMsIHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZXBzLmxlbmd0aDsgKytpKSB7XG4gICAgZGVwc1tpXS5saXN0ZW5lcnMucHVzaChzKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBSZW1vdmVzIGFuIHN0cmVhbSBmcm9tIGEgZGVwZW5kZW5jeSBhcnJheVxuICogQHBhcmFtIHtzdHJlYW19IHN0cmVhbVxuICogQHBhcmFtIHtBcnJheTxzdHJlYW0+fSBkZXBlbmRlbmNpZXNcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIocywgbGlzdGVuZXJzKSB7XG4gIHZhciBpZHggPSBsaXN0ZW5lcnMuaW5kZXhPZihzKTtcbiAgbGlzdGVuZXJzW2lkeF0gPSBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdO1xuICBsaXN0ZW5lcnMubGVuZ3RoLS07XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIERldGFjaCBhIHN0cmVhbSBmcm9tIGl0cyBkZXBlbmRlbmNpZXNcbiAqIEBwYXJhbSB7c3RyZWFtfSBzdHJlYW1cbiAqL1xuZnVuY3Rpb24gZGV0YWNoRGVwcyhzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcy5kZXBzLmxlbmd0aDsgKytpKSB7XG4gICAgcmVtb3ZlTGlzdGVuZXIocywgcy5kZXBzW2ldLmxpc3RlbmVycyk7XG4gIH1cbiAgcy5kZXBzLmxlbmd0aCA9IDA7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEVuZHMgYSBzdHJlYW1cbiAqL1xuZnVuY3Rpb24gZW5kU3RyZWFtKHMpIHtcbiAgaWYgKHMuZGVwcyAhPT0gdW5kZWZpbmVkKSBkZXRhY2hEZXBzKHMpO1xuICBpZiAocy5lbmQgIT09IHVuZGVmaW5lZCkgZGV0YWNoRGVwcyhzLmVuZCk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIHRyYW5zZHVjZXIgc3RyZWFtIHRyYW5zZm9ybWVyXG4gKi9cbmZ1bmN0aW9uIFN0cmVhbVRyYW5zZm9ybWVyKCkgeyB9XG5TdHJlYW1UcmFuc2Zvcm1lci5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBmdW5jdGlvbigpIHsgfTtcblN0cmVhbVRyYW5zZm9ybWVyLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24oKSB7IH07XG5TdHJlYW1UcmFuc2Zvcm1lci5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbihzLCB2KSB7IHJldHVybiB2OyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZseWQ7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9mbHlkL2xpYi9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	eval("var _arity = __webpack_require__(4);\nvar _curry1 = __webpack_require__(5);\nvar _curry2 = __webpack_require__(7);\nvar _curryN = __webpack_require__(8);\n\n\n/**\n * Returns a curried equivalent of the provided function, with the specified\n * arity. The curried function has two unusual capabilities. First, its\n * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the\n * following are equivalent:\n *\n *   - `g(1)(2)(3)`\n *   - `g(1)(2, 3)`\n *   - `g(1, 2)(3)`\n *   - `g(1, 2, 3)`\n *\n * Secondly, the special placeholder value `R.__` may be used to specify\n * \"gaps\", allowing partial application of any combination of arguments,\n * regardless of their positions. If `g` is as above and `_` is `R.__`, the\n * following are equivalent:\n *\n *   - `g(1, 2, 3)`\n *   - `g(_, 2, 3)(1)`\n *   - `g(_, _, 3)(1)(2)`\n *   - `g(_, _, 3)(1, 2)`\n *   - `g(_, 2)(1)(3)`\n *   - `g(_, 2)(1, 3)`\n *   - `g(_, 2)(_, 3)(1)`\n *\n * @func\n * @memberOf R\n * @since v0.5.0\n * @category Function\n * @sig Number -> (* -> a) -> (* -> a)\n * @param {Number} length The arity for the returned function.\n * @param {Function} fn The function to curry.\n * @return {Function} A new, curried function.\n * @see R.curry\n * @example\n *\n *      var sumArgs = (...args) => R.sum(args);\n *\n *      var curriedAddFourNumbers = R.curryN(4, sumArgs);\n *      var f = curriedAddFourNumbers(1, 2);\n *      var g = f(3);\n *      g(4); //=> 10\n */\nmodule.exports = _curry2(function curryN(length, fn) {\n  if (length === 1) {\n    return _curry1(fn);\n  }\n  return _arity(length, _curryN(length, [], fn));\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2ZseWQvfi9yYW1kYS9zcmMvY3VycnlOLmpzPzM1ZWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiMy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBfYXJpdHkgPSByZXF1aXJlKCcuL2ludGVybmFsL19hcml0eScpO1xudmFyIF9jdXJyeTEgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTEnKTtcbnZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG52YXIgX2N1cnJ5TiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5TicpO1xuXG5cbi8qKlxuICogUmV0dXJucyBhIGN1cnJpZWQgZXF1aXZhbGVudCBvZiB0aGUgcHJvdmlkZWQgZnVuY3Rpb24sIHdpdGggdGhlIHNwZWNpZmllZFxuICogYXJpdHkuIFRoZSBjdXJyaWVkIGZ1bmN0aW9uIGhhcyB0d28gdW51c3VhbCBjYXBhYmlsaXRpZXMuIEZpcnN0LCBpdHNcbiAqIGFyZ3VtZW50cyBuZWVkbid0IGJlIHByb3ZpZGVkIG9uZSBhdCBhIHRpbWUuIElmIGBnYCBpcyBgUi5jdXJyeU4oMywgZilgLCB0aGVcbiAqIGZvbGxvd2luZyBhcmUgZXF1aXZhbGVudDpcbiAqXG4gKiAgIC0gYGcoMSkoMikoMylgXG4gKiAgIC0gYGcoMSkoMiwgMylgXG4gKiAgIC0gYGcoMSwgMikoMylgXG4gKiAgIC0gYGcoMSwgMiwgMylgXG4gKlxuICogU2Vjb25kbHksIHRoZSBzcGVjaWFsIHBsYWNlaG9sZGVyIHZhbHVlIGBSLl9fYCBtYXkgYmUgdXNlZCB0byBzcGVjaWZ5XG4gKiBcImdhcHNcIiwgYWxsb3dpbmcgcGFydGlhbCBhcHBsaWNhdGlvbiBvZiBhbnkgY29tYmluYXRpb24gb2YgYXJndW1lbnRzLFxuICogcmVnYXJkbGVzcyBvZiB0aGVpciBwb3NpdGlvbnMuIElmIGBnYCBpcyBhcyBhYm92ZSBhbmQgYF9gIGlzIGBSLl9fYCwgdGhlXG4gKiBmb2xsb3dpbmcgYXJlIGVxdWl2YWxlbnQ6XG4gKlxuICogICAtIGBnKDEsIDIsIDMpYFxuICogICAtIGBnKF8sIDIsIDMpKDEpYFxuICogICAtIGBnKF8sIF8sIDMpKDEpKDIpYFxuICogICAtIGBnKF8sIF8sIDMpKDEsIDIpYFxuICogICAtIGBnKF8sIDIpKDEpKDMpYFxuICogICAtIGBnKF8sIDIpKDEsIDMpYFxuICogICAtIGBnKF8sIDIpKF8sIDMpKDEpYFxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjUuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnIE51bWJlciAtPiAoKiAtPiBhKSAtPiAoKiAtPiBhKVxuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCBUaGUgYXJpdHkgZm9yIHRoZSByZXR1cm5lZCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjdXJyeS5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIG5ldywgY3VycmllZCBmdW5jdGlvbi5cbiAqIEBzZWUgUi5jdXJyeVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBzdW1BcmdzID0gKC4uLmFyZ3MpID0+IFIuc3VtKGFyZ3MpO1xuICpcbiAqICAgICAgdmFyIGN1cnJpZWRBZGRGb3VyTnVtYmVycyA9IFIuY3VycnlOKDQsIHN1bUFyZ3MpO1xuICogICAgICB2YXIgZiA9IGN1cnJpZWRBZGRGb3VyTnVtYmVycygxLCAyKTtcbiAqICAgICAgdmFyIGcgPSBmKDMpO1xuICogICAgICBnKDQpOyAvLz0+IDEwXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiBjdXJyeU4obGVuZ3RoLCBmbikge1xuICBpZiAobGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIF9jdXJyeTEoZm4pO1xuICB9XG4gIHJldHVybiBfYXJpdHkobGVuZ3RoLCBfY3VycnlOKGxlbmd0aCwgW10sIGZuKSk7XG59KTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2ZseWQvfi9yYW1kYS9zcmMvY3VycnlOLmpzXG4gKiogbW9kdWxlIGlkID0gM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 4 */
/***/ function(module, exports) {

	eval("module.exports = function _arity(n, fn) {\n  /* eslint-disable no-unused-vars */\n  switch (n) {\n    case 0: return function() { return fn.apply(this, arguments); };\n    case 1: return function(a0) { return fn.apply(this, arguments); };\n    case 2: return function(a0, a1) { return fn.apply(this, arguments); };\n    case 3: return function(a0, a1, a2) { return fn.apply(this, arguments); };\n    case 4: return function(a0, a1, a2, a3) { return fn.apply(this, arguments); };\n    case 5: return function(a0, a1, a2, a3, a4) { return fn.apply(this, arguments); };\n    case 6: return function(a0, a1, a2, a3, a4, a5) { return fn.apply(this, arguments); };\n    case 7: return function(a0, a1, a2, a3, a4, a5, a6) { return fn.apply(this, arguments); };\n    case 8: return function(a0, a1, a2, a3, a4, a5, a6, a7) { return fn.apply(this, arguments); };\n    case 9: return function(a0, a1, a2, a3, a4, a5, a6, a7, a8) { return fn.apply(this, arguments); };\n    case 10: return function(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) { return fn.apply(this, arguments); };\n    default: throw new Error('First argument to _arity must be a non-negative integer no greater than ten');\n  }\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2ZseWQvfi9yYW1kYS9zcmMvaW50ZXJuYWwvX2FyaXR5LmpzPzNjNGIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGtDQUFrQztBQUNqRSxpQ0FBaUMsa0NBQWtDO0FBQ25FLHFDQUFxQyxrQ0FBa0M7QUFDdkUseUNBQXlDLGtDQUFrQztBQUMzRSw2Q0FBNkMsa0NBQWtDO0FBQy9FLGlEQUFpRCxrQ0FBa0M7QUFDbkYscURBQXFELGtDQUFrQztBQUN2Rix5REFBeUQsa0NBQWtDO0FBQzNGLDZEQUE2RCxrQ0FBa0M7QUFDL0YsaUVBQWlFLGtDQUFrQztBQUNuRyxzRUFBc0Usa0NBQWtDO0FBQ3hHO0FBQ0E7QUFDQSIsImZpbGUiOiI0LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBfYXJpdHkobiwgZm4pIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbiAgc3dpdGNoIChuKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gZnVuY3Rpb24oKSB7IHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9O1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKGEwKSB7IHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uKGEwLCBhMSkgeyByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbihhMCwgYTEsIGEyKSB7IHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9O1xuICAgIGNhc2UgNDogcmV0dXJuIGZ1bmN0aW9uKGEwLCBhMSwgYTIsIGEzKSB7IHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9O1xuICAgIGNhc2UgNTogcmV0dXJuIGZ1bmN0aW9uKGEwLCBhMSwgYTIsIGEzLCBhNCkgeyByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcbiAgICBjYXNlIDY6IHJldHVybiBmdW5jdGlvbihhMCwgYTEsIGEyLCBhMywgYTQsIGE1KSB7IHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9O1xuICAgIGNhc2UgNzogcmV0dXJuIGZ1bmN0aW9uKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2KSB7IHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9O1xuICAgIGNhc2UgODogcmV0dXJuIGZ1bmN0aW9uKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNykgeyByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcbiAgICBjYXNlIDk6IHJldHVybiBmdW5jdGlvbihhMCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4KSB7IHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9O1xuICAgIGNhc2UgMTA6IHJldHVybiBmdW5jdGlvbihhMCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4LCBhOSkgeyByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcbiAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IHRvIF9hcml0eSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIgbm8gZ3JlYXRlciB0aGFuIHRlbicpO1xuICB9XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZmx5ZC9+L3JhbWRhL3NyYy9pbnRlcm5hbC9fYXJpdHkuanNcbiAqKiBtb2R1bGUgaWQgPSA0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	eval("var _isPlaceholder = __webpack_require__(6);\n\n\n/**\n * Optimized internal one-arity curry function.\n *\n * @private\n * @category Function\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\nmodule.exports = function _curry1(fn) {\n  return function f1(a) {\n    if (arguments.length === 0 || _isPlaceholder(a)) {\n      return f1;\n    } else {\n      return fn.apply(this, arguments);\n    }\n  };\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2ZseWQvfi9yYW1kYS9zcmMvaW50ZXJuYWwvX2N1cnJ5MS5qcz81NmQ1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX2lzUGxhY2Vob2xkZXIgPSByZXF1aXJlKCcuL19pc1BsYWNlaG9sZGVyJyk7XG5cblxuLyoqXG4gKiBPcHRpbWl6ZWQgaW50ZXJuYWwgb25lLWFyaXR5IGN1cnJ5IGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjdXJyeS5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgY3VycmllZCBmdW5jdGlvbi5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBfY3VycnkxKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmMShhKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDAgfHwgX2lzUGxhY2Vob2xkZXIoYSkpIHtcbiAgICAgIHJldHVybiBmMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9O1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2ZseWQvfi9yYW1kYS9zcmMvaW50ZXJuYWwvX2N1cnJ5MS5qc1xuICoqIG1vZHVsZSBpZCA9IDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 6 */
/***/ function(module, exports) {

	eval("module.exports = function _isPlaceholder(a) {\n  return a != null &&\n         typeof a === 'object' &&\n         a['@@functional/placeholder'] === true;\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2ZseWQvfi9yYW1kYS9zcmMvaW50ZXJuYWwvX2lzUGxhY2Vob2xkZXIuanM/OWU2MiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIF9pc1BsYWNlaG9sZGVyKGEpIHtcbiAgcmV0dXJuIGEgIT0gbnVsbCAmJlxuICAgICAgICAgdHlwZW9mIGEgPT09ICdvYmplY3QnICYmXG4gICAgICAgICBhWydAQGZ1bmN0aW9uYWwvcGxhY2Vob2xkZXInXSA9PT0gdHJ1ZTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9mbHlkL34vcmFtZGEvc3JjL2ludGVybmFsL19pc1BsYWNlaG9sZGVyLmpzXG4gKiogbW9kdWxlIGlkID0gNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	eval("var _curry1 = __webpack_require__(5);\nvar _isPlaceholder = __webpack_require__(6);\n\n\n/**\n * Optimized internal two-arity curry function.\n *\n * @private\n * @category Function\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\nmodule.exports = function _curry2(fn) {\n  return function f2(a, b) {\n    switch (arguments.length) {\n      case 0:\n        return f2;\n      case 1:\n        return _isPlaceholder(a) ? f2\n             : _curry1(function(_b) { return fn(a, _b); });\n      default:\n        return _isPlaceholder(a) && _isPlaceholder(b) ? f2\n             : _isPlaceholder(a) ? _curry1(function(_a) { return fn(_a, b); })\n             : _isPlaceholder(b) ? _curry1(function(_b) { return fn(a, _b); })\n             : fn(a, b);\n    }\n  };\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2ZseWQvfi9yYW1kYS9zcmMvaW50ZXJuYWwvX2N1cnJ5Mi5qcz9mNzBkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsa0JBQWtCLEVBQUU7QUFDekQ7QUFDQTtBQUNBLHlEQUF5RCxrQkFBa0IsRUFBRTtBQUM3RSx5REFBeUQsa0JBQWtCLEVBQUU7QUFDN0U7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9fY3VycnkxJyk7XG52YXIgX2lzUGxhY2Vob2xkZXIgPSByZXF1aXJlKCcuL19pc1BsYWNlaG9sZGVyJyk7XG5cblxuLyoqXG4gKiBPcHRpbWl6ZWQgaW50ZXJuYWwgdHdvLWFyaXR5IGN1cnJ5IGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjdXJyeS5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgY3VycmllZCBmdW5jdGlvbi5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBfY3VycnkyKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmMihhLCBiKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiBmMjtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIF9pc1BsYWNlaG9sZGVyKGEpID8gZjJcbiAgICAgICAgICAgICA6IF9jdXJyeTEoZnVuY3Rpb24oX2IpIHsgcmV0dXJuIGZuKGEsIF9iKTsgfSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gX2lzUGxhY2Vob2xkZXIoYSkgJiYgX2lzUGxhY2Vob2xkZXIoYikgPyBmMlxuICAgICAgICAgICAgIDogX2lzUGxhY2Vob2xkZXIoYSkgPyBfY3VycnkxKGZ1bmN0aW9uKF9hKSB7IHJldHVybiBmbihfYSwgYik7IH0pXG4gICAgICAgICAgICAgOiBfaXNQbGFjZWhvbGRlcihiKSA/IF9jdXJyeTEoZnVuY3Rpb24oX2IpIHsgcmV0dXJuIGZuKGEsIF9iKTsgfSlcbiAgICAgICAgICAgICA6IGZuKGEsIGIpO1xuICAgIH1cbiAgfTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9mbHlkL34vcmFtZGEvc3JjL2ludGVybmFsL19jdXJyeTIuanNcbiAqKiBtb2R1bGUgaWQgPSA3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	eval("var _arity = __webpack_require__(4);\nvar _isPlaceholder = __webpack_require__(6);\n\n\n/**\n * Internal curryN function.\n *\n * @private\n * @category Function\n * @param {Number} length The arity of the curried function.\n * @param {Array} received An array of arguments received thus far.\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\nmodule.exports = function _curryN(length, received, fn) {\n  return function() {\n    var combined = [];\n    var argsIdx = 0;\n    var left = length;\n    var combinedIdx = 0;\n    while (combinedIdx < received.length || argsIdx < arguments.length) {\n      var result;\n      if (combinedIdx < received.length &&\n          (!_isPlaceholder(received[combinedIdx]) ||\n           argsIdx >= arguments.length)) {\n        result = received[combinedIdx];\n      } else {\n        result = arguments[argsIdx];\n        argsIdx += 1;\n      }\n      combined[combinedIdx] = result;\n      if (!_isPlaceholder(result)) {\n        left -= 1;\n      }\n      combinedIdx += 1;\n    }\n    return left <= 0 ? fn.apply(this, combined)\n                     : _arity(left, _curryN(length, combined, fn));\n  };\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2ZseWQvfi9yYW1kYS9zcmMvaW50ZXJuYWwvX2N1cnJ5Ti5qcz9mMDM4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsU0FBUztBQUNwQixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiOC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBfYXJpdHkgPSByZXF1aXJlKCcuL19hcml0eScpO1xudmFyIF9pc1BsYWNlaG9sZGVyID0gcmVxdWlyZSgnLi9faXNQbGFjZWhvbGRlcicpO1xuXG5cbi8qKlxuICogSW50ZXJuYWwgY3VycnlOIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggVGhlIGFyaXR5IG9mIHRoZSBjdXJyaWVkIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtBcnJheX0gcmVjZWl2ZWQgQW4gYXJyYXkgb2YgYXJndW1lbnRzIHJlY2VpdmVkIHRodXMgZmFyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBjdXJyaWVkIGZ1bmN0aW9uLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIF9jdXJyeU4obGVuZ3RoLCByZWNlaXZlZCwgZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBjb21iaW5lZCA9IFtdO1xuICAgIHZhciBhcmdzSWR4ID0gMDtcbiAgICB2YXIgbGVmdCA9IGxlbmd0aDtcbiAgICB2YXIgY29tYmluZWRJZHggPSAwO1xuICAgIHdoaWxlIChjb21iaW5lZElkeCA8IHJlY2VpdmVkLmxlbmd0aCB8fCBhcmdzSWR4IDwgYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIGlmIChjb21iaW5lZElkeCA8IHJlY2VpdmVkLmxlbmd0aCAmJlxuICAgICAgICAgICghX2lzUGxhY2Vob2xkZXIocmVjZWl2ZWRbY29tYmluZWRJZHhdKSB8fFxuICAgICAgICAgICBhcmdzSWR4ID49IGFyZ3VtZW50cy5sZW5ndGgpKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlY2VpdmVkW2NvbWJpbmVkSWR4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGFyZ3VtZW50c1thcmdzSWR4XTtcbiAgICAgICAgYXJnc0lkeCArPSAxO1xuICAgICAgfVxuICAgICAgY29tYmluZWRbY29tYmluZWRJZHhdID0gcmVzdWx0O1xuICAgICAgaWYgKCFfaXNQbGFjZWhvbGRlcihyZXN1bHQpKSB7XG4gICAgICAgIGxlZnQgLT0gMTtcbiAgICAgIH1cbiAgICAgIGNvbWJpbmVkSWR4ICs9IDE7XG4gICAgfVxuICAgIHJldHVybiBsZWZ0IDw9IDAgPyBmbi5hcHBseSh0aGlzLCBjb21iaW5lZClcbiAgICAgICAgICAgICAgICAgICAgIDogX2FyaXR5KGxlZnQsIF9jdXJyeU4obGVuZ3RoLCBjb21iaW5lZCwgZm4pKTtcbiAgfTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9mbHlkL34vcmFtZGEvc3JjL2ludGVybmFsL19jdXJyeU4uanNcbiAqKiBtb2R1bGUgaWQgPSA4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.view = exports.init = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\n// Initialise state\n\n\nvar _ramda = __webpack_require__(1);\n\nvar _h = __webpack_require__(10);\n\nvar _h2 = _interopRequireDefault(_h);\n\nvar _tcomb = __webpack_require__(13);\n\nvar _tcomb2 = _interopRequireDefault(_tcomb);\n\nvar _types = __webpack_require__(69);\n\nvar _shuffle = __webpack_require__(70);\n\nvar _shuffle2 = _interopRequireDefault(_shuffle);\n\nvar _deal = __webpack_require__(71);\n\nvar _deal2 = _interopRequireDefault(_deal);\n\nvar _stock = __webpack_require__(72);\n\nvar _stock2 = _interopRequireDefault(_stock);\n\nvar _foundations = __webpack_require__(83);\n\nvar _foundations2 = _interopRequireDefault(_foundations);\n\nvar _piles = __webpack_require__(86);\n\nvar _piles2 = _interopRequireDefault(_piles);\n\nvar _waste = __webpack_require__(88);\n\nvar _waste2 = _interopRequireDefault(_waste);\n\nvar _actions = __webpack_require__(74);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar newTable = function newTable(settings) {\n  var table = (0, _deal2.default)((0, _shuffle2.default)());\n  return _extends({}, settings, { table: table, initTable: table });\n};\n\nvar init = function init() {\n  var ret = function () {\n    return newTable({ draw3: true });\n  }.call(this);\n\n  _tcomb2.default.assert(_types.Model.is(ret), 'Invalid argument ret (expected a ' + _tcomb2.default.getTypeName(_types.Model) + ')');\n\n  return ret;\n};\n\n// View\n\nvar view = (0, _ramda.curry)(function (action$, model) {\n  var _model$table = model.table;\n  var wasteHidden = _model$table.wasteHidden;\n  var wasteVisible = _model$table.wasteVisible;\n\n  if ((0, _ramda.isEmpty)(wasteVisible) && !(0, _ramda.isEmpty)(wasteHidden)) action$(_actions.Action.ShowHiddenWaste());\n\n  return (0, _h2.default)('div.table', [(0, _stock2.default)(action$, model.table.stock), (0, _waste2.default)(action$, model.table.wasteVisible), (0, _foundations2.default)(action$, model.table.foundations), (0, _piles2.default)(action$, model.table.piles)]);\n});\n\nexports.init = init;\nexports.view = view;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwLmpzPzdhYzkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQUlBOzs7O0FBQ0E7Ozs7QUFZQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUVBOzs7O0FBaEJBLElBQU0sV0FBVyxTQUFYLFFBQVcsV0FBWTtBQUMzQixNQUFNLFFBQVEsb0JBQUssd0JBQUwsQ0FBZDtBQUNBLHNCQUFZLFFBQVosSUFBc0IsWUFBdEIsRUFBNkIsV0FBVyxLQUF4QztBQUNELENBSEQ7O0FBS0EsSUFBTSxPQUFPLFNBQVAsSUFBTztBQUFBO0FBQUEsV0FBYSxTQUFTLEVBQUUsT0FBTyxJQUFULEVBQVQsQ0FBYjtBQUFBOztBQUFBOztBQUFBO0FBQUEsQ0FBYjs7OztBQVlBLElBQU0sT0FBTyxrQkFBTSxVQUFFLE9BQUYsRUFBVyxLQUFYLEVBQXNCO0FBQUEscUJBQ0QsTUFBTSxLQURMO0FBQUEsTUFDL0IsV0FEK0IsZ0JBQy9CLFdBRCtCO0FBQUEsTUFDbEIsWUFEa0IsZ0JBQ2xCLFlBRGtCOztBQUV2QyxNQUFJLG9CQUFTLFlBQVQsS0FBMkIsQ0FBQyxvQkFBUyxXQUFULENBQWhDLEVBQXdELFFBQVMsZ0JBQU8sZUFBUCxFQUFUOztBQUV4RCxTQUFPLGlCQUFHLFdBQUgsRUFBZ0IsQ0FDckIscUJBQU8sT0FBUCxFQUFnQixNQUFNLEtBQU4sQ0FBWSxLQUE1QixDQURxQixFQUVyQixxQkFBTyxPQUFQLEVBQWdCLE1BQU0sS0FBTixDQUFZLFlBQTVCLENBRnFCLEVBR3JCLDJCQUFhLE9BQWIsRUFBc0IsTUFBTSxLQUFOLENBQVksV0FBbEMsQ0FIcUIsRUFJckIscUJBQU8sT0FBUCxFQUFnQixNQUFNLEtBQU4sQ0FBWSxLQUE1QixDQUpxQixDQUFoQixDQUFQO0FBTUQsQ0FWWSxDQUFiOztRQVlTLEksR0FBQSxJO1FBQU0sSSxHQUFBLEkiLCJmaWxlIjoiOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IHsgY3VycnksIGlzRW1wdHkgfSBmcm9tICdyYW1kYSdcbmltcG9ydCBoIGZyb20gJ3NuYWJiZG9tL2gnXG5pbXBvcnQgdGNvbWIgZnJvbSAndGNvbWInXG5pbXBvcnQgeyBNb2RlbCB9IGZyb20gJ3R5cGVzJ1xuXG5cbi8vIEluaXRpYWxpc2Ugc3RhdGVcbmltcG9ydCBzaHVmZmxlIGZyb20gJ3NodWZmbGUnXG5pbXBvcnQgZGVhbCBmcm9tICdkZWFsJ1xuY29uc3QgbmV3VGFibGUgPSBzZXR0aW5ncyA9PiB7XG4gIGNvbnN0IHRhYmxlID0gZGVhbChzaHVmZmxlKCkpXG4gIHJldHVybiB7IC4uLnNldHRpbmdzLCB0YWJsZSwgaW5pdFRhYmxlOiB0YWJsZSB9XG59XG5cbmNvbnN0IGluaXQgPSAoKTogTW9kZWwgPT4gbmV3VGFibGUoeyBkcmF3MzogdHJ1ZSB9KVxuXG5cblxuXG4vLyBWaWV3XG5pbXBvcnQgc3RvY2sgZnJvbSAnY29tcG9uZW50cy9zdG9jaydcbmltcG9ydCBmb3VuZGF0aW9ucyBmcm9tICdjb21wb25lbnRzL2ZvdW5kYXRpb25zJ1xuaW1wb3J0IHBpbGVzIGZyb20gJ2NvbXBvbmVudHMvcGlsZXMnXG5pbXBvcnQgd2FzdGUgZnJvbSAnY29tcG9uZW50cy93YXN0ZSdcblxuaW1wb3J0IHsgQWN0aW9uIH0gZnJvbSAnYWN0aW9ucydcbmNvbnN0IHZpZXcgPSBjdXJyeSgoIGFjdGlvbiQsIG1vZGVsICkgPT4ge1xuICBjb25zdCB7IHdhc3RlSGlkZGVuLCB3YXN0ZVZpc2libGUgfSA9IG1vZGVsLnRhYmxlXG4gIGlmKCBpc0VtcHR5KCB3YXN0ZVZpc2libGUgKSAmJiAhaXNFbXB0eSggd2FzdGVIaWRkZW4gKSkgYWN0aW9uJCggQWN0aW9uLlNob3dIaWRkZW5XYXN0ZSgpIClcblxuICByZXR1cm4gaCggJ2Rpdi50YWJsZScsIFtcbiAgICBzdG9jayggYWN0aW9uJCwgbW9kZWwudGFibGUuc3RvY2sgKSxcbiAgICB3YXN0ZSggYWN0aW9uJCwgbW9kZWwudGFibGUud2FzdGVWaXNpYmxlICksXG4gICAgZm91bmRhdGlvbnMoIGFjdGlvbiQsIG1vZGVsLnRhYmxlLmZvdW5kYXRpb25zICksXG4gICAgcGlsZXMoIGFjdGlvbiQsIG1vZGVsLnRhYmxlLnBpbGVzIClcbiAgXSlcbn0pXG5cbmV4cG9ydCB7IGluaXQsIHZpZXcgfVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2FwcC5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	eval("var VNode = __webpack_require__(11);\nvar is = __webpack_require__(12);\n\nfunction addNS(data, children) {\n  data.ns = 'http://www.w3.org/2000/svg';\n  if (children !== undefined) {\n    for (var i = 0; i < children.length; ++i) {\n      addNS(children[i].data, children[i].children);\n    }\n  }\n}\n\nmodule.exports = function h(sel, b, c) {\n  var data = {}, children, text, i;\n  if (c !== undefined) {\n    data = b;\n    if (is.array(c)) { children = c; }\n    else if (is.primitive(c)) { text = c; }\n  } else if (b !== undefined) {\n    if (is.array(b)) { children = b; }\n    else if (is.primitive(b)) { text = b; }\n    else { data = b; }\n  }\n  if (is.array(children)) {\n    for (i = 0; i < children.length; ++i) {\n      if (is.primitive(children[i])) children[i] = VNode(undefined, undefined, undefined, children[i]);\n    }\n  }\n  if (sel[0] === 's' && sel[1] === 'v' && sel[2] === 'g') {\n    addNS(data, children);\n  }\n  return VNode(sel, data, children, text, undefined);\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3NuYWJiZG9tL2guanM/NGY5ZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxQkFBcUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDLCtCQUErQixVQUFVO0FBQ3pDLEdBQUc7QUFDSCxzQkFBc0IsY0FBYztBQUNwQywrQkFBK0IsVUFBVTtBQUN6QyxVQUFVLFVBQVU7QUFDcEI7QUFDQTtBQUNBLGVBQWUscUJBQXFCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgVk5vZGUgPSByZXF1aXJlKCcuL3Zub2RlJyk7XG52YXIgaXMgPSByZXF1aXJlKCcuL2lzJyk7XG5cbmZ1bmN0aW9uIGFkZE5TKGRhdGEsIGNoaWxkcmVuKSB7XG4gIGRhdGEubnMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuICBpZiAoY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgIGFkZE5TKGNoaWxkcmVuW2ldLmRhdGEsIGNoaWxkcmVuW2ldLmNoaWxkcmVuKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoKHNlbCwgYiwgYykge1xuICB2YXIgZGF0YSA9IHt9LCBjaGlsZHJlbiwgdGV4dCwgaTtcbiAgaWYgKGMgIT09IHVuZGVmaW5lZCkge1xuICAgIGRhdGEgPSBiO1xuICAgIGlmIChpcy5hcnJheShjKSkgeyBjaGlsZHJlbiA9IGM7IH1cbiAgICBlbHNlIGlmIChpcy5wcmltaXRpdmUoYykpIHsgdGV4dCA9IGM7IH1cbiAgfSBlbHNlIGlmIChiICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoaXMuYXJyYXkoYikpIHsgY2hpbGRyZW4gPSBiOyB9XG4gICAgZWxzZSBpZiAoaXMucHJpbWl0aXZlKGIpKSB7IHRleHQgPSBiOyB9XG4gICAgZWxzZSB7IGRhdGEgPSBiOyB9XG4gIH1cbiAgaWYgKGlzLmFycmF5KGNoaWxkcmVuKSkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKGlzLnByaW1pdGl2ZShjaGlsZHJlbltpXSkpIGNoaWxkcmVuW2ldID0gVk5vZGUodW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgfVxuICBpZiAoc2VsWzBdID09PSAncycgJiYgc2VsWzFdID09PSAndicgJiYgc2VsWzJdID09PSAnZycpIHtcbiAgICBhZGROUyhkYXRhLCBjaGlsZHJlbik7XG4gIH1cbiAgcmV0dXJuIFZOb2RlKHNlbCwgZGF0YSwgY2hpbGRyZW4sIHRleHQsIHVuZGVmaW5lZCk7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc25hYmJkb20vaC5qc1xuICoqIG1vZHVsZSBpZCA9IDEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 11 */
/***/ function(module, exports) {

	eval("module.exports = function(sel, data, children, text, elm) {\n  var key = data === undefined ? undefined : data.key;\n  return {sel: sel, data: data, children: children,\n          text: text, elm: elm, key: key};\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3NuYWJiZG9tL3Zub2RlLmpzP2NmMmEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBIiwiZmlsZSI6IjExLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzZWwsIGRhdGEsIGNoaWxkcmVuLCB0ZXh0LCBlbG0pIHtcbiAgdmFyIGtleSA9IGRhdGEgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IGRhdGEua2V5O1xuICByZXR1cm4ge3NlbDogc2VsLCBkYXRhOiBkYXRhLCBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICAgICAgdGV4dDogdGV4dCwgZWxtOiBlbG0sIGtleToga2V5fTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zbmFiYmRvbS92bm9kZS5qc1xuICoqIG1vZHVsZSBpZCA9IDExXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 12 */
/***/ function(module, exports) {

	eval("module.exports = {\n  array: Array.isArray,\n  primitive: function(s) { return typeof s === 'string' || typeof s === 'number'; },\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3NuYWJiZG9tL2lzLmpzPzBmMmMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBLDBCQUEwQix1REFBdUQsRUFBRTtBQUNuRiIsImZpbGUiOiIxMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0ge1xuICBhcnJheTogQXJyYXkuaXNBcnJheSxcbiAgcHJpbWl0aXZlOiBmdW5jdGlvbihzKSB7IHJldHVybiB0eXBlb2YgcyA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHMgPT09ICdudW1iZXInOyB9LFxufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NuYWJiZG9tL2lzLmpzXG4gKiogbW9kdWxlIGlkID0gMTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*! @preserve\n *\n * tcomb.js - Type checking and DDD for JavaScript\n *\n * The MIT License (MIT)\n *\n * Copyright (c) 2014-2016 Giulio Canti\n *\n */\n\n// core\nvar t = __webpack_require__(14);\n\n// types\nt.Any = __webpack_require__(20);\nt.Array = __webpack_require__(29);\nt.Boolean = __webpack_require__(30);\nt.Date = __webpack_require__(32);\nt.Error = __webpack_require__(33);\nt.Function = __webpack_require__(34);\nt.Nil = __webpack_require__(35);\nt.Number = __webpack_require__(36);\nt.Integer = __webpack_require__(38);\nt.Object = __webpack_require__(44);\nt.RegExp = __webpack_require__(45);\nt.String = __webpack_require__(46);\nt.Type = __webpack_require__(47);\n\n// short alias are deprecated\nt.Arr = t.Array;\nt.Bool = t.Boolean;\nt.Dat = t.Date;\nt.Err = t.Error;\nt.Func = t.Function;\nt.Num = t.Number;\nt.Obj = t.Object;\nt.Re = t.RegExp;\nt.Str = t.String;\n\n// combinators\nt.dict = __webpack_require__(48);\nt.declare = __webpack_require__(49);\nt.enums = __webpack_require__(51);\nt.irreducible = __webpack_require__(21);\nt.list = __webpack_require__(52);\nt.maybe = __webpack_require__(53);\nt.refinement = __webpack_require__(39);\nt.struct = __webpack_require__(55);\nt.tuple = __webpack_require__(61);\nt.union = __webpack_require__(62);\nt.func = __webpack_require__(64);\nt.intersection = __webpack_require__(65);\nt.subtype = t.refinement;\nt.inter = __webpack_require__(66); // IE8 alias\nt['interface'] = t.inter;\n\n// functions\nt.assert = t;\nt.update = __webpack_require__(67);\nt.mixin = __webpack_require__(50);\nt.isType = __webpack_require__(26);\nt.is = __webpack_require__(43);\nt.getTypeName = __webpack_require__(25);\nt.match = __webpack_require__(68);\n\nmodule.exports = t;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2luZGV4LmpzPzRiNzkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQXFDO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgQHByZXNlcnZlXG4gKlxuICogdGNvbWIuanMgLSBUeXBlIGNoZWNraW5nIGFuZCBEREQgZm9yIEphdmFTY3JpcHRcbiAqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNiBHaXVsaW8gQ2FudGlcbiAqXG4gKi9cblxuLy8gY29yZVxudmFyIHQgPSByZXF1aXJlKCcuL2xpYi9hc3NlcnQnKTtcblxuLy8gdHlwZXNcbnQuQW55ID0gcmVxdWlyZSgnLi9saWIvQW55Jyk7XG50LkFycmF5ID0gcmVxdWlyZSgnLi9saWIvQXJyYXknKTtcbnQuQm9vbGVhbiA9IHJlcXVpcmUoJy4vbGliL0Jvb2xlYW4nKTtcbnQuRGF0ZSA9IHJlcXVpcmUoJy4vbGliL0RhdGUnKTtcbnQuRXJyb3IgPSByZXF1aXJlKCcuL2xpYi9FcnJvcicpO1xudC5GdW5jdGlvbiA9IHJlcXVpcmUoJy4vbGliL0Z1bmN0aW9uJyk7XG50Lk5pbCA9IHJlcXVpcmUoJy4vbGliL05pbCcpO1xudC5OdW1iZXIgPSByZXF1aXJlKCcuL2xpYi9OdW1iZXInKTtcbnQuSW50ZWdlciA9IHJlcXVpcmUoJy4vbGliL0ludGVnZXInKTtcbnQuT2JqZWN0ID0gcmVxdWlyZSgnLi9saWIvT2JqZWN0Jyk7XG50LlJlZ0V4cCA9IHJlcXVpcmUoJy4vbGliL1JlZ0V4cCcpO1xudC5TdHJpbmcgPSByZXF1aXJlKCcuL2xpYi9TdHJpbmcnKTtcbnQuVHlwZSA9IHJlcXVpcmUoJy4vbGliL1R5cGUnKTtcblxuLy8gc2hvcnQgYWxpYXMgYXJlIGRlcHJlY2F0ZWRcbnQuQXJyID0gdC5BcnJheTtcbnQuQm9vbCA9IHQuQm9vbGVhbjtcbnQuRGF0ID0gdC5EYXRlO1xudC5FcnIgPSB0LkVycm9yO1xudC5GdW5jID0gdC5GdW5jdGlvbjtcbnQuTnVtID0gdC5OdW1iZXI7XG50Lk9iaiA9IHQuT2JqZWN0O1xudC5SZSA9IHQuUmVnRXhwO1xudC5TdHIgPSB0LlN0cmluZztcblxuLy8gY29tYmluYXRvcnNcbnQuZGljdCA9IHJlcXVpcmUoJy4vbGliL2RpY3QnKTtcbnQuZGVjbGFyZSA9IHJlcXVpcmUoJy4vbGliL2RlY2xhcmUnKTtcbnQuZW51bXMgPSByZXF1aXJlKCcuL2xpYi9lbnVtcycpO1xudC5pcnJlZHVjaWJsZSA9IHJlcXVpcmUoJy4vbGliL2lycmVkdWNpYmxlJyk7XG50Lmxpc3QgPSByZXF1aXJlKCcuL2xpYi9saXN0Jyk7XG50Lm1heWJlID0gcmVxdWlyZSgnLi9saWIvbWF5YmUnKTtcbnQucmVmaW5lbWVudCA9IHJlcXVpcmUoJy4vbGliL3JlZmluZW1lbnQnKTtcbnQuc3RydWN0ID0gcmVxdWlyZSgnLi9saWIvc3RydWN0Jyk7XG50LnR1cGxlID0gcmVxdWlyZSgnLi9saWIvdHVwbGUnKTtcbnQudW5pb24gPSByZXF1aXJlKCcuL2xpYi91bmlvbicpO1xudC5mdW5jID0gcmVxdWlyZSgnLi9saWIvZnVuYycpO1xudC5pbnRlcnNlY3Rpb24gPSByZXF1aXJlKCcuL2xpYi9pbnRlcnNlY3Rpb24nKTtcbnQuc3VidHlwZSA9IHQucmVmaW5lbWVudDtcbnQuaW50ZXIgPSByZXF1aXJlKCcuL2xpYi9pbnRlcmZhY2UnKTsgLy8gSUU4IGFsaWFzXG50WydpbnRlcmZhY2UnXSA9IHQuaW50ZXI7XG5cbi8vIGZ1bmN0aW9uc1xudC5hc3NlcnQgPSB0O1xudC51cGRhdGUgPSByZXF1aXJlKCcuL2xpYi91cGRhdGUnKTtcbnQubWl4aW4gPSByZXF1aXJlKCcuL2xpYi9taXhpbicpO1xudC5pc1R5cGUgPSByZXF1aXJlKCcuL2xpYi9pc1R5cGUnKTtcbnQuaXMgPSByZXF1aXJlKCcuL2xpYi9pcycpO1xudC5nZXRUeXBlTmFtZSA9IHJlcXVpcmUoJy4vbGliL2dldFR5cGVOYW1lJyk7XG50Lm1hdGNoID0gcmVxdWlyZSgnLi9saWIvbWF0Y2gnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB0O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdGNvbWIvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	eval("var isFunction = __webpack_require__(15);\nvar isNil = __webpack_require__(16);\nvar fail = __webpack_require__(17);\nvar stringify = __webpack_require__(18);\n\nfunction assert(guard, message) {\n  if (guard !== true) {\n    if (isFunction(message)) { // handle lazy messages\n      message = message();\n    }\n    else if (isNil(message)) { // use a default message\n      message = 'Assert failed (turn on \"Pause on exceptions\" in your Source panel)';\n    }\n    assert.fail(message);\n  }\n}\n\nassert.fail = fail;\nassert.stringify = stringify;\n\nmodule.exports = assert;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi9hc3NlcnQuanM/MzY1NSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBIiwiZmlsZSI6IjE0LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKTtcbnZhciBpc05pbCA9IHJlcXVpcmUoJy4vaXNOaWwnKTtcbnZhciBmYWlsID0gcmVxdWlyZSgnLi9mYWlsJyk7XG52YXIgc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9zdHJpbmdpZnknKTtcblxuZnVuY3Rpb24gYXNzZXJ0KGd1YXJkLCBtZXNzYWdlKSB7XG4gIGlmIChndWFyZCAhPT0gdHJ1ZSkge1xuICAgIGlmIChpc0Z1bmN0aW9uKG1lc3NhZ2UpKSB7IC8vIGhhbmRsZSBsYXp5IG1lc3NhZ2VzXG4gICAgICBtZXNzYWdlID0gbWVzc2FnZSgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc05pbChtZXNzYWdlKSkgeyAvLyB1c2UgYSBkZWZhdWx0IG1lc3NhZ2VcbiAgICAgIG1lc3NhZ2UgPSAnQXNzZXJ0IGZhaWxlZCAodHVybiBvbiBcIlBhdXNlIG9uIGV4Y2VwdGlvbnNcIiBpbiB5b3VyIFNvdXJjZSBwYW5lbCknO1xuICAgIH1cbiAgICBhc3NlcnQuZmFpbChtZXNzYWdlKTtcbiAgfVxufVxuXG5hc3NlcnQuZmFpbCA9IGZhaWw7XG5hc3NlcnQuc3RyaW5naWZ5ID0gc3RyaW5naWZ5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2VydDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi90Y29tYi9saWIvYXNzZXJ0LmpzXG4gKiogbW9kdWxlIGlkID0gMTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 15 */
/***/ function(module, exports) {

	eval("module.exports = function isFunction(x) {\n  return typeof x === 'function';\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi9pc0Z1bmN0aW9uLmpzPzFjMDIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBIiwiZmlsZSI6IjE1LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0Z1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi90Y29tYi9saWIvaXNGdW5jdGlvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDE1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 16 */
/***/ function(module, exports) {

	eval("module.exports = function isNil(x) {\n  return x === null || x === void 0;\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi9pc05pbC5qcz85ZjdkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSIsImZpbGUiOiIxNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNOaWwoeCkge1xuICByZXR1cm4geCA9PT0gbnVsbCB8fCB4ID09PSB2b2lkIDA7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Rjb21iL2xpYi9pc05pbC5qc1xuICoqIG1vZHVsZSBpZCA9IDE2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 17 */
/***/ function(module, exports) {

	eval("module.exports = function fail(message) {\n  throw new TypeError('[tcomb] ' + message);\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi9mYWlsLmpzP2E2NzYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBIiwiZmlsZSI6IjE3LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmYWlsKG1lc3NhZ2UpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignW3Rjb21iXSAnICsgbWVzc2FnZSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Rjb21iL2xpYi9mYWlsLmpzXG4gKiogbW9kdWxlIGlkID0gMTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	eval("var getFunctionName = __webpack_require__(19);\n\nfunction replacer(key, value) {\n  if (typeof value === 'function') {\n    return getFunctionName(value);\n  }\n  return value;\n}\n\nmodule.exports = function stringify(x) {\n  try { // handle \"Converting circular structure to JSON\" error\n    return JSON.stringify(x, replacer, 2);\n  }\n  catch (e) {\n    return String(x);\n  }\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi9zdHJpbmdpZnkuanM/Zjg3YiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjE4LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGdldEZ1bmN0aW9uTmFtZSA9IHJlcXVpcmUoJy4vZ2V0RnVuY3Rpb25OYW1lJyk7XG5cbmZ1bmN0aW9uIHJlcGxhY2VyKGtleSwgdmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBnZXRGdW5jdGlvbk5hbWUodmFsdWUpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzdHJpbmdpZnkoeCkge1xuICB0cnkgeyAvLyBoYW5kbGUgXCJDb252ZXJ0aW5nIGNpcmN1bGFyIHN0cnVjdHVyZSB0byBKU09OXCIgZXJyb3JcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoeCwgcmVwbGFjZXIsIDIpO1xuICB9XG4gIGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIFN0cmluZyh4KTtcbiAgfVxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi90Y29tYi9saWIvc3RyaW5naWZ5LmpzXG4gKiogbW9kdWxlIGlkID0gMThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 19 */
/***/ function(module, exports) {

	eval("module.exports = function getFunctionName(f) {\n  return f.displayName || f.name || '<function' + f.length + '>';\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi9nZXRGdW5jdGlvbk5hbWUuanM/NGMxMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldEZ1bmN0aW9uTmFtZShmKSB7XG4gIHJldHVybiBmLmRpc3BsYXlOYW1lIHx8IGYubmFtZSB8fCAnPGZ1bmN0aW9uJyArIGYubGVuZ3RoICsgJz4nO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi90Y29tYi9saWIvZ2V0RnVuY3Rpb25OYW1lLmpzXG4gKiogbW9kdWxlIGlkID0gMTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	eval("var irreducible = __webpack_require__(21);\n\nmodule.exports = irreducible('Any', function () { return true; });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi9BbnkuanM/OGFjNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQSxpREFBaUQsYUFBYSxFQUFFIiwiZmlsZSI6IjIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGlycmVkdWNpYmxlID0gcmVxdWlyZSgnLi9pcnJlZHVjaWJsZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlycmVkdWNpYmxlKCdBbnknLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9KTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Rjb21iL2xpYi9BbnkuanNcbiAqKiBtb2R1bGUgaWQgPSAyMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {var assert = __webpack_require__(14);\nvar isString = __webpack_require__(23);\nvar isFunction = __webpack_require__(15);\nvar forbidNewOperator = __webpack_require__(24);\n\nmodule.exports = function irreducible(name, predicate) {\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(isString(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to irreducible(name, predicate) (expected a string)'; });\n    assert(isFunction(predicate), 'Invalid argument predicate ' + assert.stringify(predicate) + ' supplied to irreducible(name, predicate) (expected a function)');\n  }\n\n  function Irreducible(value, path) {\n\n    if (process.env.NODE_ENV !== 'production') {\n      forbidNewOperator(this, Irreducible);\n      path = path || [name];\n      assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });\n    }\n\n    return value;\n  }\n\n  Irreducible.meta = {\n    kind: 'irreducible',\n    name: name,\n    predicate: predicate,\n    identity: true\n  };\n\n  Irreducible.displayName = name;\n\n  Irreducible.is = predicate;\n\n  return Irreducible;\n};\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi9pcnJlZHVjaWJsZS5qcz82ZDYxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esd0NBQXdDLDRIQUE0SCxFQUFFO0FBQ3RLO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHNGQUFzRixFQUFFO0FBQ3BJOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EiLCJmaWxlIjoiMjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXNzZXJ0ID0gcmVxdWlyZSgnLi9hc3NlcnQnKTtcbnZhciBpc1N0cmluZyA9IHJlcXVpcmUoJy4vaXNTdHJpbmcnKTtcbnZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyk7XG52YXIgZm9yYmlkTmV3T3BlcmF0b3IgPSByZXF1aXJlKCcuL2ZvcmJpZE5ld09wZXJhdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXJyZWR1Y2libGUobmFtZSwgcHJlZGljYXRlKSB7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnQoaXNTdHJpbmcobmFtZSksIGZ1bmN0aW9uICgpIHsgcmV0dXJuICdJbnZhbGlkIGFyZ3VtZW50IG5hbWUgJyArIGFzc2VydC5zdHJpbmdpZnkobmFtZSkgKyAnIHN1cHBsaWVkIHRvIGlycmVkdWNpYmxlKG5hbWUsIHByZWRpY2F0ZSkgKGV4cGVjdGVkIGEgc3RyaW5nKSc7IH0pO1xuICAgIGFzc2VydChpc0Z1bmN0aW9uKHByZWRpY2F0ZSksICdJbnZhbGlkIGFyZ3VtZW50IHByZWRpY2F0ZSAnICsgYXNzZXJ0LnN0cmluZ2lmeShwcmVkaWNhdGUpICsgJyBzdXBwbGllZCB0byBpcnJlZHVjaWJsZShuYW1lLCBwcmVkaWNhdGUpIChleHBlY3RlZCBhIGZ1bmN0aW9uKScpO1xuICB9XG5cbiAgZnVuY3Rpb24gSXJyZWR1Y2libGUodmFsdWUsIHBhdGgpIHtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBmb3JiaWROZXdPcGVyYXRvcih0aGlzLCBJcnJlZHVjaWJsZSk7XG4gICAgICBwYXRoID0gcGF0aCB8fCBbbmFtZV07XG4gICAgICBhc3NlcnQocHJlZGljYXRlKHZhbHVlKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0ludmFsaWQgdmFsdWUgJyArIGFzc2VydC5zdHJpbmdpZnkodmFsdWUpICsgJyBzdXBwbGllZCB0byAnICsgcGF0aC5qb2luKCcvJyk7IH0pO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIElycmVkdWNpYmxlLm1ldGEgPSB7XG4gICAga2luZDogJ2lycmVkdWNpYmxlJyxcbiAgICBuYW1lOiBuYW1lLFxuICAgIHByZWRpY2F0ZTogcHJlZGljYXRlLFxuICAgIGlkZW50aXR5OiB0cnVlXG4gIH07XG5cbiAgSXJyZWR1Y2libGUuZGlzcGxheU5hbWUgPSBuYW1lO1xuXG4gIElycmVkdWNpYmxlLmlzID0gcHJlZGljYXRlO1xuXG4gIHJldHVybiBJcnJlZHVjaWJsZTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi90Y29tYi9saWIvaXJyZWR1Y2libGUuanNcbiAqKiBtb2R1bGUgaWQgPSAyMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 22 */
/***/ function(module, exports) {

	eval("// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2Nlc3MvYnJvd3Nlci5qcz84MmU0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVUiLCJmaWxlIjoiMjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgc2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Byb2Nlc3MvYnJvd3Nlci5qc1xuICoqIG1vZHVsZSBpZCA9IDIyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 23 */
/***/ function(module, exports) {

	eval("module.exports = function isString(x) {\n  return typeof x === 'string';\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi9pc1N0cmluZy5qcz85MGU5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSIsImZpbGUiOiIyMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNTdHJpbmcoeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09ICdzdHJpbmcnO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi90Y29tYi9saWIvaXNTdHJpbmcuanNcbiAqKiBtb2R1bGUgaWQgPSAyM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	eval("var assert = __webpack_require__(14);\nvar getTypeName = __webpack_require__(25);\n\nmodule.exports = function forbidNewOperator(x, type) {\n  assert(!(x instanceof type), function () { return 'Cannot use the new operator to instantiate the type ' + getTypeName(type); });\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi9mb3JiaWROZXdPcGVyYXRvci5qcz83Y2M3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMsbUZBQW1GLEVBQUU7QUFDakkiLCJmaWxlIjoiMjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXNzZXJ0ID0gcmVxdWlyZSgnLi9hc3NlcnQnKTtcbnZhciBnZXRUeXBlTmFtZSA9IHJlcXVpcmUoJy4vZ2V0VHlwZU5hbWUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmb3JiaWROZXdPcGVyYXRvcih4LCB0eXBlKSB7XG4gIGFzc2VydCghKHggaW5zdGFuY2VvZiB0eXBlKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0Nhbm5vdCB1c2UgdGhlIG5ldyBvcGVyYXRvciB0byBpbnN0YW50aWF0ZSB0aGUgdHlwZSAnICsgZ2V0VHlwZU5hbWUodHlwZSk7IH0pO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi90Y29tYi9saWIvZm9yYmlkTmV3T3BlcmF0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSAyNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	eval("var isType = __webpack_require__(26);\nvar getFunctionName = __webpack_require__(19);\n\nmodule.exports = function getTypeName(constructor) {\n  if (isType(constructor)) {\n    return constructor.displayName;\n  }\n  return getFunctionName(constructor);\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi9nZXRUeXBlTmFtZS5qcz9hYjliIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjI1LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGlzVHlwZSA9IHJlcXVpcmUoJy4vaXNUeXBlJyk7XG52YXIgZ2V0RnVuY3Rpb25OYW1lID0gcmVxdWlyZSgnLi9nZXRGdW5jdGlvbk5hbWUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRUeXBlTmFtZShjb25zdHJ1Y3Rvcikge1xuICBpZiAoaXNUeXBlKGNvbnN0cnVjdG9yKSkge1xuICAgIHJldHVybiBjb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZTtcbiAgfVxuICByZXR1cm4gZ2V0RnVuY3Rpb25OYW1lKGNvbnN0cnVjdG9yKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdGNvbWIvbGliL2dldFR5cGVOYW1lLmpzXG4gKiogbW9kdWxlIGlkID0gMjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	eval("var isFunction = __webpack_require__(15);\nvar isObject = __webpack_require__(27);\n\nmodule.exports = function isType(x) {\n  return isFunction(x) && isObject(x.meta);\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi9pc1R5cGUuanM/ZTJhMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiIyNi5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNUeXBlKHgpIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24oeCkgJiYgaXNPYmplY3QoeC5tZXRhKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdGNvbWIvbGliL2lzVHlwZS5qc1xuICoqIG1vZHVsZSBpZCA9IDI2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	eval("var isNil = __webpack_require__(16);\nvar isArray = __webpack_require__(28);\n\nmodule.exports = function isObject(x) {\n  return !isNil(x) && typeof x === 'object' && !isArray(x);\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi9pc09iamVjdC5qcz83OGE1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6IjI3LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGlzTmlsID0gcmVxdWlyZSgnLi9pc05pbCcpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc09iamVjdCh4KSB7XG4gIHJldHVybiAhaXNOaWwoeCkgJiYgdHlwZW9mIHggPT09ICdvYmplY3QnICYmICFpc0FycmF5KHgpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi90Y29tYi9saWIvaXNPYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSAyN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 28 */
/***/ function(module, exports) {

	eval("module.exports = function isArray(x) {\n  return x instanceof Array;\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi9pc0FycmF5LmpzP2Y2MDgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBIiwiZmlsZSI6IjI4LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0FycmF5KHgpIHtcbiAgcmV0dXJuIHggaW5zdGFuY2VvZiBBcnJheTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdGNvbWIvbGliL2lzQXJyYXkuanNcbiAqKiBtb2R1bGUgaWQgPSAyOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	eval("var irreducible = __webpack_require__(21);\nvar isArray = __webpack_require__(28);\n\nmodule.exports = irreducible('Array', isArray);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi9BcnJheS5qcz82MTgyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMjkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgaXJyZWR1Y2libGUgPSByZXF1aXJlKCcuL2lycmVkdWNpYmxlJyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlycmVkdWNpYmxlKCdBcnJheScsIGlzQXJyYXkpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdGNvbWIvbGliL0FycmF5LmpzXG4gKiogbW9kdWxlIGlkID0gMjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	eval("var irreducible = __webpack_require__(21);\nvar isBoolean = __webpack_require__(31);\n\nmodule.exports = irreducible('Boolean', isBoolean);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi9Cb29sZWFuLmpzPzMwODUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQSIsImZpbGUiOiIzMC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBpcnJlZHVjaWJsZSA9IHJlcXVpcmUoJy4vaXJyZWR1Y2libGUnKTtcbnZhciBpc0Jvb2xlYW4gPSByZXF1aXJlKCcuL2lzQm9vbGVhbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlycmVkdWNpYmxlKCdCb29sZWFuJywgaXNCb29sZWFuKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Rjb21iL2xpYi9Cb29sZWFuLmpzXG4gKiogbW9kdWxlIGlkID0gMzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 31 */
/***/ function(module, exports) {

	eval("module.exports = function isBoolean(x) {\n  return x === true || x === false;\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi9pc0Jvb2xlYW4uanM/MTUxMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMzEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQm9vbGVhbih4KSB7XG4gIHJldHVybiB4ID09PSB0cnVlIHx8IHggPT09IGZhbHNlO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi90Y29tYi9saWIvaXNCb29sZWFuLmpzXG4gKiogbW9kdWxlIGlkID0gMzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	eval("var irreducible = __webpack_require__(21);\n\nmodule.exports = irreducible('Date', function (x) { return x instanceof Date; });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi9EYXRlLmpzPzRmMDQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUEsbURBQW1ELDBCQUEwQixFQUFFIiwiZmlsZSI6IjMyLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGlycmVkdWNpYmxlID0gcmVxdWlyZSgnLi9pcnJlZHVjaWJsZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlycmVkdWNpYmxlKCdEYXRlJywgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggaW5zdGFuY2VvZiBEYXRlOyB9KTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Rjb21iL2xpYi9EYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gMzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	eval("var irreducible = __webpack_require__(21);\n\nmodule.exports = irreducible('Error', function (x) { return x instanceof Error; });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi9FcnJvci5qcz9kMWY0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLG9EQUFvRCwyQkFBMkIsRUFBRSIsImZpbGUiOiIzMy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBpcnJlZHVjaWJsZSA9IHJlcXVpcmUoJy4vaXJyZWR1Y2libGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBpcnJlZHVjaWJsZSgnRXJyb3InLCBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCBpbnN0YW5jZW9mIEVycm9yOyB9KTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Rjb21iL2xpYi9FcnJvci5qc1xuICoqIG1vZHVsZSBpZCA9IDMzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	eval("var irreducible = __webpack_require__(21);\nvar isFunction = __webpack_require__(15);\n\nmodule.exports = irreducible('Function', isFunction);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi9GdW5jdGlvbi5qcz8zNGFkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMzQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgaXJyZWR1Y2libGUgPSByZXF1aXJlKCcuL2lycmVkdWNpYmxlJyk7XG52YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlycmVkdWNpYmxlKCdGdW5jdGlvbicsIGlzRnVuY3Rpb24pO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdGNvbWIvbGliL0Z1bmN0aW9uLmpzXG4gKiogbW9kdWxlIGlkID0gMzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	eval("var irreducible = __webpack_require__(21);\nvar isNil = __webpack_require__(16);\n\nmodule.exports = irreducible('Nil', isNil);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi9OaWwuanM/ZGU1MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBIiwiZmlsZSI6IjM1LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGlycmVkdWNpYmxlID0gcmVxdWlyZSgnLi9pcnJlZHVjaWJsZScpO1xudmFyIGlzTmlsID0gcmVxdWlyZSgnLi9pc05pbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlycmVkdWNpYmxlKCdOaWwnLCBpc05pbCk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi90Y29tYi9saWIvTmlsLmpzXG4gKiogbW9kdWxlIGlkID0gMzVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	eval("var irreducible = __webpack_require__(21);\nvar isNumber = __webpack_require__(37);\n\nmodule.exports = irreducible('Number', isNumber);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi9OdW1iZXIuanM/ZmY5YiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBIiwiZmlsZSI6IjM2LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGlycmVkdWNpYmxlID0gcmVxdWlyZSgnLi9pcnJlZHVjaWJsZScpO1xudmFyIGlzTnVtYmVyID0gcmVxdWlyZSgnLi9pc051bWJlcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlycmVkdWNpYmxlKCdOdW1iZXInLCBpc051bWJlcik7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi90Y29tYi9saWIvTnVtYmVyLmpzXG4gKiogbW9kdWxlIGlkID0gMzZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 37 */
/***/ function(module, exports) {

	eval("module.exports = function isNumber(x) {\n  return typeof x === 'number' && isFinite(x) && !isNaN(x);\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi9pc051bWJlci5qcz9lZTU5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSIsImZpbGUiOiIzNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNOdW1iZXIoeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09ICdudW1iZXInICYmIGlzRmluaXRlKHgpICYmICFpc05hTih4KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdGNvbWIvbGliL2lzTnVtYmVyLmpzXG4gKiogbW9kdWxlIGlkID0gMzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	eval("var refinement = __webpack_require__(39);\nvar Number = __webpack_require__(36);\n\nmodule.exports = refinement(Number, function (x) { return x % 1 === 0; }, 'Integer');\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi9JbnRlZ2VyLmpzP2VjZWIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQSxrREFBa0Qsb0JBQW9CLEVBQUUiLCJmaWxlIjoiMzguanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcmVmaW5lbWVudCA9IHJlcXVpcmUoJy4vcmVmaW5lbWVudCcpO1xudmFyIE51bWJlciA9IHJlcXVpcmUoJy4vTnVtYmVyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVmaW5lbWVudChOdW1iZXIsIGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ICUgMSA9PT0gMDsgfSwgJ0ludGVnZXInKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Rjb21iL2xpYi9JbnRlZ2VyLmpzXG4gKiogbW9kdWxlIGlkID0gMzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {var assert = __webpack_require__(14);\nvar isTypeName = __webpack_require__(40);\nvar isFunction = __webpack_require__(15);\nvar forbidNewOperator = __webpack_require__(24);\nvar isIdentity = __webpack_require__(41);\nvar create = __webpack_require__(42);\nvar is = __webpack_require__(43);\nvar getTypeName = __webpack_require__(25);\nvar getFunctionName = __webpack_require__(19);\n\nfunction getDefaultName(type, predicate) {\n  return '{' + getTypeName(type) + ' | ' + getFunctionName(predicate) + '}';\n}\n\nfunction refinement(type, predicate, name) {\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(isFunction(type), function () { return 'Invalid argument type ' + assert.stringify(type) + ' supplied to refinement(type, predicate, [name]) combinator (expected a type)'; });\n    assert(isFunction(predicate), function () { return 'Invalid argument predicate supplied to refinement(type, predicate, [name]) combinator (expected a function)'; });\n    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to refinement(type, predicate, [name]) combinator (expected a string)'; });\n  }\n\n  var displayName = name || getDefaultName(type, predicate);\n  var identity = isIdentity(type);\n\n  function Refinement(value, path) {\n\n    if (process.env.NODE_ENV !== 'production') {\n      forbidNewOperator(this, Refinement);\n      path = path || [displayName];\n    }\n\n    var x = create(type, value, path);\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert(predicate(x), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });\n    }\n\n    return x;\n  }\n\n  Refinement.meta = {\n    kind: 'subtype',\n    type: type,\n    predicate: predicate,\n    name: name,\n    identity: identity\n  };\n\n  Refinement.displayName = displayName;\n\n  Refinement.is = function (x) {\n    return is(x, type) && predicate(x);\n  };\n\n  Refinement.update = function (instance, patch) {\n    return Refinement(assert.update(instance, patch));\n  };\n\n  return Refinement;\n}\n\nrefinement.getDefaultName = getDefaultName;\nmodule.exports = refinement;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi9yZWZpbmVtZW50LmpzP2M3MDMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVywrREFBK0Q7QUFDMUU7O0FBRUE7O0FBRUE7QUFDQSwwQ0FBMEMsNElBQTRJLEVBQUU7QUFDeEwsK0NBQStDLHNIQUFzSCxFQUFFO0FBQ3ZLLDBDQUEwQyw4SUFBOEksRUFBRTtBQUMxTDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esd0NBQXdDLHNGQUFzRixFQUFFO0FBQ2hJOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EiLCJmaWxlIjoiMzkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXNzZXJ0ID0gcmVxdWlyZSgnLi9hc3NlcnQnKTtcbnZhciBpc1R5cGVOYW1lID0gcmVxdWlyZSgnLi9pc1R5cGVOYW1lJyk7XG52YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpO1xudmFyIGZvcmJpZE5ld09wZXJhdG9yID0gcmVxdWlyZSgnLi9mb3JiaWROZXdPcGVyYXRvcicpO1xudmFyIGlzSWRlbnRpdHkgPSByZXF1aXJlKCcuL2lzSWRlbnRpdHknKTtcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuL2NyZWF0ZScpO1xudmFyIGlzID0gcmVxdWlyZSgnLi9pcycpO1xudmFyIGdldFR5cGVOYW1lID0gcmVxdWlyZSgnLi9nZXRUeXBlTmFtZScpO1xudmFyIGdldEZ1bmN0aW9uTmFtZSA9IHJlcXVpcmUoJy4vZ2V0RnVuY3Rpb25OYW1lJyk7XG5cbmZ1bmN0aW9uIGdldERlZmF1bHROYW1lKHR5cGUsIHByZWRpY2F0ZSkge1xuICByZXR1cm4gJ3snICsgZ2V0VHlwZU5hbWUodHlwZSkgKyAnIHwgJyArIGdldEZ1bmN0aW9uTmFtZShwcmVkaWNhdGUpICsgJ30nO1xufVxuXG5mdW5jdGlvbiByZWZpbmVtZW50KHR5cGUsIHByZWRpY2F0ZSwgbmFtZSkge1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0KGlzRnVuY3Rpb24odHlwZSksIGZ1bmN0aW9uICgpIHsgcmV0dXJuICdJbnZhbGlkIGFyZ3VtZW50IHR5cGUgJyArIGFzc2VydC5zdHJpbmdpZnkodHlwZSkgKyAnIHN1cHBsaWVkIHRvIHJlZmluZW1lbnQodHlwZSwgcHJlZGljYXRlLCBbbmFtZV0pIGNvbWJpbmF0b3IgKGV4cGVjdGVkIGEgdHlwZSknOyB9KTtcbiAgICBhc3NlcnQoaXNGdW5jdGlvbihwcmVkaWNhdGUpLCBmdW5jdGlvbiAoKSB7IHJldHVybiAnSW52YWxpZCBhcmd1bWVudCBwcmVkaWNhdGUgc3VwcGxpZWQgdG8gcmVmaW5lbWVudCh0eXBlLCBwcmVkaWNhdGUsIFtuYW1lXSkgY29tYmluYXRvciAoZXhwZWN0ZWQgYSBmdW5jdGlvbiknOyB9KTtcbiAgICBhc3NlcnQoaXNUeXBlTmFtZShuYW1lKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0ludmFsaWQgYXJndW1lbnQgbmFtZSAnICsgYXNzZXJ0LnN0cmluZ2lmeShuYW1lKSArICcgc3VwcGxpZWQgdG8gcmVmaW5lbWVudCh0eXBlLCBwcmVkaWNhdGUsIFtuYW1lXSkgY29tYmluYXRvciAoZXhwZWN0ZWQgYSBzdHJpbmcpJzsgfSk7XG4gIH1cblxuICB2YXIgZGlzcGxheU5hbWUgPSBuYW1lIHx8IGdldERlZmF1bHROYW1lKHR5cGUsIHByZWRpY2F0ZSk7XG4gIHZhciBpZGVudGl0eSA9IGlzSWRlbnRpdHkodHlwZSk7XG5cbiAgZnVuY3Rpb24gUmVmaW5lbWVudCh2YWx1ZSwgcGF0aCkge1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGZvcmJpZE5ld09wZXJhdG9yKHRoaXMsIFJlZmluZW1lbnQpO1xuICAgICAgcGF0aCA9IHBhdGggfHwgW2Rpc3BsYXlOYW1lXTtcbiAgICB9XG5cbiAgICB2YXIgeCA9IGNyZWF0ZSh0eXBlLCB2YWx1ZSwgcGF0aCk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgYXNzZXJ0KHByZWRpY2F0ZSh4KSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0ludmFsaWQgdmFsdWUgJyArIGFzc2VydC5zdHJpbmdpZnkodmFsdWUpICsgJyBzdXBwbGllZCB0byAnICsgcGF0aC5qb2luKCcvJyk7IH0pO1xuICAgIH1cblxuICAgIHJldHVybiB4O1xuICB9XG5cbiAgUmVmaW5lbWVudC5tZXRhID0ge1xuICAgIGtpbmQ6ICdzdWJ0eXBlJyxcbiAgICB0eXBlOiB0eXBlLFxuICAgIHByZWRpY2F0ZTogcHJlZGljYXRlLFxuICAgIG5hbWU6IG5hbWUsXG4gICAgaWRlbnRpdHk6IGlkZW50aXR5XG4gIH07XG5cbiAgUmVmaW5lbWVudC5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xuXG4gIFJlZmluZW1lbnQuaXMgPSBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiBpcyh4LCB0eXBlKSAmJiBwcmVkaWNhdGUoeCk7XG4gIH07XG5cbiAgUmVmaW5lbWVudC51cGRhdGUgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIHBhdGNoKSB7XG4gICAgcmV0dXJuIFJlZmluZW1lbnQoYXNzZXJ0LnVwZGF0ZShpbnN0YW5jZSwgcGF0Y2gpKTtcbiAgfTtcblxuICByZXR1cm4gUmVmaW5lbWVudDtcbn1cblxucmVmaW5lbWVudC5nZXREZWZhdWx0TmFtZSA9IGdldERlZmF1bHROYW1lO1xubW9kdWxlLmV4cG9ydHMgPSByZWZpbmVtZW50O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdGNvbWIvbGliL3JlZmluZW1lbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAzOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	eval("var isNil = __webpack_require__(16);\nvar isString = __webpack_require__(23);\n\nmodule.exports = function isTypeName(name) {\n  return isNil(name) || isString(name);\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi9pc1R5cGVOYW1lLmpzPzNlNDIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNDAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgaXNOaWwgPSByZXF1aXJlKCcuL2lzTmlsJyk7XG52YXIgaXNTdHJpbmcgPSByZXF1aXJlKCcuL2lzU3RyaW5nJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNUeXBlTmFtZShuYW1lKSB7XG4gIHJldHVybiBpc05pbChuYW1lKSB8fCBpc1N0cmluZyhuYW1lKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdGNvbWIvbGliL2lzVHlwZU5hbWUuanNcbiAqKiBtb2R1bGUgaWQgPSA0MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {var assert = __webpack_require__(14);\nvar Boolean = __webpack_require__(30);\nvar isType = __webpack_require__(26);\nvar getTypeName = __webpack_require__(25);\n\n// return true if the type constructor behaves like the identity function\nmodule.exports = function isIdentity(type) {\n  if (isType(type)) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(Boolean.is(type.meta.identity), function () { return 'Invalid meta identity ' + assert.stringify(type.meta.identity) + ' supplied to type ' + getTypeName(type); });\n    }\n    return type.meta.identity;\n  }\n  // for tcomb the other constructors, like ES6 classes, are identity-like\n  return true;\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi9pc0lkZW50aXR5LmpzPzFkOGQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsbUhBQW1ILEVBQUU7QUFDL0s7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEUiLCJmaWxlIjoiNDEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXNzZXJ0ID0gcmVxdWlyZSgnLi9hc3NlcnQnKTtcbnZhciBCb29sZWFuID0gcmVxdWlyZSgnLi9Cb29sZWFuJyk7XG52YXIgaXNUeXBlID0gcmVxdWlyZSgnLi9pc1R5cGUnKTtcbnZhciBnZXRUeXBlTmFtZSA9IHJlcXVpcmUoJy4vZ2V0VHlwZU5hbWUnKTtcblxuLy8gcmV0dXJuIHRydWUgaWYgdGhlIHR5cGUgY29uc3RydWN0b3IgYmVoYXZlcyBsaWtlIHRoZSBpZGVudGl0eSBmdW5jdGlvblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0lkZW50aXR5KHR5cGUpIHtcbiAgaWYgKGlzVHlwZSh0eXBlKSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBhc3NlcnQoQm9vbGVhbi5pcyh0eXBlLm1ldGEuaWRlbnRpdHkpLCBmdW5jdGlvbiAoKSB7IHJldHVybiAnSW52YWxpZCBtZXRhIGlkZW50aXR5ICcgKyBhc3NlcnQuc3RyaW5naWZ5KHR5cGUubWV0YS5pZGVudGl0eSkgKyAnIHN1cHBsaWVkIHRvIHR5cGUgJyArIGdldFR5cGVOYW1lKHR5cGUpOyB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGUubWV0YS5pZGVudGl0eTtcbiAgfVxuICAvLyBmb3IgdGNvbWIgdGhlIG90aGVyIGNvbnN0cnVjdG9ycywgbGlrZSBFUzYgY2xhc3NlcywgYXJlIGlkZW50aXR5LWxpa2VcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Rjb21iL2xpYi9pc0lkZW50aXR5LmpzXG4gKiogbW9kdWxlIGlkID0gNDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {var isType = __webpack_require__(26);\nvar getFunctionName = __webpack_require__(19);\nvar assert = __webpack_require__(14);\nvar stringify = __webpack_require__(18);\n\n// creates an instance of a type, handling the optional new operator\nmodule.exports = function create(type, value, path) {\n  if (isType(type)) {\n    // for structs the new operator is allowed\n    return type.meta.kind === 'struct' ? new type(value, path) : type(value, path);\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    // here type should be a class constructor and value some instance, just check membership and return the value\n    path = path || [getFunctionName(type)];\n    assert(value instanceof type, function () { return 'Invalid value ' + stringify(value) + ' supplied to ' + path.join('/'); });\n  }\n\n  return value;\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi9jcmVhdGUuanM/MzQ1ZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLCtFQUErRSxFQUFFO0FBQ2hJOztBQUVBO0FBQ0EsRSIsImZpbGUiOiI0Mi5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBpc1R5cGUgPSByZXF1aXJlKCcuL2lzVHlwZScpO1xudmFyIGdldEZ1bmN0aW9uTmFtZSA9IHJlcXVpcmUoJy4vZ2V0RnVuY3Rpb25OYW1lJyk7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnLi9hc3NlcnQnKTtcbnZhciBzdHJpbmdpZnkgPSByZXF1aXJlKCcuL3N0cmluZ2lmeScpO1xuXG4vLyBjcmVhdGVzIGFuIGluc3RhbmNlIG9mIGEgdHlwZSwgaGFuZGxpbmcgdGhlIG9wdGlvbmFsIG5ldyBvcGVyYXRvclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGUodHlwZSwgdmFsdWUsIHBhdGgpIHtcbiAgaWYgKGlzVHlwZSh0eXBlKSkge1xuICAgIC8vIGZvciBzdHJ1Y3RzIHRoZSBuZXcgb3BlcmF0b3IgaXMgYWxsb3dlZFxuICAgIHJldHVybiB0eXBlLm1ldGEua2luZCA9PT0gJ3N0cnVjdCcgPyBuZXcgdHlwZSh2YWx1ZSwgcGF0aCkgOiB0eXBlKHZhbHVlLCBwYXRoKTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gaGVyZSB0eXBlIHNob3VsZCBiZSBhIGNsYXNzIGNvbnN0cnVjdG9yIGFuZCB2YWx1ZSBzb21lIGluc3RhbmNlLCBqdXN0IGNoZWNrIG1lbWJlcnNoaXAgYW5kIHJldHVybiB0aGUgdmFsdWVcbiAgICBwYXRoID0gcGF0aCB8fCBbZ2V0RnVuY3Rpb25OYW1lKHR5cGUpXTtcbiAgICBhc3NlcnQodmFsdWUgaW5zdGFuY2VvZiB0eXBlLCBmdW5jdGlvbiAoKSB7IHJldHVybiAnSW52YWxpZCB2YWx1ZSAnICsgc3RyaW5naWZ5KHZhbHVlKSArICcgc3VwcGxpZWQgdG8gJyArIHBhdGguam9pbignLycpOyB9KTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdGNvbWIvbGliL2NyZWF0ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDQyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	eval("var isType = __webpack_require__(26);\n\n// returns true if x is an instance of type\nmodule.exports = function is(x, type) {\n  if (isType(type)) {\n    return type.is(x);\n  }\n  return x instanceof type; // type should be a class constructor\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi9pcy5qcz9kZDgyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IiLCJmaWxlIjoiNDMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgaXNUeXBlID0gcmVxdWlyZSgnLi9pc1R5cGUnKTtcblxuLy8gcmV0dXJucyB0cnVlIGlmIHggaXMgYW4gaW5zdGFuY2Ugb2YgdHlwZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpcyh4LCB0eXBlKSB7XG4gIGlmIChpc1R5cGUodHlwZSkpIHtcbiAgICByZXR1cm4gdHlwZS5pcyh4KTtcbiAgfVxuICByZXR1cm4geCBpbnN0YW5jZW9mIHR5cGU7IC8vIHR5cGUgc2hvdWxkIGJlIGEgY2xhc3MgY29uc3RydWN0b3Jcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi90Y29tYi9saWIvaXMuanNcbiAqKiBtb2R1bGUgaWQgPSA0M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	eval("var irreducible = __webpack_require__(21);\nvar isObject = __webpack_require__(27);\n\nmodule.exports = irreducible('Object', isObject);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi9PYmplY3QuanM/NTU3MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBIiwiZmlsZSI6IjQ0LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGlycmVkdWNpYmxlID0gcmVxdWlyZSgnLi9pcnJlZHVjaWJsZScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlycmVkdWNpYmxlKCdPYmplY3QnLCBpc09iamVjdCk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi90Y29tYi9saWIvT2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gNDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	eval("var irreducible = __webpack_require__(21);\n\nmodule.exports = irreducible('RegExp', function (x) { return x instanceof RegExp; });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi9SZWdFeHAuanM/ZmZlMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQSxxREFBcUQsNEJBQTRCLEVBQUUiLCJmaWxlIjoiNDUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgaXJyZWR1Y2libGUgPSByZXF1aXJlKCcuL2lycmVkdWNpYmxlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXJyZWR1Y2libGUoJ1JlZ0V4cCcsIGZ1bmN0aW9uICh4KSB7IHJldHVybiB4IGluc3RhbmNlb2YgUmVnRXhwOyB9KTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Rjb21iL2xpYi9SZWdFeHAuanNcbiAqKiBtb2R1bGUgaWQgPSA0NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	eval("var irreducible = __webpack_require__(21);\nvar isString = __webpack_require__(23);\n\nmodule.exports = irreducible('String', isString);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi9TdHJpbmcuanM/YzlhZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBIiwiZmlsZSI6IjQ2LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGlycmVkdWNpYmxlID0gcmVxdWlyZSgnLi9pcnJlZHVjaWJsZScpO1xudmFyIGlzU3RyaW5nID0gcmVxdWlyZSgnLi9pc1N0cmluZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlycmVkdWNpYmxlKCdTdHJpbmcnLCBpc1N0cmluZyk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi90Y29tYi9saWIvU3RyaW5nLmpzXG4gKiogbW9kdWxlIGlkID0gNDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	eval("var irreducible = __webpack_require__(21);\nvar isType = __webpack_require__(26);\n\nmodule.exports = irreducible('Type', isType);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi9UeXBlLmpzP2ZlNjUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQSIsImZpbGUiOiI0Ny5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBpcnJlZHVjaWJsZSA9IHJlcXVpcmUoJy4vaXJyZWR1Y2libGUnKTtcbnZhciBpc1R5cGUgPSByZXF1aXJlKCcuL2lzVHlwZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlycmVkdWNpYmxlKCdUeXBlJywgaXNUeXBlKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi90Y29tYi9saWIvVHlwZS5qc1xuICoqIG1vZHVsZSBpZCA9IDQ3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {var assert = __webpack_require__(14);\nvar isTypeName = __webpack_require__(40);\nvar isFunction = __webpack_require__(15);\nvar getTypeName = __webpack_require__(25);\nvar isIdentity = __webpack_require__(41);\nvar isObject = __webpack_require__(27);\nvar create = __webpack_require__(42);\nvar is = __webpack_require__(43);\n\nfunction getDefaultName(domain, codomain) {\n  return '{[key: ' + getTypeName(domain) + ']: ' + getTypeName(codomain) + '}';\n}\n\nfunction dict(domain, codomain, name) {\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(isFunction(domain), function () { return 'Invalid argument domain ' + assert.stringify(domain) + ' supplied to dict(domain, codomain, [name]) combinator (expected a type)'; });\n    assert(isFunction(codomain), function () { return 'Invalid argument codomain ' + assert.stringify(codomain) + ' supplied to dict(domain, codomain, [name]) combinator (expected a type)'; });\n    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to dict(domain, codomain, [name]) combinator (expected a string)'; });\n  }\n\n  var displayName = name || getDefaultName(domain, codomain);\n  var domainNameCache = getTypeName(domain);\n  var codomainNameCache = getTypeName(codomain);\n  var identity = isIdentity(domain) && isIdentity(codomain);\n\n  function Dict(value, path) {\n\n    if (process.env.NODE_ENV === 'production') {\n      if (identity) {\n        return value; // just trust the input if elements must not be hydrated\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      path = path || [displayName];\n      assert(isObject(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });\n    }\n\n    var idempotent = true; // will remain true if I can reutilise the input\n    var ret = {}; // make a temporary copy, will be discarded if idempotent remains true\n    for (var k in value) {\n      if (value.hasOwnProperty(k)) {\n        k = create(domain, k, ( process.env.NODE_ENV !== 'production' ? path.concat(domainNameCache) : null ));\n        var actual = value[k];\n        var instance = create(codomain, actual, ( process.env.NODE_ENV !== 'production' ? path.concat(k + ': ' + codomainNameCache) : null ));\n        idempotent = idempotent && ( actual === instance );\n        ret[k] = instance;\n      }\n    }\n\n    if (idempotent) { // implements idempotency\n      ret = value;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      Object.freeze(ret);\n    }\n\n    return ret;\n  }\n\n  Dict.meta = {\n    kind: 'dict',\n    domain: domain,\n    codomain: codomain,\n    name: name,\n    identity: identity\n  };\n\n  Dict.displayName = displayName;\n\n  Dict.is = function (x) {\n    if (!isObject(x)) {\n      return false;\n    }\n    for (var k in x) {\n      if (x.hasOwnProperty(k)) {\n        if (!is(k, domain) || !is(x[k], codomain)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  };\n\n  Dict.update = function (instance, patch) {\n    return Dict(assert.update(instance, patch));\n  };\n\n  return Dict;\n}\n\ndict.getDefaultName = getDefaultName;\nmodule.exports = dict;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi9kaWN0LmpzP2JmOGYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsa0VBQWtFO0FBQzdFOztBQUVBOztBQUVBO0FBQ0EsNENBQTRDLDJJQUEySSxFQUFFO0FBQ3pMLDhDQUE4QywrSUFBK0ksRUFBRTtBQUMvTCwwQ0FBMEMseUlBQXlJLEVBQUU7QUFDckw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkMsc0ZBQXNGLEVBQUU7QUFDbkk7O0FBRUEsMEJBQTBCO0FBQzFCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSIsImZpbGUiOiI0OC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBhc3NlcnQgPSByZXF1aXJlKCcuL2Fzc2VydCcpO1xudmFyIGlzVHlwZU5hbWUgPSByZXF1aXJlKCcuL2lzVHlwZU5hbWUnKTtcbnZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyk7XG52YXIgZ2V0VHlwZU5hbWUgPSByZXF1aXJlKCcuL2dldFR5cGVOYW1lJyk7XG52YXIgaXNJZGVudGl0eSA9IHJlcXVpcmUoJy4vaXNJZGVudGl0eScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4vY3JlYXRlJyk7XG52YXIgaXMgPSByZXF1aXJlKCcuL2lzJyk7XG5cbmZ1bmN0aW9uIGdldERlZmF1bHROYW1lKGRvbWFpbiwgY29kb21haW4pIHtcbiAgcmV0dXJuICd7W2tleTogJyArIGdldFR5cGVOYW1lKGRvbWFpbikgKyAnXTogJyArIGdldFR5cGVOYW1lKGNvZG9tYWluKSArICd9Jztcbn1cblxuZnVuY3Rpb24gZGljdChkb21haW4sIGNvZG9tYWluLCBuYW1lKSB7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnQoaXNGdW5jdGlvbihkb21haW4pLCBmdW5jdGlvbiAoKSB7IHJldHVybiAnSW52YWxpZCBhcmd1bWVudCBkb21haW4gJyArIGFzc2VydC5zdHJpbmdpZnkoZG9tYWluKSArICcgc3VwcGxpZWQgdG8gZGljdChkb21haW4sIGNvZG9tYWluLCBbbmFtZV0pIGNvbWJpbmF0b3IgKGV4cGVjdGVkIGEgdHlwZSknOyB9KTtcbiAgICBhc3NlcnQoaXNGdW5jdGlvbihjb2RvbWFpbiksIGZ1bmN0aW9uICgpIHsgcmV0dXJuICdJbnZhbGlkIGFyZ3VtZW50IGNvZG9tYWluICcgKyBhc3NlcnQuc3RyaW5naWZ5KGNvZG9tYWluKSArICcgc3VwcGxpZWQgdG8gZGljdChkb21haW4sIGNvZG9tYWluLCBbbmFtZV0pIGNvbWJpbmF0b3IgKGV4cGVjdGVkIGEgdHlwZSknOyB9KTtcbiAgICBhc3NlcnQoaXNUeXBlTmFtZShuYW1lKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0ludmFsaWQgYXJndW1lbnQgbmFtZSAnICsgYXNzZXJ0LnN0cmluZ2lmeShuYW1lKSArICcgc3VwcGxpZWQgdG8gZGljdChkb21haW4sIGNvZG9tYWluLCBbbmFtZV0pIGNvbWJpbmF0b3IgKGV4cGVjdGVkIGEgc3RyaW5nKSc7IH0pO1xuICB9XG5cbiAgdmFyIGRpc3BsYXlOYW1lID0gbmFtZSB8fCBnZXREZWZhdWx0TmFtZShkb21haW4sIGNvZG9tYWluKTtcbiAgdmFyIGRvbWFpbk5hbWVDYWNoZSA9IGdldFR5cGVOYW1lKGRvbWFpbik7XG4gIHZhciBjb2RvbWFpbk5hbWVDYWNoZSA9IGdldFR5cGVOYW1lKGNvZG9tYWluKTtcbiAgdmFyIGlkZW50aXR5ID0gaXNJZGVudGl0eShkb21haW4pICYmIGlzSWRlbnRpdHkoY29kb21haW4pO1xuXG4gIGZ1bmN0aW9uIERpY3QodmFsdWUsIHBhdGgpIHtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoaWRlbnRpdHkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlOyAvLyBqdXN0IHRydXN0IHRoZSBpbnB1dCBpZiBlbGVtZW50cyBtdXN0IG5vdCBiZSBoeWRyYXRlZFxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBwYXRoID0gcGF0aCB8fCBbZGlzcGxheU5hbWVdO1xuICAgICAgYXNzZXJ0KGlzT2JqZWN0KHZhbHVlKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0ludmFsaWQgdmFsdWUgJyArIGFzc2VydC5zdHJpbmdpZnkodmFsdWUpICsgJyBzdXBwbGllZCB0byAnICsgcGF0aC5qb2luKCcvJyk7IH0pO1xuICAgIH1cblxuICAgIHZhciBpZGVtcG90ZW50ID0gdHJ1ZTsgLy8gd2lsbCByZW1haW4gdHJ1ZSBpZiBJIGNhbiByZXV0aWxpc2UgdGhlIGlucHV0XG4gICAgdmFyIHJldCA9IHt9OyAvLyBtYWtlIGEgdGVtcG9yYXJ5IGNvcHksIHdpbGwgYmUgZGlzY2FyZGVkIGlmIGlkZW1wb3RlbnQgcmVtYWlucyB0cnVlXG4gICAgZm9yICh2YXIgayBpbiB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgIGsgPSBjcmVhdGUoZG9tYWluLCBrLCAoIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBwYXRoLmNvbmNhdChkb21haW5OYW1lQ2FjaGUpIDogbnVsbCApKTtcbiAgICAgICAgdmFyIGFjdHVhbCA9IHZhbHVlW2tdO1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBjcmVhdGUoY29kb21haW4sIGFjdHVhbCwgKCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gcGF0aC5jb25jYXQoayArICc6ICcgKyBjb2RvbWFpbk5hbWVDYWNoZSkgOiBudWxsICkpO1xuICAgICAgICBpZGVtcG90ZW50ID0gaWRlbXBvdGVudCAmJiAoIGFjdHVhbCA9PT0gaW5zdGFuY2UgKTtcbiAgICAgICAgcmV0W2tdID0gaW5zdGFuY2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlkZW1wb3RlbnQpIHsgLy8gaW1wbGVtZW50cyBpZGVtcG90ZW5jeVxuICAgICAgcmV0ID0gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIE9iamVjdC5mcmVlemUocmV0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgRGljdC5tZXRhID0ge1xuICAgIGtpbmQ6ICdkaWN0JyxcbiAgICBkb21haW46IGRvbWFpbixcbiAgICBjb2RvbWFpbjogY29kb21haW4sXG4gICAgbmFtZTogbmFtZSxcbiAgICBpZGVudGl0eTogaWRlbnRpdHlcbiAgfTtcblxuICBEaWN0LmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG5cbiAgRGljdC5pcyA9IGZ1bmN0aW9uICh4KSB7XG4gICAgaWYgKCFpc09iamVjdCh4KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKHZhciBrIGluIHgpIHtcbiAgICAgIGlmICh4Lmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgIGlmICghaXMoaywgZG9tYWluKSB8fCAhaXMoeFtrXSwgY29kb21haW4pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIERpY3QudXBkYXRlID0gZnVuY3Rpb24gKGluc3RhbmNlLCBwYXRjaCkge1xuICAgIHJldHVybiBEaWN0KGFzc2VydC51cGRhdGUoaW5zdGFuY2UsIHBhdGNoKSk7XG4gIH07XG5cbiAgcmV0dXJuIERpY3Q7XG59XG5cbmRpY3QuZ2V0RGVmYXVsdE5hbWUgPSBnZXREZWZhdWx0TmFtZTtcbm1vZHVsZS5leHBvcnRzID0gZGljdDtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Rjb21iL2xpYi9kaWN0LmpzXG4gKiogbW9kdWxlIGlkID0gNDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {var assert = __webpack_require__(14);\nvar isTypeName = __webpack_require__(40);\nvar isType = __webpack_require__(26);\nvar isNil = __webpack_require__(16);\nvar mixin = __webpack_require__(50);\nvar getTypeName = __webpack_require__(25);\n\n// All the .declare-d types should be clearly different from each other thus they should have\n// different names when a name was not explicitly provided.\nvar nextDeclareUniqueId = 1;\n\nmodule.exports = function declare(name) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert(isTypeName(name), function () { return 'Invalid argument name ' + name + ' supplied to declare([name]) (expected a string)'; });\n  }\n\n  var type;\n\n  function Declare(value, path) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(!isNil(type), function () { return 'Type declared but not defined, don\\'t forget to call .define on every declared type'; });\n    }\n    return type(value, path);\n  }\n\n  Declare.define = function (spec) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(isType(spec), function () { return 'Invalid argument type ' + assert.stringify(spec) +  ' supplied to define(type) (expected a type)'; });\n      assert(isNil(type), function () { return 'Declare.define(type) can only be invoked once'; });\n      assert(isNil(spec.meta.name) && Object.keys(spec.prototype).length === 0, function () { return 'Invalid argument type ' + assert.stringify(spec) + ' supplied to define(type) (expected a fresh, unnamed type)'; });\n    }\n\n    type = spec;\n    mixin(Declare, type, true); // true because it overwrites Declare.displayName\n    if (name) {\n      type.displayName = Declare.displayName = name;\n      Declare.meta.name = name;\n    }\n    // ensure identity is still false\n    Declare.meta.identity = false;\n    Declare.prototype = type.prototype;\n    return Declare;\n  };\n\n  Declare.displayName = name || ( getTypeName(Declare) + \"$\" + nextDeclareUniqueId++ );\n  // in general I can't say if this type will be an identity, for safety setting to false\n  Declare.meta = { identity: false };\n  Declare.prototype = null;\n  return Declare;\n};\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi9kZWNsYXJlLmpzP2Y5MDciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDLDZGQUE2RixFQUFFO0FBQ3pJOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsOEZBQThGLEVBQUU7QUFDeEk7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsMkdBQTJHLEVBQUU7QUFDckosdUNBQXVDLHdEQUF3RCxFQUFFO0FBQ2pHLDZGQUE2Rix5SEFBeUgsRUFBRTtBQUN4Tjs7QUFFQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EiLCJmaWxlIjoiNDkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXNzZXJ0ID0gcmVxdWlyZSgnLi9hc3NlcnQnKTtcbnZhciBpc1R5cGVOYW1lID0gcmVxdWlyZSgnLi9pc1R5cGVOYW1lJyk7XG52YXIgaXNUeXBlID0gcmVxdWlyZSgnLi9pc1R5cGUnKTtcbnZhciBpc05pbCA9IHJlcXVpcmUoJy4vaXNOaWwnKTtcbnZhciBtaXhpbiA9IHJlcXVpcmUoJy4vbWl4aW4nKTtcbnZhciBnZXRUeXBlTmFtZSA9IHJlcXVpcmUoJy4vZ2V0VHlwZU5hbWUnKTtcblxuLy8gQWxsIHRoZSAuZGVjbGFyZS1kIHR5cGVzIHNob3VsZCBiZSBjbGVhcmx5IGRpZmZlcmVudCBmcm9tIGVhY2ggb3RoZXIgdGh1cyB0aGV5IHNob3VsZCBoYXZlXG4vLyBkaWZmZXJlbnQgbmFtZXMgd2hlbiBhIG5hbWUgd2FzIG5vdCBleHBsaWNpdGx5IHByb3ZpZGVkLlxudmFyIG5leHREZWNsYXJlVW5pcXVlSWQgPSAxO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlY2xhcmUobmFtZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydChpc1R5cGVOYW1lKG5hbWUpLCBmdW5jdGlvbiAoKSB7IHJldHVybiAnSW52YWxpZCBhcmd1bWVudCBuYW1lICcgKyBuYW1lICsgJyBzdXBwbGllZCB0byBkZWNsYXJlKFtuYW1lXSkgKGV4cGVjdGVkIGEgc3RyaW5nKSc7IH0pO1xuICB9XG5cbiAgdmFyIHR5cGU7XG5cbiAgZnVuY3Rpb24gRGVjbGFyZSh2YWx1ZSwgcGF0aCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBhc3NlcnQoIWlzTmlsKHR5cGUpLCBmdW5jdGlvbiAoKSB7IHJldHVybiAnVHlwZSBkZWNsYXJlZCBidXQgbm90IGRlZmluZWQsIGRvblxcJ3QgZm9yZ2V0IHRvIGNhbGwgLmRlZmluZSBvbiBldmVyeSBkZWNsYXJlZCB0eXBlJzsgfSk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlKHZhbHVlLCBwYXRoKTtcbiAgfVxuXG4gIERlY2xhcmUuZGVmaW5lID0gZnVuY3Rpb24gKHNwZWMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgYXNzZXJ0KGlzVHlwZShzcGVjKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0ludmFsaWQgYXJndW1lbnQgdHlwZSAnICsgYXNzZXJ0LnN0cmluZ2lmeShzcGVjKSArICAnIHN1cHBsaWVkIHRvIGRlZmluZSh0eXBlKSAoZXhwZWN0ZWQgYSB0eXBlKSc7IH0pO1xuICAgICAgYXNzZXJ0KGlzTmlsKHR5cGUpLCBmdW5jdGlvbiAoKSB7IHJldHVybiAnRGVjbGFyZS5kZWZpbmUodHlwZSkgY2FuIG9ubHkgYmUgaW52b2tlZCBvbmNlJzsgfSk7XG4gICAgICBhc3NlcnQoaXNOaWwoc3BlYy5tZXRhLm5hbWUpICYmIE9iamVjdC5rZXlzKHNwZWMucHJvdG90eXBlKS5sZW5ndGggPT09IDAsIGZ1bmN0aW9uICgpIHsgcmV0dXJuICdJbnZhbGlkIGFyZ3VtZW50IHR5cGUgJyArIGFzc2VydC5zdHJpbmdpZnkoc3BlYykgKyAnIHN1cHBsaWVkIHRvIGRlZmluZSh0eXBlKSAoZXhwZWN0ZWQgYSBmcmVzaCwgdW5uYW1lZCB0eXBlKSc7IH0pO1xuICAgIH1cblxuICAgIHR5cGUgPSBzcGVjO1xuICAgIG1peGluKERlY2xhcmUsIHR5cGUsIHRydWUpOyAvLyB0cnVlIGJlY2F1c2UgaXQgb3ZlcndyaXRlcyBEZWNsYXJlLmRpc3BsYXlOYW1lXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHR5cGUuZGlzcGxheU5hbWUgPSBEZWNsYXJlLmRpc3BsYXlOYW1lID0gbmFtZTtcbiAgICAgIERlY2xhcmUubWV0YS5uYW1lID0gbmFtZTtcbiAgICB9XG4gICAgLy8gZW5zdXJlIGlkZW50aXR5IGlzIHN0aWxsIGZhbHNlXG4gICAgRGVjbGFyZS5tZXRhLmlkZW50aXR5ID0gZmFsc2U7XG4gICAgRGVjbGFyZS5wcm90b3R5cGUgPSB0eXBlLnByb3RvdHlwZTtcbiAgICByZXR1cm4gRGVjbGFyZTtcbiAgfTtcblxuICBEZWNsYXJlLmRpc3BsYXlOYW1lID0gbmFtZSB8fCAoIGdldFR5cGVOYW1lKERlY2xhcmUpICsgXCIkXCIgKyBuZXh0RGVjbGFyZVVuaXF1ZUlkKysgKTtcbiAgLy8gaW4gZ2VuZXJhbCBJIGNhbid0IHNheSBpZiB0aGlzIHR5cGUgd2lsbCBiZSBhbiBpZGVudGl0eSwgZm9yIHNhZmV0eSBzZXR0aW5nIHRvIGZhbHNlXG4gIERlY2xhcmUubWV0YSA9IHsgaWRlbnRpdHk6IGZhbHNlIH07XG4gIERlY2xhcmUucHJvdG90eXBlID0gbnVsbDtcbiAgcmV0dXJuIERlY2xhcmU7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdGNvbWIvbGliL2RlY2xhcmUuanNcbiAqKiBtb2R1bGUgaWQgPSA0OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {var isNil = __webpack_require__(16);\nvar assert = __webpack_require__(14);\n\n// safe mixin, cannot override props unless specified\nmodule.exports = function mixin(target, source, overwrite) {\n  if (isNil(source)) { return target; }\n  for (var k in source) {\n    if (source.hasOwnProperty(k)) {\n      if (overwrite !== true) {\n        if (process.env.NODE_ENV !== 'production') {\n          assert(!target.hasOwnProperty(k) || target[k] === source[k], function () { return 'Invalid call to mixin(target, source, [overwrite]): cannot overwrite property \"' + k + '\" of target object'; });\n        }\n      }\n      target[k] = source[k];\n    }\n  }\n  return target;\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi9taXhpbi5qcz9kYzU4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLHFIQUFxSCxFQUFFO0FBQzNNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEUiLCJmaWxlIjoiNTAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgaXNOaWwgPSByZXF1aXJlKCcuL2lzTmlsJyk7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnLi9hc3NlcnQnKTtcblxuLy8gc2FmZSBtaXhpbiwgY2Fubm90IG92ZXJyaWRlIHByb3BzIHVubGVzcyBzcGVjaWZpZWRcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbWl4aW4odGFyZ2V0LCBzb3VyY2UsIG92ZXJ3cml0ZSkge1xuICBpZiAoaXNOaWwoc291cmNlKSkgeyByZXR1cm4gdGFyZ2V0OyB9XG4gIGZvciAodmFyIGsgaW4gc291cmNlKSB7XG4gICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgaWYgKG92ZXJ3cml0ZSAhPT0gdHJ1ZSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGFzc2VydCghdGFyZ2V0Lmhhc093blByb3BlcnR5KGspIHx8IHRhcmdldFtrXSA9PT0gc291cmNlW2tdLCBmdW5jdGlvbiAoKSB7IHJldHVybiAnSW52YWxpZCBjYWxsIHRvIG1peGluKHRhcmdldCwgc291cmNlLCBbb3ZlcndyaXRlXSk6IGNhbm5vdCBvdmVyd3JpdGUgcHJvcGVydHkgXCInICsgayArICdcIiBvZiB0YXJnZXQgb2JqZWN0JzsgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRhcmdldFtrXSA9IHNvdXJjZVtrXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdGNvbWIvbGliL21peGluLmpzXG4gKiogbW9kdWxlIGlkID0gNTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {var assert = __webpack_require__(14);\nvar isTypeName = __webpack_require__(40);\nvar forbidNewOperator = __webpack_require__(24);\nvar isString = __webpack_require__(23);\nvar isObject = __webpack_require__(27);\n\nfunction getDefaultName(map) {\n  return Object.keys(map).map(function (k) { return assert.stringify(k); }).join(' | ');\n}\n\nfunction enums(map, name) {\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(isObject(map), function () { return 'Invalid argument map ' + assert.stringify(map) + ' supplied to enums(map, [name]) combinator (expected a dictionary of String -> String | Number)'; });\n    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to enums(map, [name]) combinator (expected a string)'; });\n  }\n\n  var displayName = name || getDefaultName(map);\n\n  function Enums(value, path) {\n\n    if (process.env.NODE_ENV !== 'production') {\n      forbidNewOperator(this, Enums);\n      path = path || [displayName];\n      assert(Enums.is(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/') + ' (expected one of ' + assert.stringify(Object.keys(map)) + ')'; });\n    }\n\n    return value;\n  }\n\n  Enums.meta = {\n    kind: 'enums',\n    map: map,\n    name: name,\n    identity: true\n  };\n\n  Enums.displayName = displayName;\n\n  Enums.is = function (x) {\n    return map.hasOwnProperty(x);\n  };\n\n  return Enums;\n}\n\nenums.of = function (keys, name) {\n  keys = isString(keys) ? keys.split(' ') : keys;\n  var value = {};\n  keys.forEach(function (k) {\n    value[k] = k;\n  });\n  return enums(value, name);\n};\n\nenums.getDefaultName = getDefaultName;\nmodule.exports = enums;\n\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi9lbnVtcy5qcz9jZDI5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMsNEJBQTRCLEVBQUU7QUFDMUU7O0FBRUE7O0FBRUE7QUFDQSx1Q0FBdUMsNEpBQTRKLEVBQUU7QUFDck0sMENBQTBDLDZIQUE2SCxFQUFFO0FBQ3pLOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx3SkFBd0osRUFBRTtBQUNyTTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQSIsImZpbGUiOiI1MS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBhc3NlcnQgPSByZXF1aXJlKCcuL2Fzc2VydCcpO1xudmFyIGlzVHlwZU5hbWUgPSByZXF1aXJlKCcuL2lzVHlwZU5hbWUnKTtcbnZhciBmb3JiaWROZXdPcGVyYXRvciA9IHJlcXVpcmUoJy4vZm9yYmlkTmV3T3BlcmF0b3InKTtcbnZhciBpc1N0cmluZyA9IHJlcXVpcmUoJy4vaXNTdHJpbmcnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuZnVuY3Rpb24gZ2V0RGVmYXVsdE5hbWUobWFwKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhtYXApLm1hcChmdW5jdGlvbiAoaykgeyByZXR1cm4gYXNzZXJ0LnN0cmluZ2lmeShrKTsgfSkuam9pbignIHwgJyk7XG59XG5cbmZ1bmN0aW9uIGVudW1zKG1hcCwgbmFtZSkge1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0KGlzT2JqZWN0KG1hcCksIGZ1bmN0aW9uICgpIHsgcmV0dXJuICdJbnZhbGlkIGFyZ3VtZW50IG1hcCAnICsgYXNzZXJ0LnN0cmluZ2lmeShtYXApICsgJyBzdXBwbGllZCB0byBlbnVtcyhtYXAsIFtuYW1lXSkgY29tYmluYXRvciAoZXhwZWN0ZWQgYSBkaWN0aW9uYXJ5IG9mIFN0cmluZyAtPiBTdHJpbmcgfCBOdW1iZXIpJzsgfSk7XG4gICAgYXNzZXJ0KGlzVHlwZU5hbWUobmFtZSksIGZ1bmN0aW9uICgpIHsgcmV0dXJuICdJbnZhbGlkIGFyZ3VtZW50IG5hbWUgJyArIGFzc2VydC5zdHJpbmdpZnkobmFtZSkgKyAnIHN1cHBsaWVkIHRvIGVudW1zKG1hcCwgW25hbWVdKSBjb21iaW5hdG9yIChleHBlY3RlZCBhIHN0cmluZyknOyB9KTtcbiAgfVxuXG4gIHZhciBkaXNwbGF5TmFtZSA9IG5hbWUgfHwgZ2V0RGVmYXVsdE5hbWUobWFwKTtcblxuICBmdW5jdGlvbiBFbnVtcyh2YWx1ZSwgcGF0aCkge1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGZvcmJpZE5ld09wZXJhdG9yKHRoaXMsIEVudW1zKTtcbiAgICAgIHBhdGggPSBwYXRoIHx8IFtkaXNwbGF5TmFtZV07XG4gICAgICBhc3NlcnQoRW51bXMuaXModmFsdWUpLCBmdW5jdGlvbiAoKSB7IHJldHVybiAnSW52YWxpZCB2YWx1ZSAnICsgYXNzZXJ0LnN0cmluZ2lmeSh2YWx1ZSkgKyAnIHN1cHBsaWVkIHRvICcgKyBwYXRoLmpvaW4oJy8nKSArICcgKGV4cGVjdGVkIG9uZSBvZiAnICsgYXNzZXJ0LnN0cmluZ2lmeShPYmplY3Qua2V5cyhtYXApKSArICcpJzsgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgRW51bXMubWV0YSA9IHtcbiAgICBraW5kOiAnZW51bXMnLFxuICAgIG1hcDogbWFwLFxuICAgIG5hbWU6IG5hbWUsXG4gICAgaWRlbnRpdHk6IHRydWVcbiAgfTtcblxuICBFbnVtcy5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xuXG4gIEVudW1zLmlzID0gZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4gbWFwLmhhc093blByb3BlcnR5KHgpO1xuICB9O1xuXG4gIHJldHVybiBFbnVtcztcbn1cblxuZW51bXMub2YgPSBmdW5jdGlvbiAoa2V5cywgbmFtZSkge1xuICBrZXlzID0gaXNTdHJpbmcoa2V5cykgPyBrZXlzLnNwbGl0KCcgJykgOiBrZXlzO1xuICB2YXIgdmFsdWUgPSB7fTtcbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgdmFsdWVba10gPSBrO1xuICB9KTtcbiAgcmV0dXJuIGVudW1zKHZhbHVlLCBuYW1lKTtcbn07XG5cbmVudW1zLmdldERlZmF1bHROYW1lID0gZ2V0RGVmYXVsdE5hbWU7XG5tb2R1bGUuZXhwb3J0cyA9IGVudW1zO1xuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi90Y29tYi9saWIvZW51bXMuanNcbiAqKiBtb2R1bGUgaWQgPSA1MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {var assert = __webpack_require__(14);\nvar isTypeName = __webpack_require__(40);\nvar isFunction = __webpack_require__(15);\nvar getTypeName = __webpack_require__(25);\nvar isIdentity = __webpack_require__(41);\nvar create = __webpack_require__(42);\nvar is = __webpack_require__(43);\nvar isArray = __webpack_require__(28);\n\nfunction getDefaultName(type) {\n  return 'Array<' + getTypeName(type) + '>';\n}\n\nfunction list(type, name) {\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(isFunction(type), function () { return 'Invalid argument type ' + assert.stringify(type) + ' supplied to list(type, [name]) combinator (expected a type)'; });\n    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to list(type, [name]) combinator (expected a string)'; });\n  }\n\n  var displayName = name || getDefaultName(type);\n  var typeNameCache = getTypeName(type);\n  var identity = isIdentity(type); // the list is identity iif type is identity\n\n  function List(value, path) {\n\n    if (process.env.NODE_ENV === 'production') {\n      if (identity) {\n        return value; // just trust the input if elements must not be hydrated\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      path = path || [displayName];\n      assert(isArray(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/') + ' (expected an array of ' + typeNameCache + ')'; });\n    }\n\n    var idempotent = true; // will remain true if I can reutilise the input\n    var ret = []; // make a temporary copy, will be discarded if idempotent remains true\n    for (var i = 0, len = value.length; i < len; i++ ) {\n      var actual = value[i];\n      var instance = create(type, actual, ( process.env.NODE_ENV !== 'production' ? path.concat(i + ': ' + typeNameCache) : null ));\n      idempotent = idempotent && ( actual === instance );\n      ret.push(instance);\n    }\n\n    if (idempotent) { // implements idempotency\n      ret = value;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      Object.freeze(ret);\n    }\n\n    return ret;\n  }\n\n  List.meta = {\n    kind: 'list',\n    type: type,\n    name: name,\n    identity: identity\n  };\n\n  List.displayName = displayName;\n\n  List.is = function (x) {\n    return isArray(x) && x.every(function (e) {\n      return is(e, type);\n    });\n  };\n\n  List.update = function (instance, patch) {\n    return List(assert.update(instance, patch));\n  };\n\n  return List;\n}\n\nlist.getDefaultName = getDefaultName;\nmodule.exports = list;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi9saXN0LmpzP2ExNGMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwwQ0FBMEMsMkhBQTJILEVBQUU7QUFDdkssMENBQTBDLDZIQUE2SCxFQUFFO0FBQ3pLOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0M7O0FBRWxDOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDLHdJQUF3SSxFQUFFO0FBQ3BMOztBQUVBLDBCQUEwQjtBQUMxQixpQkFBaUI7QUFDakIsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EiLCJmaWxlIjoiNTIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXNzZXJ0ID0gcmVxdWlyZSgnLi9hc3NlcnQnKTtcbnZhciBpc1R5cGVOYW1lID0gcmVxdWlyZSgnLi9pc1R5cGVOYW1lJyk7XG52YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpO1xudmFyIGdldFR5cGVOYW1lID0gcmVxdWlyZSgnLi9nZXRUeXBlTmFtZScpO1xudmFyIGlzSWRlbnRpdHkgPSByZXF1aXJlKCcuL2lzSWRlbnRpdHknKTtcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuL2NyZWF0ZScpO1xudmFyIGlzID0gcmVxdWlyZSgnLi9pcycpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuZnVuY3Rpb24gZ2V0RGVmYXVsdE5hbWUodHlwZSkge1xuICByZXR1cm4gJ0FycmF5PCcgKyBnZXRUeXBlTmFtZSh0eXBlKSArICc+Jztcbn1cblxuZnVuY3Rpb24gbGlzdCh0eXBlLCBuYW1lKSB7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnQoaXNGdW5jdGlvbih0eXBlKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0ludmFsaWQgYXJndW1lbnQgdHlwZSAnICsgYXNzZXJ0LnN0cmluZ2lmeSh0eXBlKSArICcgc3VwcGxpZWQgdG8gbGlzdCh0eXBlLCBbbmFtZV0pIGNvbWJpbmF0b3IgKGV4cGVjdGVkIGEgdHlwZSknOyB9KTtcbiAgICBhc3NlcnQoaXNUeXBlTmFtZShuYW1lKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0ludmFsaWQgYXJndW1lbnQgbmFtZSAnICsgYXNzZXJ0LnN0cmluZ2lmeShuYW1lKSArICcgc3VwcGxpZWQgdG8gbGlzdCh0eXBlLCBbbmFtZV0pIGNvbWJpbmF0b3IgKGV4cGVjdGVkIGEgc3RyaW5nKSc7IH0pO1xuICB9XG5cbiAgdmFyIGRpc3BsYXlOYW1lID0gbmFtZSB8fCBnZXREZWZhdWx0TmFtZSh0eXBlKTtcbiAgdmFyIHR5cGVOYW1lQ2FjaGUgPSBnZXRUeXBlTmFtZSh0eXBlKTtcbiAgdmFyIGlkZW50aXR5ID0gaXNJZGVudGl0eSh0eXBlKTsgLy8gdGhlIGxpc3QgaXMgaWRlbnRpdHkgaWlmIHR5cGUgaXMgaWRlbnRpdHlcblxuICBmdW5jdGlvbiBMaXN0KHZhbHVlLCBwYXRoKSB7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGlkZW50aXR5KSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTsgLy8ganVzdCB0cnVzdCB0aGUgaW5wdXQgaWYgZWxlbWVudHMgbXVzdCBub3QgYmUgaHlkcmF0ZWRcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcGF0aCA9IHBhdGggfHwgW2Rpc3BsYXlOYW1lXTtcbiAgICAgIGFzc2VydChpc0FycmF5KHZhbHVlKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0ludmFsaWQgdmFsdWUgJyArIGFzc2VydC5zdHJpbmdpZnkodmFsdWUpICsgJyBzdXBwbGllZCB0byAnICsgcGF0aC5qb2luKCcvJykgKyAnIChleHBlY3RlZCBhbiBhcnJheSBvZiAnICsgdHlwZU5hbWVDYWNoZSArICcpJzsgfSk7XG4gICAgfVxuXG4gICAgdmFyIGlkZW1wb3RlbnQgPSB0cnVlOyAvLyB3aWxsIHJlbWFpbiB0cnVlIGlmIEkgY2FuIHJldXRpbGlzZSB0aGUgaW5wdXRcbiAgICB2YXIgcmV0ID0gW107IC8vIG1ha2UgYSB0ZW1wb3JhcnkgY29weSwgd2lsbCBiZSBkaXNjYXJkZWQgaWYgaWRlbXBvdGVudCByZW1haW5zIHRydWVcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdmFsdWUubGVuZ3RoOyBpIDwgbGVuOyBpKysgKSB7XG4gICAgICB2YXIgYWN0dWFsID0gdmFsdWVbaV07XG4gICAgICB2YXIgaW5zdGFuY2UgPSBjcmVhdGUodHlwZSwgYWN0dWFsLCAoIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBwYXRoLmNvbmNhdChpICsgJzogJyArIHR5cGVOYW1lQ2FjaGUpIDogbnVsbCApKTtcbiAgICAgIGlkZW1wb3RlbnQgPSBpZGVtcG90ZW50ICYmICggYWN0dWFsID09PSBpbnN0YW5jZSApO1xuICAgICAgcmV0LnB1c2goaW5zdGFuY2UpO1xuICAgIH1cblxuICAgIGlmIChpZGVtcG90ZW50KSB7IC8vIGltcGxlbWVudHMgaWRlbXBvdGVuY3lcbiAgICAgIHJldCA9IHZhbHVlO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBPYmplY3QuZnJlZXplKHJldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIExpc3QubWV0YSA9IHtcbiAgICBraW5kOiAnbGlzdCcsXG4gICAgdHlwZTogdHlwZSxcbiAgICBuYW1lOiBuYW1lLFxuICAgIGlkZW50aXR5OiBpZGVudGl0eVxuICB9O1xuXG4gIExpc3QuZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcblxuICBMaXN0LmlzID0gZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4gaXNBcnJheSh4KSAmJiB4LmV2ZXJ5KGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gaXMoZSwgdHlwZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgTGlzdC51cGRhdGUgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIHBhdGNoKSB7XG4gICAgcmV0dXJuIExpc3QoYXNzZXJ0LnVwZGF0ZShpbnN0YW5jZSwgcGF0Y2gpKTtcbiAgfTtcblxuICByZXR1cm4gTGlzdDtcbn1cblxubGlzdC5nZXREZWZhdWx0TmFtZSA9IGdldERlZmF1bHROYW1lO1xubW9kdWxlLmV4cG9ydHMgPSBsaXN0O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdGNvbWIvbGliL2xpc3QuanNcbiAqKiBtb2R1bGUgaWQgPSA1MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {var assert = __webpack_require__(14);\nvar isTypeName = __webpack_require__(40);\nvar isFunction = __webpack_require__(15);\nvar isMaybe = __webpack_require__(54);\nvar isIdentity = __webpack_require__(41);\nvar Any = __webpack_require__(20);\nvar create = __webpack_require__(42);\nvar Nil = __webpack_require__(35);\nvar forbidNewOperator = __webpack_require__(24);\nvar is = __webpack_require__(43);\nvar getTypeName = __webpack_require__(25);\n\nfunction getDefaultName(type) {\n  return '?' + getTypeName(type);\n}\n\nfunction maybe(type, name) {\n\n  if (isMaybe(type) || type === Any || type === Nil) { // makes the combinator idempotent and handle Any, Nil\n    return type;\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(isFunction(type), function () { return 'Invalid argument type ' + assert.stringify(type) + ' supplied to maybe(type, [name]) combinator (expected a type)'; });\n    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to maybe(type, [name]) combinator (expected a string)'; });\n  }\n\n  var displayName = name || getDefaultName(type);\n\n  function Maybe(value, path) {\n    if (process.env.NODE_ENV !== 'production') {\n      forbidNewOperator(this, Maybe);\n    }\n    return Nil.is(value) ? value : create(type, value, path);\n  }\n\n  Maybe.meta = {\n    kind: 'maybe',\n    type: type,\n    name: name,\n    identity: isIdentity(type)\n  };\n\n  Maybe.displayName = displayName;\n\n  Maybe.is = function (x) {\n    return Nil.is(x) || is(x, type);\n  };\n\n  return Maybe;\n}\n\nmaybe.getDefaultName = getDefaultName;\nmodule.exports = maybe;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi9tYXliZS5qcz8yY2NlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLDRIQUE0SCxFQUFFO0FBQ3hLLDBDQUEwQyw4SEFBOEgsRUFBRTtBQUMxSzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EiLCJmaWxlIjoiNTMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXNzZXJ0ID0gcmVxdWlyZSgnLi9hc3NlcnQnKTtcbnZhciBpc1R5cGVOYW1lID0gcmVxdWlyZSgnLi9pc1R5cGVOYW1lJyk7XG52YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpO1xudmFyIGlzTWF5YmUgPSByZXF1aXJlKCcuL2lzTWF5YmUnKTtcbnZhciBpc0lkZW50aXR5ID0gcmVxdWlyZSgnLi9pc0lkZW50aXR5Jyk7XG52YXIgQW55ID0gcmVxdWlyZSgnLi9BbnknKTtcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuL2NyZWF0ZScpO1xudmFyIE5pbCA9IHJlcXVpcmUoJy4vTmlsJyk7XG52YXIgZm9yYmlkTmV3T3BlcmF0b3IgPSByZXF1aXJlKCcuL2ZvcmJpZE5ld09wZXJhdG9yJyk7XG52YXIgaXMgPSByZXF1aXJlKCcuL2lzJyk7XG52YXIgZ2V0VHlwZU5hbWUgPSByZXF1aXJlKCcuL2dldFR5cGVOYW1lJyk7XG5cbmZ1bmN0aW9uIGdldERlZmF1bHROYW1lKHR5cGUpIHtcbiAgcmV0dXJuICc/JyArIGdldFR5cGVOYW1lKHR5cGUpO1xufVxuXG5mdW5jdGlvbiBtYXliZSh0eXBlLCBuYW1lKSB7XG5cbiAgaWYgKGlzTWF5YmUodHlwZSkgfHwgdHlwZSA9PT0gQW55IHx8IHR5cGUgPT09IE5pbCkgeyAvLyBtYWtlcyB0aGUgY29tYmluYXRvciBpZGVtcG90ZW50IGFuZCBoYW5kbGUgQW55LCBOaWxcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0KGlzRnVuY3Rpb24odHlwZSksIGZ1bmN0aW9uICgpIHsgcmV0dXJuICdJbnZhbGlkIGFyZ3VtZW50IHR5cGUgJyArIGFzc2VydC5zdHJpbmdpZnkodHlwZSkgKyAnIHN1cHBsaWVkIHRvIG1heWJlKHR5cGUsIFtuYW1lXSkgY29tYmluYXRvciAoZXhwZWN0ZWQgYSB0eXBlKSc7IH0pO1xuICAgIGFzc2VydChpc1R5cGVOYW1lKG5hbWUpLCBmdW5jdGlvbiAoKSB7IHJldHVybiAnSW52YWxpZCBhcmd1bWVudCBuYW1lICcgKyBhc3NlcnQuc3RyaW5naWZ5KG5hbWUpICsgJyBzdXBwbGllZCB0byBtYXliZSh0eXBlLCBbbmFtZV0pIGNvbWJpbmF0b3IgKGV4cGVjdGVkIGEgc3RyaW5nKSc7IH0pO1xuICB9XG5cbiAgdmFyIGRpc3BsYXlOYW1lID0gbmFtZSB8fCBnZXREZWZhdWx0TmFtZSh0eXBlKTtcblxuICBmdW5jdGlvbiBNYXliZSh2YWx1ZSwgcGF0aCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBmb3JiaWROZXdPcGVyYXRvcih0aGlzLCBNYXliZSk7XG4gICAgfVxuICAgIHJldHVybiBOaWwuaXModmFsdWUpID8gdmFsdWUgOiBjcmVhdGUodHlwZSwgdmFsdWUsIHBhdGgpO1xuICB9XG5cbiAgTWF5YmUubWV0YSA9IHtcbiAgICBraW5kOiAnbWF5YmUnLFxuICAgIHR5cGU6IHR5cGUsXG4gICAgbmFtZTogbmFtZSxcbiAgICBpZGVudGl0eTogaXNJZGVudGl0eSh0eXBlKVxuICB9O1xuXG4gIE1heWJlLmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG5cbiAgTWF5YmUuaXMgPSBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiBOaWwuaXMoeCkgfHwgaXMoeCwgdHlwZSk7XG4gIH07XG5cbiAgcmV0dXJuIE1heWJlO1xufVxuXG5tYXliZS5nZXREZWZhdWx0TmFtZSA9IGdldERlZmF1bHROYW1lO1xubW9kdWxlLmV4cG9ydHMgPSBtYXliZTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Rjb21iL2xpYi9tYXliZS5qc1xuICoqIG1vZHVsZSBpZCA9IDUzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	eval("var isType = __webpack_require__(26);\n\nmodule.exports = function isMaybe(x) {\n  return isType(x) && ( x.meta.kind === 'maybe' );\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi9pc01heWJlLmpzPzdhOWYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6IjU0LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGlzVHlwZSA9IHJlcXVpcmUoJy4vaXNUeXBlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNNYXliZSh4KSB7XG4gIHJldHVybiBpc1R5cGUoeCkgJiYgKCB4Lm1ldGEua2luZCA9PT0gJ21heWJlJyApO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi90Y29tYi9saWIvaXNNYXliZS5qc1xuICoqIG1vZHVsZSBpZCA9IDU0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {var assert = __webpack_require__(14);\nvar isTypeName = __webpack_require__(40);\nvar String = __webpack_require__(46);\nvar Function = __webpack_require__(34);\nvar isBoolean = __webpack_require__(31);\nvar isObject = __webpack_require__(27);\nvar isNil = __webpack_require__(16);\nvar create = __webpack_require__(42);\nvar getTypeName = __webpack_require__(25);\nvar dict = __webpack_require__(48);\nvar getDefaultInterfaceName = __webpack_require__(56);\nvar extend = __webpack_require__(57);\n\nfunction getDefaultName(props) {\n  return 'Struct' + getDefaultInterfaceName(props);\n}\n\nfunction extendStruct(mixins, name) {\n  return extend(struct, mixins, name);\n}\n\nfunction getOptions(options) {\n  if (!isObject(options)) {\n    options = isNil(options) ? {} : { name: options };\n  }\n  if (!options.hasOwnProperty('strict')) {\n    options.strict = struct.strict;\n  }\n  if (!options.hasOwnProperty('defaultProps')) {\n    options.defaultProps = {};\n  }\n  return options;\n}\n\nfunction struct(props, options) {\n\n  options = getOptions(options);\n  var name = options.name;\n  var strict = options.strict;\n  var defaultProps = options.defaultProps;\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(dict(String, Function).is(props), function () { return 'Invalid argument props ' + assert.stringify(props) + ' supplied to struct(props, [options]) combinator (expected a dictionary String -> Type)'; });\n    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to struct(props, [options]) combinator (expected a string)'; });\n    assert(isBoolean(strict), function () { return 'Invalid argument strict ' + assert.stringify(strict) + ' supplied to struct(props, [options]) combinator (expected a boolean)'; });\n    assert(isObject(defaultProps), function () { return 'Invalid argument defaultProps ' + assert.stringify(defaultProps) + ' supplied to struct(props, [options]) combinator (expected an object)'; });\n  }\n\n  var displayName = name || getDefaultName(props);\n\n  function Struct(value, path) {\n\n    if (Struct.is(value)) { // implements idempotency\n      return value;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      path = path || [displayName];\n      assert(isObject(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/') + ' (expected an object)'; });\n      // strictness\n      if (strict) {\n        for (k in value) {\n          if (value.hasOwnProperty(k)) {\n            assert(props.hasOwnProperty(k), function () { return 'Invalid additional prop \"' + k + '\" supplied to ' + path.join('/'); });\n          }\n        }\n      }\n    }\n\n    if (!(this instanceof Struct)) { // `new` is optional\n      return new Struct(value, path);\n    }\n\n    for (var k in props) {\n      if (props.hasOwnProperty(k)) {\n        var expected = props[k];\n        var actual = value[k];\n        // apply defaults\n        if (actual === undefined) {\n          actual = defaultProps[k];\n        }\n        this[k] = create(expected, actual, ( process.env.NODE_ENV !== 'production' ? path.concat(k + ': ' + getTypeName(expected)) : null ));\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      Object.freeze(this);\n    }\n\n  }\n\n  Struct.meta = {\n    kind: 'struct',\n    props: props,\n    name: name,\n    identity: false,\n    strict: strict,\n    defaultProps: defaultProps\n  };\n\n  Struct.displayName = displayName;\n\n  Struct.is = function (x) {\n    return x instanceof Struct;\n  };\n\n  Struct.update = function (instance, patch) {\n    return new Struct(assert.update(instance, patch));\n  };\n\n  Struct.extend = function (xs, name) {\n    return extendStruct([Struct].concat(xs), name);\n  };\n\n  return Struct;\n}\n\nstruct.strict = false;\nstruct.getOptions = getOptions;\nstruct.getDefaultName = getDefaultName;\nstruct.extend = extendStruct;\nmodule.exports = struct;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi9zdHJ1Y3QuanM/ZmM1ZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDLElBQUk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMERBQTBELHdKQUF3SixFQUFFO0FBQ3BOLDBDQUEwQyxtSUFBbUksRUFBRTtBQUMvSywyQ0FBMkMsd0lBQXdJLEVBQUU7QUFDckwsZ0RBQWdELG9KQUFvSixFQUFFO0FBQ3RNOztBQUVBOztBQUVBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkMsZ0hBQWdILEVBQUU7QUFDN0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsNEVBQTRFLEVBQUU7QUFDdkk7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNTUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXNzZXJ0ID0gcmVxdWlyZSgnLi9hc3NlcnQnKTtcbnZhciBpc1R5cGVOYW1lID0gcmVxdWlyZSgnLi9pc1R5cGVOYW1lJyk7XG52YXIgU3RyaW5nID0gcmVxdWlyZSgnLi9TdHJpbmcnKTtcbnZhciBGdW5jdGlvbiA9IHJlcXVpcmUoJy4vRnVuY3Rpb24nKTtcbnZhciBpc0Jvb2xlYW4gPSByZXF1aXJlKCcuL2lzQm9vbGVhbicpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xudmFyIGlzTmlsID0gcmVxdWlyZSgnLi9pc05pbCcpO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4vY3JlYXRlJyk7XG52YXIgZ2V0VHlwZU5hbWUgPSByZXF1aXJlKCcuL2dldFR5cGVOYW1lJyk7XG52YXIgZGljdCA9IHJlcXVpcmUoJy4vZGljdCcpO1xudmFyIGdldERlZmF1bHRJbnRlcmZhY2VOYW1lID0gcmVxdWlyZSgnLi9nZXREZWZhdWx0SW50ZXJmYWNlTmFtZScpO1xudmFyIGV4dGVuZCA9IHJlcXVpcmUoJy4vZXh0ZW5kJyk7XG5cbmZ1bmN0aW9uIGdldERlZmF1bHROYW1lKHByb3BzKSB7XG4gIHJldHVybiAnU3RydWN0JyArIGdldERlZmF1bHRJbnRlcmZhY2VOYW1lKHByb3BzKTtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kU3RydWN0KG1peGlucywgbmFtZSkge1xuICByZXR1cm4gZXh0ZW5kKHN0cnVjdCwgbWl4aW5zLCBuYW1lKTtcbn1cblxuZnVuY3Rpb24gZ2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gIGlmICghaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICBvcHRpb25zID0gaXNOaWwob3B0aW9ucykgPyB7fSA6IHsgbmFtZTogb3B0aW9ucyB9O1xuICB9XG4gIGlmICghb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnc3RyaWN0JykpIHtcbiAgICBvcHRpb25zLnN0cmljdCA9IHN0cnVjdC5zdHJpY3Q7XG4gIH1cbiAgaWYgKCFvcHRpb25zLmhhc093blByb3BlcnR5KCdkZWZhdWx0UHJvcHMnKSkge1xuICAgIG9wdGlvbnMuZGVmYXVsdFByb3BzID0ge307XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbmZ1bmN0aW9uIHN0cnVjdChwcm9wcywgb3B0aW9ucykge1xuXG4gIG9wdGlvbnMgPSBnZXRPcHRpb25zKG9wdGlvbnMpO1xuICB2YXIgbmFtZSA9IG9wdGlvbnMubmFtZTtcbiAgdmFyIHN0cmljdCA9IG9wdGlvbnMuc3RyaWN0O1xuICB2YXIgZGVmYXVsdFByb3BzID0gb3B0aW9ucy5kZWZhdWx0UHJvcHM7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnQoZGljdChTdHJpbmcsIEZ1bmN0aW9uKS5pcyhwcm9wcyksIGZ1bmN0aW9uICgpIHsgcmV0dXJuICdJbnZhbGlkIGFyZ3VtZW50IHByb3BzICcgKyBhc3NlcnQuc3RyaW5naWZ5KHByb3BzKSArICcgc3VwcGxpZWQgdG8gc3RydWN0KHByb3BzLCBbb3B0aW9uc10pIGNvbWJpbmF0b3IgKGV4cGVjdGVkIGEgZGljdGlvbmFyeSBTdHJpbmcgLT4gVHlwZSknOyB9KTtcbiAgICBhc3NlcnQoaXNUeXBlTmFtZShuYW1lKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0ludmFsaWQgYXJndW1lbnQgbmFtZSAnICsgYXNzZXJ0LnN0cmluZ2lmeShuYW1lKSArICcgc3VwcGxpZWQgdG8gc3RydWN0KHByb3BzLCBbb3B0aW9uc10pIGNvbWJpbmF0b3IgKGV4cGVjdGVkIGEgc3RyaW5nKSc7IH0pO1xuICAgIGFzc2VydChpc0Jvb2xlYW4oc3RyaWN0KSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0ludmFsaWQgYXJndW1lbnQgc3RyaWN0ICcgKyBhc3NlcnQuc3RyaW5naWZ5KHN0cmljdCkgKyAnIHN1cHBsaWVkIHRvIHN0cnVjdChwcm9wcywgW29wdGlvbnNdKSBjb21iaW5hdG9yIChleHBlY3RlZCBhIGJvb2xlYW4pJzsgfSk7XG4gICAgYXNzZXJ0KGlzT2JqZWN0KGRlZmF1bHRQcm9wcyksIGZ1bmN0aW9uICgpIHsgcmV0dXJuICdJbnZhbGlkIGFyZ3VtZW50IGRlZmF1bHRQcm9wcyAnICsgYXNzZXJ0LnN0cmluZ2lmeShkZWZhdWx0UHJvcHMpICsgJyBzdXBwbGllZCB0byBzdHJ1Y3QocHJvcHMsIFtvcHRpb25zXSkgY29tYmluYXRvciAoZXhwZWN0ZWQgYW4gb2JqZWN0KSc7IH0pO1xuICB9XG5cbiAgdmFyIGRpc3BsYXlOYW1lID0gbmFtZSB8fCBnZXREZWZhdWx0TmFtZShwcm9wcyk7XG5cbiAgZnVuY3Rpb24gU3RydWN0KHZhbHVlLCBwYXRoKSB7XG5cbiAgICBpZiAoU3RydWN0LmlzKHZhbHVlKSkgeyAvLyBpbXBsZW1lbnRzIGlkZW1wb3RlbmN5XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHBhdGggPSBwYXRoIHx8IFtkaXNwbGF5TmFtZV07XG4gICAgICBhc3NlcnQoaXNPYmplY3QodmFsdWUpLCBmdW5jdGlvbiAoKSB7IHJldHVybiAnSW52YWxpZCB2YWx1ZSAnICsgYXNzZXJ0LnN0cmluZ2lmeSh2YWx1ZSkgKyAnIHN1cHBsaWVkIHRvICcgKyBwYXRoLmpvaW4oJy8nKSArICcgKGV4cGVjdGVkIGFuIG9iamVjdCknOyB9KTtcbiAgICAgIC8vIHN0cmljdG5lc3NcbiAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgZm9yIChrIGluIHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHZhbHVlLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgICAgICBhc3NlcnQocHJvcHMuaGFzT3duUHJvcGVydHkoayksIGZ1bmN0aW9uICgpIHsgcmV0dXJuICdJbnZhbGlkIGFkZGl0aW9uYWwgcHJvcCBcIicgKyBrICsgJ1wiIHN1cHBsaWVkIHRvICcgKyBwYXRoLmpvaW4oJy8nKTsgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFN0cnVjdCkpIHsgLy8gYG5ld2AgaXMgb3B0aW9uYWxcbiAgICAgIHJldHVybiBuZXcgU3RydWN0KHZhbHVlLCBwYXRoKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBrIGluIHByb3BzKSB7XG4gICAgICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkID0gcHJvcHNba107XG4gICAgICAgIHZhciBhY3R1YWwgPSB2YWx1ZVtrXTtcbiAgICAgICAgLy8gYXBwbHkgZGVmYXVsdHNcbiAgICAgICAgaWYgKGFjdHVhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgYWN0dWFsID0gZGVmYXVsdFByb3BzW2tdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNba10gPSBjcmVhdGUoZXhwZWN0ZWQsIGFjdHVhbCwgKCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gcGF0aC5jb25jYXQoayArICc6ICcgKyBnZXRUeXBlTmFtZShleHBlY3RlZCkpIDogbnVsbCApKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICB9XG5cbiAgfVxuXG4gIFN0cnVjdC5tZXRhID0ge1xuICAgIGtpbmQ6ICdzdHJ1Y3QnLFxuICAgIHByb3BzOiBwcm9wcyxcbiAgICBuYW1lOiBuYW1lLFxuICAgIGlkZW50aXR5OiBmYWxzZSxcbiAgICBzdHJpY3Q6IHN0cmljdCxcbiAgICBkZWZhdWx0UHJvcHM6IGRlZmF1bHRQcm9wc1xuICB9O1xuXG4gIFN0cnVjdC5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xuXG4gIFN0cnVjdC5pcyA9IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIHggaW5zdGFuY2VvZiBTdHJ1Y3Q7XG4gIH07XG5cbiAgU3RydWN0LnVwZGF0ZSA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgcGF0Y2gpIHtcbiAgICByZXR1cm4gbmV3IFN0cnVjdChhc3NlcnQudXBkYXRlKGluc3RhbmNlLCBwYXRjaCkpO1xuICB9O1xuXG4gIFN0cnVjdC5leHRlbmQgPSBmdW5jdGlvbiAoeHMsIG5hbWUpIHtcbiAgICByZXR1cm4gZXh0ZW5kU3RydWN0KFtTdHJ1Y3RdLmNvbmNhdCh4cyksIG5hbWUpO1xuICB9O1xuXG4gIHJldHVybiBTdHJ1Y3Q7XG59XG5cbnN0cnVjdC5zdHJpY3QgPSBmYWxzZTtcbnN0cnVjdC5nZXRPcHRpb25zID0gZ2V0T3B0aW9ucztcbnN0cnVjdC5nZXREZWZhdWx0TmFtZSA9IGdldERlZmF1bHROYW1lO1xuc3RydWN0LmV4dGVuZCA9IGV4dGVuZFN0cnVjdDtcbm1vZHVsZS5leHBvcnRzID0gc3RydWN0O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdGNvbWIvbGliL3N0cnVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDU1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	eval("var getTypeName = __webpack_require__(25);\n\nfunction getDefaultInterfaceName(props) {\n  return '{' + Object.keys(props).map(function (prop) {\n    return prop + ': ' + getTypeName(props[prop]);\n  }).join(', ') + '}';\n}\n\nmodule.exports = getDefaultInterfaceName;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi9nZXREZWZhdWx0SW50ZXJmYWNlTmFtZS5qcz8zYTZmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsR0FBRyxpQkFBaUI7QUFDcEI7O0FBRUEiLCJmaWxlIjoiNTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZ2V0VHlwZU5hbWUgPSByZXF1aXJlKCcuL2dldFR5cGVOYW1lJyk7XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRJbnRlcmZhY2VOYW1lKHByb3BzKSB7XG4gIHJldHVybiAneycgKyBPYmplY3Qua2V5cyhwcm9wcykubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgcmV0dXJuIHByb3AgKyAnOiAnICsgZ2V0VHlwZU5hbWUocHJvcHNbcHJvcF0pO1xuICB9KS5qb2luKCcsICcpICsgJ30nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldERlZmF1bHRJbnRlcmZhY2VOYW1lO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdGNvbWIvbGliL2dldERlZmF1bHRJbnRlcmZhY2VOYW1lLmpzXG4gKiogbW9kdWxlIGlkID0gNTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {var assert = __webpack_require__(14);\nvar isFunction = __webpack_require__(15);\nvar isArray = __webpack_require__(28);\nvar mixin = __webpack_require__(50);\nvar isStruct = __webpack_require__(58);\nvar isInterface = __webpack_require__(59);\nvar isObject = __webpack_require__(27);\nvar refinement = __webpack_require__(39);\nvar decompose = __webpack_require__(60);\n\nfunction compose(predicates, unrefinedType) {\n  return predicates.reduce(function (type, predicate) {\n    return refinement(type, predicate);\n  }, unrefinedType);\n}\n\nfunction getProps(type) {\n  return isObject(type) ? type : type.meta.props;\n}\n\nfunction getDefaultProps(type) {\n  return isObject(type) ? null : type.meta.defaultProps;\n}\n\nfunction pushAll(arr, elements) {\n  Array.prototype.push.apply(arr, elements);\n}\n\nfunction extend(combinator, mixins, options) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert(isFunction(combinator), function () { return 'Invalid argument combinator supplied to extend(combinator, mixins, options), expected a function'; });\n    assert(isArray(mixins), function () { return 'Invalid argument mixins supplied to extend(combinator, mixins, options), expected an array'; });\n  }\n  var props = {};\n  var prototype = {};\n  var predicates = [];\n  var defaultProps = {};\n  mixins.forEach(function (x, i) {\n    var decomposition = decompose(x);\n    var unrefinedType = decomposition.unrefinedType;\n    if (process.env.NODE_ENV !== 'production') {\n      assert(isObject(unrefinedType) || isStruct(unrefinedType) || isInterface(unrefinedType), function () { return 'Invalid argument mixins[' + i + '] supplied to extend(combinator, mixins, options), expected an object, struct, interface or a refinement (of struct or interface)'; });\n    }\n    pushAll(predicates, decomposition.predicates);\n    mixin(props, getProps(unrefinedType));\n    mixin(prototype, unrefinedType.prototype);\n    mixin(defaultProps, getDefaultProps(unrefinedType));\n  });\n  options = combinator.getOptions(options);\n  mixin(options.defaultProps, defaultProps);\n  var result = compose(predicates, combinator(props, options));\n  mixin(result.prototype, prototype);\n  return result;\n}\n\nmodule.exports = extend;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi9leHRlbmQuanM/MjQ3YSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0QsMkdBQTJHLEVBQUU7QUFDN0oseUNBQXlDLHFHQUFxRyxFQUFFO0FBQ2hKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRHQUE0Ryw2S0FBNkssRUFBRTtBQUMzUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QiIsImZpbGUiOiI1Ny5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBhc3NlcnQgPSByZXF1aXJlKCcuL2Fzc2VydCcpO1xudmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG52YXIgbWl4aW4gPSByZXF1aXJlKCcuL21peGluJyk7XG52YXIgaXNTdHJ1Y3QgPSByZXF1aXJlKCcuL2lzU3RydWN0Jyk7XG52YXIgaXNJbnRlcmZhY2UgPSByZXF1aXJlKCcuL2lzSW50ZXJmYWNlJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG52YXIgcmVmaW5lbWVudCA9IHJlcXVpcmUoJy4vcmVmaW5lbWVudCcpO1xudmFyIGRlY29tcG9zZSA9IHJlcXVpcmUoJy4vZGVjb21wb3NlJyk7XG5cbmZ1bmN0aW9uIGNvbXBvc2UocHJlZGljYXRlcywgdW5yZWZpbmVkVHlwZSkge1xuICByZXR1cm4gcHJlZGljYXRlcy5yZWR1Y2UoZnVuY3Rpb24gKHR5cGUsIHByZWRpY2F0ZSkge1xuICAgIHJldHVybiByZWZpbmVtZW50KHR5cGUsIHByZWRpY2F0ZSk7XG4gIH0sIHVucmVmaW5lZFR5cGUpO1xufVxuXG5mdW5jdGlvbiBnZXRQcm9wcyh0eXBlKSB7XG4gIHJldHVybiBpc09iamVjdCh0eXBlKSA/IHR5cGUgOiB0eXBlLm1ldGEucHJvcHM7XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRQcm9wcyh0eXBlKSB7XG4gIHJldHVybiBpc09iamVjdCh0eXBlKSA/IG51bGwgOiB0eXBlLm1ldGEuZGVmYXVsdFByb3BzO1xufVxuXG5mdW5jdGlvbiBwdXNoQWxsKGFyciwgZWxlbWVudHMpIHtcbiAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoYXJyLCBlbGVtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGV4dGVuZChjb21iaW5hdG9yLCBtaXhpbnMsIG9wdGlvbnMpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnQoaXNGdW5jdGlvbihjb21iaW5hdG9yKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0ludmFsaWQgYXJndW1lbnQgY29tYmluYXRvciBzdXBwbGllZCB0byBleHRlbmQoY29tYmluYXRvciwgbWl4aW5zLCBvcHRpb25zKSwgZXhwZWN0ZWQgYSBmdW5jdGlvbic7IH0pO1xuICAgIGFzc2VydChpc0FycmF5KG1peGlucyksIGZ1bmN0aW9uICgpIHsgcmV0dXJuICdJbnZhbGlkIGFyZ3VtZW50IG1peGlucyBzdXBwbGllZCB0byBleHRlbmQoY29tYmluYXRvciwgbWl4aW5zLCBvcHRpb25zKSwgZXhwZWN0ZWQgYW4gYXJyYXknOyB9KTtcbiAgfVxuICB2YXIgcHJvcHMgPSB7fTtcbiAgdmFyIHByb3RvdHlwZSA9IHt9O1xuICB2YXIgcHJlZGljYXRlcyA9IFtdO1xuICB2YXIgZGVmYXVsdFByb3BzID0ge307XG4gIG1peGlucy5mb3JFYWNoKGZ1bmN0aW9uICh4LCBpKSB7XG4gICAgdmFyIGRlY29tcG9zaXRpb24gPSBkZWNvbXBvc2UoeCk7XG4gICAgdmFyIHVucmVmaW5lZFR5cGUgPSBkZWNvbXBvc2l0aW9uLnVucmVmaW5lZFR5cGU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGFzc2VydChpc09iamVjdCh1bnJlZmluZWRUeXBlKSB8fCBpc1N0cnVjdCh1bnJlZmluZWRUeXBlKSB8fCBpc0ludGVyZmFjZSh1bnJlZmluZWRUeXBlKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0ludmFsaWQgYXJndW1lbnQgbWl4aW5zWycgKyBpICsgJ10gc3VwcGxpZWQgdG8gZXh0ZW5kKGNvbWJpbmF0b3IsIG1peGlucywgb3B0aW9ucyksIGV4cGVjdGVkIGFuIG9iamVjdCwgc3RydWN0LCBpbnRlcmZhY2Ugb3IgYSByZWZpbmVtZW50IChvZiBzdHJ1Y3Qgb3IgaW50ZXJmYWNlKSc7IH0pO1xuICAgIH1cbiAgICBwdXNoQWxsKHByZWRpY2F0ZXMsIGRlY29tcG9zaXRpb24ucHJlZGljYXRlcyk7XG4gICAgbWl4aW4ocHJvcHMsIGdldFByb3BzKHVucmVmaW5lZFR5cGUpKTtcbiAgICBtaXhpbihwcm90b3R5cGUsIHVucmVmaW5lZFR5cGUucHJvdG90eXBlKTtcbiAgICBtaXhpbihkZWZhdWx0UHJvcHMsIGdldERlZmF1bHRQcm9wcyh1bnJlZmluZWRUeXBlKSk7XG4gIH0pO1xuICBvcHRpb25zID0gY29tYmluYXRvci5nZXRPcHRpb25zKG9wdGlvbnMpO1xuICBtaXhpbihvcHRpb25zLmRlZmF1bHRQcm9wcywgZGVmYXVsdFByb3BzKTtcbiAgdmFyIHJlc3VsdCA9IGNvbXBvc2UocHJlZGljYXRlcywgY29tYmluYXRvcihwcm9wcywgb3B0aW9ucykpO1xuICBtaXhpbihyZXN1bHQucHJvdG90eXBlLCBwcm90b3R5cGUpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4dGVuZDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi90Y29tYi9saWIvZXh0ZW5kLmpzXG4gKiogbW9kdWxlIGlkID0gNTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	eval("var isType = __webpack_require__(26);\n\nmodule.exports = function isStruct(x) {\n  return isType(x) && ( x.meta.kind === 'struct' );\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi9pc1N0cnVjdC5qcz8yYmE0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiI1OC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBpc1R5cGUgPSByZXF1aXJlKCcuL2lzVHlwZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzU3RydWN0KHgpIHtcbiAgcmV0dXJuIGlzVHlwZSh4KSAmJiAoIHgubWV0YS5raW5kID09PSAnc3RydWN0JyApO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi90Y29tYi9saWIvaXNTdHJ1Y3QuanNcbiAqKiBtb2R1bGUgaWQgPSA1OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	eval("var isType = __webpack_require__(26);\n\nmodule.exports = function isInterface(x) {\n  return isType(x) && ( x.meta.kind === 'interface' );\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi9pc0ludGVyZmFjZS5qcz9hYTllIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiI1OS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBpc1R5cGUgPSByZXF1aXJlKCcuL2lzVHlwZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzSW50ZXJmYWNlKHgpIHtcbiAgcmV0dXJuIGlzVHlwZSh4KSAmJiAoIHgubWV0YS5raW5kID09PSAnaW50ZXJmYWNlJyApO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi90Y29tYi9saWIvaXNJbnRlcmZhY2UuanNcbiAqKiBtb2R1bGUgaWQgPSA1OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	eval("var isType = __webpack_require__(26);\n\nfunction isRefinement(type) {\n  return isType(type) && type.meta.kind === 'subtype';\n}\n\nfunction getPredicates(type) {\n  return isRefinement(type) ?\n    [type.meta.predicate].concat(getPredicates(type.meta.type)) :\n    [];\n}\n\nfunction getUnrefinedType(type) {\n  return isRefinement(type) ?\n    getUnrefinedType(type.meta.type) :\n    type;\n}\n\nfunction decompose(type) {\n  return {\n    predicates: getPredicates(type),\n    unrefinedType: getUnrefinedType(type)\n  };\n}\n\nmodule.exports = decompose;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi9kZWNvbXBvc2UuanM/MmE5MiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiI2MC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBpc1R5cGUgPSByZXF1aXJlKCcuL2lzVHlwZScpO1xuXG5mdW5jdGlvbiBpc1JlZmluZW1lbnQodHlwZSkge1xuICByZXR1cm4gaXNUeXBlKHR5cGUpICYmIHR5cGUubWV0YS5raW5kID09PSAnc3VidHlwZSc7XG59XG5cbmZ1bmN0aW9uIGdldFByZWRpY2F0ZXModHlwZSkge1xuICByZXR1cm4gaXNSZWZpbmVtZW50KHR5cGUpID9cbiAgICBbdHlwZS5tZXRhLnByZWRpY2F0ZV0uY29uY2F0KGdldFByZWRpY2F0ZXModHlwZS5tZXRhLnR5cGUpKSA6XG4gICAgW107XG59XG5cbmZ1bmN0aW9uIGdldFVucmVmaW5lZFR5cGUodHlwZSkge1xuICByZXR1cm4gaXNSZWZpbmVtZW50KHR5cGUpID9cbiAgICBnZXRVbnJlZmluZWRUeXBlKHR5cGUubWV0YS50eXBlKSA6XG4gICAgdHlwZTtcbn1cblxuZnVuY3Rpb24gZGVjb21wb3NlKHR5cGUpIHtcbiAgcmV0dXJuIHtcbiAgICBwcmVkaWNhdGVzOiBnZXRQcmVkaWNhdGVzKHR5cGUpLFxuICAgIHVucmVmaW5lZFR5cGU6IGdldFVucmVmaW5lZFR5cGUodHlwZSlcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkZWNvbXBvc2U7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdGNvbWIvbGliL2RlY29tcG9zZS5qc1xuICoqIG1vZHVsZSBpZCA9IDYwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {var assert = __webpack_require__(14);\nvar isTypeName = __webpack_require__(40);\nvar isFunction = __webpack_require__(15);\nvar getTypeName = __webpack_require__(25);\nvar isIdentity = __webpack_require__(41);\nvar isArray = __webpack_require__(28);\nvar create = __webpack_require__(42);\nvar is = __webpack_require__(43);\n\nfunction getDefaultName(types) {\n  return '[' + types.map(getTypeName).join(', ') + ']';\n}\n\nfunction tuple(types, name) {\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(isArray(types) && types.every(isFunction), function () { return 'Invalid argument types ' + assert.stringify(types) + ' supplied to tuple(types, [name]) combinator (expected an array of types)'; });\n    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to tuple(types, [name]) combinator (expected a string)'; });\n  }\n\n  var displayName = name || getDefaultName(types);\n  var identity = types.every(isIdentity);\n\n  function Tuple(value, path) {\n\n    if (process.env.NODE_ENV === 'production') {\n      if (identity) {\n        return value;\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      path = path || [displayName];\n      assert(isArray(value) && value.length === types.length, function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/') + ' (expected an array of length ' + types.length + ')'; });\n    }\n\n    var idempotent = true;\n    var ret = [];\n    for (var i = 0, len = types.length; i < len; i++) {\n      var expected = types[i];\n      var actual = value[i];\n      var instance = create(expected, actual, ( process.env.NODE_ENV !== 'production' ? path.concat(i + ': ' + getTypeName(expected)) : null ));\n      idempotent = idempotent && ( actual === instance );\n      ret.push(instance);\n    }\n\n    if (idempotent) { // implements idempotency\n      ret = value;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      Object.freeze(ret);\n    }\n\n    return ret;\n  }\n\n  Tuple.meta = {\n    kind: 'tuple',\n    types: types,\n    name: name,\n    identity: identity\n  };\n\n  Tuple.displayName = displayName;\n\n  Tuple.is = function (x) {\n    return isArray(x) &&\n      x.length === types.length &&\n      types.every(function (type, i) {\n        return is(x[i], type);\n      });\n  };\n\n  Tuple.update = function (instance, patch) {\n    return Tuple(assert.update(instance, patch));\n  };\n\n  return Tuple;\n}\n\ntuple.getDefaultName = getDefaultName;\nmodule.exports = tuple;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi90dXBsZS5qcz85MGU0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbUVBQW1FLDBJQUEwSSxFQUFFO0FBQy9NLDBDQUEwQywrSEFBK0gsRUFBRTtBQUMzSzs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJFQUEyRSw4SUFBOEksRUFBRTtBQUMzTjs7QUFFQTtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsdUIiLCJmaWxlIjoiNjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXNzZXJ0ID0gcmVxdWlyZSgnLi9hc3NlcnQnKTtcbnZhciBpc1R5cGVOYW1lID0gcmVxdWlyZSgnLi9pc1R5cGVOYW1lJyk7XG52YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpO1xudmFyIGdldFR5cGVOYW1lID0gcmVxdWlyZSgnLi9nZXRUeXBlTmFtZScpO1xudmFyIGlzSWRlbnRpdHkgPSByZXF1aXJlKCcuL2lzSWRlbnRpdHknKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9jcmVhdGUnKTtcbnZhciBpcyA9IHJlcXVpcmUoJy4vaXMnKTtcblxuZnVuY3Rpb24gZ2V0RGVmYXVsdE5hbWUodHlwZXMpIHtcbiAgcmV0dXJuICdbJyArIHR5cGVzLm1hcChnZXRUeXBlTmFtZSkuam9pbignLCAnKSArICddJztcbn1cblxuZnVuY3Rpb24gdHVwbGUodHlwZXMsIG5hbWUpIHtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydChpc0FycmF5KHR5cGVzKSAmJiB0eXBlcy5ldmVyeShpc0Z1bmN0aW9uKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0ludmFsaWQgYXJndW1lbnQgdHlwZXMgJyArIGFzc2VydC5zdHJpbmdpZnkodHlwZXMpICsgJyBzdXBwbGllZCB0byB0dXBsZSh0eXBlcywgW25hbWVdKSBjb21iaW5hdG9yIChleHBlY3RlZCBhbiBhcnJheSBvZiB0eXBlcyknOyB9KTtcbiAgICBhc3NlcnQoaXNUeXBlTmFtZShuYW1lKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0ludmFsaWQgYXJndW1lbnQgbmFtZSAnICsgYXNzZXJ0LnN0cmluZ2lmeShuYW1lKSArICcgc3VwcGxpZWQgdG8gdHVwbGUodHlwZXMsIFtuYW1lXSkgY29tYmluYXRvciAoZXhwZWN0ZWQgYSBzdHJpbmcpJzsgfSk7XG4gIH1cblxuICB2YXIgZGlzcGxheU5hbWUgPSBuYW1lIHx8IGdldERlZmF1bHROYW1lKHR5cGVzKTtcbiAgdmFyIGlkZW50aXR5ID0gdHlwZXMuZXZlcnkoaXNJZGVudGl0eSk7XG5cbiAgZnVuY3Rpb24gVHVwbGUodmFsdWUsIHBhdGgpIHtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoaWRlbnRpdHkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBwYXRoID0gcGF0aCB8fCBbZGlzcGxheU5hbWVdO1xuICAgICAgYXNzZXJ0KGlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gdHlwZXMubGVuZ3RoLCBmdW5jdGlvbiAoKSB7IHJldHVybiAnSW52YWxpZCB2YWx1ZSAnICsgYXNzZXJ0LnN0cmluZ2lmeSh2YWx1ZSkgKyAnIHN1cHBsaWVkIHRvICcgKyBwYXRoLmpvaW4oJy8nKSArICcgKGV4cGVjdGVkIGFuIGFycmF5IG9mIGxlbmd0aCAnICsgdHlwZXMubGVuZ3RoICsgJyknOyB9KTtcbiAgICB9XG5cbiAgICB2YXIgaWRlbXBvdGVudCA9IHRydWU7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGV4cGVjdGVkID0gdHlwZXNbaV07XG4gICAgICB2YXIgYWN0dWFsID0gdmFsdWVbaV07XG4gICAgICB2YXIgaW5zdGFuY2UgPSBjcmVhdGUoZXhwZWN0ZWQsIGFjdHVhbCwgKCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gcGF0aC5jb25jYXQoaSArICc6ICcgKyBnZXRUeXBlTmFtZShleHBlY3RlZCkpIDogbnVsbCApKTtcbiAgICAgIGlkZW1wb3RlbnQgPSBpZGVtcG90ZW50ICYmICggYWN0dWFsID09PSBpbnN0YW5jZSApO1xuICAgICAgcmV0LnB1c2goaW5zdGFuY2UpO1xuICAgIH1cblxuICAgIGlmIChpZGVtcG90ZW50KSB7IC8vIGltcGxlbWVudHMgaWRlbXBvdGVuY3lcbiAgICAgIHJldCA9IHZhbHVlO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBPYmplY3QuZnJlZXplKHJldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIFR1cGxlLm1ldGEgPSB7XG4gICAga2luZDogJ3R1cGxlJyxcbiAgICB0eXBlczogdHlwZXMsXG4gICAgbmFtZTogbmFtZSxcbiAgICBpZGVudGl0eTogaWRlbnRpdHlcbiAgfTtcblxuICBUdXBsZS5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xuXG4gIFR1cGxlLmlzID0gZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4gaXNBcnJheSh4KSAmJlxuICAgICAgeC5sZW5ndGggPT09IHR5cGVzLmxlbmd0aCAmJlxuICAgICAgdHlwZXMuZXZlcnkoZnVuY3Rpb24gKHR5cGUsIGkpIHtcbiAgICAgICAgcmV0dXJuIGlzKHhbaV0sIHR5cGUpO1xuICAgICAgfSk7XG4gIH07XG5cbiAgVHVwbGUudXBkYXRlID0gZnVuY3Rpb24gKGluc3RhbmNlLCBwYXRjaCkge1xuICAgIHJldHVybiBUdXBsZShhc3NlcnQudXBkYXRlKGluc3RhbmNlLCBwYXRjaCkpO1xuICB9O1xuXG4gIHJldHVybiBUdXBsZTtcbn1cblxudHVwbGUuZ2V0RGVmYXVsdE5hbWUgPSBnZXREZWZhdWx0TmFtZTtcbm1vZHVsZS5leHBvcnRzID0gdHVwbGU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdGNvbWIvbGliL3R1cGxlLmpzXG4gKiogbW9kdWxlIGlkID0gNjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {var assert = __webpack_require__(14);\nvar isTypeName = __webpack_require__(40);\nvar isFunction = __webpack_require__(15);\nvar getTypeName = __webpack_require__(25);\nvar isIdentity = __webpack_require__(41);\nvar isArray = __webpack_require__(28);\nvar create = __webpack_require__(42);\nvar is = __webpack_require__(43);\nvar forbidNewOperator = __webpack_require__(24);\nvar isType = __webpack_require__(26);\nvar isUnion = __webpack_require__(63);\nvar isNil = __webpack_require__(16);\n\nfunction getDefaultName(types) {\n  return types.map(getTypeName).join(' | ');\n}\n\nfunction union(types, name) {\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(isArray(types) && types.every(isFunction) && types.length >= 2, function () { return 'Invalid argument types ' + assert.stringify(types) + ' supplied to union(types, [name]) combinator (expected an array of at least 2 types)'; });\n    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to union(types, [name]) combinator (expected a string)'; });\n  }\n\n  var displayName = name || getDefaultName(types);\n  var identity = types.every(isIdentity);\n\n  function Union(value, path) {\n\n    if (process.env.NODE_ENV === 'production') {\n      if (identity) {\n        return value;\n      }\n    }\n\n    var type = Union.dispatch(value);\n    if (!type && Union.is(value)) {\n      return value;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      forbidNewOperator(this, Union);\n      path = path || [displayName];\n      assert(isType(type), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/') + ' (no constructor returned by dispatch)'; });\n      path[path.length - 1] += '(' + getTypeName(type) + ')';\n    }\n\n    return create(type, value, path);\n  }\n\n  Union.meta = {\n    kind: 'union',\n    types: types,\n    name: name,\n    identity: identity\n  };\n\n  Union.displayName = displayName;\n\n  Union.is = function (x) {\n    return types.some(function (type) {\n      return is(x, type);\n    });\n  };\n\n  Union.dispatch = function (x) { // default dispatch implementation\n    for (var i = 0, len = types.length; i < len; i++ ) {\n      var type = types[i];\n      if (isUnion(type)) { // handle union of unions\n        var t = type.dispatch(x);\n        if (!isNil(t)) {\n          return t;\n        }\n      }\n      else if (is(x, type)) {\n        return type;\n      }\n    }\n  };\n\n  Union.update = function (instance, patch) {\n    return Union(assert.update(instance, patch));\n  };\n\n  return Union;\n}\n\nunion.getDefaultName = getDefaultName;\nmodule.exports = union;\n\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi91bmlvbi5qcz83MmZhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx3RkFBd0YscUpBQXFKLEVBQUU7QUFDL08sMENBQTBDLCtIQUErSCxFQUFFO0FBQzNLOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsaUlBQWlJLEVBQUU7QUFDM0s7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsaUNBQWlDO0FBQ2pDLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EiLCJmaWxlIjoiNjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXNzZXJ0ID0gcmVxdWlyZSgnLi9hc3NlcnQnKTtcbnZhciBpc1R5cGVOYW1lID0gcmVxdWlyZSgnLi9pc1R5cGVOYW1lJyk7XG52YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpO1xudmFyIGdldFR5cGVOYW1lID0gcmVxdWlyZSgnLi9nZXRUeXBlTmFtZScpO1xudmFyIGlzSWRlbnRpdHkgPSByZXF1aXJlKCcuL2lzSWRlbnRpdHknKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9jcmVhdGUnKTtcbnZhciBpcyA9IHJlcXVpcmUoJy4vaXMnKTtcbnZhciBmb3JiaWROZXdPcGVyYXRvciA9IHJlcXVpcmUoJy4vZm9yYmlkTmV3T3BlcmF0b3InKTtcbnZhciBpc1R5cGUgPSByZXF1aXJlKCcuL2lzVHlwZScpO1xudmFyIGlzVW5pb24gPSByZXF1aXJlKCcuL2lzVW5pb24nKTtcbnZhciBpc05pbCA9IHJlcXVpcmUoJy4vaXNOaWwnKTtcblxuZnVuY3Rpb24gZ2V0RGVmYXVsdE5hbWUodHlwZXMpIHtcbiAgcmV0dXJuIHR5cGVzLm1hcChnZXRUeXBlTmFtZSkuam9pbignIHwgJyk7XG59XG5cbmZ1bmN0aW9uIHVuaW9uKHR5cGVzLCBuYW1lKSB7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnQoaXNBcnJheSh0eXBlcykgJiYgdHlwZXMuZXZlcnkoaXNGdW5jdGlvbikgJiYgdHlwZXMubGVuZ3RoID49IDIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuICdJbnZhbGlkIGFyZ3VtZW50IHR5cGVzICcgKyBhc3NlcnQuc3RyaW5naWZ5KHR5cGVzKSArICcgc3VwcGxpZWQgdG8gdW5pb24odHlwZXMsIFtuYW1lXSkgY29tYmluYXRvciAoZXhwZWN0ZWQgYW4gYXJyYXkgb2YgYXQgbGVhc3QgMiB0eXBlcyknOyB9KTtcbiAgICBhc3NlcnQoaXNUeXBlTmFtZShuYW1lKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0ludmFsaWQgYXJndW1lbnQgbmFtZSAnICsgYXNzZXJ0LnN0cmluZ2lmeShuYW1lKSArICcgc3VwcGxpZWQgdG8gdW5pb24odHlwZXMsIFtuYW1lXSkgY29tYmluYXRvciAoZXhwZWN0ZWQgYSBzdHJpbmcpJzsgfSk7XG4gIH1cblxuICB2YXIgZGlzcGxheU5hbWUgPSBuYW1lIHx8IGdldERlZmF1bHROYW1lKHR5cGVzKTtcbiAgdmFyIGlkZW50aXR5ID0gdHlwZXMuZXZlcnkoaXNJZGVudGl0eSk7XG5cbiAgZnVuY3Rpb24gVW5pb24odmFsdWUsIHBhdGgpIHtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoaWRlbnRpdHkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0eXBlID0gVW5pb24uZGlzcGF0Y2godmFsdWUpO1xuICAgIGlmICghdHlwZSAmJiBVbmlvbi5pcyh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgZm9yYmlkTmV3T3BlcmF0b3IodGhpcywgVW5pb24pO1xuICAgICAgcGF0aCA9IHBhdGggfHwgW2Rpc3BsYXlOYW1lXTtcbiAgICAgIGFzc2VydChpc1R5cGUodHlwZSksIGZ1bmN0aW9uICgpIHsgcmV0dXJuICdJbnZhbGlkIHZhbHVlICcgKyBhc3NlcnQuc3RyaW5naWZ5KHZhbHVlKSArICcgc3VwcGxpZWQgdG8gJyArIHBhdGguam9pbignLycpICsgJyAobm8gY29uc3RydWN0b3IgcmV0dXJuZWQgYnkgZGlzcGF0Y2gpJzsgfSk7XG4gICAgICBwYXRoW3BhdGgubGVuZ3RoIC0gMV0gKz0gJygnICsgZ2V0VHlwZU5hbWUodHlwZSkgKyAnKSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZSh0eXBlLCB2YWx1ZSwgcGF0aCk7XG4gIH1cblxuICBVbmlvbi5tZXRhID0ge1xuICAgIGtpbmQ6ICd1bmlvbicsXG4gICAgdHlwZXM6IHR5cGVzLFxuICAgIG5hbWU6IG5hbWUsXG4gICAgaWRlbnRpdHk6IGlkZW50aXR5XG4gIH07XG5cbiAgVW5pb24uZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcblxuICBVbmlvbi5pcyA9IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIHR5cGVzLnNvbWUoZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIHJldHVybiBpcyh4LCB0eXBlKTtcbiAgICB9KTtcbiAgfTtcblxuICBVbmlvbi5kaXNwYXRjaCA9IGZ1bmN0aW9uICh4KSB7IC8vIGRlZmF1bHQgZGlzcGF0Y2ggaW1wbGVtZW50YXRpb25cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKysgKSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVzW2ldO1xuICAgICAgaWYgKGlzVW5pb24odHlwZSkpIHsgLy8gaGFuZGxlIHVuaW9uIG9mIHVuaW9uc1xuICAgICAgICB2YXIgdCA9IHR5cGUuZGlzcGF0Y2goeCk7XG4gICAgICAgIGlmICghaXNOaWwodCkpIHtcbiAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXMoeCwgdHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIFVuaW9uLnVwZGF0ZSA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgcGF0Y2gpIHtcbiAgICByZXR1cm4gVW5pb24oYXNzZXJ0LnVwZGF0ZShpbnN0YW5jZSwgcGF0Y2gpKTtcbiAgfTtcblxuICByZXR1cm4gVW5pb247XG59XG5cbnVuaW9uLmdldERlZmF1bHROYW1lID0gZ2V0RGVmYXVsdE5hbWU7XG5tb2R1bGUuZXhwb3J0cyA9IHVuaW9uO1xuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi90Y29tYi9saWIvdW5pb24uanNcbiAqKiBtb2R1bGUgaWQgPSA2MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	eval("var isType = __webpack_require__(26);\n\nmodule.exports = function isUnion(x) {\n  return isType(x) && ( x.meta.kind === 'union' );\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi9pc1VuaW9uLmpzPzJmMzQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6IjYzLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGlzVHlwZSA9IHJlcXVpcmUoJy4vaXNUeXBlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNVbmlvbih4KSB7XG4gIHJldHVybiBpc1R5cGUoeCkgJiYgKCB4Lm1ldGEua2luZCA9PT0gJ3VuaW9uJyApO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi90Y29tYi9saWIvaXNVbmlvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDYzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {var assert = __webpack_require__(14);\nvar isTypeName = __webpack_require__(40);\nvar FunctionType = __webpack_require__(34);\nvar isArray = __webpack_require__(28);\nvar list = __webpack_require__(52);\nvar isObject = __webpack_require__(27);\nvar create = __webpack_require__(42);\nvar isNil = __webpack_require__(16);\nvar isBoolean = __webpack_require__(31);\nvar tuple = __webpack_require__(61);\nvar getFunctionName = __webpack_require__(19);\nvar getTypeName = __webpack_require__(25);\nvar isType = __webpack_require__(26);\n\nfunction getDefaultName(domain, codomain) {\n  return '(' + domain.map(getTypeName).join(', ') + ') => ' + getTypeName(codomain);\n}\n\nfunction isInstrumented(f) {\n  return FunctionType.is(f) && isObject(f.instrumentation);\n}\n\nfunction getOptionalArgumentsIndex(types) {\n  var end = types.length;\n  var areAllMaybes = false;\n  for (var i = end - 1; i >= 0; i--) {\n    var type = types[i];\n    if (!isType(type) || type.meta.kind !== 'maybe') {\n      return (i + 1);\n    } else {\n      areAllMaybes = true;\n    }\n  }\n  return areAllMaybes ? 0 : end;\n}\n\nfunction func(domain, codomain, name) {\n\n  domain = isArray(domain) ? domain : [domain]; // handle handy syntax for unary functions\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(list(FunctionType).is(domain), function () { return 'Invalid argument domain ' + assert.stringify(domain) + ' supplied to func(domain, codomain, [name]) combinator (expected an array of types)'; });\n    assert(FunctionType.is(codomain), function () { return 'Invalid argument codomain ' + assert.stringify(codomain) + ' supplied to func(domain, codomain, [name]) combinator (expected a type)'; });\n    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to func(domain, codomain, [name]) combinator (expected a string)'; });\n  }\n\n  var displayName = name || getDefaultName(domain, codomain);\n  var domainLength = domain.length;\n  var optionalArgumentsIndex = getOptionalArgumentsIndex(domain);\n\n  function FuncType(value, path) {\n\n    if (!isInstrumented(value)) { // automatically instrument the function\n      return FuncType.of(value);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      path = path || [displayName];\n      assert(FuncType.is(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });\n    }\n\n    return value;\n  }\n\n  FuncType.meta = {\n    kind: 'func',\n    domain: domain,\n    codomain: codomain,\n    name: name,\n    identity: true\n  };\n\n  FuncType.displayName = displayName;\n\n  FuncType.is = function (x) {\n    return isInstrumented(x) &&\n      x.instrumentation.domain.length === domainLength &&\n      x.instrumentation.domain.every(function (type, i) {\n        return type === domain[i];\n      }) &&\n      x.instrumentation.codomain === codomain;\n  };\n\n  FuncType.of = function (f, curried) {\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert(FunctionType.is(f), function () { return 'Invalid argument f supplied to func.of ' + displayName + ' (expected a function)'; });\n      assert(isNil(curried) || isBoolean(curried), function () { return 'Invalid argument curried ' + assert.stringify(curried) + ' supplied to func.of ' + displayName + ' (expected a boolean)'; });\n    }\n\n    if (FuncType.is(f)) { // makes FuncType.of idempotent\n      return f;\n    }\n\n    function fn() {\n      var args = Array.prototype.slice.call(arguments);\n      var argsLength = args.length;\n\n      if (process.env.NODE_ENV !== 'production') {\n        // type-check arguments\n        var tupleLength = curried ? argsLength : Math.max(argsLength, optionalArgumentsIndex);\n        tuple(domain.slice(0, tupleLength), 'arguments of function ' + displayName)(args);\n      }\n\n      if (curried && argsLength < domainLength) {\n        if (process.env.NODE_ENV !== 'production') {\n          assert(argsLength > 0, 'Invalid arguments.length = 0 for curried function ' + displayName);\n        }\n        var g = Function.prototype.bind.apply(f, [this].concat(args));\n        var newDomain = func(domain.slice(argsLength), codomain);\n        return newDomain.of(g, true);\n      }\n      else {\n        return create(codomain, f.apply(this, args));\n      }\n    }\n\n    fn.instrumentation = {\n      domain: domain,\n      codomain: codomain,\n      f: f\n    };\n\n    fn.displayName = getFunctionName(f);\n\n    return fn;\n\n  };\n\n  return FuncType;\n\n}\n\nfunc.getDefaultName = getDefaultName;\nfunc.getOptionalArgumentsIndex = getOptionalArgumentsIndex;\nmodule.exports = func;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi9mdW5jLmpzPzdiZmQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwrQ0FBK0M7O0FBRS9DO0FBQ0EsdURBQXVELHNKQUFzSixFQUFFO0FBQy9NLG1EQUFtRCwrSUFBK0ksRUFBRTtBQUNwTSwwQ0FBMEMseUlBQXlJLEVBQUU7QUFDckw7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlDQUFpQztBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEMsc0ZBQXNGLEVBQUU7QUFDdEk7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw4Q0FBOEMsMkZBQTJGLEVBQUU7QUFDM0ksZ0VBQWdFLGtJQUFrSSxFQUFFO0FBQ3BNOztBQUVBLHlCQUF5QjtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiI2NC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBhc3NlcnQgPSByZXF1aXJlKCcuL2Fzc2VydCcpO1xudmFyIGlzVHlwZU5hbWUgPSByZXF1aXJlKCcuL2lzVHlwZU5hbWUnKTtcbnZhciBGdW5jdGlvblR5cGUgPSByZXF1aXJlKCcuL0Z1bmN0aW9uJyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xudmFyIGxpc3QgPSByZXF1aXJlKCcuL2xpc3QnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuL2NyZWF0ZScpO1xudmFyIGlzTmlsID0gcmVxdWlyZSgnLi9pc05pbCcpO1xudmFyIGlzQm9vbGVhbiA9IHJlcXVpcmUoJy4vaXNCb29sZWFuJyk7XG52YXIgdHVwbGUgPSByZXF1aXJlKCcuL3R1cGxlJyk7XG52YXIgZ2V0RnVuY3Rpb25OYW1lID0gcmVxdWlyZSgnLi9nZXRGdW5jdGlvbk5hbWUnKTtcbnZhciBnZXRUeXBlTmFtZSA9IHJlcXVpcmUoJy4vZ2V0VHlwZU5hbWUnKTtcbnZhciBpc1R5cGUgPSByZXF1aXJlKCcuL2lzVHlwZScpO1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0TmFtZShkb21haW4sIGNvZG9tYWluKSB7XG4gIHJldHVybiAnKCcgKyBkb21haW4ubWFwKGdldFR5cGVOYW1lKS5qb2luKCcsICcpICsgJykgPT4gJyArIGdldFR5cGVOYW1lKGNvZG9tYWluKTtcbn1cblxuZnVuY3Rpb24gaXNJbnN0cnVtZW50ZWQoZikge1xuICByZXR1cm4gRnVuY3Rpb25UeXBlLmlzKGYpICYmIGlzT2JqZWN0KGYuaW5zdHJ1bWVudGF0aW9uKTtcbn1cblxuZnVuY3Rpb24gZ2V0T3B0aW9uYWxBcmd1bWVudHNJbmRleCh0eXBlcykge1xuICB2YXIgZW5kID0gdHlwZXMubGVuZ3RoO1xuICB2YXIgYXJlQWxsTWF5YmVzID0gZmFsc2U7XG4gIGZvciAodmFyIGkgPSBlbmQgLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciB0eXBlID0gdHlwZXNbaV07XG4gICAgaWYgKCFpc1R5cGUodHlwZSkgfHwgdHlwZS5tZXRhLmtpbmQgIT09ICdtYXliZScpIHtcbiAgICAgIHJldHVybiAoaSArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcmVBbGxNYXliZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJlQWxsTWF5YmVzID8gMCA6IGVuZDtcbn1cblxuZnVuY3Rpb24gZnVuYyhkb21haW4sIGNvZG9tYWluLCBuYW1lKSB7XG5cbiAgZG9tYWluID0gaXNBcnJheShkb21haW4pID8gZG9tYWluIDogW2RvbWFpbl07IC8vIGhhbmRsZSBoYW5keSBzeW50YXggZm9yIHVuYXJ5IGZ1bmN0aW9uc1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0KGxpc3QoRnVuY3Rpb25UeXBlKS5pcyhkb21haW4pLCBmdW5jdGlvbiAoKSB7IHJldHVybiAnSW52YWxpZCBhcmd1bWVudCBkb21haW4gJyArIGFzc2VydC5zdHJpbmdpZnkoZG9tYWluKSArICcgc3VwcGxpZWQgdG8gZnVuYyhkb21haW4sIGNvZG9tYWluLCBbbmFtZV0pIGNvbWJpbmF0b3IgKGV4cGVjdGVkIGFuIGFycmF5IG9mIHR5cGVzKSc7IH0pO1xuICAgIGFzc2VydChGdW5jdGlvblR5cGUuaXMoY29kb21haW4pLCBmdW5jdGlvbiAoKSB7IHJldHVybiAnSW52YWxpZCBhcmd1bWVudCBjb2RvbWFpbiAnICsgYXNzZXJ0LnN0cmluZ2lmeShjb2RvbWFpbikgKyAnIHN1cHBsaWVkIHRvIGZ1bmMoZG9tYWluLCBjb2RvbWFpbiwgW25hbWVdKSBjb21iaW5hdG9yIChleHBlY3RlZCBhIHR5cGUpJzsgfSk7XG4gICAgYXNzZXJ0KGlzVHlwZU5hbWUobmFtZSksIGZ1bmN0aW9uICgpIHsgcmV0dXJuICdJbnZhbGlkIGFyZ3VtZW50IG5hbWUgJyArIGFzc2VydC5zdHJpbmdpZnkobmFtZSkgKyAnIHN1cHBsaWVkIHRvIGZ1bmMoZG9tYWluLCBjb2RvbWFpbiwgW25hbWVdKSBjb21iaW5hdG9yIChleHBlY3RlZCBhIHN0cmluZyknOyB9KTtcbiAgfVxuXG4gIHZhciBkaXNwbGF5TmFtZSA9IG5hbWUgfHwgZ2V0RGVmYXVsdE5hbWUoZG9tYWluLCBjb2RvbWFpbik7XG4gIHZhciBkb21haW5MZW5ndGggPSBkb21haW4ubGVuZ3RoO1xuICB2YXIgb3B0aW9uYWxBcmd1bWVudHNJbmRleCA9IGdldE9wdGlvbmFsQXJndW1lbnRzSW5kZXgoZG9tYWluKTtcblxuICBmdW5jdGlvbiBGdW5jVHlwZSh2YWx1ZSwgcGF0aCkge1xuXG4gICAgaWYgKCFpc0luc3RydW1lbnRlZCh2YWx1ZSkpIHsgLy8gYXV0b21hdGljYWxseSBpbnN0cnVtZW50IHRoZSBmdW5jdGlvblxuICAgICAgcmV0dXJuIEZ1bmNUeXBlLm9mKHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcGF0aCA9IHBhdGggfHwgW2Rpc3BsYXlOYW1lXTtcbiAgICAgIGFzc2VydChGdW5jVHlwZS5pcyh2YWx1ZSksIGZ1bmN0aW9uICgpIHsgcmV0dXJuICdJbnZhbGlkIHZhbHVlICcgKyBhc3NlcnQuc3RyaW5naWZ5KHZhbHVlKSArICcgc3VwcGxpZWQgdG8gJyArIHBhdGguam9pbignLycpOyB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBGdW5jVHlwZS5tZXRhID0ge1xuICAgIGtpbmQ6ICdmdW5jJyxcbiAgICBkb21haW46IGRvbWFpbixcbiAgICBjb2RvbWFpbjogY29kb21haW4sXG4gICAgbmFtZTogbmFtZSxcbiAgICBpZGVudGl0eTogdHJ1ZVxuICB9O1xuXG4gIEZ1bmNUeXBlLmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG5cbiAgRnVuY1R5cGUuaXMgPSBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiBpc0luc3RydW1lbnRlZCh4KSAmJlxuICAgICAgeC5pbnN0cnVtZW50YXRpb24uZG9tYWluLmxlbmd0aCA9PT0gZG9tYWluTGVuZ3RoICYmXG4gICAgICB4Lmluc3RydW1lbnRhdGlvbi5kb21haW4uZXZlcnkoZnVuY3Rpb24gKHR5cGUsIGkpIHtcbiAgICAgICAgcmV0dXJuIHR5cGUgPT09IGRvbWFpbltpXTtcbiAgICAgIH0pICYmXG4gICAgICB4Lmluc3RydW1lbnRhdGlvbi5jb2RvbWFpbiA9PT0gY29kb21haW47XG4gIH07XG5cbiAgRnVuY1R5cGUub2YgPSBmdW5jdGlvbiAoZiwgY3VycmllZCkge1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGFzc2VydChGdW5jdGlvblR5cGUuaXMoZiksIGZ1bmN0aW9uICgpIHsgcmV0dXJuICdJbnZhbGlkIGFyZ3VtZW50IGYgc3VwcGxpZWQgdG8gZnVuYy5vZiAnICsgZGlzcGxheU5hbWUgKyAnIChleHBlY3RlZCBhIGZ1bmN0aW9uKSc7IH0pO1xuICAgICAgYXNzZXJ0KGlzTmlsKGN1cnJpZWQpIHx8IGlzQm9vbGVhbihjdXJyaWVkKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0ludmFsaWQgYXJndW1lbnQgY3VycmllZCAnICsgYXNzZXJ0LnN0cmluZ2lmeShjdXJyaWVkKSArICcgc3VwcGxpZWQgdG8gZnVuYy5vZiAnICsgZGlzcGxheU5hbWUgKyAnIChleHBlY3RlZCBhIGJvb2xlYW4pJzsgfSk7XG4gICAgfVxuXG4gICAgaWYgKEZ1bmNUeXBlLmlzKGYpKSB7IC8vIG1ha2VzIEZ1bmNUeXBlLm9mIGlkZW1wb3RlbnRcbiAgICAgIHJldHVybiBmO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZuKCkge1xuICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgdmFyIGFyZ3NMZW5ndGggPSBhcmdzLmxlbmd0aDtcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgLy8gdHlwZS1jaGVjayBhcmd1bWVudHNcbiAgICAgICAgdmFyIHR1cGxlTGVuZ3RoID0gY3VycmllZCA/IGFyZ3NMZW5ndGggOiBNYXRoLm1heChhcmdzTGVuZ3RoLCBvcHRpb25hbEFyZ3VtZW50c0luZGV4KTtcbiAgICAgICAgdHVwbGUoZG9tYWluLnNsaWNlKDAsIHR1cGxlTGVuZ3RoKSwgJ2FyZ3VtZW50cyBvZiBmdW5jdGlvbiAnICsgZGlzcGxheU5hbWUpKGFyZ3MpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3VycmllZCAmJiBhcmdzTGVuZ3RoIDwgZG9tYWluTGVuZ3RoKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgYXNzZXJ0KGFyZ3NMZW5ndGggPiAwLCAnSW52YWxpZCBhcmd1bWVudHMubGVuZ3RoID0gMCBmb3IgY3VycmllZCBmdW5jdGlvbiAnICsgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBnID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoZiwgW3RoaXNdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgIHZhciBuZXdEb21haW4gPSBmdW5jKGRvbWFpbi5zbGljZShhcmdzTGVuZ3RoKSwgY29kb21haW4pO1xuICAgICAgICByZXR1cm4gbmV3RG9tYWluLm9mKGcsIHRydWUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBjcmVhdGUoY29kb21haW4sIGYuYXBwbHkodGhpcywgYXJncykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZuLmluc3RydW1lbnRhdGlvbiA9IHtcbiAgICAgIGRvbWFpbjogZG9tYWluLFxuICAgICAgY29kb21haW46IGNvZG9tYWluLFxuICAgICAgZjogZlxuICAgIH07XG5cbiAgICBmbi5kaXNwbGF5TmFtZSA9IGdldEZ1bmN0aW9uTmFtZShmKTtcblxuICAgIHJldHVybiBmbjtcblxuICB9O1xuXG4gIHJldHVybiBGdW5jVHlwZTtcblxufVxuXG5mdW5jLmdldERlZmF1bHROYW1lID0gZ2V0RGVmYXVsdE5hbWU7XG5mdW5jLmdldE9wdGlvbmFsQXJndW1lbnRzSW5kZXggPSBnZXRPcHRpb25hbEFyZ3VtZW50c0luZGV4O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdGNvbWIvbGliL2Z1bmMuanNcbiAqKiBtb2R1bGUgaWQgPSA2NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {var assert = __webpack_require__(14);\nvar isTypeName = __webpack_require__(40);\nvar isFunction = __webpack_require__(15);\nvar isArray = __webpack_require__(28);\nvar forbidNewOperator = __webpack_require__(41);\nvar is = __webpack_require__(43);\nvar getTypeName = __webpack_require__(25);\n\nfunction getDefaultName(types) {\n  return types.map(getTypeName).join(' & ');\n}\n\nfunction intersection(types, name) {\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(isArray(types) && types.every(isFunction) && types.length >= 2, function () { return 'Invalid argument types ' + assert.stringify(types) + ' supplied to intersection(types, [name]) combinator (expected an array of at least 2 types)'; });\n    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to intersection(types, [name]) combinator (expected a string)'; });\n  }\n\n  var displayName = name || getDefaultName(types);\n\n  function Intersection(value, path) {\n\n    if (process.env.NODE_ENV !== 'production') {\n      forbidNewOperator(this, Intersection);\n      path = path || [displayName];\n      assert(Intersection.is(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });\n    }\n\n    return value;\n  }\n\n  Intersection.meta = {\n    kind: 'intersection',\n    types: types,\n    name: name,\n    identity: true\n  };\n\n  Intersection.displayName = displayName;\n\n  Intersection.is = function (x) {\n    return types.every(function (type) {\n      return is(x, type);\n    });\n  };\n\n  Intersection.update = function (instance, patch) {\n    return Intersection(assert.update(instance, patch));\n  };\n\n  return Intersection;\n}\n\nintersection.getDefaultName = getDefaultName;\nmodule.exports = intersection;\n\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi9pbnRlcnNlY3Rpb24uanM/ZjA0NyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx3RkFBd0YsNEpBQTRKLEVBQUU7QUFDdFAsMENBQTBDLHNJQUFzSSxFQUFFO0FBQ2xMOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxzRkFBc0YsRUFBRTtBQUMxSTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSIsImZpbGUiOiI2NS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBhc3NlcnQgPSByZXF1aXJlKCcuL2Fzc2VydCcpO1xudmFyIGlzVHlwZU5hbWUgPSByZXF1aXJlKCcuL2lzVHlwZU5hbWUnKTtcbnZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xudmFyIGZvcmJpZE5ld09wZXJhdG9yID0gcmVxdWlyZSgnLi9pc0lkZW50aXR5Jyk7XG52YXIgaXMgPSByZXF1aXJlKCcuL2lzJyk7XG52YXIgZ2V0VHlwZU5hbWUgPSByZXF1aXJlKCcuL2dldFR5cGVOYW1lJyk7XG5cbmZ1bmN0aW9uIGdldERlZmF1bHROYW1lKHR5cGVzKSB7XG4gIHJldHVybiB0eXBlcy5tYXAoZ2V0VHlwZU5hbWUpLmpvaW4oJyAmICcpO1xufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3Rpb24odHlwZXMsIG5hbWUpIHtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydChpc0FycmF5KHR5cGVzKSAmJiB0eXBlcy5ldmVyeShpc0Z1bmN0aW9uKSAmJiB0eXBlcy5sZW5ndGggPj0gMiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0ludmFsaWQgYXJndW1lbnQgdHlwZXMgJyArIGFzc2VydC5zdHJpbmdpZnkodHlwZXMpICsgJyBzdXBwbGllZCB0byBpbnRlcnNlY3Rpb24odHlwZXMsIFtuYW1lXSkgY29tYmluYXRvciAoZXhwZWN0ZWQgYW4gYXJyYXkgb2YgYXQgbGVhc3QgMiB0eXBlcyknOyB9KTtcbiAgICBhc3NlcnQoaXNUeXBlTmFtZShuYW1lKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0ludmFsaWQgYXJndW1lbnQgbmFtZSAnICsgYXNzZXJ0LnN0cmluZ2lmeShuYW1lKSArICcgc3VwcGxpZWQgdG8gaW50ZXJzZWN0aW9uKHR5cGVzLCBbbmFtZV0pIGNvbWJpbmF0b3IgKGV4cGVjdGVkIGEgc3RyaW5nKSc7IH0pO1xuICB9XG5cbiAgdmFyIGRpc3BsYXlOYW1lID0gbmFtZSB8fCBnZXREZWZhdWx0TmFtZSh0eXBlcyk7XG5cbiAgZnVuY3Rpb24gSW50ZXJzZWN0aW9uKHZhbHVlLCBwYXRoKSB7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgZm9yYmlkTmV3T3BlcmF0b3IodGhpcywgSW50ZXJzZWN0aW9uKTtcbiAgICAgIHBhdGggPSBwYXRoIHx8IFtkaXNwbGF5TmFtZV07XG4gICAgICBhc3NlcnQoSW50ZXJzZWN0aW9uLmlzKHZhbHVlKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0ludmFsaWQgdmFsdWUgJyArIGFzc2VydC5zdHJpbmdpZnkodmFsdWUpICsgJyBzdXBwbGllZCB0byAnICsgcGF0aC5qb2luKCcvJyk7IH0pO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIEludGVyc2VjdGlvbi5tZXRhID0ge1xuICAgIGtpbmQ6ICdpbnRlcnNlY3Rpb24nLFxuICAgIHR5cGVzOiB0eXBlcyxcbiAgICBuYW1lOiBuYW1lLFxuICAgIGlkZW50aXR5OiB0cnVlXG4gIH07XG5cbiAgSW50ZXJzZWN0aW9uLmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG5cbiAgSW50ZXJzZWN0aW9uLmlzID0gZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4gdHlwZXMuZXZlcnkoZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIHJldHVybiBpcyh4LCB0eXBlKTtcbiAgICB9KTtcbiAgfTtcblxuICBJbnRlcnNlY3Rpb24udXBkYXRlID0gZnVuY3Rpb24gKGluc3RhbmNlLCBwYXRjaCkge1xuICAgIHJldHVybiBJbnRlcnNlY3Rpb24oYXNzZXJ0LnVwZGF0ZShpbnN0YW5jZSwgcGF0Y2gpKTtcbiAgfTtcblxuICByZXR1cm4gSW50ZXJzZWN0aW9uO1xufVxuXG5pbnRlcnNlY3Rpb24uZ2V0RGVmYXVsdE5hbWUgPSBnZXREZWZhdWx0TmFtZTtcbm1vZHVsZS5leHBvcnRzID0gaW50ZXJzZWN0aW9uO1xuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi90Y29tYi9saWIvaW50ZXJzZWN0aW9uLmpzXG4gKiogbW9kdWxlIGlkID0gNjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {var assert = __webpack_require__(14);\nvar isTypeName = __webpack_require__(40);\nvar String = __webpack_require__(46);\nvar Function = __webpack_require__(34);\nvar isBoolean = __webpack_require__(31);\nvar isObject = __webpack_require__(27);\nvar isNil = __webpack_require__(16);\nvar create = __webpack_require__(42);\nvar getTypeName = __webpack_require__(25);\nvar dict = __webpack_require__(48);\nvar getDefaultInterfaceName = __webpack_require__(56);\nvar isIdentity = __webpack_require__(41);\nvar is = __webpack_require__(43);\nvar extend = __webpack_require__(57);\n\nfunction extendInterface(mixins, name) {\n  return extend(inter, mixins, name);\n}\n\nfunction getOptions(options) {\n  if (!isObject(options)) {\n    options = isNil(options) ? {} : { name: options };\n  }\n  if (!options.hasOwnProperty('strict')) {\n    options.strict = inter.strict;\n  }\n  return options;\n}\n\nfunction inter(props, options) {\n\n  options = getOptions(options);\n  var name = options.name;\n  var strict = options.strict;\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(dict(String, Function).is(props), function () { return 'Invalid argument props ' + assert.stringify(props) + ' supplied to interface(props, [options]) combinator (expected a dictionary String -> Type)'; });\n    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to interface(props, [options]) combinator (expected a string)'; });\n    assert(isBoolean(strict), function () { return 'Invalid argument strict ' + assert.stringify(strict) + ' supplied to struct(props, [options]) combinator (expected a boolean)'; });\n  }\n\n  var displayName = name || getDefaultInterfaceName(props);\n  var identity = Object.keys(props).map(function (prop) { return props[prop]; }).every(isIdentity);\n\n  function Interface(value, path) {\n\n    if (process.env.NODE_ENV === 'production') {\n      if (identity) {\n        return value; // just trust the input if elements must not be hydrated\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      path = path || [displayName];\n      // strictness\n      if (strict) {\n        for (var k in value) {\n          assert(props.hasOwnProperty(k), function () { return 'Invalid additional prop \"' + k + '\" supplied to ' + path.join('/'); });\n        }\n      }\n    }\n\n    var idempotent = true;\n    var ret = {};\n    for (var prop in props) {\n      var expected = props[prop];\n      var actual = value[prop];\n      var instance = create(expected, actual, ( process.env.NODE_ENV !== 'production' ? path.concat(prop + ': ' + getTypeName(expected)) : null ));\n      idempotent = idempotent && ( actual === instance );\n      ret[prop] = instance;\n    }\n\n    if (idempotent) { // implements idempotency\n      ret = value;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      Object.freeze(ret);\n    }\n\n    return ret;\n\n  }\n\n  Interface.meta = {\n    kind: 'interface',\n    props: props,\n    name: name,\n    identity: identity,\n    strict: strict\n  };\n\n  Interface.displayName = displayName;\n\n  Interface.is = function (x) {\n    if (strict) {\n      for (var k in x) {\n        if (!props.hasOwnProperty(k)) {\n          return false;\n        }\n      }\n    }\n    for (var prop in props) {\n      if (!is(x[prop], props[prop])) {\n        return false;\n      }\n    }\n    return true;\n  };\n\n  Interface.update = function (instance, patch) {\n    return Interface(assert.update(instance, patch));\n  };\n\n  Interface.extend = function (xs, name) {\n    return extendInterface([Interface].concat(xs), name);\n  };\n\n  return Interface;\n}\n\ninter.strict = false;\ninter.getOptions = getOptions;\ninter.getDefaultName = getDefaultInterfaceName;\ninter.extend = extendInterface;\nmodule.exports = inter;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi9pbnRlcmZhY2UuanM/NmI2NCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDLElBQUk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBEQUEwRCwySkFBMkosRUFBRTtBQUN2TiwwQ0FBMEMsc0lBQXNJLEVBQUU7QUFDbEwsMkNBQTJDLHdJQUF3SSxFQUFFO0FBQ3JMOztBQUVBO0FBQ0EseURBQXlELG9CQUFvQixFQUFFOztBQUUvRTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCw0RUFBNEUsRUFBRTtBQUNySTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXNzZXJ0ID0gcmVxdWlyZSgnLi9hc3NlcnQnKTtcbnZhciBpc1R5cGVOYW1lID0gcmVxdWlyZSgnLi9pc1R5cGVOYW1lJyk7XG52YXIgU3RyaW5nID0gcmVxdWlyZSgnLi9TdHJpbmcnKTtcbnZhciBGdW5jdGlvbiA9IHJlcXVpcmUoJy4vRnVuY3Rpb24nKTtcbnZhciBpc0Jvb2xlYW4gPSByZXF1aXJlKCcuL2lzQm9vbGVhbicpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xudmFyIGlzTmlsID0gcmVxdWlyZSgnLi9pc05pbCcpO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4vY3JlYXRlJyk7XG52YXIgZ2V0VHlwZU5hbWUgPSByZXF1aXJlKCcuL2dldFR5cGVOYW1lJyk7XG52YXIgZGljdCA9IHJlcXVpcmUoJy4vZGljdCcpO1xudmFyIGdldERlZmF1bHRJbnRlcmZhY2VOYW1lID0gcmVxdWlyZSgnLi9nZXREZWZhdWx0SW50ZXJmYWNlTmFtZScpO1xudmFyIGlzSWRlbnRpdHkgPSByZXF1aXJlKCcuL2lzSWRlbnRpdHknKTtcbnZhciBpcyA9IHJlcXVpcmUoJy4vaXMnKTtcbnZhciBleHRlbmQgPSByZXF1aXJlKCcuL2V4dGVuZCcpO1xuXG5mdW5jdGlvbiBleHRlbmRJbnRlcmZhY2UobWl4aW5zLCBuYW1lKSB7XG4gIHJldHVybiBleHRlbmQoaW50ZXIsIG1peGlucywgbmFtZSk7XG59XG5cbmZ1bmN0aW9uIGdldE9wdGlvbnMob3B0aW9ucykge1xuICBpZiAoIWlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgb3B0aW9ucyA9IGlzTmlsKG9wdGlvbnMpID8ge30gOiB7IG5hbWU6IG9wdGlvbnMgfTtcbiAgfVxuICBpZiAoIW9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ3N0cmljdCcpKSB7XG4gICAgb3B0aW9ucy5zdHJpY3QgPSBpbnRlci5zdHJpY3Q7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbmZ1bmN0aW9uIGludGVyKHByb3BzLCBvcHRpb25zKSB7XG5cbiAgb3B0aW9ucyA9IGdldE9wdGlvbnMob3B0aW9ucyk7XG4gIHZhciBuYW1lID0gb3B0aW9ucy5uYW1lO1xuICB2YXIgc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3Q7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnQoZGljdChTdHJpbmcsIEZ1bmN0aW9uKS5pcyhwcm9wcyksIGZ1bmN0aW9uICgpIHsgcmV0dXJuICdJbnZhbGlkIGFyZ3VtZW50IHByb3BzICcgKyBhc3NlcnQuc3RyaW5naWZ5KHByb3BzKSArICcgc3VwcGxpZWQgdG8gaW50ZXJmYWNlKHByb3BzLCBbb3B0aW9uc10pIGNvbWJpbmF0b3IgKGV4cGVjdGVkIGEgZGljdGlvbmFyeSBTdHJpbmcgLT4gVHlwZSknOyB9KTtcbiAgICBhc3NlcnQoaXNUeXBlTmFtZShuYW1lKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0ludmFsaWQgYXJndW1lbnQgbmFtZSAnICsgYXNzZXJ0LnN0cmluZ2lmeShuYW1lKSArICcgc3VwcGxpZWQgdG8gaW50ZXJmYWNlKHByb3BzLCBbb3B0aW9uc10pIGNvbWJpbmF0b3IgKGV4cGVjdGVkIGEgc3RyaW5nKSc7IH0pO1xuICAgIGFzc2VydChpc0Jvb2xlYW4oc3RyaWN0KSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0ludmFsaWQgYXJndW1lbnQgc3RyaWN0ICcgKyBhc3NlcnQuc3RyaW5naWZ5KHN0cmljdCkgKyAnIHN1cHBsaWVkIHRvIHN0cnVjdChwcm9wcywgW29wdGlvbnNdKSBjb21iaW5hdG9yIChleHBlY3RlZCBhIGJvb2xlYW4pJzsgfSk7XG4gIH1cblxuICB2YXIgZGlzcGxheU5hbWUgPSBuYW1lIHx8IGdldERlZmF1bHRJbnRlcmZhY2VOYW1lKHByb3BzKTtcbiAgdmFyIGlkZW50aXR5ID0gT2JqZWN0LmtleXMocHJvcHMpLm1hcChmdW5jdGlvbiAocHJvcCkgeyByZXR1cm4gcHJvcHNbcHJvcF07IH0pLmV2ZXJ5KGlzSWRlbnRpdHkpO1xuXG4gIGZ1bmN0aW9uIEludGVyZmFjZSh2YWx1ZSwgcGF0aCkge1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpZGVudGl0eSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7IC8vIGp1c3QgdHJ1c3QgdGhlIGlucHV0IGlmIGVsZW1lbnRzIG11c3Qgbm90IGJlIGh5ZHJhdGVkXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHBhdGggPSBwYXRoIHx8IFtkaXNwbGF5TmFtZV07XG4gICAgICAvLyBzdHJpY3RuZXNzXG4gICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgIGZvciAodmFyIGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICBhc3NlcnQocHJvcHMuaGFzT3duUHJvcGVydHkoayksIGZ1bmN0aW9uICgpIHsgcmV0dXJuICdJbnZhbGlkIGFkZGl0aW9uYWwgcHJvcCBcIicgKyBrICsgJ1wiIHN1cHBsaWVkIHRvICcgKyBwYXRoLmpvaW4oJy8nKTsgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaWRlbXBvdGVudCA9IHRydWU7XG4gICAgdmFyIHJldCA9IHt9O1xuICAgIGZvciAodmFyIHByb3AgaW4gcHJvcHMpIHtcbiAgICAgIHZhciBleHBlY3RlZCA9IHByb3BzW3Byb3BdO1xuICAgICAgdmFyIGFjdHVhbCA9IHZhbHVlW3Byb3BdO1xuICAgICAgdmFyIGluc3RhbmNlID0gY3JlYXRlKGV4cGVjdGVkLCBhY3R1YWwsICggcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHBhdGguY29uY2F0KHByb3AgKyAnOiAnICsgZ2V0VHlwZU5hbWUoZXhwZWN0ZWQpKSA6IG51bGwgKSk7XG4gICAgICBpZGVtcG90ZW50ID0gaWRlbXBvdGVudCAmJiAoIGFjdHVhbCA9PT0gaW5zdGFuY2UgKTtcbiAgICAgIHJldFtwcm9wXSA9IGluc3RhbmNlO1xuICAgIH1cblxuICAgIGlmIChpZGVtcG90ZW50KSB7IC8vIGltcGxlbWVudHMgaWRlbXBvdGVuY3lcbiAgICAgIHJldCA9IHZhbHVlO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBPYmplY3QuZnJlZXplKHJldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcblxuICB9XG5cbiAgSW50ZXJmYWNlLm1ldGEgPSB7XG4gICAga2luZDogJ2ludGVyZmFjZScsXG4gICAgcHJvcHM6IHByb3BzLFxuICAgIG5hbWU6IG5hbWUsXG4gICAgaWRlbnRpdHk6IGlkZW50aXR5LFxuICAgIHN0cmljdDogc3RyaWN0XG4gIH07XG5cbiAgSW50ZXJmYWNlLmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG5cbiAgSW50ZXJmYWNlLmlzID0gZnVuY3Rpb24gKHgpIHtcbiAgICBpZiAoc3RyaWN0KSB7XG4gICAgICBmb3IgKHZhciBrIGluIHgpIHtcbiAgICAgICAgaWYgKCFwcm9wcy5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBwcm9wIGluIHByb3BzKSB7XG4gICAgICBpZiAoIWlzKHhbcHJvcF0sIHByb3BzW3Byb3BdKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIEludGVyZmFjZS51cGRhdGUgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIHBhdGNoKSB7XG4gICAgcmV0dXJuIEludGVyZmFjZShhc3NlcnQudXBkYXRlKGluc3RhbmNlLCBwYXRjaCkpO1xuICB9O1xuXG4gIEludGVyZmFjZS5leHRlbmQgPSBmdW5jdGlvbiAoeHMsIG5hbWUpIHtcbiAgICByZXR1cm4gZXh0ZW5kSW50ZXJmYWNlKFtJbnRlcmZhY2VdLmNvbmNhdCh4cyksIG5hbWUpO1xuICB9O1xuXG4gIHJldHVybiBJbnRlcmZhY2U7XG59XG5cbmludGVyLnN0cmljdCA9IGZhbHNlO1xuaW50ZXIuZ2V0T3B0aW9ucyA9IGdldE9wdGlvbnM7XG5pbnRlci5nZXREZWZhdWx0TmFtZSA9IGdldERlZmF1bHRJbnRlcmZhY2VOYW1lO1xuaW50ZXIuZXh0ZW5kID0gZXh0ZW5kSW50ZXJmYWNlO1xubW9kdWxlLmV4cG9ydHMgPSBpbnRlcjtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Rjb21iL2xpYi9pbnRlcmZhY2UuanNcbiAqKiBtb2R1bGUgaWQgPSA2NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {var assert = __webpack_require__(14);\nvar isObject = __webpack_require__(27);\nvar isFunction = __webpack_require__(15);\nvar isArray = __webpack_require__(28);\nvar isNumber = __webpack_require__(37);\nvar mixin = __webpack_require__(50);\n\nfunction getShallowCopy(x) {\n  if (isArray(x)) {\n    return x.concat();\n  }\n  if (x instanceof Date || x instanceof RegExp) {\n    return x;\n  }\n  if (isObject(x)) {\n    return mixin({}, x);\n  }\n  return x;\n}\n\nfunction isCommand(k) {\n  return update.commands.hasOwnProperty(k);\n}\n\nfunction getCommand(k) {\n  return update.commands[k];\n}\n\nfunction update(instance, patch) {\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(isObject(patch), function () { return 'Invalid argument patch ' + assert.stringify(patch) + ' supplied to function update(instance, patch): expected an object containing commands'; });\n  }\n\n  var value = instance;\n  var isChanged = false;\n  var newValue;\n  for (var k in patch) {\n    if (patch.hasOwnProperty(k)) {\n      if (isCommand(k)) {\n        newValue = getCommand(k)(patch[k], value);\n        if (newValue !== instance) {\n          isChanged = true;\n          value = newValue;\n        } else {\n          value = instance;\n        }\n      }\n      else {\n        if (value === instance) {\n          value = getShallowCopy(instance);\n        }\n        newValue = update(value[k], patch[k]);\n        isChanged = isChanged || ( newValue !== value[k] );\n        value[k] = newValue;\n      }\n    }\n  }\n  return isChanged ? value : instance;\n}\n\n// built-in commands\n\nfunction $apply(f, value) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert(isFunction(f), 'Invalid argument f supplied to immutability helper { $apply: f } (expected a function)');\n  }\n  return f(value);\n}\n\nfunction $push(elements, arr) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert(isArray(elements), 'Invalid argument elements supplied to immutability helper { $push: elements } (expected an array)');\n    assert(isArray(arr), 'Invalid value supplied to immutability helper $push (expected an array)');\n  }\n  if (elements.length > 0) {\n    return arr.concat(elements);\n  }\n  return arr;\n}\n\nfunction $remove(keys, obj) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert(isArray(keys), 'Invalid argument keys supplied to immutability helper { $remove: keys } (expected an array)');\n    assert(isObject(obj), 'Invalid value supplied to immutability helper $remove (expected an object)');\n  }\n  if (keys.length > 0) {\n    obj = getShallowCopy(obj);\n    for (var i = 0, len = keys.length; i < len; i++ ) {\n      delete obj[keys[i]];\n    }\n  }\n  return obj;\n}\n\nfunction $set(value) {\n  return value;\n}\n\nfunction $splice(splices, arr) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert(isArray(splices) && splices.every(isArray), 'Invalid argument splices supplied to immutability helper { $splice: splices } (expected an array of arrays)');\n    assert(isArray(arr), 'Invalid value supplied to immutability helper $splice (expected an array)');\n  }\n  if (splices.length > 0) {\n    arr = getShallowCopy(arr);\n    return splices.reduce(function (acc, splice) {\n      acc.splice.apply(acc, splice);\n      return acc;\n    }, arr);\n  }\n  return arr;\n}\n\nfunction $swap(config, arr) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert(isObject(config), 'Invalid argument config supplied to immutability helper { $swap: config } (expected an object)');\n    assert(isNumber(config.from), 'Invalid argument config.from supplied to immutability helper { $swap: config } (expected a number)');\n    assert(isNumber(config.to), 'Invalid argument config.to supplied to immutability helper { $swap: config } (expected a number)');\n    assert(isArray(arr), 'Invalid value supplied to immutability helper $swap (expected an array)');\n  }\n  if (config.from !== config.to) {\n    arr = getShallowCopy(arr);\n    var element = arr[config.to];\n    arr[config.to] = arr[config.from];\n    arr[config.from] = element;\n  }\n  return arr;\n}\n\nfunction $unshift(elements, arr) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert(isArray(elements), 'Invalid argument elements supplied to immutability helper {$unshift: elements} (expected an array)');\n    assert(isArray(arr), 'Invalid value supplied to immutability helper $unshift (expected an array)');\n  }\n  if (elements.length > 0) {\n    return elements.concat(arr);\n  }\n  return arr;\n}\n\nfunction $merge(whatToMerge, value) {\n  var isChanged = false;\n  var result = getShallowCopy(value);\n  for (var k in whatToMerge) {\n    if (whatToMerge.hasOwnProperty(k)) {\n      result[k] = whatToMerge[k];\n      isChanged = isChanged || ( result[k] !== value[k] );\n    }\n  }\n  return isChanged ? result : value;\n}\n\nupdate.commands = {\n  $apply: $apply,\n  $push: $push,\n  $remove: $remove,\n  $set: $set,\n  $splice: $splice,\n  $swap: $swap,\n  $unshift: $unshift,\n  $merge: $merge\n};\n\nmodule.exports = update;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi91cGRhdGUuanM/M2E1MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHlDQUF5QyxzSkFBc0osRUFBRTtBQUNqTTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLCtFQUErRSxZQUFZO0FBQzNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEZBQTBGLGtCQUFrQjtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0ZBQWtGLGdCQUFnQjtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrSEFBa0gsbUJBQW1CO0FBQ3JJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUZBQXVGLGdCQUFnQjtBQUN2RyxpR0FBaUcsZ0JBQWdCO0FBQ2pILDZGQUE2RixnQkFBZ0I7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBGQUEwRixtQkFBbUI7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiI2Ny5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBhc3NlcnQgPSByZXF1aXJlKCcuL2Fzc2VydCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xudmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG52YXIgaXNOdW1iZXIgPSByZXF1aXJlKCcuL2lzTnVtYmVyJyk7XG52YXIgbWl4aW4gPSByZXF1aXJlKCcuL21peGluJyk7XG5cbmZ1bmN0aW9uIGdldFNoYWxsb3dDb3B5KHgpIHtcbiAgaWYgKGlzQXJyYXkoeCkpIHtcbiAgICByZXR1cm4geC5jb25jYXQoKTtcbiAgfVxuICBpZiAoeCBpbnN0YW5jZW9mIERhdGUgfHwgeCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiB4O1xuICB9XG4gIGlmIChpc09iamVjdCh4KSkge1xuICAgIHJldHVybiBtaXhpbih7fSwgeCk7XG4gIH1cbiAgcmV0dXJuIHg7XG59XG5cbmZ1bmN0aW9uIGlzQ29tbWFuZChrKSB7XG4gIHJldHVybiB1cGRhdGUuY29tbWFuZHMuaGFzT3duUHJvcGVydHkoayk7XG59XG5cbmZ1bmN0aW9uIGdldENvbW1hbmQoaykge1xuICByZXR1cm4gdXBkYXRlLmNvbW1hbmRzW2tdO1xufVxuXG5mdW5jdGlvbiB1cGRhdGUoaW5zdGFuY2UsIHBhdGNoKSB7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnQoaXNPYmplY3QocGF0Y2gpLCBmdW5jdGlvbiAoKSB7IHJldHVybiAnSW52YWxpZCBhcmd1bWVudCBwYXRjaCAnICsgYXNzZXJ0LnN0cmluZ2lmeShwYXRjaCkgKyAnIHN1cHBsaWVkIHRvIGZ1bmN0aW9uIHVwZGF0ZShpbnN0YW5jZSwgcGF0Y2gpOiBleHBlY3RlZCBhbiBvYmplY3QgY29udGFpbmluZyBjb21tYW5kcyc7IH0pO1xuICB9XG5cbiAgdmFyIHZhbHVlID0gaW5zdGFuY2U7XG4gIHZhciBpc0NoYW5nZWQgPSBmYWxzZTtcbiAgdmFyIG5ld1ZhbHVlO1xuICBmb3IgKHZhciBrIGluIHBhdGNoKSB7XG4gICAgaWYgKHBhdGNoLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICBpZiAoaXNDb21tYW5kKGspKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gZ2V0Q29tbWFuZChrKShwYXRjaFtrXSwgdmFsdWUpO1xuICAgICAgICBpZiAobmV3VmFsdWUgIT09IGluc3RhbmNlKSB7XG4gICAgICAgICAgaXNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICB2YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gaW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAodmFsdWUgPT09IGluc3RhbmNlKSB7XG4gICAgICAgICAgdmFsdWUgPSBnZXRTaGFsbG93Q29weShpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgbmV3VmFsdWUgPSB1cGRhdGUodmFsdWVba10sIHBhdGNoW2tdKTtcbiAgICAgICAgaXNDaGFuZ2VkID0gaXNDaGFuZ2VkIHx8ICggbmV3VmFsdWUgIT09IHZhbHVlW2tdICk7XG4gICAgICAgIHZhbHVlW2tdID0gbmV3VmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBpc0NoYW5nZWQgPyB2YWx1ZSA6IGluc3RhbmNlO1xufVxuXG4vLyBidWlsdC1pbiBjb21tYW5kc1xuXG5mdW5jdGlvbiAkYXBwbHkoZiwgdmFsdWUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnQoaXNGdW5jdGlvbihmKSwgJ0ludmFsaWQgYXJndW1lbnQgZiBzdXBwbGllZCB0byBpbW11dGFiaWxpdHkgaGVscGVyIHsgJGFwcGx5OiBmIH0gKGV4cGVjdGVkIGEgZnVuY3Rpb24pJyk7XG4gIH1cbiAgcmV0dXJuIGYodmFsdWUpO1xufVxuXG5mdW5jdGlvbiAkcHVzaChlbGVtZW50cywgYXJyKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0KGlzQXJyYXkoZWxlbWVudHMpLCAnSW52YWxpZCBhcmd1bWVudCBlbGVtZW50cyBzdXBwbGllZCB0byBpbW11dGFiaWxpdHkgaGVscGVyIHsgJHB1c2g6IGVsZW1lbnRzIH0gKGV4cGVjdGVkIGFuIGFycmF5KScpO1xuICAgIGFzc2VydChpc0FycmF5KGFyciksICdJbnZhbGlkIHZhbHVlIHN1cHBsaWVkIHRvIGltbXV0YWJpbGl0eSBoZWxwZXIgJHB1c2ggKGV4cGVjdGVkIGFuIGFycmF5KScpO1xuICB9XG4gIGlmIChlbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIGFyci5jb25jYXQoZWxlbWVudHMpO1xuICB9XG4gIHJldHVybiBhcnI7XG59XG5cbmZ1bmN0aW9uICRyZW1vdmUoa2V5cywgb2JqKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0KGlzQXJyYXkoa2V5cyksICdJbnZhbGlkIGFyZ3VtZW50IGtleXMgc3VwcGxpZWQgdG8gaW1tdXRhYmlsaXR5IGhlbHBlciB7ICRyZW1vdmU6IGtleXMgfSAoZXhwZWN0ZWQgYW4gYXJyYXkpJyk7XG4gICAgYXNzZXJ0KGlzT2JqZWN0KG9iaiksICdJbnZhbGlkIHZhbHVlIHN1cHBsaWVkIHRvIGltbXV0YWJpbGl0eSBoZWxwZXIgJHJlbW92ZSAoZXhwZWN0ZWQgYW4gb2JqZWN0KScpO1xuICB9XG4gIGlmIChrZXlzLmxlbmd0aCA+IDApIHtcbiAgICBvYmogPSBnZXRTaGFsbG93Q29weShvYmopO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xuICAgICAgZGVsZXRlIG9ialtrZXlzW2ldXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gJHNldCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uICRzcGxpY2Uoc3BsaWNlcywgYXJyKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0KGlzQXJyYXkoc3BsaWNlcykgJiYgc3BsaWNlcy5ldmVyeShpc0FycmF5KSwgJ0ludmFsaWQgYXJndW1lbnQgc3BsaWNlcyBzdXBwbGllZCB0byBpbW11dGFiaWxpdHkgaGVscGVyIHsgJHNwbGljZTogc3BsaWNlcyB9IChleHBlY3RlZCBhbiBhcnJheSBvZiBhcnJheXMpJyk7XG4gICAgYXNzZXJ0KGlzQXJyYXkoYXJyKSwgJ0ludmFsaWQgdmFsdWUgc3VwcGxpZWQgdG8gaW1tdXRhYmlsaXR5IGhlbHBlciAkc3BsaWNlIChleHBlY3RlZCBhbiBhcnJheSknKTtcbiAgfVxuICBpZiAoc3BsaWNlcy5sZW5ndGggPiAwKSB7XG4gICAgYXJyID0gZ2V0U2hhbGxvd0NvcHkoYXJyKTtcbiAgICByZXR1cm4gc3BsaWNlcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgc3BsaWNlKSB7XG4gICAgICBhY2Muc3BsaWNlLmFwcGx5KGFjYywgc3BsaWNlKTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgYXJyKTtcbiAgfVxuICByZXR1cm4gYXJyO1xufVxuXG5mdW5jdGlvbiAkc3dhcChjb25maWcsIGFycikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydChpc09iamVjdChjb25maWcpLCAnSW52YWxpZCBhcmd1bWVudCBjb25maWcgc3VwcGxpZWQgdG8gaW1tdXRhYmlsaXR5IGhlbHBlciB7ICRzd2FwOiBjb25maWcgfSAoZXhwZWN0ZWQgYW4gb2JqZWN0KScpO1xuICAgIGFzc2VydChpc051bWJlcihjb25maWcuZnJvbSksICdJbnZhbGlkIGFyZ3VtZW50IGNvbmZpZy5mcm9tIHN1cHBsaWVkIHRvIGltbXV0YWJpbGl0eSBoZWxwZXIgeyAkc3dhcDogY29uZmlnIH0gKGV4cGVjdGVkIGEgbnVtYmVyKScpO1xuICAgIGFzc2VydChpc051bWJlcihjb25maWcudG8pLCAnSW52YWxpZCBhcmd1bWVudCBjb25maWcudG8gc3VwcGxpZWQgdG8gaW1tdXRhYmlsaXR5IGhlbHBlciB7ICRzd2FwOiBjb25maWcgfSAoZXhwZWN0ZWQgYSBudW1iZXIpJyk7XG4gICAgYXNzZXJ0KGlzQXJyYXkoYXJyKSwgJ0ludmFsaWQgdmFsdWUgc3VwcGxpZWQgdG8gaW1tdXRhYmlsaXR5IGhlbHBlciAkc3dhcCAoZXhwZWN0ZWQgYW4gYXJyYXkpJyk7XG4gIH1cbiAgaWYgKGNvbmZpZy5mcm9tICE9PSBjb25maWcudG8pIHtcbiAgICBhcnIgPSBnZXRTaGFsbG93Q29weShhcnIpO1xuICAgIHZhciBlbGVtZW50ID0gYXJyW2NvbmZpZy50b107XG4gICAgYXJyW2NvbmZpZy50b10gPSBhcnJbY29uZmlnLmZyb21dO1xuICAgIGFycltjb25maWcuZnJvbV0gPSBlbGVtZW50O1xuICB9XG4gIHJldHVybiBhcnI7XG59XG5cbmZ1bmN0aW9uICR1bnNoaWZ0KGVsZW1lbnRzLCBhcnIpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnQoaXNBcnJheShlbGVtZW50cyksICdJbnZhbGlkIGFyZ3VtZW50IGVsZW1lbnRzIHN1cHBsaWVkIHRvIGltbXV0YWJpbGl0eSBoZWxwZXIgeyR1bnNoaWZ0OiBlbGVtZW50c30gKGV4cGVjdGVkIGFuIGFycmF5KScpO1xuICAgIGFzc2VydChpc0FycmF5KGFyciksICdJbnZhbGlkIHZhbHVlIHN1cHBsaWVkIHRvIGltbXV0YWJpbGl0eSBoZWxwZXIgJHVuc2hpZnQgKGV4cGVjdGVkIGFuIGFycmF5KScpO1xuICB9XG4gIGlmIChlbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIGVsZW1lbnRzLmNvbmNhdChhcnIpO1xuICB9XG4gIHJldHVybiBhcnI7XG59XG5cbmZ1bmN0aW9uICRtZXJnZSh3aGF0VG9NZXJnZSwgdmFsdWUpIHtcbiAgdmFyIGlzQ2hhbmdlZCA9IGZhbHNlO1xuICB2YXIgcmVzdWx0ID0gZ2V0U2hhbGxvd0NvcHkodmFsdWUpO1xuICBmb3IgKHZhciBrIGluIHdoYXRUb01lcmdlKSB7XG4gICAgaWYgKHdoYXRUb01lcmdlLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICByZXN1bHRba10gPSB3aGF0VG9NZXJnZVtrXTtcbiAgICAgIGlzQ2hhbmdlZCA9IGlzQ2hhbmdlZCB8fCAoIHJlc3VsdFtrXSAhPT0gdmFsdWVba10gKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGlzQ2hhbmdlZCA/IHJlc3VsdCA6IHZhbHVlO1xufVxuXG51cGRhdGUuY29tbWFuZHMgPSB7XG4gICRhcHBseTogJGFwcGx5LFxuICAkcHVzaDogJHB1c2gsXG4gICRyZW1vdmU6ICRyZW1vdmUsXG4gICRzZXQ6ICRzZXQsXG4gICRzcGxpY2U6ICRzcGxpY2UsXG4gICRzd2FwOiAkc3dhcCxcbiAgJHVuc2hpZnQ6ICR1bnNoaWZ0LFxuICAkbWVyZ2U6ICRtZXJnZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB1cGRhdGU7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi90Y29tYi9saWIvdXBkYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gNjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {var assert = __webpack_require__(14);\nvar isFunction = __webpack_require__(15);\nvar isType = __webpack_require__(26);\nvar Any = __webpack_require__(20);\n\nmodule.exports = function match(x) {\n  var type, guard, f, count;\n  for (var i = 1, len = arguments.length; i < len; ) {\n    type = arguments[i];\n    guard = arguments[i + 1];\n    f = arguments[i + 2];\n\n    if (isFunction(f) && !isType(f)) {\n      i = i + 3;\n    }\n    else {\n      f = guard;\n      guard = Any.is;\n      i = i + 2;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      count = (count || 0) + 1;\n      assert(isType(type), function () { return 'Invalid type in clause #' + count; });\n      assert(isFunction(guard), function () { return 'Invalid guard in clause #' + count; });\n      assert(isFunction(f), function () { return 'Invalid block in clause #' + count; });\n    }\n\n    if (type.is(x) && guard(x)) {\n      return f(x);\n    }\n  }\n  assert.fail('Match error');\n};\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Rjb21iL2xpYi9tYXRjaC5qcz8wZjQyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDLDJDQUEyQyxFQUFFO0FBQ3JGLDZDQUE2Qyw0Q0FBNEMsRUFBRTtBQUMzRix5Q0FBeUMsNENBQTRDLEVBQUU7QUFDdkY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjY4LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGFzc2VydCA9IHJlcXVpcmUoJy4vYXNzZXJ0Jyk7XG52YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpO1xudmFyIGlzVHlwZSA9IHJlcXVpcmUoJy4vaXNUeXBlJyk7XG52YXIgQW55ID0gcmVxdWlyZSgnLi9BbnknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtYXRjaCh4KSB7XG4gIHZhciB0eXBlLCBndWFyZCwgZiwgY291bnQ7XG4gIGZvciAodmFyIGkgPSAxLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuOyApIHtcbiAgICB0eXBlID0gYXJndW1lbnRzW2ldO1xuICAgIGd1YXJkID0gYXJndW1lbnRzW2kgKyAxXTtcbiAgICBmID0gYXJndW1lbnRzW2kgKyAyXTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKGYpICYmICFpc1R5cGUoZikpIHtcbiAgICAgIGkgPSBpICsgMztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBmID0gZ3VhcmQ7XG4gICAgICBndWFyZCA9IEFueS5pcztcbiAgICAgIGkgPSBpICsgMjtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgY291bnQgPSAoY291bnQgfHwgMCkgKyAxO1xuICAgICAgYXNzZXJ0KGlzVHlwZSh0eXBlKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0ludmFsaWQgdHlwZSBpbiBjbGF1c2UgIycgKyBjb3VudDsgfSk7XG4gICAgICBhc3NlcnQoaXNGdW5jdGlvbihndWFyZCksIGZ1bmN0aW9uICgpIHsgcmV0dXJuICdJbnZhbGlkIGd1YXJkIGluIGNsYXVzZSAjJyArIGNvdW50OyB9KTtcbiAgICAgIGFzc2VydChpc0Z1bmN0aW9uKGYpLCBmdW5jdGlvbiAoKSB7IHJldHVybiAnSW52YWxpZCBibG9jayBpbiBjbGF1c2UgIycgKyBjb3VudDsgfSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUuaXMoeCkgJiYgZ3VhcmQoeCkpIHtcbiAgICAgIHJldHVybiBmKHgpO1xuICAgIH1cbiAgfVxuICBhc3NlcnQuZmFpbCgnTWF0Y2ggZXJyb3InKTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi90Y29tYi9saWIvbWF0Y2guanNcbiAqKiBtb2R1bGUgaWQgPSA2OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MoveType = exports.Lenses = exports.Model = exports.InitTable = exports.Table = exports.Subpile = exports.Pile = exports.Piles = exports.Foundations = exports.Foundation = exports.VisibleWaste = exports.HiddenWaste = exports.Stock = exports.Deck = exports.Card = undefined;\n\nvar _tcomb = __webpack_require__(13);\n\nvar _tcomb2 = _interopRequireDefault(_tcomb);\n\nvar _ramda = __webpack_require__(1);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar len = (0, _ramda.propEq)('length');\nvar maxLen = function maxLen(x) {\n  return (0, _ramda.propSatisfies)((0, _ramda.gte)(x), 'length');\n};\nvar allUniq = function allUniq(a) {\n  return (0, _ramda.equals)(a, (0, _ramda.uniq)(a));\n};\n\n/*  Deck  */\nvar isRank = function isRank(n) {\n  return n >= 1 && n <= 14;\n};\nvar Rank = (0, _tcomb.refinement)(_tcomb2.default.Number, isRank, 'Rank');\n\nvar Suit = _tcomb.enums.of(['hearts', 'clubs', 'spades', 'diamonds'], 'Suit');\n\nvar Card = (0, _tcomb.tuple)([Rank, Suit], 'Card');\n\nvar Deck = (0, _tcomb.refinement)(_tcomb2.default.list(Card), (0, _ramda.allPass)([len(52), allUniq]), 'Deck');\n\n/*  Table  */\nvar Stock = _tcomb2.default.refinement(_tcomb2.default.list(Card), maxLen(52), 'Stock');\n\nvar HiddenWaste = _tcomb2.default.list(Card, 'HiddenWaste');\nvar VisibleWaste = _tcomb2.default.refinement(_tcomb2.default.list(Card), maxLen(3), 'VisibleWaste');\n\nvar Foundation = _tcomb2.default.refinement(_tcomb2.default.list(Card), maxLen(13), 'Foundation');\nvar Foundations = _tcomb2.default.refinement(_tcomb2.default.list(Foundation), len(4), 'Foundations');\n\nvar Subpile = (0, _tcomb.refinement)((0, _tcomb.list)(Card), maxLen(52), 'Subpile');\nvar Pile = _tcomb2.default.interface({ downturned: Subpile, upturned: Subpile }, 'Pile');\nvar Piles = (0, _tcomb.refinement)((0, _tcomb.list)(Pile), len(7), 'Piles');\n\nvar tableToDeck = function tableToDeck(_ref) {\n  var stock = _ref.stock;\n  var wasteHidden = _ref.wasteHidden;\n  var wasteVisible = _ref.wasteVisible;\n  var foundations = _ref.foundations;\n  var piles = _ref.piles;\n  return (0, _ramda.unnest)([stock, wasteHidden, wasteVisible, (0, _ramda.unnest)(foundations), (0, _ramda.unnest)((0, _ramda.map)((0, _ramda.compose)(_ramda.unnest, _ramda.values), piles))]);\n};\n\nvar Table = (0, _tcomb.refinement)(_tcomb2.default.interface({ stock: Stock,\n  wasteHidden: HiddenWaste,\n  wasteVisible: VisibleWaste,\n  foundations: Foundations,\n  piles: Piles\n})\n// count of all cards must equal 52\n, function (t) {\n  return Deck(tableToDeck(t));\n}, 'Table');\n\nvar InitTable = (0, _tcomb.refinement)(Table, (0, _ramda.where)({\n  stock: len(24),\n  wasteHidden: len(0),\n  wasteVisible: len(0),\n  foundations: (0, _ramda.all)(_ramda.isEmpty),\n  piles: (0, _ramda.addIndex)(_ramda.all)(function (val, i) {\n    return (0, _ramda.where)({\n      upturned: len(1),\n      downturned: len(i)\n    }, val);\n  })\n}), 'InitTable');\n\n/*  Model  */\nvar Model = _tcomb2.default.interface({\n  draw3: _tcomb2.default.Boolean,\n  table: Table,\n  initTable: InitTable\n  // , selected: $.Nullable( Lens )\n});\n\n/*  VDOM  */\nvar DomElement = (0, _tcomb.irreducible)('DomElement', function (x) {\n  return x instanceof Element;\n});\nvar SnabbData = (0, _tcomb.struct)({});\n\nvar VNode = (0, _tcomb.declare)('VNode');\nVNode.define((0, _tcomb.struct)({\n  sel: _tcomb2.default.String,\n  data: SnabbData,\n  children: _tcomb2.default.maybe(VNode),\n  text: _tcomb2.default.maybe(_tcomb2.default.String),\n  elm: DomElement,\n  key: _tcomb2.default.Any\n}));\n\n/*  Lens  */\nvar Lens = (0, _tcomb.irreducible)('Lens', function (x) {\n  return x.toString() === 'function (toFunctorFn) {\\n            return function (target) {\\n                return map(function (focus) {\\n                    return setter(focus, target);\\n                }, toFunctorFn(getter(target)));\\n            };\\n        }';\n});\n\nvar Lenses = (0, _tcomb.list)(Lens, 'Lenses');\n\nvar MoveType = _tcomb.enums.of(['card', 'empty']);\n\nexports.Card = Card;\nexports.Deck = Deck;\nexports.Stock = Stock;\nexports.HiddenWaste = HiddenWaste;\nexports.VisibleWaste = VisibleWaste;\nexports.Foundation = Foundation;\nexports.Foundations = Foundations;\nexports.Piles = Piles;\nexports.Pile = Pile;\nexports.Subpile = Subpile;\nexports.HiddenWaste = HiddenWaste;\nexports.VisibleWaste = VisibleWaste;\nexports.Table = Table;\nexports.InitTable = InitTable;\nexports.Model = Model;\nexports.Lenses = Lenses;\nexports.MoveType = MoveType;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdHlwZXMuanM/ODlhOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7Ozs7QUFDQTs7OztBQUdBLElBQU0sTUFBTSxtQkFBUSxRQUFSLENBQVo7QUFDQSxJQUFNLFNBQVMsU0FBVCxNQUFTO0FBQUEsU0FBSywwQkFBZSxnQkFBSyxDQUFMLENBQWYsRUFBeUIsUUFBekIsQ0FBTDtBQUFBLENBQWY7QUFDQSxJQUFNLFVBQVUsU0FBVixPQUFVO0FBQUEsU0FBSyxtQkFBTyxDQUFQLEVBQVUsaUJBQUssQ0FBTCxDQUFWLENBQUw7QUFBQSxDQUFoQjs7O0FBSUEsSUFBTSxTQUFTLFNBQVQsTUFBUztBQUFBLFNBQUssS0FBSyxDQUFMLElBQVUsS0FBSyxFQUFwQjtBQUFBLENBQWY7QUFDQSxJQUFNLE9BQU8sdUJBQVksZ0JBQUUsTUFBZCxFQUFzQixNQUF0QixFQUE4QixNQUE5QixDQUFiOztBQUVBLElBQU0sT0FBTyxhQUFNLEVBQU4sQ0FBUyxDQUFFLFFBQUYsRUFBWSxPQUFaLEVBQXFCLFFBQXJCLEVBQStCLFVBQS9CLENBQVQsRUFBc0QsTUFBdEQsQ0FBYjs7QUFFQSxJQUFNLE9BQU8sa0JBQU0sQ0FBRSxJQUFGLEVBQVEsSUFBUixDQUFOLEVBQXNCLE1BQXRCLENBQWI7O0FBRUEsSUFBTSxPQUFPLHVCQUNYLGdCQUFFLElBQUYsQ0FBUSxJQUFSLENBRFcsRUFFWCxvQkFDRCxDQUFFLElBQUssRUFBTCxDQUFGLEVBQ0UsT0FERixDQURDLENBRlcsRUFNWCxNQU5XLENBQWI7OztBQVVBLElBQU0sUUFBUSxnQkFBRSxVQUFGLENBQWMsZ0JBQUUsSUFBRixDQUFRLElBQVIsQ0FBZCxFQUE4QixPQUFRLEVBQVIsQ0FBOUIsRUFBNEMsT0FBNUMsQ0FBZDs7QUFFQSxJQUFNLGNBQWMsZ0JBQUUsSUFBRixDQUFRLElBQVIsRUFBYyxhQUFkLENBQXBCO0FBQ0EsSUFBTSxlQUFlLGdCQUFFLFVBQUYsQ0FBYyxnQkFBRSxJ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Q0FBYjs7QUFVQSxJQUFNLFNBQVMsaUJBQU0sSUFBTixFQUFZLFFBQVosQ0FBZjs7QUFFQSxJQUFNLFdBQVcsYUFBTSxFQUFOLENBQVMsQ0FBRSxNQUFGLEVBQVUsT0FBVixDQUFULENBQWpCOztRQUlFLEksR0FBQSxJO1FBQ0EsSSxHQUFBLEk7UUFDQSxLLEdBQUEsSztRQUNBLFcsR0FBQSxXO1FBQ0EsWSxHQUFBLFk7UUFDQSxVLEdBQUEsVTtRQUNBLFcsR0FBQSxXO1FBQ0EsSyxHQUFBLEs7UUFDQSxJLEdBQUEsSTtRQUNBLE8sR0FBQSxPO1FBQ0EsVyxHQUFBLFc7UUFBYSxZLEdBQUEsWTtRQUNiLEssR0FBQSxLO1FBQ0EsUyxHQUFBLFM7UUFDQSxLLEdBQUEsSztRQUNBLE0sR0FBQSxNO1FBQ0EsUSxHQUFBLFEiLCJmaWxlIjoiNjkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdCwgeyBpcnJlZHVjaWJsZSwgcmVmaW5lbWVudCwgbGlzdCwgc3RydWN0LCB0dXBsZSwgZW51bXMsIGRlY2xhcmUgfSBmcm9tICd0Y29tYidcbmltcG9ydCB7IHByb3BFcSwgcHJvcFNhdGlzZmllcywgZ3RlIGFzIGx0ZSwgYWxsLCBhbGxQYXNzLCB3aGVyZSwgYWRkSW5kZXgsIHRvU3RyaW5nLCBpc0VtcHR5LCBlcXVhbHMsIHVuaXEsIHJlZHVjZSwgY29uY2F0LCB2YWx1ZXMsIGNvbXBvc2UsIG1lcmdlV2l0aCwgdW5uZXN0LCBtYXAsIHdoZW4sIEYsIFQgfSBmcm9tICdyYW1kYSdcblxuXG5jb25zdCBsZW4gPSBwcm9wRXEoICdsZW5ndGgnIClcbmNvbnN0IG1heExlbiA9IHggPT4gcHJvcFNhdGlzZmllcyggbHRlKCB4ICksICdsZW5ndGgnIClcbmNvbnN0IGFsbFVuaXEgPSBhID0+IGVxdWFscyhhLCB1bmlxKGEpKVxuXG5cbi8qICBEZWNrICAqL1xuY29uc3QgaXNSYW5rID0gbiA9PiBuID49IDEgJiYgbiA8PSAxNFxuY29uc3QgUmFuayA9IHJlZmluZW1lbnQoIHQuTnVtYmVyLCBpc1JhbmssICdSYW5rJyApXG5cbmNvbnN0IFN1aXQgPSBlbnVtcy5vZihbICdoZWFydHMnLCAnY2x1YnMnLCAnc3BhZGVzJywgJ2RpYW1vbmRzJyBdLCAnU3VpdCcgKVxuXG5jb25zdCBDYXJkID0gdHVwbGUoWyBSYW5rLCBTdWl0IF0sICdDYXJkJyApXG5cbmNvbnN0IERlY2sgPSByZWZpbmVtZW50XG4oIHQubGlzdCggQ2FyZCApXG4sIGFsbFBhc3MoXG5cdFsgbGVuKCA1MiApXG5cdCwgYWxsVW5pcVxuXHRdKVxuLCAnRGVjaycgKVxuXG5cbi8qICBUYWJsZSAgKi9cbmNvbnN0IFN0b2NrID0gdC5yZWZpbmVtZW50KCB0Lmxpc3QoIENhcmQgKSwgbWF4TGVuKCA1MiApLCAnU3RvY2snIClcblxuY29uc3QgSGlkZGVuV2FzdGUgPSB0Lmxpc3QoIENhcmQsICdIaWRkZW5XYXN0ZScgKVxuY29uc3QgVmlzaWJsZVdhc3RlID0gdC5yZWZpbmVtZW50KCB0Lmxpc3QoIENhcmQgKSwgbWF4TGVuKCAzICksICdWaXNpYmxlV2FzdGUnIClcblxuY29uc3QgRm91bmRhdGlvbiA9IHQucmVmaW5lbWVudCggdC5saXN0KCBDYXJkICksIG1heExlbiggMTMgKSwgJ0ZvdW5kYXRpb24nIClcbmNvbnN0IEZvdW5kYXRpb25zID0gdC5yZWZpbmVtZW50KCB0Lmxpc3QoIEZvdW5kYXRpb24gKSwgbGVuKCA0ICksICdGb3VuZGF0aW9ucycgKVxuXG5jb25zdCBTdWJwaWxlID0gcmVmaW5lbWVudCggbGlzdCggQ2FyZCApLCBtYXhMZW4oIDUyICksICdTdWJwaWxlJyApXG5jb25zdCBQaWxlID0gdC5pbnRlcmZhY2UoeyBkb3dudHVybmVkOiBTdWJwaWxlLCB1cHR1cm5lZDogU3VicGlsZSB9LCAnUGlsZScgKVxuY29uc3QgUGlsZXMgPSByZWZpbmVtZW50KCBsaXN0KCBQaWxlICksIGxlbiggNyApLCAnUGlsZXMnIClcblxuXG5jb25zdCB0YWJsZVRvRGVjayA9ICh7IHN0b2NrLCB3YXN0ZUhpZGRlbiwgd2FzdGVWaXNpYmxlLCBmb3VuZGF0aW9ucywgcGlsZXMgfSkgPT5cbiAgICB1bm5lc3QoWyBzdG9jaywgd2FzdGVIaWRkZW4sIHdhc3RlVmlzaWJsZSwgdW5uZXN0KGZvdW5kYXRpb25zKSwgdW5uZXN0KG1hcChjb21wb3NlKHVubmVzdCx2YWx1ZXMpLCBwaWxlcykpIF0pXG5cbmNvbnN0IFRhYmxlID0gcmVmaW5lbWVudFxuKCB0LmludGVyZmFjZShcbiAgeyBzdG9jazogU3RvY2tcbiAgLCB3YXN0ZUhpZGRlbjogSGlkZGVuV2FzdGVcbiAgLCB3YXN0ZVZpc2libGU6IFZpc2libGVXYXN0ZVxuICAsIGZvdW5kYXRpb25zOiBGb3VuZGF0aW9uc1xuICAsIHBpbGVzOiBQaWxlc1xuICB9KVxuICAvLyBjb3VudCBvZiBhbGwgY2FyZHMgbXVzdCBlcXVhbCA1MlxuLCB0ID0+IERlY2sodGFibGVUb0RlY2sodCkpXG4sICdUYWJsZScgKVxuXG5jb25zdCBJbml0VGFibGUgPSByZWZpbmVtZW50KCBUYWJsZSwgd2hlcmUoe1xuXHRzdG9jazogbGVuKCAyNCApXG4sIHdhc3RlSGlkZGVuOiBsZW4oIDAgKVxuLCB3YXN0ZVZpc2libGU6IGxlbiggMCApXG4sIGZvdW5kYXRpb25zOiBhbGwoIGlzRW1wdHkgKVxuLCBwaWxlczogYWRkSW5kZXgoYWxsKSgoIHZhbCwgaSApID0+IHdoZXJlKHtcbiAgICB1cHR1cm5lZDogbGVuKCAxIClcbiAgLCBkb3dudHVybmVkOiBsZW4oIGkgKVxuICB9LCB2YWwgKSlcbn0pLCAnSW5pdFRhYmxlJyApXG5cbi8qICBNb2RlbCAgKi9cbmNvbnN0IE1vZGVsID0gdC5pbnRlcmZhY2Uoe1xuXHRkcmF3MzogdC5Cb29sZWFuXG4sIHRhYmxlOiBUYWJsZVxuLCBpbml0VGFibGU6IEluaXRUYWJsZVxuLy8gLCBzZWxlY3RlZDogJC5OdWxsYWJsZSggTGVucyApXG59KVxuXG5cbi8qICBWRE9NICAqL1xuY29uc3QgRG9tRWxlbWVudCA9IGlycmVkdWNpYmxlKCAnRG9tRWxlbWVudCcsIHggPT4geCBpbnN0YW5jZW9mIEVsZW1lbnQgKVxuY29uc3QgU25hYmJEYXRhID0gc3RydWN0KHtcbn0pXG5cbmNvbnN0IFZOb2RlID0gZGVjbGFyZSggJ1ZOb2RlJyApXG5WTm9kZS5kZWZpbmUoIHN0cnVjdCh7XG5cdHNlbDogdC5TdHJpbmdcbixcdGRhdGE6IFNuYWJiRGF0YVxuLCBjaGlsZHJlbjogdC5tYXliZSggVk5vZGUgKVxuLCB0ZXh0OiB0Lm1heWJlKCB0LlN0cmluZyApXG4sIGVsbTogRG9tRWxlbWVudFxuLCBrZXk6IHQuQW55XG59KSlcblxuLyogIExlbnMgICovXG5jb25zdCBMZW5zID0gaXJyZWR1Y2libGUoICdMZW5zJywgeCA9PiB4LnRvU3RyaW5nKCkgPT09XG4gIGBmdW5jdGlvbiAodG9GdW5jdG9yRm4pIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hcChmdW5jdGlvbiAoZm9jdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldHRlcihmb2N1cywgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9LCB0b0Z1bmN0b3JGbihnZXR0ZXIodGFyZ2V0KSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfWBcbilcblxuY29uc3QgTGVuc2VzID0gbGlzdCggTGVucywgJ0xlbnNlcycgKVxuXG5jb25zdCBNb3ZlVHlwZSA9IGVudW1zLm9mKFsgJ2NhcmQnLCAnZW1wdHknIF0pXG5cblxuZXhwb3J0XG57IENhcmRcbiwgRGVja1xuLCBTdG9ja1xuLCBIaWRkZW5XYXN0ZVxuLCBWaXNpYmxlV2FzdGVcbiwgRm91bmRhdGlvblxuLCBGb3VuZGF0aW9uc1xuLCBQaWxlc1xuLCBQaWxlXG4sIFN1YnBpbGVcbiwgSGlkZGVuV2FzdGUsIFZpc2libGVXYXN0ZVxuLCBUYWJsZVxuLCBJbml0VGFibGVcbiwgTW9kZWxcbiwgTGVuc2VzXG4sIE1vdmVUeXBlXG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy90eXBlcy5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _ramda = __webpack_require__(1);\n\nvar _tcomb = __webpack_require__(13);\n\nvar _tcomb2 = _interopRequireDefault(_tcomb);\n\nvar _types = __webpack_require__(69);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nArray.prototype.concatAll = function () {\n  var output = [];\n  this.forEach(function (ary) {\n    return ary.forEach(function (el) {\n      return output.push(el);\n    });\n  });\n  return output;\n};\n\nArray.prototype.shuffle = function () {\n  var array = this;\n  var m = array.length,\n      t = void 0,\n      i = void 0;\n\n  while (m) {\n    i = Math.floor(Math.random() * m--);\n\n    t = array[m];\n    array[m] = array[i];\n    array[i] = t;\n  }\n\n  return array;\n};\n\n// shuffle :: () -> Deck\n\nexports.default = function () {\n  var ret = function () {\n    return (0, _ramda.range)(1, 14).map(function (rank) {\n      return [[rank, 'hearts'], [rank, 'clubs'], [rank, 'spades'], [rank, 'diamonds']];\n    }).concatAll().shuffle();\n  }.call(this);\n\n  _tcomb2.default.assert(_types.Deck.is(ret), 'Invalid argument ret (expected a ' + _tcomb2.default.getTypeName(_types.Deck) + ')');\n\n  return ret;\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc2h1ZmZsZS5qcz9lZDI5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOztBQUNBOzs7O0FBQ0E7Ozs7QUFFQSxNQUFNLFNBQU4sQ0FBZ0IsU0FBaEIsR0FBNEIsWUFBWTtBQUN0QyxNQUFNLFNBQVMsRUFBZjtBQUNBLE9BQUssT0FBTCxDQUFjO0FBQUEsV0FDWixJQUFJLE9BQUosQ0FBYTtBQUFBLGFBQU0sT0FBTyxJQUFQLENBQWEsRUFBYixDQUFOO0FBQUEsS0FBYixDQURZO0FBQUEsR0FBZDtBQUVBLFNBQU8sTUFBUDtBQUNELENBTEQ7O0FBT0EsTUFBTSxTQUFOLENBQWdCLE9BQWhCLEdBQTBCLFlBQVk7QUFDcEMsTUFBSSxRQUFRLElBQVo7QUFDQSxNQUFJLElBQUksTUFBTSxNQUFkO01BQXNCLFVBQXRCO01BQXlCLFVBQXpCOztBQUVBLFNBQU8sQ0FBUCxFQUFVO0FBQ1IsUUFBSSxLQUFLLEtBQUwsQ0FBVyxLQUFLLE1BQUwsS0FBZ0IsR0FBM0IsQ0FBSjs7QUFFQSxRQUFJLE1BQU0sQ0FBTixDQUFKO0FBQ0EsVUFBTSxDQUFOLElBQVcsTUFBTSxDQUFOLENBQVg7QUFDQSxVQUFNLENBQU4sSUFBVyxDQUFYO0FBQ0Q7O0FBRUQsU0FBTyxLQUFQO0FBQ0QsQ0FiRDs7OztrQkFnQmU7QUFBQTtBQUFBLFdBQ2Isa0JBQU8sQ0FBUCxFQUFVLEVBQVYsRUFBZSxHQUFmLENBQW9CO0FBQUEsYUFDbEIsQ0FBRSxDQUFFLElBQUYsRUFBUSxRQUFSLENBQUYsRUFDRSxDQUFFLElBQUYsRUFBUSxPQUFSLENBREYsRUFFRSxDQUFFLElBQUYsRUFBUSxRQUFSLENBRkYsRUFHRSxDQUFFLElBQUYsRUFBUSxVQUFSLENBSEYsQ0FEa0I7QUFBQSxLQUFwQixFQUtFLFNBTEYsR0FLYyxPQUxkLEVBRGE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBLEMiLCJmaWxlIjoiNzAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByYW5nZSB9IGZyb20gJ3JhbWRhJ1xuaW1wb3J0IHQgZnJvbSAndGNvbWInXG5pbXBvcnQgeyBEZWNrIH0gZnJvbSAndHlwZXMnXG5cbkFycmF5LnByb3RvdHlwZS5jb25jYXRBbGwgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IG91dHB1dCA9IFtdXG4gIHRoaXMuZm9yRWFjaCggYXJ5ID0+XG4gICAgYXJ5LmZvckVhY2goIGVsID0+IG91dHB1dC5wdXNoKCBlbCApICkpXG4gIHJldHVybiBvdXRwdXRcbn1cblxuQXJyYXkucHJvdG90eXBlLnNodWZmbGUgPSBmdW5jdGlvbiAoKSB7XG4gIGxldCBhcnJheSA9IHRoaXNcbiAgbGV0IG0gPSBhcnJheS5sZW5ndGgsIHQsIGk7XG5cbiAgd2hpbGUgKG0pIHtcbiAgICBpID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbS0tKTtcblxuICAgIHQgPSBhcnJheVttXTtcbiAgICBhcnJheVttXSA9IGFycmF5W2ldO1xuICAgIGFycmF5W2ldID0gdDtcbiAgfVxuXG4gIHJldHVybiBhcnJheTtcbn1cblxuLy8gc2h1ZmZsZSA6OiAoKSAtPiBEZWNrXG5leHBvcnQgZGVmYXVsdCAoKTogRGVjayA9PlxuICByYW5nZSggMSwgMTQgKS5tYXAoIHJhbmsgPT5cbiAgICBbIFsgcmFuaywgJ2hlYXJ0cycgXVxuICAgICwgWyByYW5rLCAnY2x1YnMnIF1cbiAgICAsIFsgcmFuaywgJ3NwYWRlcycgXVxuICAgICwgWyByYW5rLCAnZGlhbW9uZHMnIF1dXG4gICkuY29uY2F0QWxsKCkuc2h1ZmZsZSgpXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9zaHVmZmxlLmpzXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _tcomb = __webpack_require__(13);\n\nvar _tcomb2 = _interopRequireDefault(_tcomb);\n\nvar _types = __webpack_require__(69);\n\nvar _ramda = __webpack_require__(1);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default =\n// Deal :: Deck -> InitTable\nfunction (deck) {\n  _tcomb2.default.assert(_types.Deck.is(deck), 'Invalid argument deck (expected a ' + _tcomb2.default.getTypeName(_types.Deck) + ')');\n\n  var ret = function (deck) {\n    var iter = deck[Symbol.iterator]();\n    var card = function card() {\n      return iter.next().value;\n    };\n\n    var stock = (0, _ramda.map)(card, (0, _ramda.range)(0, 24));\n    var wasteHidden = [];\n    var wasteVisible = [];\n    var foundations = [[], [], [], []];\n    var piles = [{ upturned: [card()], downturned: [] }, { upturned: [card()], downturned: [card()] }, { upturned: [card()], downturned: [card(), card()] }, { upturned: [card()], downturned: [card(), card(), card()] }, { upturned: [card()], downturned: [card(), card(), card(), card()] }, { upturned: [card()], downturned: [card(), card(), card(), card(), card()] }, { upturned: [card()], downturned: [card(), card(), card(), card(), card(), card()] }];\n\n    return { stock: stock, wasteHidden: wasteHidden, wasteVisible: wasteVisible, foundations: foundations, piles: piles };\n  }.call(this, deck);\n\n  _tcomb2.default.assert(_types.InitTable.is(ret), 'Invalid argument ret (expected a ' + _tcomb2.default.getTypeName(_types.InitTable) + ')');\n\n  return ret;\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZGVhbC5qcz8wZmExIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7O0FBRUE7O0FBQ0E7Ozs7OztBQUtBLFVBQUUsSUFBRjtBQUFBOztBQUFBLDRCQUE2QjtBQUMzQixRQUFNLE9BQU8sS0FBTSxPQUFPLFFBQWIsR0FBYjtBQUNBLFFBQU0sT0FBTyxTQUFQLElBQU87QUFBQSxhQUFNLEtBQUssSUFBTCxHQUFZLEtBQWxCO0FBQUEsS0FBYjs7QUFFQSxRQUFNLFFBQVEsZ0JBQUssSUFBTCxFQUFXLGtCQUFPLENBQVAsRUFBVSxFQUFWLENBQVgsQ0FBZDtBQUNBLFFBQU0sY0FBYyxFQUFwQjtBQUNBLFFBQU0sZUFBZSxFQUFyQjtBQUNBLFFBQU0sY0FBYyxDQUFFLEVBQUYsRUFBTSxFQUFOLEVBQVUsRUFBVixFQUFjLEVBQWQsQ0FBcEI7QUFDQSxRQUFNLFFBQ04sQ0FBRSxFQUFFLFVBQVUsQ0FBRSxNQUFGLENBQVosRUFBd0IsWUFBWSxFQUFwQyxFQUFGLEVBQ0UsRUFBRSxVQUFVLENBQUUsTUFBRixDQUFaLEVBQXdCLFlBQVksQ0FBQyxNQUFELENBQXBDLEVBREYsRUFFRSxFQUFFLFVBQVUsQ0FBRSxNQUFGLENBQVosRUFBd0IsWUFBWSxDQUFDLE1BQUQsRUFBUyxNQUFULENBQXBDLEVBRkYsRUFHRSxFQUFFLFVBQVUsQ0FBRSxNQUFGLENBQVosRUFBd0IsWUFBWSxDQUFDLE1BQUQsRUFBUyxNQUFULEVBQWlCLE1BQWpCLENBQXBDLEVBSEYsRUFJRSxFQUFFLFVBQVUsQ0FBRSxNQUFGLENBQVosRUFBd0IsWUFBWSxDQUFDLE1BQUQsRUFBUyxNQUFULEVBQWlCLE1BQWpCLEVBQXlCLE1BQXpCLENBQXBDLEVBSkYsRUFLRSxFQUFFLFVBQVUsQ0FBRSxNQUFGLENBQVosRUFBd0IsWUFBWSxDQUFDLE1BQUQsRUFBUyxNQUFULEVBQWlCLE1BQWpCLEVBQXlCLE1BQXpCLEVBQWlDLE1BQWpDLENBQXBDLEVBTEYsRUFNRSxFQUFFLFVBQVUsQ0FBRSxNQUFGLENBQVosRUFBd0IsWUFBWSxDQUFDLE1BQUQsRUFBUyxNQUFULEVBQWlCLE1BQWpCLEVBQXlCLE1BQXpCLEVBQWlDLE1BQWpDLEVBQXlDLE1BQXpDLENBQXBDLEVBTkYsQ0FEQTs7QUFVQSxXQUFPLEVBQUUsWUFBRixFQUFTLHdCQUFULEVBQXNCLDBCQUF0QixFQUFvQyx3QkFBcEMsRUFBaUQsWUFBakQsRUFBUDtBQUNELEdBbkJEOztBQUFBOztBQUFBO0FBQUEsQyIsImZpbGUiOiI3MS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0IGZyb20gJ3Rjb21iJ1xuXG5pbXBvcnQgeyBEZWNrLCBJbml0VGFibGUgfSBmcm9tICd0eXBlcydcbmltcG9ydCB7IHJhbmdlLCBtYXAgfSBmcm9tICAncmFtZGEnXG5cblxuZXhwb3J0IGRlZmF1bHRcbi8vIERlYWwgOjogRGVjayAtPiBJbml0VGFibGVcbiggZGVjazogRGVjayApOiBJbml0VGFibGUgPT4ge1xuICBjb25zdCBpdGVyID0gZGVja1sgU3ltYm9sLml0ZXJhdG9yIF0oKVxuICBjb25zdCBjYXJkID0gKCkgPT4gaXRlci5uZXh0KCkudmFsdWVcblxuICBjb25zdCBzdG9jayA9IG1hcCggY2FyZCwgcmFuZ2UoIDAsIDI0ICkpXG4gIGNvbnN0IHdhc3RlSGlkZGVuID0gW11cbiAgY29uc3Qgd2FzdGVWaXNpYmxlID0gW11cbiAgY29uc3QgZm91bmRhdGlvbnMgPSBbIFtdLCBbXSwgW10sIFtdIF1cbiAgY29uc3QgcGlsZXMgPVxuICBbIHsgdXB0dXJuZWQ6IFsgY2FyZCgpIF0sIGRvd250dXJuZWQ6IFtdIH1cbiAgLCB7IHVwdHVybmVkOiBbIGNhcmQoKSBdLCBkb3dudHVybmVkOiBbY2FyZCgpXSB9XG4gICwgeyB1cHR1cm5lZDogWyBjYXJkKCkgXSwgZG93bnR1cm5lZDogW2NhcmQoKSwgY2FyZCgpXSB9XG4gICwgeyB1cHR1cm5lZDogWyBjYXJkKCkgXSwgZG93bnR1cm5lZDogW2NhcmQoKSwgY2FyZCgpLCBjYXJkKCldIH1cbiAgLCB7IHVwdHVybmVkOiBbIGNhcmQoKSBdLCBkb3dudHVybmVkOiBbY2FyZCgpLCBjYXJkKCksIGNhcmQoKSwgY2FyZCgpXSB9XG4gICwgeyB1cHR1cm5lZDogWyBjYXJkKCkgXSwgZG93bnR1cm5lZDogW2NhcmQoKSwgY2FyZCgpLCBjYXJkKCksIGNhcmQoKSwgY2FyZCgpXSB9XG4gICwgeyB1cHR1cm5lZDogWyBjYXJkKCkgXSwgZG93bnR1cm5lZDogW2NhcmQoKSwgY2FyZCgpLCBjYXJkKCksIGNhcmQoKSwgY2FyZCgpLCBjYXJkKCldIH1cbiAgXVxuXG4gIHJldHVybiB7IHN0b2NrLCB3YXN0ZUhpZGRlbiwgd2FzdGVWaXNpYmxlLCBmb3VuZGF0aW9ucywgcGlsZXMgfVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvZGVhbC5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _h = __webpack_require__(10);\n\nvar _h2 = _interopRequireDefault(_h);\n\nvar _ramda = __webpack_require__(1);\n\nvar _tcomb = __webpack_require__(13);\n\nvar _tcomb2 = _interopRequireDefault(_tcomb);\n\nvar _types = __webpack_require__(69);\n\nvar _downturnedCard = __webpack_require__(73);\n\nvar _downturnedCard2 = _interopRequireDefault(_downturnedCard);\n\nvar _actions = __webpack_require__(74);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function (action$, stock) {\n\t_tcomb2.default.assert(_types.Stock.is(stock), 'Invalid argument stock (expected a ' + _tcomb2.default.getTypeName(_types.Stock) + ')');\n\n\treturn (0, _h2.default)('div.stock', { on: { click: [action$, _actions.Action.Draw()] } }, [(0, _ramda.isEmpty)(stock) ? (0, _h2.default)('div.empty') : (0, _downturnedCard2.default)()]);\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9zdG9jay5qcz8zYjkwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7OztBQUNBOzs7O2tCQUdBLFVBQUUsT0FBRixFQUFXLEtBQVg7QUFBQTs7QUFBQSxRQUNDLGlCQUFHLFdBQUgsRUFDRSxFQUFFLElBQUksRUFBRSxPQUFPLENBQUUsT0FBRixFQUFXLGdCQUFPLElBQVAsRUFBWCxDQUFULEVBQU4sRUFERixFQUVHLENBQUUsb0JBQVMsS0FBVCxJQUFtQixpQkFBRyxXQUFILENBQW5CLEdBQXNDLCtCQUF4QyxDQUZILENBREQ7QUFBQSxDIiwiZmlsZSI6IjcyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgaCBmcm9tICdzbmFiYmRvbS9oJ1xuaW1wb3J0IHsgaXNFbXB0eSB9IGZyb20gJ3JhbWRhJ1xuaW1wb3J0IHRjb21iIGZyb20gJ3Rjb21iJ1xuaW1wb3J0IHsgU3RvY2sgfSBmcm9tICd0eXBlcydcbmltcG9ydCBkb3dudHVybmVkQ2FyZCBmcm9tICcuL2Rvd250dXJuZWQtY2FyZCdcbmltcG9ydCB7IEFjdGlvbiB9IGZyb20gJ2FjdGlvbnMnXG5cbmV4cG9ydCBkZWZhdWx0XG4oIGFjdGlvbiQsIHN0b2NrOiBTdG9jayApID0+XG5cdGgoICdkaXYuc3RvY2snXG5cdCxcdHtcdG9uOiB7IGNsaWNrOiBbIGFjdGlvbiQsIEFjdGlvbi5EcmF3KCkgXX19XG4gICwgWyBpc0VtcHR5KCBzdG9jayApID8gaCggJ2Rpdi5lbXB0eScgKSA6IGRvd250dXJuZWRDYXJkKCkgXVxuXHQpXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9jb21wb25lbnRzL3N0b2NrLmpzXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _h = __webpack_require__(10);\n\nvar _h2 = _interopRequireDefault(_h);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function () {\n\treturn (0, _h2.default)('img.card', { props: { src: '/cards/back.svg' } });\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9kb3dudHVybmVkLWNhcmQuanM/ZGUxYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFDQTs7Ozs7O2tCQUlBO0FBQUEsUUFDQyxpQkFBRyxVQUFILEVBQWUsRUFBRSxPQUFPLEVBQUUsc0JBQUYsRUFBVCxFQUFmLENBREQ7QUFBQSxDIiwiZmlsZSI6IjczLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgaCBmcm9tICdzbmFiYmRvbS9oJ1xuXG5cbmV4cG9ydCBkZWZhdWx0XG4oKSA9PlxuXHRoKCAnaW1nLmNhcmQnLCB7IHByb3BzOiB7IHNyYzogYC9jYXJkcy9iYWNrLnN2Z2AgfX0pXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9jb21wb25lbnRzL2Rvd250dXJuZWQtY2FyZC5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.actions = exports.Action = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _tcomb = __webpack_require__(13);\n\nvar _tcomb2 = _interopRequireDefault(_tcomb);\n\nvar _types = __webpack_require__(69);\n\nvar _unionType = __webpack_require__(75);\n\nvar _unionType2 = _interopRequireDefault(_unionType);\n\nvar _ramda = __webpack_require__(1);\n\nvar _deal = __webpack_require__(71);\n\nvar _deal2 = _interopRequireDefault(_deal);\n\nvar _shuffle = __webpack_require__(70);\n\nvar _shuffle2 = _interopRequireDefault(_shuffle);\n\nvar _is = __webpack_require__(82);\n\nvar _is2 = _interopRequireDefault(_is);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar newTable = function newTable(settings) {\n  var table = (0, _deal2.default)((0, _shuffle2.default)());\n  return _extends({}, settings, { table: table, initTable: table });\n};\n\n// Lenses\n// const subLens = lens => str => compose( lens, lensProp(str) )\n// const table = lensProp( 'table' )\n// const [  wasteHidden,  wasteVisible,  stock  ] =  map( subLens( table )\n//     , [ 'wasteHidden','wasteVisible','stock' ])\n\nvar log = function log(a) {\n  console.log(a);return a;\n};\nvar beep = new Audio('/beep.mp3');\nvar lensPath = (0, _ramda.compose)((0, _ramda.apply)(_ramda.compose), (0, _ramda.map)((0, _ramda.ifElse)(_is2.default.integer, _ramda.lensIndex, _ramda.lensProp)));\nvar len = (0, _ramda.propEq)('length');\n\n// rank is defined differently on foundations and piles\nvar fRank = function fRank(card) {\n  return _is2.default.undefined(card) ? 0 : card[0];\n}; // Foundation rank\nvar pRank = function pRank(card) {\n  return _is2.default.undefined(card) ? 14 : card[0];\n}; // Pile rank\nvar suit = function suit(card) {\n  return card[1];\n};\nvar color = function color(card) {\n  return { 'diamonds': 'red',\n    'hearts': 'red',\n    'clubs': 'black',\n    'spades': 'black'\n  }[suit(card)];\n};\nvar isAce = function isAce(card) {\n  return Card.rank(card) === 1;\n};\n\n//  -----------------------------------------------------------------  //\n\nvar Deal = function Deal(model) {\n  return function () {\n    return newTable(model);\n  };\n};\nvar Reset = function Reset(model) {\n  return function () {\n    return (0, _ramda.assoc)('table', model.initTable, model);\n  };\n};\n\nvar Draw = function Draw(model) {\n  return function () {\n    var ret = function () {\n      var _model$table = model.table;\n      var stock = _model$table.stock;\n      var wasteHidden = _model$table.wasteHidden;\n      var wasteVisible = _model$table.wasteVisible;\n\n      var table = (0, _ramda.isEmpty)(stock) ? _extends({}, model.table, { stock: (0, _ramda.concat)(wasteHidden, wasteVisible),\n        wasteHidden: [],\n        wasteVisible: []\n      }) : _extends({}, model.table, { wasteHidden: (0, _ramda.concat)(wasteHidden, wasteVisible),\n        wasteVisible: (0, _ramda.take)(3, stock),\n        stock: (0, _ramda.drop)(3, stock)\n      });\n\n      return _extends({}, model, { table: table });\n    }.call(this);\n\n    _tcomb2.default.assert(_types.Model.is(ret), 'Invalid argument ret (expected a ' + _tcomb2.default.getTypeName(_types.Model) + ')');\n\n    return ret;\n  };\n};\n\nvar Move = function Move(model) {\n  return function (path, type) {\n    _tcomb2.default.assert(_types.MoveType.is(type), 'Invalid argument type (expected a ' + _tcomb2.default.getTypeName(_types.MoveType) + ')');\n\n    console.log(path, type);\n    var deselect = function deselect() {\n      beep.play();return (0, _ramda.dissoc)('selected', model);\n    };\n\n    if (!path) return model; // Block moving cards from stock that aren't top\n    if (type === 'empty' && !migrantPath) return model; // Can't select empty pile\n    if (!model.selected) return (0, _ramda.assoc)('selected', path, model); // Select card\n\n    var migrantPath = model.selected;\n    var occupantPath = path;\n\n    if ((0, _ramda.equals)(migrantPath, occupantPath)) return deselect(); // Deselect on same card\n    if (occupantPath[1] === 'wasteVisible' && migrantPath) return deselect(); // Can't put a card on waste\n\n    var migrantL = lensPath(migrantPath);\n    var migrantLocationL = lensPath((0, _ramda.dropLast)(1, migrantPath));\n    var downturnedL = lensPath([].concat(_toConsumableArray((0, _ramda.dropLast)(2, migrantPath)), ['downturned']));\n    var occupantL = lensPath(occupantPath);\n    var occupantLocationL = lensPath((0, _ramda.dropLast)(1, occupantPath));\n\n    var migrant = (0, _ramda.view)(migrantL, model);\n    var occupant = (0, _ramda.view)(occupantL, model);\n    var migrantLocation = (0, _ramda.view)(migrantLocationL, model);\n\n    if (migrantPath[1] === 'foundations') {\n      var validSuit = suit(migrant) === suit(occupant || migrant); // Compare only if occupant exists\n      var validRank = fRank(migrant) === fRank(occupant) + 1;\n      if (!(validSuit && validRank)) return deselect();\n    }\n\n    if (migrantPath[1] === 'piles') {\n      if ((0, _ramda.equals)(migrantPath[2], occupantPath[2])) return deselect(); // Deselect on same pile\n\n      var _validSuit = color(migrant) !== color(occupant || migrant); // Compare only if occupant exists\n      var _validRank = pRank(migrant) === pRank(occupant) - 1;\n      if (!(_validSuit && _validRank)) return deselect();\n\n      var migrantIdx = migrantPath[4];\n      var pileHeight = (0, _ramda.view)(migrantLocationL, model).length;\n      var top = pileHeight - 1;\n      var cardCount = pileHeight - migrantIdx;\n\n      // if migrant is not top of pile\n      console.log('migrantIdx:', migrantIdx, '  top:', top);\n      if (migrantIdx != top) return (0, _ramda.pipe)((0, _ramda.dissoc)('selected'), (0, _ramda.over)(occupantLocationL, flip(_ramda.concat)((0, _ramda.take)(cardCount, (0, _ramda.view)(migrantLocationL, model)))) // Copy migrant to occupantLocation\n      , (0, _ramda.over)(migrantLocationL, (0, _ramda.dropLast)(cardCount)) // Drop from migrantLocation\n      )(model);\n    }\n\n    // if migrant is top of pile\n    return (0, _ramda.pipe)((0, _ramda.dissoc)('selected'), (0, _ramda.over)(occupantLocationL, (0, _ramda.append)(migrant)) // Copy migrant to occupantLocation\n    , (0, _ramda.over)(migrantLocationL, (0, _ramda.dropLast)(1)) // Drop from migrantLocation\n    )(model);\n  };\n};\n\nvar ShowHiddenPile = function ShowHiddenPile(model) {\n  return function (pileIdx) {\n    var ret = function (pileIdx) {\n      var upturned = lensPath(['table', 'piles', pileIdx, 'upturned']);\n      var downturned = lensPath(['table', 'piles', pileIdx, 'downturned']);\n      return (0, _ramda.pipe)((0, _ramda.over)(upturned, (0, _ramda.append)((0, _ramda.head)((0, _ramda.view)(downturned, model)))) // append downturned[0] to upturned\n      , (0, _ramda.over)(downturned, (0, _ramda.drop)(1)) // drop downturned[0]\n      )(model);\n    }.call(this, pileIdx);\n\n    _tcomb2.default.assert(_types.Model.is(ret), 'Invalid argument ret (expected a ' + _tcomb2.default.getTypeName(_types.Model) + ')');\n\n    return ret;\n  };\n};\n\nvar ShowHiddenWaste = function ShowHiddenWaste(model) {\n  return function () {\n    var ret = function () {\n      var _model$table2 = model.table;\n      var wasteHidden = _model$table2.wasteHidden;\n      var wasteVisible = _model$table2.wasteVisible;\n\n      var table = _extends({}, model.table, { wasteVisible: [(0, _ramda.last)(wasteHidden)],\n        wasteHidden: (0, _ramda.dropLast)(1, wasteHidden)\n      });\n      return _extends({}, model, { table: table });\n    }.call(this);\n\n    _tcomb2.default.assert(_types.Model.is(ret), 'Invalid argument ret (expected a ' + _tcomb2.default.getTypeName(_types.Model) + ')');\n\n    return ret;\n  };\n};\n\nvar Foundation = function Foundation(model) {\n  return function (path) {\n    return 'dblclick';\n  };\n};\n// Fuck this for now. enhancement.\n\nvar Drop = function Drop(model) {\n  return function () {\n    return (0, _ramda.dissoc)('cardPath', model);\n  };\n};\nvar Undo = function Undo(model) {\n  return function () {};\n};\nvar ShowSettings = function ShowSettings(model) {\n  return function () {};\n};\nvar UpdateSettings = function UpdateSettings(model) {\n  return function () {};\n};\n\n//  ------------------------------------------  //\n\nvar Action = exports.Action = (0, _unionType2.default)({\n  Deal: [],\n  Reset: [],\n  Draw: [],\n  Move: [_ramda.T, _ramda.T],\n  ShowHiddenPile: [Number],\n  ShowHiddenWaste: [],\n  Foundation: [_ramda.T],\n  Drop: [],\n  Undo: [],\n  ShowSettings: [],\n  UpdateSettings: []\n});\n\nvar actions = exports.actions = {\n  Deal: Deal,\n  Reset: Reset,\n  Draw: Draw,\n  Move: Move,\n  ShowHiddenPile: ShowHiddenPile,\n  ShowHiddenWaste: ShowHiddenWaste,\n  Foundation: Foundation,\n  Drop: Drop,\n  Undo: Undo,\n  ShowSettings: ShowSettings,\n  UpdateSettings: UpdateSettings\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYWN0aW9ucy5qcz8wZTY5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7O0FBRUEsSUFBTSxXQUFXLFNBQVgsUUFBVyxXQUFZO0FBQzNCLE1BQU0sUUFBUSxvQkFBSyx3QkFBTCxDQUFkO0FBQ0Esc0JBQVksUUFBWixJQUFzQixZQUF0QixFQUE2QixXQUFXLEtBQXhDO0FBQ0QsQ0FIRDs7Ozs7Ozs7QUFXQSxJQUFNLE1BQU0sU0FBTixHQUFNLElBQUs7QUFBRSxVQUFRLEdBQVIsQ0FBWSxDQUFaLEVBQWdCLE9BQU8sQ0FBUDtBQUFVLENBQTdDO0FBQ0EsSUFBTSxPQUFPLElBQUksS0FBSixDQUFXLFdBQVgsQ0FBYjtBQUNBLElBQU0sV0FBVyxvQkFBUyxpQ0FBVCxFQUEyQixnQkFBSyxtQkFBUSxhQUFHLE9BQVgsb0NBQUwsQ0FBM0IsQ0FBakI7QUFDQSxJQUFNLE1BQU0sbUJBQVEsUUFBUixDQUFaOzs7QUFJQSxJQUFNLFFBQVEsU0FBUixLQUFRO0FBQUEsU0FBUSxhQUFHLFNBQUgsQ0FBYSxJQUFiLElBQXFCLENBQXJCLEdBQXlCLEtBQUssQ0FBTCxDQUFqQztBQUFBLENBQWQsQztBQUNBLElBQU0sUUFBUSxTQUFSLEtBQVE7QUFBQSxTQUFRLGFBQUcsU0FBSCxDQUFhLElBQWIsSUFBcUIsRUFBckIsR0FBMEIsS0FBSyxDQUFMLENBQWxDO0FBQUEsQ0FBZCxDO0FBQ0EsSUFBTSxPQUFPLFNBQVAsSUFBTztBQUFBLFNBQVEsS0FBSyxDQUFMLENBQVI7QUFBQSxDQUFiO0FBQ0EsSUFBTSxRQUFRLFNBQVIsS0FBUSxPQUFRO0FBQUUsU0FDdEIsRUFBRSxZQUFhLEtBQWY7QUFDRSxjQUFhLEtBRGY7QUFFRSxhQUFhLE9BRmY7QUFHRSxjQUFhO0FBSGYsSUFJRyxLQUFLLElBQUwsQ0FKSCxDQURzQjtBQU10QixDQU5GO0FBT0EsSUFBTSxRQUFRLFNBQVIsS0FBUTtBQUFBLFNBQVEsS0FBSyxJQUFMLENBQVUsSUFBVixNQUFvQixDQUE1QjtBQUFBLENBQWQ7Ozs7QUFLQSxJQUFNLE9BQU8sU0FBUCxJQUFPO0FBQUEsU0FBUztBQUFBLFdBQU0sU0FBVSxLQUFWLENBQU47QUFBQSxHQUFUO0FBQUEsQ0FBYjtBQUNBLElBQU0sUUFBUSxTQUFSLEtBQVE7QUFBQSxTQUFTO0FBQUEsV0FBTSxrQkFBTyxPQUFQLEVBQWdCLE1BQU0sU0FBdEIsRUFBaUMsS0FBakMsQ0FBTjtBQUFBLEdBQVQ7QUFBQSxDQUFkOztBQUdBLElBQU0sT0FBTyxTQUFQLElBQU87QUFBQSxTQUFTO0FBQUEsMEJBQWE7QUFBQSx5QkFDWSxNQUFNLEtBRGxCO0FBQUEsVUFDekIsS0FEeUIsZ0JBQ3pCLEtBRHlCO0FBQUEsVUFDbEIsV0FEa0IsZ0JBQ2xCLFdBRGtCO0FBQUEsVUFDTCxZQURLLGdCQUNMLFlBREs7O0FBRWpDLFVBQU0sUUFBUSxvQkFBUSxLQUFSLGlCQUNQLE1BQU0sS0FEQyxJQUVWLE9BQU8sbUJBQVEsV0FBUixFQUFxQixZQUFyQixDQUZHO0FBR1YscUJBQWEsRUFISDtBQUlWLHNCQUFjO0FBSkosd0JBTVIsTUFBTSxLQU5FLElBT1osYUFBYSxtQkFBUSxXQUFSLEVBQXFCLFlBQXJCLENBUEQ7QUFRVixzQkFBYyxpQkFBTSxDQUFOLEVBQVMsS0FBVCxDQVJKO0FBU1YsZUFBTyxpQkFBTSxDQUFOLEVBQVMsS0FBVDtBQVRHLFFBQWQ7O0FBWUEsMEJBQVksS0FBWixJQUFtQixZQUFuQjtBQUNELEtBZnFCOztBQUFBOztBQUFBO0FBQUEsR0FBVDtBQUFBLENBQWI7O0FBaUJBLElBQU0sT0FBTyxTQUFQLElBQU87QUFBQSxTQUFTLFVBQUUsSUFBRixFQUFRLElBQVIsRUFBNEI7QUFBQTs7QUFDaEQsWUFBUSxHQUFSLENBQVksSUFBWixFQUFrQixJQUFsQjtBQUNBLFFBQU0sV0FBVyxTQUFYLFFBQVcsR0FBTTtBQUFFLFdBQUssSUFBTCxHQUFhLE9BQU8sbUJBQVEsVUFBUixFQUFvQixLQUFwQixDQUFQO0FBQW9DLEtBQTFFOztBQUVBLFFBQUksQ0FBQyxJQUFMLEVBQVksT0FBTyxLQUFQLEM7QUFDWixRQUFJLFNBQVMsT0FBVCxJQUFvQixDQUFDLFdBQXpCLEVBQXVDLE9BQU8sS0FBUCxDO0FBQ3ZDLFFBQUksQ0FBQyxNQUFNLFFBQVgsRUFBc0IsT0FBTyxrQkFBTyxVQUFQLEVBQW1CLElBQW5CLEVBQXlCLEtBQXpCLENBQVAsQzs7QUFFdEIsUUFBTSxjQUFjLE1BQU0sUUFBMUI7QUFDQSxRQUFNLGVBQWUsSUFBckI7O0FBRUEsUUFBSSxtQkFBUSxXQUFSLEVBQXFCLFlBQXJCLENBQUosRUFBeUMsT0FBTyxVQUFQLEM7QUFDekMsUUFBSSxhQUFhLENBQWIsTUFBb0IsY0FBcEIsSUFBc0MsV0FBMUMsRUFBd0QsT0FBTyxVQUFQLEM7O0FBR3hELFFBQU0sV0FBcUIsU0FBVSxXQUFWLENBQTNCO0FBQ0EsUUFBTSxtQkFBcUIsU0FBVSxxQkFBUyxDQUFULEVBQVksV0FBWixDQUFWLENBQTNCO0FBQ0EsUUFBTSxjQUFtQixzQ0FBYyxxQkFBUyxDQUFULEVBQVksV0FBWixDQUFkLElBQXlDLFlBQXpDLEdBQXpCO0FBQ0EsUUFBTSxZQUFzQixTQUFVLFlBQVYsQ0FBNUI7QUFDQSxRQUFNLG9CQUFzQixTQUFVLHFCQUFTLENBQVQsRUFBWSxZQUFaLENBQVYsQ0FBNUI7O0FBRUEsUUFBTSxVQUFVLGlCQUFNLFFBQU4sRUFBZ0IsS0FBaEIsQ0FBaEI7QUFDQSxRQUFNLFdBQVcsaUJBQU0sU0FBTixFQUFpQixLQUFqQixDQUFqQjtBQUNBLFFBQU0sa0JBQWtCLGlCQUFNLGdCQUFOLEVBQXdCLEtBQXhCLENBQXhCOztBQUdBLFFBQUksWUFBWSxDQUFaLE1BQW1CLGFBQXZCLEVBQXVDO0FBQ3JDLFVBQU0sWUFBWSxLQUFNLE9BQU4sTUFBb0IsS0FBTSxZQUFZLE9BQWxCLENBQXRDLEM7QUFDQSxVQUFNLFlBQVksTUFBTyxPQUFQLE1BQXFCLE1BQU8sUUFBUCxJQUFvQixDQUEzRDtBQUNBLFVBQUcsRUFBRyxhQUFhLFNBQWhCLENBQUgsRUFBZ0MsT0FBTyxVQUFQO0FBQ2pDOztBQUVELFFBQUksWUFBWSxDQUFaLE1BQW1CLE9BQXZCLEVBQWlDO0FBQy9CLFVBQUksbUJBQVEsWUFBWSxDQUFaLENBQVIsRUFBd0IsYUFBYSxDQUFiLENBQXhCLENBQUosRUFBK0MsT0FBTyxVQUFQLEM7O0FBRS9DLFVBQU0sYUFBWSxNQUFPLE9BQVAsTUFBcUIsTUFBTyxZQUFZLE9BQW5CLENBQXZDLEM7QUFDQSxVQUFNLGFBQVksTUFBTyxPQUFQLE1BQXFCLE1BQU8sUUFBUCxJQUFvQixDQUEzRDtBQUNBLFVBQUcsRUFBRyxjQUFhLFVBQWhCLENBQUgsRUFBZ0MsT0FBTyxVQUFQOztBQUVoQyxVQUFNLGFBQWEsWUFBWSxDQUFaLENBQW5CO0FBQ0EsVUFBTSxhQUFhLGlCQUFNLGdCQUFOLEVBQXdCLEtBQXhCLEVBQWdDLE1BQW5EO0FBQ0EsVUFBTSxNQUFNLGFBQWEsQ0FBekI7QUFDQSxVQUFNLFlBQVksYUFBYSxVQUEvQjs7O0FBR0EsY0FBUSxHQUFSLENBQWEsYUFBYixFQUE0QixVQUE1QixFQUF3QyxRQUF4QyxFQUFrRCxHQUFsRDtBQUNBLFVBQUksY0FBYyxHQUFsQixFQUNFLE9BQU8saUJBQ0wsbUJBQVEsVUFBUixDQURLLEVBRUwsaUJBQU0saUJBQU4sRUFBeUIsb0JBQWMsaUJBQU0sU0FBTixFQUFpQixpQkFBTSxnQkFBTixFQUF3QixLQUF4QixDQUFqQixDQUFkLENBQXpCLEM7QUFGSyxRQUdMLGlCQUFNLGdCQUFOLEVBQXdCLHFCQUFVLFNBQVYsQ0FBeEIsQztBQUhLLFFBSUosS0FKSSxDQUFQO0FBS0g7OztBQUdELFdBQU8saUJBQ0wsbUJBQVEsVUFBUixDQURLLEVBRUwsaUJBQU0saUJBQU4sRUFBeUIsbUJBQVEsT0FBUixDQUF6QixDO0FBRkssTUFHTCxpQkFBTSxnQkFBTixFQUF3QixxQkFBUyxDQUFULENBQXhCLEM7QUFISyxNQUlKLEtBSkksQ0FBUDtBQUtELEdBNURZO0FBQUEsQ0FBYjs7QUE4REEsSUFBTSxpQkFBaUIsU0FBakIsY0FBaUI7QUFBQSxTQUFTLFVBQUUsT0FBRjtBQUFBLGlDQUFzQjtBQUNwRCxVQUFNLFdBQWEsU0FBUyxDQUFFLE9BQUYsRUFBVyxPQUFYLEVBQW9CLE9BQXBCLEVBQTZCLFVBQTdCLENBQVQsQ0FBbkI7QUFDQSxVQUFNLGFBQWEsU0FBUyxDQUFFLE9BQUYsRUFBVyxPQUFYLEVBQW9CLE9BQXBCLEVBQTZCLFlBQTdCLENBQVQsQ0FBbkI7QUFDQSxhQUFPLGlCQUNMLGlCQUFNLFFBQU4sRUFBZ0IsbUJBQVEsaUJBQU0saUJBQU0sVUFBTixFQUFrQixLQUFsQixDQUFOLENBQVIsQ0FBaEIsQztBQURLLFFBRUwsaUJBQU0sVUFBTixFQUFrQixpQkFBSyxDQUFMLENBQWxCLEM7QUFGSyxRQUdKLEtBSEksQ0FBUDtBQUlELEtBUCtCOztBQUFBOztBQUFBO0FBQUEsR0FBVDtBQUFBLENBQXZCOztBQVNBLElBQU0sa0JBQWtCLFNBQWxCLGVBQWtCO0FBQUEsU0FBUztBQUFBLDBCQUFhO0FBQUEsMEJBQ04sTUFBTSxLQURBO0FBQUEsVUFDcEMsV0FEb0MsaUJBQ3BDLFdBRG9DO0FBQUEsVUFDdkIsWUFEdUIsaUJBQ3ZCLFlBRHVCOztBQUU1QyxVQUFNLHFCQUNELE1BQU0sS0FETCxJQUVKLGNBQWMsQ0FBRSxpQkFBTSxXQUFOLENBQUYsQ0FGVjtBQUdKLHFCQUFhLHFCQUFVLENBQVYsRUFBYSxXQUFiO0FBSFQsUUFBTjtBQUtBLDBCQUFZLEtBQVosSUFBbUIsWUFBbkI7QUFDRCxLQVJnQzs7QUFBQTs7QUFBQTtBQUFBLEdBQVQ7QUFBQSxDQUF4Qjs7QUFVQSxJQUFNLGFBQWEsU0FBYixVQUFhO0FBQUEsU0FBUztBQUFBLFdBQVEsVUFBUjtBQUFBLEdBQVQ7QUFBQSxDQUFuQjs7O0FBR0EsSUFBTSxPQUFPLFNBQVAsSUFBTztBQUFBLFNBQVM7QUFBQSxXQUFNLG1CQUFRLFVBQVIsRUFBb0IsS0FBcEIsQ0FBTjtBQUFBLEdBQVQ7QUFBQSxDQUFiO0FBQ0EsSUFBTSxPQUFPLFNBQVAsSUFBTztBQUFBLFNBQVMsWUFBTSxDQUFFLENBQWpCO0FBQUEsQ0FBYjtBQUNBLElBQU0sZUFBZSxTQUFmLFlBQWU7QUFBQSxTQUFTLFlBQU0sQ0FBRSxDQUFqQjtBQUFBLENBQXJCO0FBQ0EsSUFBTSxpQkFBaUIsU0FBakIsY0FBaUI7QUFBQSxTQUFTLFlBQU0sQ0FBRSxDQUFqQjtBQUFBLENBQXZCOzs7O0FBS08sSUFBTSwwQkFBUyx5QkFBSztBQUN6QixRQUFNLEVBRG1CO0FBRXpCLFNBQU8sRUFGa0I7QUFHekIsUUFBTSxFQUhtQjtBQUl6QixRQUFNLG9CQUptQjtBQUt6QixrQkFBZ0IsQ0FBRSxNQUFGLENBTFM7QUFNekIsbUJBQWlCLEVBTlE7QUFPekIsY0FBWSxVQVBhO0FBUXpCLFFBQU0sRUFSbUI7QUFTekIsUUFBTSxFQVRtQjtBQVV6QixnQkFBYyxFQVZXO0FBV3pCLGtCQUFnQjtBQVhTLENBQUwsQ0FBZjs7QUFjQSxJQUFNLDRCQUFVO0FBQ3RCLFlBRHNCO0FBRXJCLGNBRnFCO0FBR3JCLFlBSHFCO0FBSXJCLFlBSnFCO0FBS3JCLGdDQUxxQjtBQU1yQixrQ0FOcUI7QUFPckIsd0JBUHFCO0FBUXJCLFlBUnFCO0FBU3JCLFlBVHFCO0FBVXJCLDRCQVZxQjtBQVdyQjtBQVhxQixDQUFoQiIsImZpbGUiOiI3NC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IHRjb21iIGZyb20gJ3Rjb21iJ1xuaW1wb3J0IHsgTW9kZWwsIE1vdmVUeXBlIH0gZnJvbSAndHlwZXMnXG5pbXBvcnQgVHlwZSBmcm9tICd1bmlvbi10eXBlJ1xuaW1wb3J0IHsgYWxsUGFzcywgYXBwZW5kLCBhc3NvYywgYXBwbHksIGNvbXBvc2UsIGNvbmNhdCwgZGlzc29jLCBkcm9wLCBkcm9wTGFzdCwgZXF1YWxzLCBmbGF0dGVuLCBoZWFkLCBpZGVudGl0eSwgaWZFbHNlLCBpc0VtcHR5LCBsYXN0LCBsZW5zSW5kZXgsIGxlbnNQcm9wLCBtYXAsIG5vdCwgb3ZlciwgcGlwZSwgcHJvcEVxLCByZXZlcnNlLCBzZXQsIFQgYXMgQW55LCB0YWtlLCB2aWV3IH0gZnJvbSAncmFtZGEnXG5pbXBvcnQgZGVhbCBmcm9tICdkZWFsJ1xuaW1wb3J0IHNodWZmbGUgZnJvbSAnc2h1ZmZsZSdcbmltcG9ydCBpcyBmcm9tICdAcHduL2lzJ1xuXG5jb25zdCBuZXdUYWJsZSA9IHNldHRpbmdzID0+IHtcbiAgY29uc3QgdGFibGUgPSBkZWFsKHNodWZmbGUoKSlcbiAgcmV0dXJuIHsgLi4uc2V0dGluZ3MsIHRhYmxlLCBpbml0VGFibGU6IHRhYmxlIH1cbn1cblxuLy8gTGVuc2VzXG4vLyBjb25zdCBzdWJMZW5zID0gbGVucyA9PiBzdHIgPT4gY29tcG9zZSggbGVucywgbGVuc1Byb3Aoc3RyKSApXG4vLyBjb25zdCB0YWJsZSA9IGxlbnNQcm9wKCAndGFibGUnIClcbi8vIGNvbnN0IFsgIHdhc3RlSGlkZGVuLCAgd2FzdGVWaXNpYmxlLCAgc3RvY2sgIF0gPSAgbWFwKCBzdWJMZW5zKCB0YWJsZSApXG4vLyAgICAgLCBbICd3YXN0ZUhpZGRlbicsJ3dhc3RlVmlzaWJsZScsJ3N0b2NrJyBdKVxuXG5jb25zdCBsb2cgPSBhID0+IHsgY29uc29sZS5sb2coYSk7IHJldHVybiBhIH1cbmNvbnN0IGJlZXAgPSBuZXcgQXVkaW8oICcvYmVlcC5tcDMnIClcbmNvbnN0IGxlbnNQYXRoID0gY29tcG9zZSggYXBwbHkoIGNvbXBvc2UgKSwgbWFwKCBpZkVsc2UoIGlzLmludGVnZXIsIGxlbnNJbmRleCwgbGVuc1Byb3AgKSkpXG5jb25zdCBsZW4gPSBwcm9wRXEoICdsZW5ndGgnIClcblxuXG4vLyByYW5rIGlzIGRlZmluZWQgZGlmZmVyZW50bHkgb24gZm91bmRhdGlvbnMgYW5kIHBpbGVzXG5jb25zdCBmUmFuayA9IGNhcmQgPT4gaXMudW5kZWZpbmVkKGNhcmQpID8gMCA6IGNhcmRbMF0gICAvLyBGb3VuZGF0aW9uIHJhbmtcbmNvbnN0IHBSYW5rID0gY2FyZCA9PiBpcy51bmRlZmluZWQoY2FyZCkgPyAxNCA6IGNhcmRbMF0gICAvLyBQaWxlIHJhbmtcbmNvbnN0IHN1aXQgPSBjYXJkID0+IGNhcmRbMV1cbmNvbnN0IGNvbG9yID0gY2FyZCA9PiB7IHJldHVybiAoXG4gIHsgJ2RpYW1vbmRzJyA6ICdyZWQnXG4gICwgJ2hlYXJ0cycgICA6ICdyZWQnXG4gICwgJ2NsdWJzJyAgICA6ICdibGFjaydcbiAgLCAnc3BhZGVzJyAgIDogJ2JsYWNrJ1xuICB9WyBzdWl0KGNhcmQpIF1cbil9XG5jb25zdCBpc0FjZSA9IGNhcmQgPT4gQ2FyZC5yYW5rKGNhcmQpID09PSAxXG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAgLy9cblxuXG5jb25zdCBEZWFsID0gbW9kZWwgPT4gKCkgPT4gbmV3VGFibGUoIG1vZGVsIClcbmNvbnN0IFJlc2V0ID0gbW9kZWwgPT4gKCkgPT4gYXNzb2MoICd0YWJsZScsIG1vZGVsLmluaXRUYWJsZSwgbW9kZWwgKVxuXG5cbmNvbnN0IERyYXcgPSBtb2RlbCA9PiAoKTogTW9kZWwgPT4ge1xuICBjb25zdCB7IHN0b2NrLCB3YXN0ZUhpZGRlbiwgd2FzdGVWaXNpYmxlIH0gPSBtb2RlbC50YWJsZVxuICBjb25zdCB0YWJsZSA9IGlzRW1wdHkoc3RvY2spXG4gID8geyAuLi5tb2RlbC50YWJsZVxuICAgICwgc3RvY2s6IGNvbmNhdCggd2FzdGVIaWRkZW4sIHdhc3RlVmlzaWJsZSApXG4gICAgLCB3YXN0ZUhpZGRlbjogW11cbiAgICAsIHdhc3RlVmlzaWJsZTogW11cbiAgICB9XG5cdDogeyAuLi5tb2RlbC50YWJsZVxuXHRcdCwgd2FzdGVIaWRkZW46IGNvbmNhdCggd2FzdGVIaWRkZW4sIHdhc3RlVmlzaWJsZSApXG4gICAgLCB3YXN0ZVZpc2libGU6IHRha2UoIDMsIHN0b2NrIClcbiAgICAsIHN0b2NrOiBkcm9wKCAzLCBzdG9jayApXG5cdFx0fVxuXG4gIHJldHVybiB7IC4uLm1vZGVsLCB0YWJsZSB9XG59XG5cbmNvbnN0IE1vdmUgPSBtb2RlbCA9PiAoIHBhdGgsIHR5cGU6IE1vdmVUeXBlICkgPT4ge1xuICBjb25zb2xlLmxvZyhwYXRoLCB0eXBlKVxuICBjb25zdCBkZXNlbGVjdCA9ICgpID0+IHsgYmVlcC5wbGF5KCk7IHJldHVybiBkaXNzb2MoICdzZWxlY3RlZCcsIG1vZGVsICkgfVxuXG4gIGlmKCAhcGF0aCApIHJldHVybiBtb2RlbCAgLy8gQmxvY2sgbW92aW5nIGNhcmRzIGZyb20gc3RvY2sgdGhhdCBhcmVuJ3QgdG9wXG4gIGlmKCB0eXBlID09PSAnZW1wdHknICYmICFtaWdyYW50UGF0aCApIHJldHVybiBtb2RlbCAgICAgICAgIC8vIENhbid0IHNlbGVjdCBlbXB0eSBwaWxlXG4gIGlmKCAhbW9kZWwuc2VsZWN0ZWQgKSByZXR1cm4gYXNzb2MoICdzZWxlY3RlZCcsIHBhdGgsIG1vZGVsICkgIC8vIFNlbGVjdCBjYXJkXG5cbiAgY29uc3QgbWlncmFudFBhdGggPSBtb2RlbC5zZWxlY3RlZFxuICBjb25zdCBvY2N1cGFudFBhdGggPSBwYXRoXG5cbiAgaWYoIGVxdWFscyggbWlncmFudFBhdGgsIG9jY3VwYW50UGF0aCApKSByZXR1cm4gZGVzZWxlY3QoKSAgICAgICAgICAvLyBEZXNlbGVjdCBvbiBzYW1lIGNhcmRcbiAgaWYoIG9jY3VwYW50UGF0aFsxXSA9PT0gJ3dhc3RlVmlzaWJsZScgJiYgbWlncmFudFBhdGggKSByZXR1cm4gZGVzZWxlY3QoKSAgLy8gQ2FuJ3QgcHV0IGEgY2FyZCBvbiB3YXN0ZVxuXG5cbiAgY29uc3QgbWlncmFudEwgICAgICAgICAgID0gbGVuc1BhdGgoIG1pZ3JhbnRQYXRoIClcbiAgY29uc3QgbWlncmFudExvY2F0aW9uTCAgID0gbGVuc1BhdGgoIGRyb3BMYXN0KDEsIG1pZ3JhbnRQYXRoICkpXG4gIGNvbnN0IGRvd250dXJuZWRMICAgICAgPSBsZW5zUGF0aChbIC4uLmRyb3BMYXN0KDIsIG1pZ3JhbnRQYXRoICksICdkb3dudHVybmVkJyBdKVxuICBjb25zdCBvY2N1cGFudEwgICAgICAgICAgID0gbGVuc1BhdGgoIG9jY3VwYW50UGF0aCApXG4gIGNvbnN0IG9jY3VwYW50TG9jYXRpb25MICAgPSBsZW5zUGF0aCggZHJvcExhc3QoMSwgb2NjdXBhbnRQYXRoICkpXG5cbiAgY29uc3QgbWlncmFudCA9IHZpZXcoIG1pZ3JhbnRMLCBtb2RlbCApXG4gIGNvbnN0IG9jY3VwYW50ID0gdmlldyggb2NjdXBhbnRMLCBtb2RlbCApXG4gIGNvbnN0IG1pZ3JhbnRMb2NhdGlvbiA9IHZpZXcoIG1pZ3JhbnRMb2NhdGlvbkwsIG1vZGVsIClcblxuXG4gIGlmKCBtaWdyYW50UGF0aFsxXSA9PT0gJ2ZvdW5kYXRpb25zJyApIHtcbiAgICBjb25zdCB2YWxpZFN1aXQgPSBzdWl0KCBtaWdyYW50ICkgPT09IHN1aXQoIG9jY3VwYW50IHx8IG1pZ3JhbnQgKSAgLy8gQ29tcGFyZSBvbmx5IGlmIG9jY3VwYW50IGV4aXN0c1xuICAgIGNvbnN0IHZhbGlkUmFuayA9IGZSYW5rKCBtaWdyYW50ICkgPT09IGZSYW5rKCBvY2N1cGFudCApICsgMVxuICAgIGlmKCEoIHZhbGlkU3VpdCAmJiB2YWxpZFJhbmsgKSkgcmV0dXJuIGRlc2VsZWN0KClcbiAgfVxuXG4gIGlmKCBtaWdyYW50UGF0aFsxXSA9PT0gJ3BpbGVzJyApIHtcbiAgICBpZiggZXF1YWxzKCBtaWdyYW50UGF0aFsyXSwgb2NjdXBhbnRQYXRoWzJdICkpIHJldHVybiBkZXNlbGVjdCgpICAgLy8gRGVzZWxlY3Qgb24gc2FtZSBwaWxlXG5cbiAgICBjb25zdCB2YWxpZFN1aXQgPSBjb2xvciggbWlncmFudCApICE9PSBjb2xvciggb2NjdXBhbnQgfHwgbWlncmFudCApICAvLyBDb21wYXJlIG9ubHkgaWYgb2NjdXBhbnQgZXhpc3RzXG4gICAgY29uc3QgdmFsaWRSYW5rID0gcFJhbmsoIG1pZ3JhbnQgKSA9PT0gcFJhbmsoIG9jY3VwYW50ICkgLSAxXG4gICAgaWYoISggdmFsaWRTdWl0ICYmIHZhbGlkUmFuayApKSByZXR1cm4gZGVzZWxlY3QoKVxuXG4gICAgY29uc3QgbWlncmFudElkeCA9IG1pZ3JhbnRQYXRoWzRdXG4gICAgY29uc3QgcGlsZUhlaWdodCA9IHZpZXcoIG1pZ3JhbnRMb2NhdGlvbkwsIG1vZGVsICkubGVuZ3RoXG4gICAgY29uc3QgdG9wID0gcGlsZUhlaWdodCAtIDFcbiAgICBjb25zdCBjYXJkQ291bnQgPSBwaWxlSGVpZ2h0IC0gbWlncmFudElkeFxuICAgIFxuICAgIC8vIGlmIG1pZ3JhbnQgaXMgbm90IHRvcCBvZiBwaWxlXG4gICAgY29uc29sZS5sb2coICdtaWdyYW50SWR4OicsIG1pZ3JhbnRJZHgsICcgIHRvcDonLCB0b3ApXG4gICAgaWYoIG1pZ3JhbnRJZHggIT0gdG9wICkgXG4gICAgICByZXR1cm4gcGlwZVxuICAgICAgKCBkaXNzb2MoICdzZWxlY3RlZCcgKVxuICAgICAgLCBvdmVyKCBvY2N1cGFudExvY2F0aW9uTCwgZmxpcChjb25jYXQpKCB0YWtlKCBjYXJkQ291bnQsIHZpZXcoIG1pZ3JhbnRMb2NhdGlvbkwsIG1vZGVsICkpKSkgICAgICAvLyBDb3B5IG1pZ3JhbnQgdG8gb2NjdXBhbnRMb2NhdGlvblxuICAgICAgLCBvdmVyKCBtaWdyYW50TG9jYXRpb25MLCBkcm9wTGFzdCggY2FyZENvdW50ICkpICAgICAgICAgLy8gRHJvcCBmcm9tIG1pZ3JhbnRMb2NhdGlvblxuICAgICAgKSggbW9kZWwgKVxuICB9XG5cbiAgLy8gaWYgbWlncmFudCBpcyB0b3Agb2YgcGlsZVxuICByZXR1cm4gcGlwZVxuICAoIGRpc3NvYyggJ3NlbGVjdGVkJyApXG4gICwgb3Zlciggb2NjdXBhbnRMb2NhdGlvbkwsIGFwcGVuZCggbWlncmFudCApKSAgICAgIC8vIENvcHkgbWlncmFudCB0byBvY2N1cGFudExvY2F0aW9uXG4gICwgb3ZlciggbWlncmFudExvY2F0aW9uTCwgZHJvcExhc3QoMSkgKSAgICAgICAgIC8vIERyb3AgZnJvbSBtaWdyYW50TG9jYXRpb25cbiAgKSggbW9kZWwgKVxufVxuXG5jb25zdCBTaG93SGlkZGVuUGlsZSA9IG1vZGVsID0+ICggcGlsZUlkeCApOiBNb2RlbCA9PiB7XG4gIGNvbnN0IHVwdHVybmVkICAgPSBsZW5zUGF0aChbICd0YWJsZScsICdwaWxlcycsIHBpbGVJZHgsICd1cHR1cm5lZCcgXSlcbiAgY29uc3QgZG93bnR1cm5lZCA9IGxlbnNQYXRoKFsgJ3RhYmxlJywgJ3BpbGVzJywgcGlsZUlkeCwgJ2Rvd250dXJuZWQnIF0pXG4gIHJldHVybiBwaXBlXG4gICggb3ZlciggdXB0dXJuZWQsIGFwcGVuZCggaGVhZCggdmlldyggZG93bnR1cm5lZCwgbW9kZWwgKSkpKSAgLy8gYXBwZW5kIGRvd250dXJuZWRbMF0gdG8gdXB0dXJuZWRcbiAgLCBvdmVyKCBkb3dudHVybmVkLCBkcm9wKDEpICkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkcm9wIGRvd250dXJuZWRbMF1cbiAgKSggbW9kZWwgKVxufVxuXG5jb25zdCBTaG93SGlkZGVuV2FzdGUgPSBtb2RlbCA9PiAoKTogTW9kZWwgPT4ge1xuICBjb25zdCB7IHdhc3RlSGlkZGVuLCB3YXN0ZVZpc2libGUgfSA9IG1vZGVsLnRhYmxlXG4gIGNvbnN0IHRhYmxlID1cbiAgeyAuLi5tb2RlbC50YWJsZVxuICAsIHdhc3RlVmlzaWJsZTogWyBsYXN0KCB3YXN0ZUhpZGRlbiApIF1cbiAgLCB3YXN0ZUhpZGRlbjogZHJvcExhc3QoIDEsIHdhc3RlSGlkZGVuIClcbiAgfVxuICByZXR1cm4geyAuLi5tb2RlbCwgdGFibGUgfVxufVxuXG5jb25zdCBGb3VuZGF0aW9uID0gbW9kZWwgPT4gcGF0aCA9PiAnZGJsY2xpY2snXG4vLyBGdWNrIHRoaXMgZm9yIG5vdy4gZW5oYW5jZW1lbnQuXG5cbmNvbnN0IERyb3AgPSBtb2RlbCA9PiAoKSA9PiBkaXNzb2MoICdjYXJkUGF0aCcsIG1vZGVsIClcbmNvbnN0IFVuZG8gPSBtb2RlbCA9PiAoKSA9PiB7fVxuY29uc3QgU2hvd1NldHRpbmdzID0gbW9kZWwgPT4gKCkgPT4ge31cbmNvbnN0IFVwZGF0ZVNldHRpbmdzID0gbW9kZWwgPT4gKCkgPT4ge31cblxuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICAvL1xuXG5leHBvcnQgY29uc3QgQWN0aW9uID0gVHlwZSh7XG4gIERlYWw6IFtdXG4sIFJlc2V0OiBbXVxuLCBEcmF3OiBbXVxuLCBNb3ZlOiBbIEFueSwgQW55IF1cbiwgU2hvd0hpZGRlblBpbGU6IFsgTnVtYmVyIF1cbiwgU2hvd0hpZGRlbldhc3RlOiBbXVxuLCBGb3VuZGF0aW9uOiBbIEFueSBdXG4sIERyb3A6IFtdXG4sIFVuZG86IFtdXG4sIFNob3dTZXR0aW5nczogW11cbiwgVXBkYXRlU2V0dGluZ3M6IFtdXG59KVxuXG5leHBvcnQgY29uc3QgYWN0aW9ucyA9IHtcblx0RGVhbFxuLCBSZXNldFxuLCBEcmF3XG4sIE1vdmVcbiwgU2hvd0hpZGRlblBpbGVcbiwgU2hvd0hpZGRlbldhc3RlXG4sIEZvdW5kYXRpb25cbiwgRHJvcFxuLCBVbmRvXG4sIFNob3dTZXR0aW5nc1xuLCBVcGRhdGVTZXR0aW5nc1xufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvYWN0aW9ucy5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	eval("var curryN = __webpack_require__(76);\n\nvar isString = function(s) { return typeof s === 'string'; };\nvar isNumber = function(n) { return typeof n === 'number'; };\nvar isBoolean = function(b) { return typeof b === 'boolean'; };\nvar isObject = function(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n};\nvar isFunction = function(f) { return typeof f === 'function'; };\nvar isArray = Array.isArray || function(a) { return 'length' in a; };\n\nvar mapConstrToFn = function(group, constr) {\n  return constr === String    ? isString\n       : constr === Number    ? isNumber\n       : constr === Boolean   ? isBoolean\n       : constr === Object    ? isObject\n       : constr === Array     ? isArray\n       : constr === Function  ? isFunction\n       : constr === undefined ? group\n                              : constr;\n};\n\nvar numToStr = ['first', 'second', 'third', 'fourth', 'fifth', 'sixth', 'seventh', 'eighth', 'ninth', 'tenth'];\n\nvar validate = function(group, validators, name, args) {\n  var validator, v, i;\n  for (i = 0; i < args.length; ++i) {\n    v = args[i];\n    validator = mapConstrToFn(group, validators[i]);\n    if (Type.check === true &&\n        (validator.prototype === undefined || !validator.prototype.isPrototypeOf(v)) &&\n        (typeof validator !== 'function' || !validator(v))) {\n      throw new TypeError('wrong value ' + v + ' passed to location ' + numToStr[i] + ' in ' + name);\n    }\n  }\n};\n\nfunction valueToArray(value) {\n  var i, arr = [];\n  for (i = 0; i < value._keys.length; ++i) {\n    arr.push(value[value._keys[i]]);\n  }\n  return arr;\n}\n\nfunction extractValues(keys, obj) {\n  var arr = [], i;\n  for (i = 0; i < keys.length; ++i) arr[i] = obj[keys[i]];\n  return arr;\n}\n\nfunction constructor(group, name, fields) {\n  var validators, keys = Object.keys(fields), i;\n  if (isArray(fields)) {\n    validators = fields;\n  } else {\n    validators = extractValues(keys, fields);\n  }\n  function construct() {\n    var val = Object.create(group.prototype), i;\n    val._keys = keys;\n    val._name = name;\n    if (Type.check === true) {\n      validate(group, validators, name, arguments);\n    }\n    for (i = 0; i < arguments.length; ++i) {\n      val[keys[i]] = arguments[i];\n    }\n    return val;\n  }\n  group[name] = curryN(keys.length, construct);\n  if (keys !== undefined) {\n    group[name+'Of'] = function(obj) {\n      return construct.apply(undefined, extractValues(keys, obj));\n    };\n  }\n}\n\nfunction rawCase(type, cases, value, arg) {\n  var wildcard = false;\n  var handler = cases[value._name];\n  if (handler === undefined) {\n    handler = cases['_'];\n    wildcard = true;\n  }\n  if (Type.check === true) {\n    if (!type.prototype.isPrototypeOf(value)) {\n      throw new TypeError('wrong type passed to case');\n    } else if (handler === undefined) {\n      throw new Error('non-exhaustive patterns in a function');\n    }\n  }\n  var args = wildcard === true ? [arg]\n           : arg !== undefined ? valueToArray(value).concat([arg])\n           : valueToArray(value);\n  return handler.apply(undefined, args);\n}\n\nvar typeCase = curryN(3, rawCase);\nvar caseOn = curryN(4, rawCase);\n\nfunction createIterator() {\n  return {\n    idx: 0,\n    val: this,\n    next: function() {\n      var keys = this.val._keys;\n      return this.idx === keys.length\n        ? {done: true}\n        : {value: this.val[keys[this.idx++]]};\n    }\n  };\n}\n\nfunction Type(desc) {\n  var key, res, obj = {};\n  obj.prototype = {};\n  obj.prototype[Symbol ? Symbol.iterator : '@@iterator'] = createIterator;\n  obj.case = typeCase(obj);\n  obj.caseOn = caseOn(obj);\n  for (key in desc) {\n    res = constructor(obj, key, desc[key]);\n  }\n  return obj;\n}\n\nType.check = true;\n\nmodule.exports = Type;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3VuaW9uLXR5cGUvdW5pb24tdHlwZS5qcz80YzRmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLDRCQUE0Qiw4QkFBOEI7QUFDMUQsNEJBQTRCLDhCQUE4QjtBQUMxRCw2QkFBNkIsK0JBQStCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGdDQUFnQztBQUM5RCw0Q0FBNEMsc0JBQXNCOztBQUVsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLHdCQUF3QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEiLCJmaWxlIjoiNzUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgY3VycnlOID0gcmVxdWlyZSgncmFtZGEvc3JjL2N1cnJ5TicpO1xuXG52YXIgaXNTdHJpbmcgPSBmdW5jdGlvbihzKSB7IHJldHVybiB0eXBlb2YgcyA9PT0gJ3N0cmluZyc7IH07XG52YXIgaXNOdW1iZXIgPSBmdW5jdGlvbihuKSB7IHJldHVybiB0eXBlb2YgbiA9PT0gJ251bWJlcic7IH07XG52YXIgaXNCb29sZWFuID0gZnVuY3Rpb24oYikgeyByZXR1cm4gdHlwZW9mIGIgPT09ICdib29sZWFuJzsgfTtcbnZhciBpc09iamVjdCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufTtcbnZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24oZikgeyByZXR1cm4gdHlwZW9mIGYgPT09ICdmdW5jdGlvbic7IH07XG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24oYSkgeyByZXR1cm4gJ2xlbmd0aCcgaW4gYTsgfTtcblxudmFyIG1hcENvbnN0clRvRm4gPSBmdW5jdGlvbihncm91cCwgY29uc3RyKSB7XG4gIHJldHVybiBjb25zdHIgPT09IFN0cmluZyAgICA/IGlzU3RyaW5nXG4gICAgICAgOiBjb25zdHIgPT09IE51bWJlciAgICA/IGlzTnVtYmVyXG4gICAgICAgOiBjb25zdHIgPT09IEJvb2xlYW4gICA/IGlzQm9vbGVhblxuICAgICAgIDogY29uc3RyID09PSBPYmplY3QgICAgPyBpc09iamVjdFxuICAgICAgIDogY29uc3RyID09PSBBcnJheSAgICAgPyBpc0FycmF5XG4gICAgICAgOiBjb25zdHIgPT09IEZ1bmN0aW9uICA/IGlzRnVuY3Rpb25cbiAgICAgICA6IGNvbnN0ciA9PT0gdW5kZWZpbmVkID8gZ3JvdXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY29uc3RyO1xufTtcblxudmFyIG51bVRvU3RyID0gWydmaXJzdCcsICdzZWNvbmQnLCAndGhpcmQnLCAnZm91cnRoJywgJ2ZpZnRoJywgJ3NpeHRoJywgJ3NldmVudGgnLCAnZWlnaHRoJywgJ25pbnRoJywgJ3RlbnRoJ107XG5cbnZhciB2YWxpZGF0ZSA9IGZ1bmN0aW9uKGdyb3VwLCB2YWxpZGF0b3JzLCBuYW1lLCBhcmdzKSB7XG4gIHZhciB2YWxpZGF0b3IsIHYsIGk7XG4gIGZvciAoaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgdiA9IGFyZ3NbaV07XG4gICAgdmFsaWRhdG9yID0gbWFwQ29uc3RyVG9Gbihncm91cCwgdmFsaWRhdG9yc1tpXSk7XG4gICAgaWYgKFR5cGUuY2hlY2sgPT09IHRydWUgJiZcbiAgICAgICAgKHZhbGlkYXRvci5wcm90b3R5cGUgPT09IHVuZGVmaW5lZCB8fCAhdmFsaWRhdG9yLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKHYpKSAmJlxuICAgICAgICAodHlwZW9mIHZhbGlkYXRvciAhPT0gJ2Z1bmN0aW9uJyB8fCAhdmFsaWRhdG9yKHYpKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignd3JvbmcgdmFsdWUgJyArIHYgKyAnIHBhc3NlZCB0byBsb2NhdGlvbiAnICsgbnVtVG9TdHJbaV0gKyAnIGluICcgKyBuYW1lKTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHZhbHVlVG9BcnJheSh2YWx1ZSkge1xuICB2YXIgaSwgYXJyID0gW107XG4gIGZvciAoaSA9IDA7IGkgPCB2YWx1ZS5fa2V5cy5sZW5ndGg7ICsraSkge1xuICAgIGFyci5wdXNoKHZhbHVlW3ZhbHVlLl9rZXlzW2ldXSk7XG4gIH1cbiAgcmV0dXJuIGFycjtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdFZhbHVlcyhrZXlzLCBvYmopIHtcbiAgdmFyIGFyciA9IFtdLCBpO1xuICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkgYXJyW2ldID0gb2JqW2tleXNbaV1dO1xuICByZXR1cm4gYXJyO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3Rvcihncm91cCwgbmFtZSwgZmllbGRzKSB7XG4gIHZhciB2YWxpZGF0b3JzLCBrZXlzID0gT2JqZWN0LmtleXMoZmllbGRzKSwgaTtcbiAgaWYgKGlzQXJyYXkoZmllbGRzKSkge1xuICAgIHZhbGlkYXRvcnMgPSBmaWVsZHM7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWRhdG9ycyA9IGV4dHJhY3RWYWx1ZXMoa2V5cywgZmllbGRzKTtcbiAgfVxuICBmdW5jdGlvbiBjb25zdHJ1Y3QoKSB7XG4gICAgdmFyIHZhbCA9IE9iamVjdC5jcmVhdGUoZ3JvdXAucHJvdG90eXBlKSwgaTtcbiAgICB2YWwuX2tleXMgPSBrZXlzO1xuICAgIHZhbC5fbmFtZSA9IG5hbWU7XG4gICAgaWYgKFR5cGUuY2hlY2sgPT09IHRydWUpIHtcbiAgICAgIHZhbGlkYXRlKGdyb3VwLCB2YWxpZGF0b3JzLCBuYW1lLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YWxba2V5c1tpXV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgZ3JvdXBbbmFtZV0gPSBjdXJyeU4oa2V5cy5sZW5ndGgsIGNvbnN0cnVjdCk7XG4gIGlmIChrZXlzICE9PSB1bmRlZmluZWQpIHtcbiAgICBncm91cFtuYW1lKydPZiddID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gY29uc3RydWN0LmFwcGx5KHVuZGVmaW5lZCwgZXh0cmFjdFZhbHVlcyhrZXlzLCBvYmopKTtcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIHJhd0Nhc2UodHlwZSwgY2FzZXMsIHZhbHVlLCBhcmcpIHtcbiAgdmFyIHdpbGRjYXJkID0gZmFsc2U7XG4gIHZhciBoYW5kbGVyID0gY2FzZXNbdmFsdWUuX25hbWVdO1xuICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaGFuZGxlciA9IGNhc2VzWydfJ107XG4gICAgd2lsZGNhcmQgPSB0cnVlO1xuICB9XG4gIGlmIChUeXBlLmNoZWNrID09PSB0cnVlKSB7XG4gICAgaWYgKCF0eXBlLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignd3JvbmcgdHlwZSBwYXNzZWQgdG8gY2FzZScpO1xuICAgIH0gZWxzZSBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vbi1leGhhdXN0aXZlIHBhdHRlcm5zIGluIGEgZnVuY3Rpb24nKTtcbiAgICB9XG4gIH1cbiAgdmFyIGFyZ3MgPSB3aWxkY2FyZCA9PT0gdHJ1ZSA/IFthcmddXG4gICAgICAgICAgIDogYXJnICE9PSB1bmRlZmluZWQgPyB2YWx1ZVRvQXJyYXkodmFsdWUpLmNvbmNhdChbYXJnXSlcbiAgICAgICAgICAgOiB2YWx1ZVRvQXJyYXkodmFsdWUpO1xuICByZXR1cm4gaGFuZGxlci5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xufVxuXG52YXIgdHlwZUNhc2UgPSBjdXJyeU4oMywgcmF3Q2FzZSk7XG52YXIgY2FzZU9uID0gY3VycnlOKDQsIHJhd0Nhc2UpO1xuXG5mdW5jdGlvbiBjcmVhdGVJdGVyYXRvcigpIHtcbiAgcmV0dXJuIHtcbiAgICBpZHg6IDAsXG4gICAgdmFsOiB0aGlzLFxuICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGtleXMgPSB0aGlzLnZhbC5fa2V5cztcbiAgICAgIHJldHVybiB0aGlzLmlkeCA9PT0ga2V5cy5sZW5ndGhcbiAgICAgICAgPyB7ZG9uZTogdHJ1ZX1cbiAgICAgICAgOiB7dmFsdWU6IHRoaXMudmFsW2tleXNbdGhpcy5pZHgrK11dfTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIFR5cGUoZGVzYykge1xuICB2YXIga2V5LCByZXMsIG9iaiA9IHt9O1xuICBvYmoucHJvdG90eXBlID0ge307XG4gIG9iai5wcm90b3R5cGVbU3ltYm9sID8gU3ltYm9sLml0ZXJhdG9yIDogJ0BAaXRlcmF0b3InXSA9IGNyZWF0ZUl0ZXJhdG9yO1xuICBvYmouY2FzZSA9IHR5cGVDYXNlKG9iaik7XG4gIG9iai5jYXNlT24gPSBjYXNlT24ob2JqKTtcbiAgZm9yIChrZXkgaW4gZGVzYykge1xuICAgIHJlcyA9IGNvbnN0cnVjdG9yKG9iaiwga2V5LCBkZXNjW2tleV0pO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cblR5cGUuY2hlY2sgPSB0cnVlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFR5cGU7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91bmlvbi10eXBlL3VuaW9uLXR5cGUuanNcbiAqKiBtb2R1bGUgaWQgPSA3NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	eval("var _arity = __webpack_require__(77);\nvar _curry1 = __webpack_require__(78);\nvar _curry2 = __webpack_require__(80);\nvar _curryN = __webpack_require__(81);\n\n\n/**\n * Returns a curried equivalent of the provided function, with the specified\n * arity. The curried function has two unusual capabilities. First, its\n * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the\n * following are equivalent:\n *\n *   - `g(1)(2)(3)`\n *   - `g(1)(2, 3)`\n *   - `g(1, 2)(3)`\n *   - `g(1, 2, 3)`\n *\n * Secondly, the special placeholder value `R.__` may be used to specify\n * \"gaps\", allowing partial application of any combination of arguments,\n * regardless of their positions. If `g` is as above and `_` is `R.__`, the\n * following are equivalent:\n *\n *   - `g(1, 2, 3)`\n *   - `g(_, 2, 3)(1)`\n *   - `g(_, _, 3)(1)(2)`\n *   - `g(_, _, 3)(1, 2)`\n *   - `g(_, 2)(1)(3)`\n *   - `g(_, 2)(1, 3)`\n *   - `g(_, 2)(_, 3)(1)`\n *\n * @func\n * @memberOf R\n * @since v0.5.0\n * @category Function\n * @sig Number -> (* -> a) -> (* -> a)\n * @param {Number} length The arity for the returned function.\n * @param {Function} fn The function to curry.\n * @return {Function} A new, curried function.\n * @see R.curry\n * @example\n *\n *      var sumArgs = (...args) => R.sum(args);\n *\n *      var curriedAddFourNumbers = R.curryN(4, sumArgs);\n *      var f = curriedAddFourNumbers(1, 2);\n *      var g = f(3);\n *      g(4); //=> 10\n */\nmodule.exports = _curry2(function curryN(length, fn) {\n  if (length === 1) {\n    return _curry1(fn);\n  }\n  return _arity(length, _curryN(length, [], fn));\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3VuaW9uLXR5cGUvfi9yYW1kYS9zcmMvY3VycnlOLmpzP2NlMmEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiNzYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX2FyaXR5ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fYXJpdHknKTtcbnZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkxJyk7XG52YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xudmFyIF9jdXJyeU4gPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeU4nKTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBjdXJyaWVkIGVxdWl2YWxlbnQgb2YgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLCB3aXRoIHRoZSBzcGVjaWZpZWRcbiAqIGFyaXR5LiBUaGUgY3VycmllZCBmdW5jdGlvbiBoYXMgdHdvIHVudXN1YWwgY2FwYWJpbGl0aWVzLiBGaXJzdCwgaXRzXG4gKiBhcmd1bWVudHMgbmVlZG4ndCBiZSBwcm92aWRlZCBvbmUgYXQgYSB0aW1lLiBJZiBgZ2AgaXMgYFIuY3VycnlOKDMsIGYpYCwgdGhlXG4gKiBmb2xsb3dpbmcgYXJlIGVxdWl2YWxlbnQ6XG4gKlxuICogICAtIGBnKDEpKDIpKDMpYFxuICogICAtIGBnKDEpKDIsIDMpYFxuICogICAtIGBnKDEsIDIpKDMpYFxuICogICAtIGBnKDEsIDIsIDMpYFxuICpcbiAqIFNlY29uZGx5LCB0aGUgc3BlY2lhbCBwbGFjZWhvbGRlciB2YWx1ZSBgUi5fX2AgbWF5IGJlIHVzZWQgdG8gc3BlY2lmeVxuICogXCJnYXBzXCIsIGFsbG93aW5nIHBhcnRpYWwgYXBwbGljYXRpb24gb2YgYW55IGNvbWJpbmF0aW9uIG9mIGFyZ3VtZW50cyxcbiAqIHJlZ2FyZGxlc3Mgb2YgdGhlaXIgcG9zaXRpb25zLiBJZiBgZ2AgaXMgYXMgYWJvdmUgYW5kIGBfYCBpcyBgUi5fX2AsIHRoZVxuICogZm9sbG93aW5nIGFyZSBlcXVpdmFsZW50OlxuICpcbiAqICAgLSBgZygxLCAyLCAzKWBcbiAqICAgLSBgZyhfLCAyLCAzKSgxKWBcbiAqICAgLSBgZyhfLCBfLCAzKSgxKSgyKWBcbiAqICAgLSBgZyhfLCBfLCAzKSgxLCAyKWBcbiAqICAgLSBgZyhfLCAyKSgxKSgzKWBcbiAqICAgLSBgZyhfLCAyKSgxLCAzKWBcbiAqICAgLSBgZyhfLCAyKShfLCAzKSgxKWBcbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC41LjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyBOdW1iZXIgLT4gKCogLT4gYSkgLT4gKCogLT4gYSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggVGhlIGFyaXR5IGZvciB0aGUgcmV0dXJuZWQgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBuZXcsIGN1cnJpZWQgZnVuY3Rpb24uXG4gKiBAc2VlIFIuY3VycnlcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgc3VtQXJncyA9ICguLi5hcmdzKSA9PiBSLnN1bShhcmdzKTtcbiAqXG4gKiAgICAgIHZhciBjdXJyaWVkQWRkRm91ck51bWJlcnMgPSBSLmN1cnJ5Tig0LCBzdW1BcmdzKTtcbiAqICAgICAgdmFyIGYgPSBjdXJyaWVkQWRkRm91ck51bWJlcnMoMSwgMik7XG4gKiAgICAgIHZhciBnID0gZigzKTtcbiAqICAgICAgZyg0KTsgLy89PiAxMFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gY3VycnlOKGxlbmd0aCwgZm4pIHtcbiAgaWYgKGxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBfY3VycnkxKGZuKTtcbiAgfVxuICByZXR1cm4gX2FyaXR5KGxlbmd0aCwgX2N1cnJ5TihsZW5ndGgsIFtdLCBmbikpO1xufSk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91bmlvbi10eXBlL34vcmFtZGEvc3JjL2N1cnJ5Ti5qc1xuICoqIG1vZHVsZSBpZCA9IDc2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 77 */
/***/ function(module, exports) {

	eval("module.exports = function _arity(n, fn) {\n  /* eslint-disable no-unused-vars */\n  switch (n) {\n    case 0: return function() { return fn.apply(this, arguments); };\n    case 1: return function(a0) { return fn.apply(this, arguments); };\n    case 2: return function(a0, a1) { return fn.apply(this, arguments); };\n    case 3: return function(a0, a1, a2) { return fn.apply(this, arguments); };\n    case 4: return function(a0, a1, a2, a3) { return fn.apply(this, arguments); };\n    case 5: return function(a0, a1, a2, a3, a4) { return fn.apply(this, arguments); };\n    case 6: return function(a0, a1, a2, a3, a4, a5) { return fn.apply(this, arguments); };\n    case 7: return function(a0, a1, a2, a3, a4, a5, a6) { return fn.apply(this, arguments); };\n    case 8: return function(a0, a1, a2, a3, a4, a5, a6, a7) { return fn.apply(this, arguments); };\n    case 9: return function(a0, a1, a2, a3, a4, a5, a6, a7, a8) { return fn.apply(this, arguments); };\n    case 10: return function(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) { return fn.apply(this, arguments); };\n    default: throw new Error('First argument to _arity must be a non-negative integer no greater than ten');\n  }\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3VuaW9uLXR5cGUvfi9yYW1kYS9zcmMvaW50ZXJuYWwvX2FyaXR5LmpzP2Q1NTUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGtDQUFrQztBQUNqRSxpQ0FBaUMsa0NBQWtDO0FBQ25FLHFDQUFxQyxrQ0FBa0M7QUFDdkUseUNBQXlDLGtDQUFrQztBQUMzRSw2Q0FBNkMsa0NBQWtDO0FBQy9FLGlEQUFpRCxrQ0FBa0M7QUFDbkYscURBQXFELGtDQUFrQztBQUN2Rix5REFBeUQsa0NBQWtDO0FBQzNGLDZEQUE2RCxrQ0FBa0M7QUFDL0YsaUVBQWlFLGtDQUFrQztBQUNuRyxzRUFBc0Usa0NBQWtDO0FBQ3hHO0FBQ0E7QUFDQSIsImZpbGUiOiI3Ny5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gX2FyaXR5KG4sIGZuKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4gIHN3aXRjaCAobikge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmN0aW9uKCkgeyByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbihhMCkgeyByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbihhMCwgYTEpIHsgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24oYTAsIGExLCBhMikgeyByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcbiAgICBjYXNlIDQ6IHJldHVybiBmdW5jdGlvbihhMCwgYTEsIGEyLCBhMykgeyByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcbiAgICBjYXNlIDU6IHJldHVybiBmdW5jdGlvbihhMCwgYTEsIGEyLCBhMywgYTQpIHsgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH07XG4gICAgY2FzZSA2OiByZXR1cm4gZnVuY3Rpb24oYTAsIGExLCBhMiwgYTMsIGE0LCBhNSkgeyByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcbiAgICBjYXNlIDc6IHJldHVybiBmdW5jdGlvbihhMCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNikgeyByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcbiAgICBjYXNlIDg6IHJldHVybiBmdW5jdGlvbihhMCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcpIHsgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH07XG4gICAgY2FzZSA5OiByZXR1cm4gZnVuY3Rpb24oYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCkgeyByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcbiAgICBjYXNlIDEwOiByZXR1cm4gZnVuY3Rpb24oYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCwgYTkpIHsgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH07XG4gICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCB0byBfYXJpdHkgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyIG5vIGdyZWF0ZXIgdGhhbiB0ZW4nKTtcbiAgfVxufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3VuaW9uLXR5cGUvfi9yYW1kYS9zcmMvaW50ZXJuYWwvX2FyaXR5LmpzXG4gKiogbW9kdWxlIGlkID0gNzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	eval("var _isPlaceholder = __webpack_require__(79);\n\n\n/**\n * Optimized internal one-arity curry function.\n *\n * @private\n * @category Function\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\nmodule.exports = function _curry1(fn) {\n  return function f1(a) {\n    if (arguments.length === 0 || _isPlaceholder(a)) {\n      return f1;\n    } else {\n      return fn.apply(this, arguments);\n    }\n  };\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3VuaW9uLXR5cGUvfi9yYW1kYS9zcmMvaW50ZXJuYWwvX2N1cnJ5MS5qcz9iMGVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ijc4LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIF9pc1BsYWNlaG9sZGVyID0gcmVxdWlyZSgnLi9faXNQbGFjZWhvbGRlcicpO1xuXG5cbi8qKlxuICogT3B0aW1pemVkIGludGVybmFsIG9uZS1hcml0eSBjdXJyeSBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIGN1cnJpZWQgZnVuY3Rpb24uXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gX2N1cnJ5MShmbikge1xuICByZXR1cm4gZnVuY3Rpb24gZjEoYSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwIHx8IF9pc1BsYWNlaG9sZGVyKGEpKSB7XG4gICAgICByZXR1cm4gZjE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91bmlvbi10eXBlL34vcmFtZGEvc3JjL2ludGVybmFsL19jdXJyeTEuanNcbiAqKiBtb2R1bGUgaWQgPSA3OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 79 */
/***/ function(module, exports) {

	eval("module.exports = function _isPlaceholder(a) {\n  return a != null &&\n         typeof a === 'object' &&\n         a['@@functional/placeholder'] === true;\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3VuaW9uLXR5cGUvfi9yYW1kYS9zcmMvaW50ZXJuYWwvX2lzUGxhY2Vob2xkZXIuanM/OTFiZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ijc5LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBfaXNQbGFjZWhvbGRlcihhKSB7XG4gIHJldHVybiBhICE9IG51bGwgJiZcbiAgICAgICAgIHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgYVsnQEBmdW5jdGlvbmFsL3BsYWNlaG9sZGVyJ10gPT09IHRydWU7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdW5pb24tdHlwZS9+L3JhbWRhL3NyYy9pbnRlcm5hbC9faXNQbGFjZWhvbGRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDc5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	eval("var _curry1 = __webpack_require__(78);\nvar _isPlaceholder = __webpack_require__(79);\n\n\n/**\n * Optimized internal two-arity curry function.\n *\n * @private\n * @category Function\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\nmodule.exports = function _curry2(fn) {\n  return function f2(a, b) {\n    switch (arguments.length) {\n      case 0:\n        return f2;\n      case 1:\n        return _isPlaceholder(a) ? f2\n             : _curry1(function(_b) { return fn(a, _b); });\n      default:\n        return _isPlaceholder(a) && _isPlaceholder(b) ? f2\n             : _isPlaceholder(a) ? _curry1(function(_a) { return fn(_a, b); })\n             : _isPlaceholder(b) ? _curry1(function(_b) { return fn(a, _b); })\n             : fn(a, b);\n    }\n  };\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3VuaW9uLXR5cGUvfi9yYW1kYS9zcmMvaW50ZXJuYWwvX2N1cnJ5Mi5qcz83ZjA3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsa0JBQWtCLEVBQUU7QUFDekQ7QUFDQTtBQUNBLHlEQUF5RCxrQkFBa0IsRUFBRTtBQUM3RSx5REFBeUQsa0JBQWtCLEVBQUU7QUFDN0U7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiODAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX2N1cnJ5MSA9IHJlcXVpcmUoJy4vX2N1cnJ5MScpO1xudmFyIF9pc1BsYWNlaG9sZGVyID0gcmVxdWlyZSgnLi9faXNQbGFjZWhvbGRlcicpO1xuXG5cbi8qKlxuICogT3B0aW1pemVkIGludGVybmFsIHR3by1hcml0eSBjdXJyeSBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIGN1cnJpZWQgZnVuY3Rpb24uXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gX2N1cnJ5Mihmbikge1xuICByZXR1cm4gZnVuY3Rpb24gZjIoYSwgYikge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gZjI7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiBfaXNQbGFjZWhvbGRlcihhKSA/IGYyXG4gICAgICAgICAgICAgOiBfY3VycnkxKGZ1bmN0aW9uKF9iKSB7IHJldHVybiBmbihhLCBfYik7IH0pO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIF9pc1BsYWNlaG9sZGVyKGEpICYmIF9pc1BsYWNlaG9sZGVyKGIpID8gZjJcbiAgICAgICAgICAgICA6IF9pc1BsYWNlaG9sZGVyKGEpID8gX2N1cnJ5MShmdW5jdGlvbihfYSkgeyByZXR1cm4gZm4oX2EsIGIpOyB9KVxuICAgICAgICAgICAgIDogX2lzUGxhY2Vob2xkZXIoYikgPyBfY3VycnkxKGZ1bmN0aW9uKF9iKSB7IHJldHVybiBmbihhLCBfYik7IH0pXG4gICAgICAgICAgICAgOiBmbihhLCBiKTtcbiAgICB9XG4gIH07XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdW5pb24tdHlwZS9+L3JhbWRhL3NyYy9pbnRlcm5hbC9fY3VycnkyLmpzXG4gKiogbW9kdWxlIGlkID0gODBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	eval("var _arity = __webpack_require__(77);\nvar _isPlaceholder = __webpack_require__(79);\n\n\n/**\n * Internal curryN function.\n *\n * @private\n * @category Function\n * @param {Number} length The arity of the curried function.\n * @param {Array} received An array of arguments received thus far.\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\nmodule.exports = function _curryN(length, received, fn) {\n  return function() {\n    var combined = [];\n    var argsIdx = 0;\n    var left = length;\n    var combinedIdx = 0;\n    while (combinedIdx < received.length || argsIdx < arguments.length) {\n      var result;\n      if (combinedIdx < received.length &&\n          (!_isPlaceholder(received[combinedIdx]) ||\n           argsIdx >= arguments.length)) {\n        result = received[combinedIdx];\n      } else {\n        result = arguments[argsIdx];\n        argsIdx += 1;\n      }\n      combined[combinedIdx] = result;\n      if (!_isPlaceholder(result)) {\n        left -= 1;\n      }\n      combinedIdx += 1;\n    }\n    return left <= 0 ? fn.apply(this, combined)\n                     : _arity(left, _curryN(length, combined, fn));\n  };\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3VuaW9uLXR5cGUvfi9yYW1kYS9zcmMvaW50ZXJuYWwvX2N1cnJ5Ti5qcz9kMDFhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsU0FBUztBQUNwQixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiODEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX2FyaXR5ID0gcmVxdWlyZSgnLi9fYXJpdHknKTtcbnZhciBfaXNQbGFjZWhvbGRlciA9IHJlcXVpcmUoJy4vX2lzUGxhY2Vob2xkZXInKTtcblxuXG4vKipcbiAqIEludGVybmFsIGN1cnJ5TiBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIFRoZSBhcml0eSBvZiB0aGUgY3VycmllZCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXl9IHJlY2VpdmVkIEFuIGFycmF5IG9mIGFyZ3VtZW50cyByZWNlaXZlZCB0aHVzIGZhci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjdXJyeS5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgY3VycmllZCBmdW5jdGlvbi5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBfY3VycnlOKGxlbmd0aCwgcmVjZWl2ZWQsIGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY29tYmluZWQgPSBbXTtcbiAgICB2YXIgYXJnc0lkeCA9IDA7XG4gICAgdmFyIGxlZnQgPSBsZW5ndGg7XG4gICAgdmFyIGNvbWJpbmVkSWR4ID0gMDtcbiAgICB3aGlsZSAoY29tYmluZWRJZHggPCByZWNlaXZlZC5sZW5ndGggfHwgYXJnc0lkeCA8IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBpZiAoY29tYmluZWRJZHggPCByZWNlaXZlZC5sZW5ndGggJiZcbiAgICAgICAgICAoIV9pc1BsYWNlaG9sZGVyKHJlY2VpdmVkW2NvbWJpbmVkSWR4XSkgfHxcbiAgICAgICAgICAgYXJnc0lkeCA+PSBhcmd1bWVudHMubGVuZ3RoKSkge1xuICAgICAgICByZXN1bHQgPSByZWNlaXZlZFtjb21iaW5lZElkeF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBhcmd1bWVudHNbYXJnc0lkeF07XG4gICAgICAgIGFyZ3NJZHggKz0gMTtcbiAgICAgIH1cbiAgICAgIGNvbWJpbmVkW2NvbWJpbmVkSWR4XSA9IHJlc3VsdDtcbiAgICAgIGlmICghX2lzUGxhY2Vob2xkZXIocmVzdWx0KSkge1xuICAgICAgICBsZWZ0IC09IDE7XG4gICAgICB9XG4gICAgICBjb21iaW5lZElkeCArPSAxO1xuICAgIH1cbiAgICByZXR1cm4gbGVmdCA8PSAwID8gZm4uYXBwbHkodGhpcywgY29tYmluZWQpXG4gICAgICAgICAgICAgICAgICAgICA6IF9hcml0eShsZWZ0LCBfY3VycnlOKGxlbmd0aCwgY29tYmluZWQsIGZuKSk7XG4gIH07XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdW5pb24tdHlwZS9+L3JhbWRhL3NyYy9pbnRlcm5hbC9fY3VycnlOLmpzXG4gKiogbW9kdWxlIGlkID0gODFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;//\n//     is.js - 1.0.2\n//     Minimalistic predicate library\n//     Pwn <hi@pwn.buzz>\n//\n\n( function ( root , factory ) {\n\n  if ( true ) {\n\n    // AMD. Register as an anonymous module.\n    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\n  } else if ( typeof module === 'object' && module.exports ) {\n\n    // Node. Does not work with strict CommonJS, but only CommonJS-like\n    // environments that support `module.exports`, like Node.\n    module.exports = factory()\n\n  } else {\n\n    // Browser globals\n    root.is = factory()\n\n  }\n\n} )( this , function factory() {\n\n  var is = { not : {} }\n  var util\n\n  var hasOwnProperty = Object.prototype.hasOwnProperty\n\n\n  //\n  // __getTag( value )__\n  //\n  // Get the _[[class]]_ attribute, or _tag_ in `is.js` terminology, of any\n  // given value.\n  //\n\n  var getTag = ( function () {\n\n    var reSource = /(?:function|class)\\s*(\\w*)/\n\n    var toString = Object.prototype.toString\n    var toSource = Function.prototype.toString\n\n    return function tagOf( value ) {\n\n      var tagFromClass\n      var tagFromSource\n\n      if ( value === null ) {\n        return 'null'\n      } else if ( value === void 0 ) {\n        return 'undefined'\n      }\n\n      tagFromClass = toString.call( value )\n      tagFromClass = tagFromClass.substring( 8 , tagFromClass.length - 1 )\n\n      if ( typeof value.constructor !== 'function' ) {\n        return tagFromClass.toLowerCase()\n      } else {\n        tagFromSource = toSource.call( value.constructor ).match( reSource )[ 1 ]\n        return ( tagFromSource || tagFromClass ).toLowerCase()\n      }\n\n    }\n\n  } )()\n\n\n  //\n  // __ownKeys( value )__\n  //\n  // `Object.keys` ponyfill.\n  //\n\n  var ownKeys = Object.keys || ( function ( dontEnums ) {\n\n    var dontEnumsLength = dontEnums.length\n    var hasDontEnumBug = !{ toString : null }.propertyIsEnumerable( 'toString' )\n\n    return function ownKeys( object ) {\n\n      var key\n      var keys = []\n      var index\n\n      if ( object === null || object === void 0 ) {\n        throw new TypeError( 'ownKeys called on non-object' )\n      }\n\n      for ( key in object ) {\n        if ( hasOwnProperty.call( object , key ) ) {\n          keys.push( key )\n        }\n      }\n\n      // Fix IE < 9 _JScript DontEnum Bug_.\n      if ( hasDontEnumBug ) {\n        for ( index = 0 ; index < dontEnumsLength ; index += 1 ) {\n          key = dontEnums[ index ]\n          if ( hasOwnProperty.call( object , key ) ) {\n            keys.push( key )\n          }\n        }\n      }\n\n      return keys\n\n    }\n\n  } )( [\n\n    // These properties are marked as _DontEnum_ in IE < 9.\n    // They will never show up in `for...in` loops nor pass\n    // `propertyIsEnumerable` check.\n    'toString' ,\n    'toLocaleString' ,\n    'valueOf' ,\n    'isPrototypeOf' ,\n    'hasOwnProperty' ,\n    'propertyIsEnumerable' ,\n    'constructor'\n\n  ] )\n\n\n  util = {\n\n    //\n    // __util.addPredicate( name , predicate )__\n    //\n    // Add new checks(or _predicates_ in `is.js` terminology).\n    //\n\n    addPredicate : function addPredicate( name , predicate ) {\n\n      if ( /^(not|use)$/.test( name ) ) {\n        throw new Error( '\"' + name + '\" is a reserved name' )\n      }\n\n      if ( hasOwnProperty.call( is , name ) ) {\n        throw new Error( 'predicate \"' + name + '\" already defined' )\n      }\n\n      if ( typeof predicate !== 'function' ) {\n        throw new TypeError( 'predicate must be a function' )\n      }\n\n      is[ name ] = predicate\n      is.not[ name ] = function delegate() {\n        return !predicate.apply( null , arguments )\n      }\n\n    }\n\n  }\n\n\n  //\n  // __is.use( bundle )__\n  //\n  // Define new _bundles_(collection of related _predicates_).\n  //\n\n  is.use = function use( bundle ) {\n\n    if ( typeof bundle === 'function' ) {\n\n      //\n      // `bundle` takes two parameters(order matters):\n      //\n      //    - `util`: The utility object.\n      //    - `is`: The `is` export.\n      //\n      // The `util` and `is` export is passed in as free variables so that one\n      // can write standalone bundles without referencing `is.js` first.\n      //\n      //    ```js\n      //    // standalone bundle, does not depend on `is.js`\n      //    module.exports = function bundle( util , is ) {\n      //      util.addPredicate( 'eq' , function ( value , other ) {\n      //        if ( is.not.object( value ) || is.not.object( other ) ) {\n      //          return false\n      //        }\n      //        return value.uuid = other.uuid\n      //      } )\n      //    }\n      //    ```\n      //\n      // To import the bundle:\n      //\n      //    ```js\n      //    is.use( require( 'path/to/bundle' ) )\n      //    ```\n      //\n\n      bundle( util , is )\n\n    }\n\n  }\n\n\n  //\n  // # CORE BUNDLES\n  // Predicates shipped with `is.js`, packaged in various bundles.\n  //\n\n\n  //\n  // ### bundle:nil\n  //\n\n  is.use( function nilBundle( util ) {\n\n    //\n    // __is.null( value )__\n    //\n    // Checks whether given value is `null`.\n    //\n\n    util.addPredicate( 'null' , function isNull( value ) {\n      return value === null\n    } )\n\n\n    //\n    // __is.undefined( value )__\n    //\n    // Checks whether given value is `undefined`.\n    //\n\n    util.addPredicate( 'undefined' , function isUndefined( value ) {\n      return value === void 0\n    } )\n\n\n    //\n    // __is.exist( value )__\n    //\n    // Checks whether given value exists, i.e, not `null` nor `undefined`.\n    //\n\n    util.addPredicate( 'exist' , function isExist( value ) {\n      return value != null // eslint-disable-line no-eq-null\n    } )\n\n\n    //\n    // __is.nil( value )__\n    //\n    // Checks whether given value is either `null` or `undefined`.\n    //\n\n    util.addPredicate( 'nil' , function isNil( value ) {\n      return value == null // eslint-disable-line no-eq-null\n    } )\n\n  } )\n\n\n  //\n  // ### bundle:number\n  //\n\n  is.use( function numberBundle( util ) {\n\n    //\n    // __is.number( value )__\n    //\n    // Checks whether given value is a number.\n    //\n\n    util.addPredicate( 'number' , function isNumber( value ) {\n      return typeof value === 'number'\n    } )\n\n\n    //\n    // __is.numeral( value )__\n    //\n    // Checks whether given value is a numeral, i.e:\n    //\n    // - a genuine finite number\n    // - or a string that represents a finite number\n    //\n\n    util.addPredicate( 'numeral' , function isNumeral( value ) {\n\n      var tag = getTag( value )\n      if ( tag !== 'number' && tag !== 'string' ) {\n        return false\n      }\n\n      if ( is.emptyString( value ) ) {\n        return false\n      }\n\n      try {\n        value = Number( value )\n      } catch ( error ) {\n        return false\n      }\n\n      return is.finite( value )\n\n    } )\n\n\n    //\n    // __is.nan( value )__\n    //\n    // Checks whether given value is `NaN`.\n    //\n\n    util.addPredicate( 'nan' , function isNaN( value ) {\n      return value !== value // eslint-disable-line no-self-compare\n    } )\n\n\n    //\n    // __is.odd( number )__\n    //\n    // Checks whether given value is an odd number.\n    //\n\n    util.addPredicate( 'odd' , function isOdd( number ) {\n      return is.integer( number ) && number % 2 === 1\n    } )\n\n\n    //\n    // __is.even( number )__\n    //\n    // Checks whether given value is an even number.\n    //\n\n    util.addPredicate( 'even' , function isEven( number ) {\n      return is.integer( number ) && number % 2 === 0\n    } )\n\n\n    //\n    // __is.finite( number )__\n    //\n    // Checks whether given value is a finite number.\n    //\n\n    if ( Number.isFinite ) {\n      util.addPredicate( 'finite' , Number.isFinite )\n    } else {\n      util.addPredicate( 'finite' , function isFiniteNumber( number ) {\n        return is.number( number ) && isFinite( number )\n      } )\n    }\n\n\n    //\n    // __is.infinite( number )__\n    //\n    // Checks whether given value is an infinite number, i.e: + or -.\n    //\n\n    util.addPredicate( 'infinite' , function isInfinite( number ) {\n      return number === +1 / 0 || number === -1 / 0\n    } )\n\n\n    //\n    // __is.integer( number )__\n    //\n    // Checks whether given value is an integer.\n    //\n\n    if ( Number.isInteger ) {\n      util.addPredicate( 'integer' , Number.isInteger )\n    } else {\n      util.addPredicate( 'integer' , function isInteger( number ) {\n        return is.finite( number ) && Math.floor( number ) === number\n      } )\n    }\n\n\n    //\n    // __is.safeInteger( number )__\n    //\n    // Checks whether given value is a safe integer.\n    //\n\n    if ( Number.isSafeInteger ) {\n      util.addPredicate( 'safeInteger' , Number.isSafeInteger )\n    } else {\n      ( function () {\n\n        var MAX = Number.MAX_SAFE_INTEGER || Math.pow( 2 , 53 ) - 1\n        var MIN = Number.MIN_SAFE_INTEGER || -MAX\n\n        util.addPredicate( 'safeInteger' , function isSafeInteger( number ) {\n          return is.integer( number ) && ( number >= MIN && number <= MAX )\n        } )\n\n      } )()\n    }\n\n  } )\n\n\n  //\n  // ### bundle:string\n  //\n\n  is.use( function stringBundle( util ) {\n\n    //\n    // __is.string( value )__\n    //\n    // Checks whether given value is a string.\n    //\n\n    util.addPredicate( 'string' , function isString( value ) {\n      return typeof value === 'string'\n    } )\n\n\n    //\n    // __is.emptyString( string )__\n    //\n    // Checks whether given value is an empty string, i.e, a string with whitespace characters only.\n    //\n\n    util.addPredicate( 'emptyString' , function isEmptyString( string ) {\n      return is.string( string ) && /^\\s*$/.test( string )\n    } )\n\n\n    //\n    // __is.substring( substring , string , [offset=0] )__\n    //\n    // Checks whether one string may be found within another string.\n    //\n\n    util.addPredicate( 'substring' , function isSubstring( substring , string , offset ) {\n\n      var length\n\n      if ( getTag( string ) !== 'string' ) {\n        return false\n      }\n\n      length = string.length\n      offset = is.integer( offset ) ? offset : 0\n\n      // Allow negative offsets.\n      if ( offset < 0 ) {\n        offset = length + offset\n      }\n\n      if ( offset < 0 || offset >= length ) {\n        return false\n      }\n\n      return string.indexOf( substring , offset ) !== -1\n\n    } )\n\n\n    if ( String.prototype.startsWith && String.prototype.endsWith ) {\n\n      //\n      // __is.prefix( prefix , string )__\n      //\n      // Checks whether `string` starts with `prefix`.\n      //\n\n      util.addPredicate( 'prefix' , function isPrefix( prefix , string ) {\n        return getTag( string ) === 'string' && string.startsWith( prefix )\n      } )\n\n\n      //\n      // __is.suffix( suffix , string )__\n      //\n      // Checks whether `string` ends with `suffix`.\n      //\n\n      util.addPredicate( 'suffix' , function isSuffix( suffix , string ) {\n        return getTag( string ) === 'string' && string.endsWith( suffix )\n      } )\n\n    } else {\n\n      ( function ( makePredicate ) {\n\n        util.addPredicate( 'prefix' , makePredicate() )\n        util.addPredicate( 'suffix' , makePredicate( true ) )\n\n      } )( function makePredicate( suffix ) {\n\n        return function predicate( affix , string ) {\n\n          var index\n          var offset\n          var affixLength\n          var stringLength\n\n          if ( getTag( string ) !== 'string' ) {\n            return false\n          }\n\n          affix = String( affix )\n\n          affixLength = affix.length\n          stringLength = string.length\n\n          if ( affixLength > stringLength ) {\n            return false\n          }\n\n          offset = suffix ? stringLength - affixLength : 0\n\n          for ( index = 0 ; index < affixLength ; index += 1 ) {\n            if ( string.charCodeAt( offset + index ) !== affix.charCodeAt( index ) ) {\n              return false\n            }\n          }\n\n          return true\n\n        }\n\n      } )\n\n    }\n\n  } )\n\n\n  //\n  // ### bundle:boolean\n  //\n\n  is.use( function booleanBundle( util ) {\n\n    //\n    // __is.boolean( value )__\n    //\n    // Checks whether given value is a boolean.\n    //\n\n    util.addPredicate( 'boolean' , function isBoolean( value ) {\n      return value === true || value === false\n    } )\n\n  } )\n\n\n  //\n  // ### bundle:object\n  //\n\n  is.use( function objectBundle( util ) {\n\n    //\n    // __is.object( value )__\n    //\n    // Checks whether given value is an object.\n    //\n\n    util.addPredicate( 'object' , function isObject( value ) {\n      return is.not.primitive( value )\n    } )\n\n\n    //\n    // __is.emptyObject( object )__\n    //\n    // Checks whether given value is an empty object, i.e, an object without\n    // any own, enumerable, string keyed properties.\n    //\n\n    util.addPredicate( 'emptyObject' , function isEmptyObject( object ) {\n      return is.object( object ) && ownKeys( object ).length === 0\n    } )\n\n\n    //\n    // __is.propertyDefined( object , path )__\n    //\n    // Checks whether `path` is a direct or inherited property of `object`.\n    //\n\n    util.addPredicate( 'propertyDefined' , function isPropertyDefined( object , path ) {\n\n      var key\n      var keys\n      var context\n\n      context = object\n      keys = String( path ).split( '.' )\n\n      while ( key = keys.shift() ) { // eslint-disable-line no-cond-assign\n        if ( is.not.object( context ) || !( key in context ) ) {\n          return false\n        } else {\n          context = context[ key ]\n        }\n      }\n\n      return true\n\n    } )\n\n\n    //\n    // __is.conforms( object , schema , [strict=false] )__\n    //\n    // Checks whether `object` conforms to `schema`.\n    //\n    // A `schema` is an object whose properties are functions that takes\n    // these parameters(in order):\n    //\n    // - __value:any__ - The value of current iteration.\n    // - __key:string__ - The corresponding key of current iteration.\n    // - __context:object__ - The object in question.\n    //\n    // These functions, or _validators_, are called for each corresponding key\n    // in `object` to check whether object conforms to the schema. An object is\n    // said to be conforms to the schema if all validators passed.\n    //\n    // In strict mode(where `strict=true`), `is.conforms` also checks whether\n    // `object` and `schema` has the same set of own, enumerable, string-keyed\n    // properties, in addition to check whether all validators passed.\n    //\n\n    util.addPredicate( 'conforms' , function isConforms( object , schema , strict ) {\n\n      var key\n      var keys\n      var index\n      var length\n      var validator\n\n      if ( is.not.object( object ) || is.not.object( schema ) ) {\n        return false\n      }\n\n      keys = ownKeys( schema )\n      length = keys.length\n\n      if ( strict && length !== ownKeys( object ).length ) {\n        return false\n      }\n\n      for ( index = 0 ; index < length ; index += 1 ) {\n\n        key = keys[ index ]\n        validator = schema[ key ]\n\n        if ( typeof validator !== 'function' ) {\n          continue\n        }\n\n        if ( !hasOwnProperty.call( object , key ) ||\n             !validator( object[ key ] , key , object ) ) {\n          return false\n        }\n\n      }\n\n      return true\n\n    } )\n\n  } )\n\n\n  //\n  // ### bundle:array\n  //\n\n  is.use( function arrayBundle( util ) {\n\n    //\n    // __is.array( value )__\n    //\n    // Checks whether given value is an array.\n    //\n\n    if ( Array.isArray ) {\n      util.addPredicate( 'array' , Array.isArray )\n    } else {\n      util.addPredicate( 'array' , function isArray( value ) {\n        return getTag( value ) === 'array'\n      } )\n    }\n\n\n    //\n    // __is.arrayLikeObject( value )__\n    //\n    // Checks whether given value is an _array-like_ object.\n    //\n    // An object is qualified as _array-like_ if it has a property named\n    // `length` that is a positive safe integer. As a special case, functions\n    // are never qualified as _array-like_.\n    //\n\n    util.addPredicate( 'arrayLikeObject' , function isArrayLikeObject( value ) {\n\n      var length\n\n      if ( is.primitive( value ) || is[ 'function' ]( value ) ) {\n        return false\n      } else {\n        length = value.length\n        return is.integer( length ) && length >= 0 && length <= 0xFFFFFFFF // 32-bit unsigned int maximum\n      }\n\n    } )\n\n\n    //\n    // __is.inArray( value , array , [offset=0] , [comparator=is.equal] )__\n    //\n    // Checks whether given array or array-like object contains certain element.\n    //\n    // - __value__: The element to search.\n    // - __array__: The array or array-like object to search from.\n    // - __offset__: The index to search from, inclusive.\n    // - __comparator__: The comparator invoked per element against `value`.\n    //\n\n    util.addPredicate( 'inArray' , function isInArray( value , array , offset , comparator ) {\n\n      var index\n      var length\n\n      // Only works with genuine arrays or array-like objects.\n      if ( is.not.arrayLikeObject( array ) ) {\n        return false\n      }\n\n      if ( is[ 'function' ]( offset ) ) {\n        comparator = offset\n        offset = 0\n      } else {\n        offset = is.integer( offset ) ? offset : 0\n        comparator = is[ 'function' ]( comparator ) ? comparator : is.equal\n      }\n\n      length = array.length\n\n      // Allow negative offsets.\n      if ( offset < 0 ) {\n        offset = length + offset\n      }\n\n      if ( offset < 0 || offset >= length ) {\n        return false\n      }\n\n      for ( index = offset ; index < length ; index += 1 ) {\n\n        // Skip _holes_ in sparse arrays.\n        if ( !hasOwnProperty.call( array , index ) ) {\n          continue\n        }\n\n        if ( comparator( value , array[ index ] ) ) {\n          return true\n        }\n\n      }\n\n      return false\n\n    } )\n\n  } )\n\n\n  //\n  // ### bundle:type\n  //\n\n  is.use( function typeBundle( util ) {\n\n    //\n    // __is.sameType( value , other )__\n    //\n    // Checks whether given values are of the same type.\n    //\n\n    util.addPredicate( 'sameType' , function isSameType( value , other ) {\n      return typeof value === typeof other && getTag( value ) === getTag( other )\n    } )\n\n\n    //\n    // __is.primitive( value )__\n    //\n    // Checks whether given value is a primitive.\n    //\n\n    util.addPredicate( 'primitive' , function isPrimitive( value ) {\n      return is.nil( value ) ||\n             is.number( value ) ||\n             is.string( value ) ||\n             is.boolean( value ) ||\n             is.symbol( value )\n    } )\n\n\n    //\n    // Generate type check predicates for standard builtin classes.\n    //\n\n    ; ( function ( makePredicate , tags ) { // eslint-disable-line semi-spacing\n\n      var tag\n      var index\n      var length = tags.length\n\n      for ( index = 0 ; index < length ; index += 1 ) {\n        tag = tags[ index ]\n        util.addPredicate( tag , makePredicate( tag.toLowerCase() ) )\n      }\n\n    } )( function makePredicate( tag ) {\n\n      return function predicate( value ) {\n        return getTag( value ) === tag\n      }\n\n    } , [ 'date' , 'error' , 'function' , 'map' , 'regexp' , 'set' , 'symbol' ] )\n\n  } )\n\n\n  //\n  // ### bundle:equality\n  //\n\n  is.use( function equalityBundle( util ) {\n\n    //\n    // __is.equal( value , other )__\n    //\n    // Checks whether given values are equal, using _SameValueZero_ algorithm.\n    //\n\n    util.addPredicate( 'equal' , function isEqual( value , other ) {\n      return value === other || ( value !== value && other !== other ) // eslint-disable-line no-self-compare\n    } )\n\n\n    //\n    // __is.deepEqual( value , other )__\n    //\n    // Checks whether given values are deeply equal, i.e:\n    //\n    // - If `Type( value ) !== Type( other )`, returns `false`.\n    // - For primitives, checks whether they are equal using _SameValueZero_.\n    // - For arrays, checks whether they have same set of members, all of\n    //   which are deeply equal.\n    // - Otherwise, checks whether they have same set of own, enumerable, string\n    //   keyed properties, all of which are deeply equal.\n    //\n\n    util.addPredicate( 'deepEqual' , function isDeepEqual( value , other ) {\n\n      if ( is.not.sameType( value , other ) ) {\n        return false\n      }\n\n      if ( is.primitive( value ) ) {\n        return is.equal( value , other )\n      }\n\n      if ( is.array( value ) ) {\n\n        if ( value.length !== other.length ) {\n          return false\n        }\n\n        return ( function () {\n\n          var index\n          var length\n\n          for ( index = 0 , length = value.length ; index < length ; index += 1 ) {\n            if ( is.not.deepEqual( value[ index ] , other[ index ] ) ) {\n              return false\n            }\n          }\n\n          return true\n\n        } )()\n\n      }\n\n      return ( function () {\n\n        var key\n        var keys\n        var index\n        var length\n\n        keys = ownKeys( value )\n        length = keys.length\n\n        if ( length !== ownKeys( other ).length ) {\n          return false\n        }\n\n        for ( index = 0 ; index < length ; index += 1 ) {\n          key = keys[ index ]\n          if ( !hasOwnProperty.call( other , key ) ||\n               is.not.deepEqual( value[ key ] , other[ key ] ) ) {\n            return false\n          }\n        }\n\n        return true\n\n      } )()\n\n    } )\n\n  } )\n\n\n  return is\n\n} )\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0Bwd24vaXMvbGliL2lzLmpzP2Y3YTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVELFlBQVksU0FBUztBQUNyQjs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMkJBQTJCLGtCQUFrQjs7QUFFN0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUIsMEJBQTBCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUwsR0FBRzs7O0FBR0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVULE9BQU87QUFDUDs7QUFFQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7O0FBR0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUCxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMkJBQTJCLHNCQUFzQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQOztBQUVBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLGlCQUFpQjs7QUFFeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTCxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRCQUE0QixpQkFBaUI7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTs7QUFFQSxLQUFLLHNDQUFzQzs7QUFFM0M7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUwsR0FBRzs7O0FBR0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLG1EQUFtRCxpQkFBaUI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsaUJBQWlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQLEtBQUs7O0FBRUwsR0FBRzs7O0FBR0g7O0FBRUEsQ0FBQyIsImZpbGUiOiI4Mi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vXG4vLyAgICAgaXMuanMgLSAxLjAuMlxuLy8gICAgIE1pbmltYWxpc3RpYyBwcmVkaWNhdGUgbGlicmFyeVxuLy8gICAgIFB3biA8aGlAcHduLmJ1eno+XG4vL1xuXG4oIGZ1bmN0aW9uICggcm9vdCAsIGZhY3RvcnkgKSB7XG5cbiAgaWYgKCB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG5cbiAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG4gICAgZGVmaW5lKCBmYWN0b3J5IClcblxuICB9IGVsc2UgaWYgKCB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cyApIHtcblxuICAgIC8vIE5vZGUuIERvZXMgbm90IHdvcmsgd2l0aCBzdHJpY3QgQ29tbW9uSlMsIGJ1dCBvbmx5IENvbW1vbkpTLWxpa2VcbiAgICAvLyBlbnZpcm9ubWVudHMgdGhhdCBzdXBwb3J0IGBtb2R1bGUuZXhwb3J0c2AsIGxpa2UgTm9kZS5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKVxuXG4gIH0gZWxzZSB7XG5cbiAgICAvLyBCcm93c2VyIGdsb2JhbHNcbiAgICByb290LmlzID0gZmFjdG9yeSgpXG5cbiAgfVxuXG59ICkoIHRoaXMgLCBmdW5jdGlvbiBmYWN0b3J5KCkge1xuXG4gIHZhciBpcyA9IHsgbm90IDoge30gfVxuICB2YXIgdXRpbFxuXG4gIHZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcblxuXG4gIC8vXG4gIC8vIF9fZ2V0VGFnKCB2YWx1ZSApX19cbiAgLy9cbiAgLy8gR2V0IHRoZSBfW1tjbGFzc11dXyBhdHRyaWJ1dGUsIG9yIF90YWdfIGluIGBpcy5qc2AgdGVybWlub2xvZ3ksIG9mIGFueVxuICAvLyBnaXZlbiB2YWx1ZS5cbiAgLy9cblxuICB2YXIgZ2V0VGFnID0gKCBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgcmVTb3VyY2UgPSAvKD86ZnVuY3Rpb258Y2xhc3MpXFxzKihcXHcqKS9cblxuICAgIHZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbiAgICB2YXIgdG9Tb3VyY2UgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmdcblxuICAgIHJldHVybiBmdW5jdGlvbiB0YWdPZiggdmFsdWUgKSB7XG5cbiAgICAgIHZhciB0YWdGcm9tQ2xhc3NcbiAgICAgIHZhciB0YWdGcm9tU291cmNlXG5cbiAgICAgIGlmICggdmFsdWUgPT09IG51bGwgKSB7XG4gICAgICAgIHJldHVybiAnbnVsbCdcbiAgICAgIH0gZWxzZSBpZiAoIHZhbHVlID09PSB2b2lkIDAgKSB7XG4gICAgICAgIHJldHVybiAndW5kZWZpbmVkJ1xuICAgICAgfVxuXG4gICAgICB0YWdGcm9tQ2xhc3MgPSB0b1N0cmluZy5jYWxsKCB2YWx1ZSApXG4gICAgICB0YWdGcm9tQ2xhc3MgPSB0YWdGcm9tQ2xhc3Muc3Vic3RyaW5nKCA4ICwgdGFnRnJvbUNsYXNzLmxlbmd0aCAtIDEgKVxuXG4gICAgICBpZiAoIHR5cGVvZiB2YWx1ZS5jb25zdHJ1Y3RvciAhPT0gJ2Z1bmN0aW9uJyApIHtcbiAgICAgICAgcmV0dXJuIHRhZ0Zyb21DbGFzcy50b0xvd2VyQ2FzZSgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YWdGcm9tU291cmNlID0gdG9Tb3VyY2UuY2FsbCggdmFsdWUuY29uc3RydWN0b3IgKS5tYXRjaCggcmVTb3VyY2UgKVsgMSBdXG4gICAgICAgIHJldHVybiAoIHRhZ0Zyb21Tb3VyY2UgfHwgdGFnRnJvbUNsYXNzICkudG9Mb3dlckNhc2UoKVxuICAgICAgfVxuXG4gICAgfVxuXG4gIH0gKSgpXG5cblxuICAvL1xuICAvLyBfX293bktleXMoIHZhbHVlIClfX1xuICAvL1xuICAvLyBgT2JqZWN0LmtleXNgIHBvbnlmaWxsLlxuICAvL1xuXG4gIHZhciBvd25LZXlzID0gT2JqZWN0LmtleXMgfHwgKCBmdW5jdGlvbiAoIGRvbnRFbnVtcyApIHtcblxuICAgIHZhciBkb250RW51bXNMZW5ndGggPSBkb250RW51bXMubGVuZ3RoXG4gICAgdmFyIGhhc0RvbnRFbnVtQnVnID0gIXsgdG9TdHJpbmcgOiBudWxsIH0ucHJvcGVydHlJc0VudW1lcmFibGUoICd0b1N0cmluZycgKVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG93bktleXMoIG9iamVjdCApIHtcblxuICAgICAgdmFyIGtleVxuICAgICAgdmFyIGtleXMgPSBbXVxuICAgICAgdmFyIGluZGV4XG5cbiAgICAgIGlmICggb2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwICkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCAnb3duS2V5cyBjYWxsZWQgb24gbm9uLW9iamVjdCcgKVxuICAgICAgfVxuXG4gICAgICBmb3IgKCBrZXkgaW4gb2JqZWN0ICkge1xuICAgICAgICBpZiAoIGhhc093blByb3BlcnR5LmNhbGwoIG9iamVjdCAsIGtleSApICkge1xuICAgICAgICAgIGtleXMucHVzaCgga2V5IClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBGaXggSUUgPCA5IF9KU2NyaXB0IERvbnRFbnVtIEJ1Z18uXG4gICAgICBpZiAoIGhhc0RvbnRFbnVtQnVnICkge1xuICAgICAgICBmb3IgKCBpbmRleCA9IDAgOyBpbmRleCA8IGRvbnRFbnVtc0xlbmd0aCA7IGluZGV4ICs9IDEgKSB7XG4gICAgICAgICAga2V5ID0gZG9udEVudW1zWyBpbmRleCBdXG4gICAgICAgICAgaWYgKCBoYXNPd25Qcm9wZXJ0eS5jYWxsKCBvYmplY3QgLCBrZXkgKSApIHtcbiAgICAgICAgICAgIGtleXMucHVzaCgga2V5IClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGtleXNcblxuICAgIH1cblxuICB9ICkoIFtcblxuICAgIC8vIFRoZXNlIHByb3BlcnRpZXMgYXJlIG1hcmtlZCBhcyBfRG9udEVudW1fIGluIElFIDwgOS5cbiAgICAvLyBUaGV5IHdpbGwgbmV2ZXIgc2hvdyB1cCBpbiBgZm9yLi4uaW5gIGxvb3BzIG5vciBwYXNzXG4gICAgLy8gYHByb3BlcnR5SXNFbnVtZXJhYmxlYCBjaGVjay5cbiAgICAndG9TdHJpbmcnICxcbiAgICAndG9Mb2NhbGVTdHJpbmcnICxcbiAgICAndmFsdWVPZicgLFxuICAgICdpc1Byb3RvdHlwZU9mJyAsXG4gICAgJ2hhc093blByb3BlcnR5JyAsXG4gICAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJyAsXG4gICAgJ2NvbnN0cnVjdG9yJ1xuXG4gIF0gKVxuXG5cbiAgdXRpbCA9IHtcblxuICAgIC8vXG4gICAgLy8gX191dGlsLmFkZFByZWRpY2F0ZSggbmFtZSAsIHByZWRpY2F0ZSApX19cbiAgICAvL1xuICAgIC8vIEFkZCBuZXcgY2hlY2tzKG9yIF9wcmVkaWNhdGVzXyBpbiBgaXMuanNgIHRlcm1pbm9sb2d5KS5cbiAgICAvL1xuXG4gICAgYWRkUHJlZGljYXRlIDogZnVuY3Rpb24gYWRkUHJlZGljYXRlKCBuYW1lICwgcHJlZGljYXRlICkge1xuXG4gICAgICBpZiAoIC9eKG5vdHx1c2UpJC8udGVzdCggbmFtZSApICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoICdcIicgKyBuYW1lICsgJ1wiIGlzIGEgcmVzZXJ2ZWQgbmFtZScgKVxuICAgICAgfVxuXG4gICAgICBpZiAoIGhhc093blByb3BlcnR5LmNhbGwoIGlzICwgbmFtZSApICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoICdwcmVkaWNhdGUgXCInICsgbmFtZSArICdcIiBhbHJlYWR5IGRlZmluZWQnIClcbiAgICAgIH1cblxuICAgICAgaWYgKCB0eXBlb2YgcHJlZGljYXRlICE9PSAnZnVuY3Rpb24nICkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCAncHJlZGljYXRlIG11c3QgYmUgYSBmdW5jdGlvbicgKVxuICAgICAgfVxuXG4gICAgICBpc1sgbmFtZSBdID0gcHJlZGljYXRlXG4gICAgICBpcy5ub3RbIG5hbWUgXSA9IGZ1bmN0aW9uIGRlbGVnYXRlKCkge1xuICAgICAgICByZXR1cm4gIXByZWRpY2F0ZS5hcHBseSggbnVsbCAsIGFyZ3VtZW50cyApXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfVxuXG5cbiAgLy9cbiAgLy8gX19pcy51c2UoIGJ1bmRsZSApX19cbiAgLy9cbiAgLy8gRGVmaW5lIG5ldyBfYnVuZGxlc18oY29sbGVjdGlvbiBvZiByZWxhdGVkIF9wcmVkaWNhdGVzXykuXG4gIC8vXG5cbiAgaXMudXNlID0gZnVuY3Rpb24gdXNlKCBidW5kbGUgKSB7XG5cbiAgICBpZiAoIHR5cGVvZiBidW5kbGUgPT09ICdmdW5jdGlvbicgKSB7XG5cbiAgICAgIC8vXG4gICAgICAvLyBgYnVuZGxlYCB0YWtlcyB0d28gcGFyYW1ldGVycyhvcmRlciBtYXR0ZXJzKTpcbiAgICAgIC8vXG4gICAgICAvLyAgICAtIGB1dGlsYDogVGhlIHV0aWxpdHkgb2JqZWN0LlxuICAgICAgLy8gICAgLSBgaXNgOiBUaGUgYGlzYCBleHBvcnQuXG4gICAgICAvL1xuICAgICAgLy8gVGhlIGB1dGlsYCBhbmQgYGlzYCBleHBvcnQgaXMgcGFzc2VkIGluIGFzIGZyZWUgdmFyaWFibGVzIHNvIHRoYXQgb25lXG4gICAgICAvLyBjYW4gd3JpdGUgc3RhbmRhbG9uZSBidW5kbGVzIHdpdGhvdXQgcmVmZXJlbmNpbmcgYGlzLmpzYCBmaXJzdC5cbiAgICAgIC8vXG4gICAgICAvLyAgICBgYGBqc1xuICAgICAgLy8gICAgLy8gc3RhbmRhbG9uZSBidW5kbGUsIGRvZXMgbm90IGRlcGVuZCBvbiBgaXMuanNgXG4gICAgICAvLyAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJ1bmRsZSggdXRpbCAsIGlzICkge1xuICAgICAgLy8gICAgICB1dGlsLmFkZFByZWRpY2F0ZSggJ2VxJyAsIGZ1bmN0aW9uICggdmFsdWUgLCBvdGhlciApIHtcbiAgICAgIC8vICAgICAgICBpZiAoIGlzLm5vdC5vYmplY3QoIHZhbHVlICkgfHwgaXMubm90Lm9iamVjdCggb3RoZXIgKSApIHtcbiAgICAgIC8vICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgLy8gICAgICAgIH1cbiAgICAgIC8vICAgICAgICByZXR1cm4gdmFsdWUudXVpZCA9IG90aGVyLnV1aWRcbiAgICAgIC8vICAgICAgfSApXG4gICAgICAvLyAgICB9XG4gICAgICAvLyAgICBgYGBcbiAgICAgIC8vXG4gICAgICAvLyBUbyBpbXBvcnQgdGhlIGJ1bmRsZTpcbiAgICAgIC8vXG4gICAgICAvLyAgICBgYGBqc1xuICAgICAgLy8gICAgaXMudXNlKCByZXF1aXJlKCAncGF0aC90by9idW5kbGUnICkgKVxuICAgICAgLy8gICAgYGBgXG4gICAgICAvL1xuXG4gICAgICBidW5kbGUoIHV0aWwgLCBpcyApXG5cbiAgICB9XG5cbiAgfVxuXG5cbiAgLy9cbiAgLy8gIyBDT1JFIEJVTkRMRVNcbiAgLy8gUHJlZGljYXRlcyBzaGlwcGVkIHdpdGggYGlzLmpzYCwgcGFja2FnZWQgaW4gdmFyaW91cyBidW5kbGVzLlxuICAvL1xuXG5cbiAgLy9cbiAgLy8gIyMjIGJ1bmRsZTpuaWxcbiAgLy9cblxuICBpcy51c2UoIGZ1bmN0aW9uIG5pbEJ1bmRsZSggdXRpbCApIHtcblxuICAgIC8vXG4gICAgLy8gX19pcy5udWxsKCB2YWx1ZSApX19cbiAgICAvL1xuICAgIC8vIENoZWNrcyB3aGV0aGVyIGdpdmVuIHZhbHVlIGlzIGBudWxsYC5cbiAgICAvL1xuXG4gICAgdXRpbC5hZGRQcmVkaWNhdGUoICdudWxsJyAsIGZ1bmN0aW9uIGlzTnVsbCggdmFsdWUgKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGxcbiAgICB9IClcblxuXG4gICAgLy9cbiAgICAvLyBfX2lzLnVuZGVmaW5lZCggdmFsdWUgKV9fXG4gICAgLy9cbiAgICAvLyBDaGVja3Mgd2hldGhlciBnaXZlbiB2YWx1ZSBpcyBgdW5kZWZpbmVkYC5cbiAgICAvL1xuXG4gICAgdXRpbC5hZGRQcmVkaWNhdGUoICd1bmRlZmluZWQnICwgZnVuY3Rpb24gaXNVbmRlZmluZWQoIHZhbHVlICkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSB2b2lkIDBcbiAgICB9IClcblxuXG4gICAgLy9cbiAgICAvLyBfX2lzLmV4aXN0KCB2YWx1ZSApX19cbiAgICAvL1xuICAgIC8vIENoZWNrcyB3aGV0aGVyIGdpdmVuIHZhbHVlIGV4aXN0cywgaS5lLCBub3QgYG51bGxgIG5vciBgdW5kZWZpbmVkYC5cbiAgICAvL1xuXG4gICAgdXRpbC5hZGRQcmVkaWNhdGUoICdleGlzdCcgLCBmdW5jdGlvbiBpc0V4aXN0KCB2YWx1ZSApIHtcbiAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXEtbnVsbFxuICAgIH0gKVxuXG5cbiAgICAvL1xuICAgIC8vIF9faXMubmlsKCB2YWx1ZSApX19cbiAgICAvL1xuICAgIC8vIENoZWNrcyB3aGV0aGVyIGdpdmVuIHZhbHVlIGlzIGVpdGhlciBgbnVsbGAgb3IgYHVuZGVmaW5lZGAuXG4gICAgLy9cblxuICAgIHV0aWwuYWRkUHJlZGljYXRlKCAnbmlsJyAsIGZ1bmN0aW9uIGlzTmlsKCB2YWx1ZSApIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PSBudWxsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXEtbnVsbFxuICAgIH0gKVxuXG4gIH0gKVxuXG5cbiAgLy9cbiAgLy8gIyMjIGJ1bmRsZTpudW1iZXJcbiAgLy9cblxuICBpcy51c2UoIGZ1bmN0aW9uIG51bWJlckJ1bmRsZSggdXRpbCApIHtcblxuICAgIC8vXG4gICAgLy8gX19pcy5udW1iZXIoIHZhbHVlIClfX1xuICAgIC8vXG4gICAgLy8gQ2hlY2tzIHdoZXRoZXIgZ2l2ZW4gdmFsdWUgaXMgYSBudW1iZXIuXG4gICAgLy9cblxuICAgIHV0aWwuYWRkUHJlZGljYXRlKCAnbnVtYmVyJyAsIGZ1bmN0aW9uIGlzTnVtYmVyKCB2YWx1ZSApIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInXG4gICAgfSApXG5cblxuICAgIC8vXG4gICAgLy8gX19pcy5udW1lcmFsKCB2YWx1ZSApX19cbiAgICAvL1xuICAgIC8vIENoZWNrcyB3aGV0aGVyIGdpdmVuIHZhbHVlIGlzIGEgbnVtZXJhbCwgaS5lOlxuICAgIC8vXG4gICAgLy8gLSBhIGdlbnVpbmUgZmluaXRlIG51bWJlclxuICAgIC8vIC0gb3IgYSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIGEgZmluaXRlIG51bWJlclxuICAgIC8vXG5cbiAgICB1dGlsLmFkZFByZWRpY2F0ZSggJ251bWVyYWwnICwgZnVuY3Rpb24gaXNOdW1lcmFsKCB2YWx1ZSApIHtcblxuICAgICAgdmFyIHRhZyA9IGdldFRhZyggdmFsdWUgKVxuICAgICAgaWYgKCB0YWcgIT09ICdudW1iZXInICYmIHRhZyAhPT0gJ3N0cmluZycgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICBpZiAoIGlzLmVtcHR5U3RyaW5nKCB2YWx1ZSApICkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFsdWUgPSBOdW1iZXIoIHZhbHVlIClcbiAgICAgIH0gY2F0Y2ggKCBlcnJvciApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpcy5maW5pdGUoIHZhbHVlIClcblxuICAgIH0gKVxuXG5cbiAgICAvL1xuICAgIC8vIF9faXMubmFuKCB2YWx1ZSApX19cbiAgICAvL1xuICAgIC8vIENoZWNrcyB3aGV0aGVyIGdpdmVuIHZhbHVlIGlzIGBOYU5gLlxuICAgIC8vXG5cbiAgICB1dGlsLmFkZFByZWRpY2F0ZSggJ25hbicgLCBmdW5jdGlvbiBpc05hTiggdmFsdWUgKSB7XG4gICAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgfSApXG5cblxuICAgIC8vXG4gICAgLy8gX19pcy5vZGQoIG51bWJlciApX19cbiAgICAvL1xuICAgIC8vIENoZWNrcyB3aGV0aGVyIGdpdmVuIHZhbHVlIGlzIGFuIG9kZCBudW1iZXIuXG4gICAgLy9cblxuICAgIHV0aWwuYWRkUHJlZGljYXRlKCAnb2RkJyAsIGZ1bmN0aW9uIGlzT2RkKCBudW1iZXIgKSB7XG4gICAgICByZXR1cm4gaXMuaW50ZWdlciggbnVtYmVyICkgJiYgbnVtYmVyICUgMiA9PT0gMVxuICAgIH0gKVxuXG5cbiAgICAvL1xuICAgIC8vIF9faXMuZXZlbiggbnVtYmVyIClfX1xuICAgIC8vXG4gICAgLy8gQ2hlY2tzIHdoZXRoZXIgZ2l2ZW4gdmFsdWUgaXMgYW4gZXZlbiBudW1iZXIuXG4gICAgLy9cblxuICAgIHV0aWwuYWRkUHJlZGljYXRlKCAnZXZlbicgLCBmdW5jdGlvbiBpc0V2ZW4oIG51bWJlciApIHtcbiAgICAgIHJldHVybiBpcy5pbnRlZ2VyKCBudW1iZXIgKSAmJiBudW1iZXIgJSAyID09PSAwXG4gICAgfSApXG5cblxuICAgIC8vXG4gICAgLy8gX19pcy5maW5pdGUoIG51bWJlciApX19cbiAgICAvL1xuICAgIC8vIENoZWNrcyB3aGV0aGVyIGdpdmVuIHZhbHVlIGlzIGEgZmluaXRlIG51bWJlci5cbiAgICAvL1xuXG4gICAgaWYgKCBOdW1iZXIuaXNGaW5pdGUgKSB7XG4gICAgICB1dGlsLmFkZFByZWRpY2F0ZSggJ2Zpbml0ZScgLCBOdW1iZXIuaXNGaW5pdGUgKVxuICAgIH0gZWxzZSB7XG4gICAgICB1dGlsLmFkZFByZWRpY2F0ZSggJ2Zpbml0ZScgLCBmdW5jdGlvbiBpc0Zpbml0ZU51bWJlciggbnVtYmVyICkge1xuICAgICAgICByZXR1cm4gaXMubnVtYmVyKCBudW1iZXIgKSAmJiBpc0Zpbml0ZSggbnVtYmVyIClcbiAgICAgIH0gKVxuICAgIH1cblxuXG4gICAgLy9cbiAgICAvLyBfX2lzLmluZmluaXRlKCBudW1iZXIgKV9fXG4gICAgLy9cbiAgICAvLyBDaGVja3Mgd2hldGhlciBnaXZlbiB2YWx1ZSBpcyBhbiBpbmZpbml0ZSBudW1iZXIsIGkuZTogK+KIniBvciAt4oieLlxuICAgIC8vXG5cbiAgICB1dGlsLmFkZFByZWRpY2F0ZSggJ2luZmluaXRlJyAsIGZ1bmN0aW9uIGlzSW5maW5pdGUoIG51bWJlciApIHtcbiAgICAgIHJldHVybiBudW1iZXIgPT09ICsxIC8gMCB8fCBudW1iZXIgPT09IC0xIC8gMFxuICAgIH0gKVxuXG5cbiAgICAvL1xuICAgIC8vIF9faXMuaW50ZWdlciggbnVtYmVyIClfX1xuICAgIC8vXG4gICAgLy8gQ2hlY2tzIHdoZXRoZXIgZ2l2ZW4gdmFsdWUgaXMgYW4gaW50ZWdlci5cbiAgICAvL1xuXG4gICAgaWYgKCBOdW1iZXIuaXNJbnRlZ2VyICkge1xuICAgICAgdXRpbC5hZGRQcmVkaWNhdGUoICdpbnRlZ2VyJyAsIE51bWJlci5pc0ludGVnZXIgKVxuICAgIH0gZWxzZSB7XG4gICAgICB1dGlsLmFkZFByZWRpY2F0ZSggJ2ludGVnZXInICwgZnVuY3Rpb24gaXNJbnRlZ2VyKCBudW1iZXIgKSB7XG4gICAgICAgIHJldHVybiBpcy5maW5pdGUoIG51bWJlciApICYmIE1hdGguZmxvb3IoIG51bWJlciApID09PSBudW1iZXJcbiAgICAgIH0gKVxuICAgIH1cblxuXG4gICAgLy9cbiAgICAvLyBfX2lzLnNhZmVJbnRlZ2VyKCBudW1iZXIgKV9fXG4gICAgLy9cbiAgICAvLyBDaGVja3Mgd2hldGhlciBnaXZlbiB2YWx1ZSBpcyBhIHNhZmUgaW50ZWdlci5cbiAgICAvL1xuXG4gICAgaWYgKCBOdW1iZXIuaXNTYWZlSW50ZWdlciApIHtcbiAgICAgIHV0aWwuYWRkUHJlZGljYXRlKCAnc2FmZUludGVnZXInICwgTnVtYmVyLmlzU2FmZUludGVnZXIgKVxuICAgIH0gZWxzZSB7XG4gICAgICAoIGZ1bmN0aW9uICgpIHtcblxuICAgICAgICB2YXIgTUFYID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgTWF0aC5wb3coIDIgLCA1MyApIC0gMVxuICAgICAgICB2YXIgTUlOID0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIgfHwgLU1BWFxuXG4gICAgICAgIHV0aWwuYWRkUHJlZGljYXRlKCAnc2FmZUludGVnZXInICwgZnVuY3Rpb24gaXNTYWZlSW50ZWdlciggbnVtYmVyICkge1xuICAgICAgICAgIHJldHVybiBpcy5pbnRlZ2VyKCBudW1iZXIgKSAmJiAoIG51bWJlciA+PSBNSU4gJiYgbnVtYmVyIDw9IE1BWCApXG4gICAgICAgIH0gKVxuXG4gICAgICB9ICkoKVxuICAgIH1cblxuICB9IClcblxuXG4gIC8vXG4gIC8vICMjIyBidW5kbGU6c3RyaW5nXG4gIC8vXG5cbiAgaXMudXNlKCBmdW5jdGlvbiBzdHJpbmdCdW5kbGUoIHV0aWwgKSB7XG5cbiAgICAvL1xuICAgIC8vIF9faXMuc3RyaW5nKCB2YWx1ZSApX19cbiAgICAvL1xuICAgIC8vIENoZWNrcyB3aGV0aGVyIGdpdmVuIHZhbHVlIGlzIGEgc3RyaW5nLlxuICAgIC8vXG5cbiAgICB1dGlsLmFkZFByZWRpY2F0ZSggJ3N0cmluZycgLCBmdW5jdGlvbiBpc1N0cmluZyggdmFsdWUgKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJ1xuICAgIH0gKVxuXG5cbiAgICAvL1xuICAgIC8vIF9faXMuZW1wdHlTdHJpbmcoIHN0cmluZyApX19cbiAgICAvL1xuICAgIC8vIENoZWNrcyB3aGV0aGVyIGdpdmVuIHZhbHVlIGlzIGFuIGVtcHR5IHN0cmluZywgaS5lLCBhIHN0cmluZyB3aXRoIHdoaXRlc3BhY2UgY2hhcmFjdGVycyBvbmx5LlxuICAgIC8vXG5cbiAgICB1dGlsLmFkZFByZWRpY2F0ZSggJ2VtcHR5U3RyaW5nJyAsIGZ1bmN0aW9uIGlzRW1wdHlTdHJpbmcoIHN0cmluZyApIHtcbiAgICAgIHJldHVybiBpcy5zdHJpbmcoIHN0cmluZyApICYmIC9eXFxzKiQvLnRlc3QoIHN0cmluZyApXG4gICAgfSApXG5cblxuICAgIC8vXG4gICAgLy8gX19pcy5zdWJzdHJpbmcoIHN1YnN0cmluZyAsIHN0cmluZyAsIFtvZmZzZXQ9MF0gKV9fXG4gICAgLy9cbiAgICAvLyBDaGVja3Mgd2hldGhlciBvbmUgc3RyaW5nIG1heSBiZSBmb3VuZCB3aXRoaW4gYW5vdGhlciBzdHJpbmcuXG4gICAgLy9cblxuICAgIHV0aWwuYWRkUHJlZGljYXRlKCAnc3Vic3RyaW5nJyAsIGZ1bmN0aW9uIGlzU3Vic3RyaW5nKCBzdWJzdHJpbmcgLCBzdHJpbmcgLCBvZmZzZXQgKSB7XG5cbiAgICAgIHZhciBsZW5ndGhcblxuICAgICAgaWYgKCBnZXRUYWcoIHN0cmluZyApICE9PSAnc3RyaW5nJyApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgICAgIG9mZnNldCA9IGlzLmludGVnZXIoIG9mZnNldCApID8gb2Zmc2V0IDogMFxuXG4gICAgICAvLyBBbGxvdyBuZWdhdGl2ZSBvZmZzZXRzLlxuICAgICAgaWYgKCBvZmZzZXQgPCAwICkge1xuICAgICAgICBvZmZzZXQgPSBsZW5ndGggKyBvZmZzZXRcbiAgICAgIH1cblxuICAgICAgaWYgKCBvZmZzZXQgPCAwIHx8IG9mZnNldCA+PSBsZW5ndGggKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RyaW5nLmluZGV4T2YoIHN1YnN0cmluZyAsIG9mZnNldCApICE9PSAtMVxuXG4gICAgfSApXG5cblxuICAgIGlmICggU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoICYmIFN0cmluZy5wcm90b3R5cGUuZW5kc1dpdGggKSB7XG5cbiAgICAgIC8vXG4gICAgICAvLyBfX2lzLnByZWZpeCggcHJlZml4ICwgc3RyaW5nIClfX1xuICAgICAgLy9cbiAgICAgIC8vIENoZWNrcyB3aGV0aGVyIGBzdHJpbmdgIHN0YXJ0cyB3aXRoIGBwcmVmaXhgLlxuICAgICAgLy9cblxuICAgICAgdXRpbC5hZGRQcmVkaWNhdGUoICdwcmVmaXgnICwgZnVuY3Rpb24gaXNQcmVmaXgoIHByZWZpeCAsIHN0cmluZyApIHtcbiAgICAgICAgcmV0dXJuIGdldFRhZyggc3RyaW5nICkgPT09ICdzdHJpbmcnICYmIHN0cmluZy5zdGFydHNXaXRoKCBwcmVmaXggKVxuICAgICAgfSApXG5cblxuICAgICAgLy9cbiAgICAgIC8vIF9faXMuc3VmZml4KCBzdWZmaXggLCBzdHJpbmcgKV9fXG4gICAgICAvL1xuICAgICAgLy8gQ2hlY2tzIHdoZXRoZXIgYHN0cmluZ2AgZW5kcyB3aXRoIGBzdWZmaXhgLlxuICAgICAgLy9cblxuICAgICAgdXRpbC5hZGRQcmVkaWNhdGUoICdzdWZmaXgnICwgZnVuY3Rpb24gaXNTdWZmaXgoIHN1ZmZpeCAsIHN0cmluZyApIHtcbiAgICAgICAgcmV0dXJuIGdldFRhZyggc3RyaW5nICkgPT09ICdzdHJpbmcnICYmIHN0cmluZy5lbmRzV2l0aCggc3VmZml4IClcbiAgICAgIH0gKVxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgKCBmdW5jdGlvbiAoIG1ha2VQcmVkaWNhdGUgKSB7XG5cbiAgICAgICAgdXRpbC5hZGRQcmVkaWNhdGUoICdwcmVmaXgnICwgbWFrZVByZWRpY2F0ZSgpIClcbiAgICAgICAgdXRpbC5hZGRQcmVkaWNhdGUoICdzdWZmaXgnICwgbWFrZVByZWRpY2F0ZSggdHJ1ZSApIClcblxuICAgICAgfSApKCBmdW5jdGlvbiBtYWtlUHJlZGljYXRlKCBzdWZmaXggKSB7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHByZWRpY2F0ZSggYWZmaXggLCBzdHJpbmcgKSB7XG5cbiAgICAgICAgICB2YXIgaW5kZXhcbiAgICAgICAgICB2YXIgb2Zmc2V0XG4gICAgICAgICAgdmFyIGFmZml4TGVuZ3RoXG4gICAgICAgICAgdmFyIHN0cmluZ0xlbmd0aFxuXG4gICAgICAgICAgaWYgKCBnZXRUYWcoIHN0cmluZyApICE9PSAnc3RyaW5nJyApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGFmZml4ID0gU3RyaW5nKCBhZmZpeCApXG5cbiAgICAgICAgICBhZmZpeExlbmd0aCA9IGFmZml4Lmxlbmd0aFxuICAgICAgICAgIHN0cmluZ0xlbmd0aCA9IHN0cmluZy5sZW5ndGhcblxuICAgICAgICAgIGlmICggYWZmaXhMZW5ndGggPiBzdHJpbmdMZW5ndGggKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvZmZzZXQgPSBzdWZmaXggPyBzdHJpbmdMZW5ndGggLSBhZmZpeExlbmd0aCA6IDBcblxuICAgICAgICAgIGZvciAoIGluZGV4ID0gMCA7IGluZGV4IDwgYWZmaXhMZW5ndGggOyBpbmRleCArPSAxICkge1xuICAgICAgICAgICAgaWYgKCBzdHJpbmcuY2hhckNvZGVBdCggb2Zmc2V0ICsgaW5kZXggKSAhPT0gYWZmaXguY2hhckNvZGVBdCggaW5kZXggKSApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRydWVcblxuICAgICAgICB9XG5cbiAgICAgIH0gKVxuXG4gICAgfVxuXG4gIH0gKVxuXG5cbiAgLy9cbiAgLy8gIyMjIGJ1bmRsZTpib29sZWFuXG4gIC8vXG5cbiAgaXMudXNlKCBmdW5jdGlvbiBib29sZWFuQnVuZGxlKCB1dGlsICkge1xuXG4gICAgLy9cbiAgICAvLyBfX2lzLmJvb2xlYW4oIHZhbHVlIClfX1xuICAgIC8vXG4gICAgLy8gQ2hlY2tzIHdoZXRoZXIgZ2l2ZW4gdmFsdWUgaXMgYSBib29sZWFuLlxuICAgIC8vXG5cbiAgICB1dGlsLmFkZFByZWRpY2F0ZSggJ2Jvb2xlYW4nICwgZnVuY3Rpb24gaXNCb29sZWFuKCB2YWx1ZSApIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2VcbiAgICB9IClcblxuICB9IClcblxuXG4gIC8vXG4gIC8vICMjIyBidW5kbGU6b2JqZWN0XG4gIC8vXG5cbiAgaXMudXNlKCBmdW5jdGlvbiBvYmplY3RCdW5kbGUoIHV0aWwgKSB7XG5cbiAgICAvL1xuICAgIC8vIF9faXMub2JqZWN0KCB2YWx1ZSApX19cbiAgICAvL1xuICAgIC8vIENoZWNrcyB3aGV0aGVyIGdpdmVuIHZhbHVlIGlzIGFuIG9iamVjdC5cbiAgICAvL1xuXG4gICAgdXRpbC5hZGRQcmVkaWNhdGUoICdvYmplY3QnICwgZnVuY3Rpb24gaXNPYmplY3QoIHZhbHVlICkge1xuICAgICAgcmV0dXJuIGlzLm5vdC5wcmltaXRpdmUoIHZhbHVlIClcbiAgICB9IClcblxuXG4gICAgLy9cbiAgICAvLyBfX2lzLmVtcHR5T2JqZWN0KCBvYmplY3QgKV9fXG4gICAgLy9cbiAgICAvLyBDaGVja3Mgd2hldGhlciBnaXZlbiB2YWx1ZSBpcyBhbiBlbXB0eSBvYmplY3QsIGkuZSwgYW4gb2JqZWN0IHdpdGhvdXRcbiAgICAvLyBhbnkgb3duLCBlbnVtZXJhYmxlLCBzdHJpbmcga2V5ZWQgcHJvcGVydGllcy5cbiAgICAvL1xuXG4gICAgdXRpbC5hZGRQcmVkaWNhdGUoICdlbXB0eU9iamVjdCcgLCBmdW5jdGlvbiBpc0VtcHR5T2JqZWN0KCBvYmplY3QgKSB7XG4gICAgICByZXR1cm4gaXMub2JqZWN0KCBvYmplY3QgKSAmJiBvd25LZXlzKCBvYmplY3QgKS5sZW5ndGggPT09IDBcbiAgICB9IClcblxuXG4gICAgLy9cbiAgICAvLyBfX2lzLnByb3BlcnR5RGVmaW5lZCggb2JqZWN0ICwgcGF0aCApX19cbiAgICAvL1xuICAgIC8vIENoZWNrcyB3aGV0aGVyIGBwYXRoYCBpcyBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAuXG4gICAgLy9cblxuICAgIHV0aWwuYWRkUHJlZGljYXRlKCAncHJvcGVydHlEZWZpbmVkJyAsIGZ1bmN0aW9uIGlzUHJvcGVydHlEZWZpbmVkKCBvYmplY3QgLCBwYXRoICkge1xuXG4gICAgICB2YXIga2V5XG4gICAgICB2YXIga2V5c1xuICAgICAgdmFyIGNvbnRleHRcblxuICAgICAgY29udGV4dCA9IG9iamVjdFxuICAgICAga2V5cyA9IFN0cmluZyggcGF0aCApLnNwbGl0KCAnLicgKVxuXG4gICAgICB3aGlsZSAoIGtleSA9IGtleXMuc2hpZnQoKSApIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25kLWFzc2lnblxuICAgICAgICBpZiAoIGlzLm5vdC5vYmplY3QoIGNvbnRleHQgKSB8fCAhKCBrZXkgaW4gY29udGV4dCApICkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0WyBrZXkgXVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlXG5cbiAgICB9IClcblxuXG4gICAgLy9cbiAgICAvLyBfX2lzLmNvbmZvcm1zKCBvYmplY3QgLCBzY2hlbWEgLCBbc3RyaWN0PWZhbHNlXSApX19cbiAgICAvL1xuICAgIC8vIENoZWNrcyB3aGV0aGVyIGBvYmplY3RgIGNvbmZvcm1zIHRvIGBzY2hlbWFgLlxuICAgIC8vXG4gICAgLy8gQSBgc2NoZW1hYCBpcyBhbiBvYmplY3Qgd2hvc2UgcHJvcGVydGllcyBhcmUgZnVuY3Rpb25zIHRoYXQgdGFrZXNcbiAgICAvLyB0aGVzZSBwYXJhbWV0ZXJzKGluIG9yZGVyKTpcbiAgICAvL1xuICAgIC8vIC0gX192YWx1ZTphbnlfXyAtIFRoZSB2YWx1ZSBvZiBjdXJyZW50IGl0ZXJhdGlvbi5cbiAgICAvLyAtIF9fa2V5OnN0cmluZ19fIC0gVGhlIGNvcnJlc3BvbmRpbmcga2V5IG9mIGN1cnJlbnQgaXRlcmF0aW9uLlxuICAgIC8vIC0gX19jb250ZXh0Om9iamVjdF9fIC0gVGhlIG9iamVjdCBpbiBxdWVzdGlvbi5cbiAgICAvL1xuICAgIC8vIFRoZXNlIGZ1bmN0aW9ucywgb3IgX3ZhbGlkYXRvcnNfLCBhcmUgY2FsbGVkIGZvciBlYWNoIGNvcnJlc3BvbmRpbmcga2V5XG4gICAgLy8gaW4gYG9iamVjdGAgdG8gY2hlY2sgd2hldGhlciBvYmplY3QgY29uZm9ybXMgdG8gdGhlIHNjaGVtYS4gQW4gb2JqZWN0IGlzXG4gICAgLy8gc2FpZCB0byBiZSBjb25mb3JtcyB0byB0aGUgc2NoZW1hIGlmIGFsbCB2YWxpZGF0b3JzIHBhc3NlZC5cbiAgICAvL1xuICAgIC8vIEluIHN0cmljdCBtb2RlKHdoZXJlIGBzdHJpY3Q9dHJ1ZWApLCBgaXMuY29uZm9ybXNgIGFsc28gY2hlY2tzIHdoZXRoZXJcbiAgICAvLyBgb2JqZWN0YCBhbmQgYHNjaGVtYWAgaGFzIHRoZSBzYW1lIHNldCBvZiBvd24sIGVudW1lcmFibGUsIHN0cmluZy1rZXllZFxuICAgIC8vIHByb3BlcnRpZXMsIGluIGFkZGl0aW9uIHRvIGNoZWNrIHdoZXRoZXIgYWxsIHZhbGlkYXRvcnMgcGFzc2VkLlxuICAgIC8vXG5cbiAgICB1dGlsLmFkZFByZWRpY2F0ZSggJ2NvbmZvcm1zJyAsIGZ1bmN0aW9uIGlzQ29uZm9ybXMoIG9iamVjdCAsIHNjaGVtYSAsIHN0cmljdCApIHtcblxuICAgICAgdmFyIGtleVxuICAgICAgdmFyIGtleXNcbiAgICAgIHZhciBpbmRleFxuICAgICAgdmFyIGxlbmd0aFxuICAgICAgdmFyIHZhbGlkYXRvclxuXG4gICAgICBpZiAoIGlzLm5vdC5vYmplY3QoIG9iamVjdCApIHx8IGlzLm5vdC5vYmplY3QoIHNjaGVtYSApICkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAga2V5cyA9IG93bktleXMoIHNjaGVtYSApXG4gICAgICBsZW5ndGggPSBrZXlzLmxlbmd0aFxuXG4gICAgICBpZiAoIHN0cmljdCAmJiBsZW5ndGggIT09IG93bktleXMoIG9iamVjdCApLmxlbmd0aCApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGZvciAoIGluZGV4ID0gMCA7IGluZGV4IDwgbGVuZ3RoIDsgaW5kZXggKz0gMSApIHtcblxuICAgICAgICBrZXkgPSBrZXlzWyBpbmRleCBdXG4gICAgICAgIHZhbGlkYXRvciA9IHNjaGVtYVsga2V5IF1cblxuICAgICAgICBpZiAoIHR5cGVvZiB2YWxpZGF0b3IgIT09ICdmdW5jdGlvbicgKSB7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggIWhhc093blByb3BlcnR5LmNhbGwoIG9iamVjdCAsIGtleSApIHx8XG4gICAgICAgICAgICAgIXZhbGlkYXRvciggb2JqZWN0WyBrZXkgXSAsIGtleSAsIG9iamVjdCApICkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWVcblxuICAgIH0gKVxuXG4gIH0gKVxuXG5cbiAgLy9cbiAgLy8gIyMjIGJ1bmRsZTphcnJheVxuICAvL1xuXG4gIGlzLnVzZSggZnVuY3Rpb24gYXJyYXlCdW5kbGUoIHV0aWwgKSB7XG5cbiAgICAvL1xuICAgIC8vIF9faXMuYXJyYXkoIHZhbHVlIClfX1xuICAgIC8vXG4gICAgLy8gQ2hlY2tzIHdoZXRoZXIgZ2l2ZW4gdmFsdWUgaXMgYW4gYXJyYXkuXG4gICAgLy9cblxuICAgIGlmICggQXJyYXkuaXNBcnJheSApIHtcbiAgICAgIHV0aWwuYWRkUHJlZGljYXRlKCAnYXJyYXknICwgQXJyYXkuaXNBcnJheSApXG4gICAgfSBlbHNlIHtcbiAgICAgIHV0aWwuYWRkUHJlZGljYXRlKCAnYXJyYXknICwgZnVuY3Rpb24gaXNBcnJheSggdmFsdWUgKSB7XG4gICAgICAgIHJldHVybiBnZXRUYWcoIHZhbHVlICkgPT09ICdhcnJheSdcbiAgICAgIH0gKVxuICAgIH1cblxuXG4gICAgLy9cbiAgICAvLyBfX2lzLmFycmF5TGlrZU9iamVjdCggdmFsdWUgKV9fXG4gICAgLy9cbiAgICAvLyBDaGVja3Mgd2hldGhlciBnaXZlbiB2YWx1ZSBpcyBhbiBfYXJyYXktbGlrZV8gb2JqZWN0LlxuICAgIC8vXG4gICAgLy8gQW4gb2JqZWN0IGlzIHF1YWxpZmllZCBhcyBfYXJyYXktbGlrZV8gaWYgaXQgaGFzIGEgcHJvcGVydHkgbmFtZWRcbiAgICAvLyBgbGVuZ3RoYCB0aGF0IGlzIGEgcG9zaXRpdmUgc2FmZSBpbnRlZ2VyLiBBcyBhIHNwZWNpYWwgY2FzZSwgZnVuY3Rpb25zXG4gICAgLy8gYXJlIG5ldmVyIHF1YWxpZmllZCBhcyBfYXJyYXktbGlrZV8uXG4gICAgLy9cblxuICAgIHV0aWwuYWRkUHJlZGljYXRlKCAnYXJyYXlMaWtlT2JqZWN0JyAsIGZ1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KCB2YWx1ZSApIHtcblxuICAgICAgdmFyIGxlbmd0aFxuXG4gICAgICBpZiAoIGlzLnByaW1pdGl2ZSggdmFsdWUgKSB8fCBpc1sgJ2Z1bmN0aW9uJyBdKCB2YWx1ZSApICkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlbmd0aCA9IHZhbHVlLmxlbmd0aFxuICAgICAgICByZXR1cm4gaXMuaW50ZWdlciggbGVuZ3RoICkgJiYgbGVuZ3RoID49IDAgJiYgbGVuZ3RoIDw9IDB4RkZGRkZGRkYgLy8gMzItYml0IHVuc2lnbmVkIGludCBtYXhpbXVtXG4gICAgICB9XG5cbiAgICB9IClcblxuXG4gICAgLy9cbiAgICAvLyBfX2lzLmluQXJyYXkoIHZhbHVlICwgYXJyYXkgLCBbb2Zmc2V0PTBdICwgW2NvbXBhcmF0b3I9aXMuZXF1YWxdIClfX1xuICAgIC8vXG4gICAgLy8gQ2hlY2tzIHdoZXRoZXIgZ2l2ZW4gYXJyYXkgb3IgYXJyYXktbGlrZSBvYmplY3QgY29udGFpbnMgY2VydGFpbiBlbGVtZW50LlxuICAgIC8vXG4gICAgLy8gLSBfX3ZhbHVlX186IFRoZSBlbGVtZW50IHRvIHNlYXJjaC5cbiAgICAvLyAtIF9fYXJyYXlfXzogVGhlIGFycmF5IG9yIGFycmF5LWxpa2Ugb2JqZWN0IHRvIHNlYXJjaCBmcm9tLlxuICAgIC8vIC0gX19vZmZzZXRfXzogVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLCBpbmNsdXNpdmUuXG4gICAgLy8gLSBfX2NvbXBhcmF0b3JfXzogVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudCBhZ2FpbnN0IGB2YWx1ZWAuXG4gICAgLy9cblxuICAgIHV0aWwuYWRkUHJlZGljYXRlKCAnaW5BcnJheScgLCBmdW5jdGlvbiBpc0luQXJyYXkoIHZhbHVlICwgYXJyYXkgLCBvZmZzZXQgLCBjb21wYXJhdG9yICkge1xuXG4gICAgICB2YXIgaW5kZXhcbiAgICAgIHZhciBsZW5ndGhcblxuICAgICAgLy8gT25seSB3b3JrcyB3aXRoIGdlbnVpbmUgYXJyYXlzIG9yIGFycmF5LWxpa2Ugb2JqZWN0cy5cbiAgICAgIGlmICggaXMubm90LmFycmF5TGlrZU9iamVjdCggYXJyYXkgKSApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGlmICggaXNbICdmdW5jdGlvbicgXSggb2Zmc2V0ICkgKSB7XG4gICAgICAgIGNvbXBhcmF0b3IgPSBvZmZzZXRcbiAgICAgICAgb2Zmc2V0ID0gMFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2Zmc2V0ID0gaXMuaW50ZWdlciggb2Zmc2V0ICkgPyBvZmZzZXQgOiAwXG4gICAgICAgIGNvbXBhcmF0b3IgPSBpc1sgJ2Z1bmN0aW9uJyBdKCBjb21wYXJhdG9yICkgPyBjb21wYXJhdG9yIDogaXMuZXF1YWxcbiAgICAgIH1cblxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoXG5cbiAgICAgIC8vIEFsbG93IG5lZ2F0aXZlIG9mZnNldHMuXG4gICAgICBpZiAoIG9mZnNldCA8IDAgKSB7XG4gICAgICAgIG9mZnNldCA9IGxlbmd0aCArIG9mZnNldFxuICAgICAgfVxuXG4gICAgICBpZiAoIG9mZnNldCA8IDAgfHwgb2Zmc2V0ID49IGxlbmd0aCApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGZvciAoIGluZGV4ID0gb2Zmc2V0IDsgaW5kZXggPCBsZW5ndGggOyBpbmRleCArPSAxICkge1xuXG4gICAgICAgIC8vIFNraXAgX2hvbGVzXyBpbiBzcGFyc2UgYXJyYXlzLlxuICAgICAgICBpZiAoICFoYXNPd25Qcm9wZXJ0eS5jYWxsKCBhcnJheSAsIGluZGV4ICkgKSB7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggY29tcGFyYXRvciggdmFsdWUgLCBhcnJheVsgaW5kZXggXSApICkge1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2VcblxuICAgIH0gKVxuXG4gIH0gKVxuXG5cbiAgLy9cbiAgLy8gIyMjIGJ1bmRsZTp0eXBlXG4gIC8vXG5cbiAgaXMudXNlKCBmdW5jdGlvbiB0eXBlQnVuZGxlKCB1dGlsICkge1xuXG4gICAgLy9cbiAgICAvLyBfX2lzLnNhbWVUeXBlKCB2YWx1ZSAsIG90aGVyIClfX1xuICAgIC8vXG4gICAgLy8gQ2hlY2tzIHdoZXRoZXIgZ2l2ZW4gdmFsdWVzIGFyZSBvZiB0aGUgc2FtZSB0eXBlLlxuICAgIC8vXG5cbiAgICB1dGlsLmFkZFByZWRpY2F0ZSggJ3NhbWVUeXBlJyAsIGZ1bmN0aW9uIGlzU2FtZVR5cGUoIHZhbHVlICwgb3RoZXIgKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSB0eXBlb2Ygb3RoZXIgJiYgZ2V0VGFnKCB2YWx1ZSApID09PSBnZXRUYWcoIG90aGVyIClcbiAgICB9IClcblxuXG4gICAgLy9cbiAgICAvLyBfX2lzLnByaW1pdGl2ZSggdmFsdWUgKV9fXG4gICAgLy9cbiAgICAvLyBDaGVja3Mgd2hldGhlciBnaXZlbiB2YWx1ZSBpcyBhIHByaW1pdGl2ZS5cbiAgICAvL1xuXG4gICAgdXRpbC5hZGRQcmVkaWNhdGUoICdwcmltaXRpdmUnICwgZnVuY3Rpb24gaXNQcmltaXRpdmUoIHZhbHVlICkge1xuICAgICAgcmV0dXJuIGlzLm5pbCggdmFsdWUgKSB8fFxuICAgICAgICAgICAgIGlzLm51bWJlciggdmFsdWUgKSB8fFxuICAgICAgICAgICAgIGlzLnN0cmluZyggdmFsdWUgKSB8fFxuICAgICAgICAgICAgIGlzLmJvb2xlYW4oIHZhbHVlICkgfHxcbiAgICAgICAgICAgICBpcy5zeW1ib2woIHZhbHVlIClcbiAgICB9IClcblxuXG4gICAgLy9cbiAgICAvLyBHZW5lcmF0ZSB0eXBlIGNoZWNrIHByZWRpY2F0ZXMgZm9yIHN0YW5kYXJkIGJ1aWx0aW4gY2xhc3Nlcy5cbiAgICAvL1xuXG4gICAgOyAoIGZ1bmN0aW9uICggbWFrZVByZWRpY2F0ZSAsIHRhZ3MgKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgc2VtaS1zcGFjaW5nXG5cbiAgICAgIHZhciB0YWdcbiAgICAgIHZhciBpbmRleFxuICAgICAgdmFyIGxlbmd0aCA9IHRhZ3MubGVuZ3RoXG5cbiAgICAgIGZvciAoIGluZGV4ID0gMCA7IGluZGV4IDwgbGVuZ3RoIDsgaW5kZXggKz0gMSApIHtcbiAgICAgICAgdGFnID0gdGFnc1sgaW5kZXggXVxuICAgICAgICB1dGlsLmFkZFByZWRpY2F0ZSggdGFnICwgbWFrZVByZWRpY2F0ZSggdGFnLnRvTG93ZXJDYXNlKCkgKSApXG4gICAgICB9XG5cbiAgICB9ICkoIGZ1bmN0aW9uIG1ha2VQcmVkaWNhdGUoIHRhZyApIHtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHByZWRpY2F0ZSggdmFsdWUgKSB7XG4gICAgICAgIHJldHVybiBnZXRUYWcoIHZhbHVlICkgPT09IHRhZ1xuICAgICAgfVxuXG4gICAgfSAsIFsgJ2RhdGUnICwgJ2Vycm9yJyAsICdmdW5jdGlvbicgLCAnbWFwJyAsICdyZWdleHAnICwgJ3NldCcgLCAnc3ltYm9sJyBdIClcblxuICB9IClcblxuXG4gIC8vXG4gIC8vICMjIyBidW5kbGU6ZXF1YWxpdHlcbiAgLy9cblxuICBpcy51c2UoIGZ1bmN0aW9uIGVxdWFsaXR5QnVuZGxlKCB1dGlsICkge1xuXG4gICAgLy9cbiAgICAvLyBfX2lzLmVxdWFsKCB2YWx1ZSAsIG90aGVyIClfX1xuICAgIC8vXG4gICAgLy8gQ2hlY2tzIHdoZXRoZXIgZ2l2ZW4gdmFsdWVzIGFyZSBlcXVhbCwgdXNpbmcgX1NhbWVWYWx1ZVplcm9fIGFsZ29yaXRobS5cbiAgICAvL1xuXG4gICAgdXRpbC5hZGRQcmVkaWNhdGUoICdlcXVhbCcgLCBmdW5jdGlvbiBpc0VxdWFsKCB2YWx1ZSAsIG90aGVyICkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAoIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIgKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIH0gKVxuXG5cbiAgICAvL1xuICAgIC8vIF9faXMuZGVlcEVxdWFsKCB2YWx1ZSAsIG90aGVyIClfX1xuICAgIC8vXG4gICAgLy8gQ2hlY2tzIHdoZXRoZXIgZ2l2ZW4gdmFsdWVzIGFyZSBkZWVwbHkgZXF1YWwsIGkuZTpcbiAgICAvL1xuICAgIC8vIC0gSWYgYFR5cGUoIHZhbHVlICkgIT09IFR5cGUoIG90aGVyIClgLCByZXR1cm5zIGBmYWxzZWAuXG4gICAgLy8gLSBGb3IgcHJpbWl0aXZlcywgY2hlY2tzIHdoZXRoZXIgdGhleSBhcmUgZXF1YWwgdXNpbmcgX1NhbWVWYWx1ZVplcm9fLlxuICAgIC8vIC0gRm9yIGFycmF5cywgY2hlY2tzIHdoZXRoZXIgdGhleSBoYXZlIHNhbWUgc2V0IG9mIG1lbWJlcnMsIGFsbCBvZlxuICAgIC8vICAgd2hpY2ggYXJlIGRlZXBseSBlcXVhbC5cbiAgICAvLyAtIE90aGVyd2lzZSwgY2hlY2tzIHdoZXRoZXIgdGhleSBoYXZlIHNhbWUgc2V0IG9mIG93biwgZW51bWVyYWJsZSwgc3RyaW5nXG4gICAgLy8gICBrZXllZCBwcm9wZXJ0aWVzLCBhbGwgb2Ygd2hpY2ggYXJlIGRlZXBseSBlcXVhbC5cbiAgICAvL1xuXG4gICAgdXRpbC5hZGRQcmVkaWNhdGUoICdkZWVwRXF1YWwnICwgZnVuY3Rpb24gaXNEZWVwRXF1YWwoIHZhbHVlICwgb3RoZXIgKSB7XG5cbiAgICAgIGlmICggaXMubm90LnNhbWVUeXBlKCB2YWx1ZSAsIG90aGVyICkgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICBpZiAoIGlzLnByaW1pdGl2ZSggdmFsdWUgKSApIHtcbiAgICAgICAgcmV0dXJuIGlzLmVxdWFsKCB2YWx1ZSAsIG90aGVyIClcbiAgICAgIH1cblxuICAgICAgaWYgKCBpcy5hcnJheSggdmFsdWUgKSApIHtcblxuICAgICAgICBpZiAoIHZhbHVlLmxlbmd0aCAhPT0gb3RoZXIubGVuZ3RoICkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICggZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgdmFyIGluZGV4XG4gICAgICAgICAgdmFyIGxlbmd0aFxuXG4gICAgICAgICAgZm9yICggaW5kZXggPSAwICwgbGVuZ3RoID0gdmFsdWUubGVuZ3RoIDsgaW5kZXggPCBsZW5ndGggOyBpbmRleCArPSAxICkge1xuICAgICAgICAgICAgaWYgKCBpcy5ub3QuZGVlcEVxdWFsKCB2YWx1ZVsgaW5kZXggXSAsIG90aGVyWyBpbmRleCBdICkgKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0cnVlXG5cbiAgICAgICAgfSApKClcblxuICAgICAgfVxuXG4gICAgICByZXR1cm4gKCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgdmFyIGtleVxuICAgICAgICB2YXIga2V5c1xuICAgICAgICB2YXIgaW5kZXhcbiAgICAgICAgdmFyIGxlbmd0aFxuXG4gICAgICAgIGtleXMgPSBvd25LZXlzKCB2YWx1ZSApXG4gICAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoXG5cbiAgICAgICAgaWYgKCBsZW5ndGggIT09IG93bktleXMoIG90aGVyICkubGVuZ3RoICkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICggaW5kZXggPSAwIDsgaW5kZXggPCBsZW5ndGggOyBpbmRleCArPSAxICkge1xuICAgICAgICAgIGtleSA9IGtleXNbIGluZGV4IF1cbiAgICAgICAgICBpZiAoICFoYXNPd25Qcm9wZXJ0eS5jYWxsKCBvdGhlciAsIGtleSApIHx8XG4gICAgICAgICAgICAgICBpcy5ub3QuZGVlcEVxdWFsKCB2YWx1ZVsga2V5IF0gLCBvdGhlclsga2V5IF0gKSApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlXG5cbiAgICAgIH0gKSgpXG5cbiAgICB9IClcblxuICB9IClcblxuXG4gIHJldHVybiBpc1xuXG59IClcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L0Bwd24vaXMvbGliL2lzLmpzXG4gKiogbW9kdWxlIGlkID0gODJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _h = __webpack_require__(10);\n\nvar _h2 = _interopRequireDefault(_h);\n\nvar _ramda = __webpack_require__(1);\n\nvar _tcomb = __webpack_require__(13);\n\nvar _tcomb2 = _interopRequireDefault(_tcomb);\n\nvar _types = __webpack_require__(69);\n\nvar _foundation = __webpack_require__(84);\n\nvar _foundation2 = _interopRequireDefault(_foundation);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function (action$, foundations) {\n\t_tcomb2.default.assert(_types.Foundations.is(foundations), 'Invalid argument foundations (expected a ' + _tcomb2.default.getTypeName(_types.Foundations) + ')');\n\n\treturn (0, _h2.default)('div.foundations', foundations.map((0, _foundation2.default)(action$)));\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9mb3VuZGF0aW9ucy5qcz9iMDk0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7Ozs7O2tCQUdBLFVBQUUsT0FBRixFQUFXLFdBQVg7QUFBQTs7QUFBQSxRQUNDLGlCQUFHLGlCQUFILEVBQXNCLFlBQVksR0FBWixDQUFpQiwwQkFBWSxPQUFaLENBQWpCLENBQXRCLENBREQ7QUFBQSxDIiwiZmlsZSI6IjgzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgaCBmcm9tICdzbmFiYmRvbS9oJ1xuaW1wb3J0IHsgaXNFbXB0eSB9IGZyb20gJ3JhbWRhJ1xuaW1wb3J0IHRjb21iIGZyb20gJ3Rjb21iJ1xuaW1wb3J0IHsgRm91bmRhdGlvbnMgfSBmcm9tICd0eXBlcydcbmltcG9ydCBmb3VuZGF0aW9uIGZyb20gJy4vZm91bmRhdGlvbidcblxuZXhwb3J0IGRlZmF1bHRcbiggYWN0aW9uJCwgZm91bmRhdGlvbnM6IEZvdW5kYXRpb25zICkgPT5cblx0aCggJ2Rpdi5mb3VuZGF0aW9ucycsIGZvdW5kYXRpb25zLm1hcCggZm91bmRhdGlvbiggYWN0aW9uJCApKSlcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2NvbXBvbmVudHMvZm91bmRhdGlvbnMuanNcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _h = __webpack_require__(10);\n\nvar _h2 = _interopRequireDefault(_h);\n\nvar _ramda = __webpack_require__(1);\n\nvar _tcomb = __webpack_require__(13);\n\nvar _tcomb2 = _interopRequireDefault(_tcomb);\n\nvar _types = __webpack_require__(69);\n\nvar _card = __webpack_require__(85);\n\nvar _card2 = _interopRequireDefault(_card);\n\nvar _actions = __webpack_require__(74);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = (0, _ramda.curry)(function (action$, foundation, idx) {\n  _tcomb2.default.assert(_types.Foundation.is(foundation), 'Invalid argument foundation (expected a ' + _tcomb2.default.getTypeName(_types.Foundation) + ')');\n\n  return (0, _h2.default)('div.foundation', [(0, _ramda.isEmpty)(foundation) ? (0, _h2.default)('div.empty', { on: { click: [action$, _actions.Action.Move(['table', 'foundations', idx, 0], 'empty')] } }) : (0, _card2.default)(action$, (0, _ramda.last)(foundation), ['table', 'foundations', idx, foundation.length - 1])]);\n});//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9mb3VuZGF0aW9uLmpzP2E5YzYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7OztBQUNBOztBQUNBOzs7O0FBQ0E7Ozs7a0JBR0Esa0JBQU0sVUFBRSxPQUFGLEVBQVcsVUFBWCxFQUFtQyxHQUFuQztBQUFBOztBQUFBLFNBQ0wsaUJBQUcsZ0JBQUgsRUFDRyxDQUFFLG9CQUFRLFVBQVIsSUFDQSxpQkFBRyxXQUFILEVBQWdCLEVBQUUsSUFBSSxFQUFFLE9BQU8sQ0FBRSxPQUFGLEVBQVcsZ0JBQU8sSUFBUCxDQUFZLENBQUUsT0FBRixFQUFXLGFBQVgsRUFBMEIsR0FBMUIsRUFBK0IsQ0FBL0IsQ0FBWixFQUFnRCxPQUFoRCxDQUFYLENBQVQsRUFBTixFQUFoQixDQURBLEdBRUEsb0JBQU0sT0FBTixFQUFlLGlCQUFNLFVBQU4sQ0FBZixFQUFtQyxDQUFFLE9BQUYsRUFBVyxhQUFYLEVBQTBCLEdBQTFCLEVBQStCLFdBQVcsTUFBWCxHQUFvQixDQUFuRCxDQUFuQyxDQUZGLENBREgsQ0FESztBQUFBLENBQU4sQyIsImZpbGUiOiI4NC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IGggZnJvbSAnc25hYmJkb20vaCdcbmltcG9ydCB7IGlzRW1wdHksIGN1cnJ5LCBsYXN0IH0gZnJvbSAncmFtZGEnXG5pbXBvcnQgdGNvbWIgZnJvbSAndGNvbWInXG5pbXBvcnQgeyBGb3VuZGF0aW9uIH0gZnJvbSAndHlwZXMnXG5pbXBvcnQgY2FyZCBmcm9tICcuL2NhcmQnXG5pbXBvcnQgeyBBY3Rpb24gfSBmcm9tICdhY3Rpb25zJ1xuXG5leHBvcnQgZGVmYXVsdFxuY3VycnkoKCBhY3Rpb24kLCBmb3VuZGF0aW9uOiBGb3VuZGF0aW9uLCBpZHggKSA9PlxuXHRoKCAnZGl2LmZvdW5kYXRpb24nXG4gICwgWyBpc0VtcHR5KGZvdW5kYXRpb24pXG4gICAgPyBoKCAnZGl2LmVtcHR5JywgeyBvbjogeyBjbGljazogWyBhY3Rpb24kLCBBY3Rpb24uTW92ZShbICd0YWJsZScsICdmb3VuZGF0aW9ucycsIGlkeCwgMCBdLCAnZW1wdHknICkgXX19KVxuICAgIDogY2FyZCggYWN0aW9uJCwgbGFzdCggZm91bmRhdGlvbiApLCBbICd0YWJsZScsICdmb3VuZGF0aW9ucycsIGlkeCwgZm91bmRhdGlvbi5sZW5ndGggLSAxIF0pXG4gICAgXSlcbilcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2NvbXBvbmVudHMvZm91bmRhdGlvbi5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _h = __webpack_require__(10);\n\nvar _h2 = _interopRequireDefault(_h);\n\nvar _ramda = __webpack_require__(1);\n\nvar _tcomb = __webpack_require__(13);\n\nvar _tcomb2 = _interopRequireDefault(_tcomb);\n\nvar _types = __webpack_require__(69);\n\nvar _actions = __webpack_require__(74);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = (0, _ramda.curry)(function (action$, card, path) {\n\t_tcomb2.default.assert(_types.Card.is(card), 'Invalid argument card (expected a ' + _tcomb2.default.getTypeName(_types.Card) + ')');\n\n\treturn (0, _h2.default)('img.card', { props: { src: '/cards/' + card.join('_') + '.svg' },\n\t\ton: { click: [action$, _actions.Action.Move(path, 'card')] }\n\t});\n});\n\n// If path is false, Move does nothing//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9jYXJkLmpzP2EzZTUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7OztBQUNBOztBQUNBOzs7O2tCQUlBLGtCQUFNLFVBQUUsT0FBRixFQUFXLElBQVgsRUFBdUIsSUFBdkI7QUFBQTs7QUFBQSxRQUNMLGlCQUFHLFVBQUgsRUFDRSxFQUFFLE9BQU8sRUFBRSxpQkFBZSxLQUFLLElBQUwsQ0FBVSxHQUFWLENBQWYsU0FBRixFQUFUO0FBQ0MsTUFBSSxFQUFFLE9BQU8sQ0FBRSxPQUFGLEVBQVcsZ0JBQU8sSUFBUCxDQUFhLElBQWIsRUFBbUIsTUFBbkIsQ0FBWCxDQUFUO0FBREwsRUFERixDQURLO0FBQUEsQ0FBTixDIiwiZmlsZSI6Ijg1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgaCBmcm9tICdzbmFiYmRvbS9oJ1xuaW1wb3J0IHsgY3VycnkgfSBmcm9tICdyYW1kYSdcbmltcG9ydCB0IGZyb20gJ3Rjb21iJ1xuaW1wb3J0IHsgQ2FyZCwgTGVuc2VzIH0gZnJvbSAndHlwZXMnXG5pbXBvcnQgeyBBY3Rpb24gfSBmcm9tICdhY3Rpb25zJ1xuXG5cbmV4cG9ydCBkZWZhdWx0XG5jdXJyeSgoIGFjdGlvbiQsIGNhcmQ6IENhcmQsIHBhdGggICkgPT5cblx0aCggJ2ltZy5jYXJkJ1xuXHQsIHsgcHJvcHM6IHsgc3JjOiBgL2NhcmRzLyR7Y2FyZC5qb2luKCdfJyl9LnN2Z2AgfVxuXHRcdCwgb246IHsgY2xpY2s6IFsgYWN0aW9uJCwgQWN0aW9uLk1vdmUoIHBhdGgsICdjYXJkJyApIF19XG5cdFx0fVxuXHQpXG4pXG5cbi8vIElmIHBhdGggaXMgZmFsc2UsIE1vdmUgZG9lcyBub3RoaW5nXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9jb21wb25lbnRzL2NhcmQuanNcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _h = __webpack_require__(10);\n\nvar _h2 = _interopRequireDefault(_h);\n\nvar _tcomb = __webpack_require__(13);\n\nvar _tcomb2 = _interopRequireDefault(_tcomb);\n\nvar _types = __webpack_require__(69);\n\nvar _pile = __webpack_require__(87);\n\nvar _pile2 = _interopRequireDefault(_pile);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function (action$, piles) {\n\t_tcomb2.default.assert(_types.Piles.is(piles), 'Invalid argument piles (expected a ' + _tcomb2.default.getTypeName(_types.Piles) + ')');\n\n\treturn (0, _h2.default)('div.piles', piles.map((0, _pile2.default)(action$)));\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9waWxlcy5qcz8yOTNmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7Ozs7O2tCQUdBLFVBQUUsT0FBRixFQUFXLEtBQVg7QUFBQTs7QUFBQSxRQUNDLGlCQUFHLFdBQUgsRUFBZ0IsTUFBTSxHQUFOLENBQVcsb0JBQU0sT0FBTixDQUFYLENBQWhCLENBREQ7QUFBQSxDIiwiZmlsZSI6Ijg2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgaCBmcm9tICdzbmFiYmRvbS9oJ1xuaW1wb3J0IHRjb21iIGZyb20gJ3Rjb21iJ1xuaW1wb3J0IHsgUGlsZXMgfSBmcm9tICd0eXBlcydcbmltcG9ydCBwaWxlIGZyb20gJy4vcGlsZSdcblxuZXhwb3J0IGRlZmF1bHRcbiggYWN0aW9uJCwgcGlsZXM6IFBpbGVzICkgPT5cblx0aCggJ2Rpdi5waWxlcycsIHBpbGVzLm1hcCggcGlsZSggYWN0aW9uJCApKSlcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2NvbXBvbmVudHMvcGlsZXMuanNcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _h = __webpack_require__(10);\n\nvar _h2 = _interopRequireDefault(_h);\n\nvar _ramda = __webpack_require__(1);\n\nvar _tcomb = __webpack_require__(13);\n\nvar _tcomb2 = _interopRequireDefault(_tcomb);\n\nvar _types = __webpack_require__(69);\n\nvar _card = __webpack_require__(85);\n\nvar _card2 = _interopRequireDefault(_card);\n\nvar _downturnedCard = __webpack_require__(73);\n\nvar _downturnedCard2 = _interopRequireDefault(_downturnedCard);\n\nvar _actions = __webpack_require__(74);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar map = (0, _ramda.addIndex)(_ramda.map);\nexports.default = (0, _ramda.curry)(function (action$, pile, pileIdx) {\n  _tcomb2.default.assert(_types.Pile.is(pile), 'Invalid argument pile (expected a ' + _tcomb2.default.getTypeName(_types.Pile) + ')');\n\n  var createPile = map(function (model, cardIdx) {\n    return (0, _card2.default)(action$, model, ['table', 'piles', pileIdx, 'upturned', cardIdx]);\n  });\n\n  if ((0, _ramda.isEmpty)(pile.upturned) && !(0, _ramda.isEmpty)(pile.downturned)) action$(_actions.Action.ShowHiddenPile(pileIdx));\n\n  var empty = (0, _ramda.isEmpty)((0, _ramda.concat)(pile.upturned, pile.downturned)) ? [(0, _h2.default)('div.empty', { on: { click: [action$, _actions.Action.Move(['table', 'piles', pileIdx, 'upturned', 0], 'empty')] } })] : null;\n\n  return (0, _h2.default)('div.pile', empty || [].concat(_toConsumableArray(pile.downturned.map(_downturnedCard2.default)), _toConsumableArray(createPile(pile.upturned))));\n});//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9waWxlLmpzPzViMGEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQ0E7Ozs7QUFDQTs7QUFFQTs7OztBQUNBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBTEEsSUFBTSxNQUFNLGdDQUFaO2tCQVVBLGtCQUFNLFVBQUUsT0FBRixFQUFXLElBQVgsRUFBdUIsT0FBdkIsRUFBb0M7QUFBQTs7QUFDeEMsTUFBTSxhQUFhLElBQUksVUFBRSxLQUFGLEVBQVMsT0FBVDtBQUFBLFdBQXNCLG9CQUFNLE9BQU4sRUFBZSxLQUFmLEVBQXNCLENBQUUsT0FBRixFQUFXLE9BQVgsRUFBb0IsT0FBcEIsRUFBNkIsVUFBN0IsRUFBeUMsT0FBekMsQ0FBdEIsQ0FBdEI7QUFBQSxHQUFKLENBQW5COztBQUVBLE1BQUksb0JBQVMsS0FBSyxRQUFkLEtBQTRCLENBQUMsb0JBQVMsS0FBSyxVQUFkLENBQWpDLEVBQ0UsUUFBUyxnQkFBTyxjQUFQLENBQXVCLE9BQXZCLENBQVQ7O0FBRUYsTUFBTSxRQUFRLG9CQUFTLG1CQUFRLEtBQUssUUFBYixFQUF1QixLQUFLLFVBQTVCLENBQVQsSUFDWixDQUFFLGlCQUFHLFdBQUgsRUFBZ0IsRUFBRSxJQUFJLEVBQUUsT0FBTyxDQUFFLE9BQUYsRUFBVyxnQkFBTyxJQUFQLENBQVksQ0FBRSxPQUFGLEVBQVcsT0FBWCxFQUFvQixPQUFwQixFQUE2QixVQUE3QixFQUF5QyxDQUF6QyxDQUFaLEVBQTBELE9BQTFELENBQVgsQ0FBVCxFQUFOLEVBQWhCLENBQUYsQ0FEWSxHQUVaLElBRkY7O0FBSUEsU0FBTyxpQkFBRyxVQUFILEVBQWUsc0NBQ2pCLEtBQUssVUFBTCxDQUFnQixHQUFoQiwwQkFEaUIsc0JBRWpCLFdBQVksS0FBSyxRQUFqQixDQUZpQixFQUFmLENBQVA7QUFJRCxDQWRELEMiLCJmaWxlIjoiODcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCBoIGZyb20gJ3NuYWJiZG9tL2gnXG5pbXBvcnQgeyBhZGRJbmRleCwgY29tcG9zZSwgY29uY2F0LCBjdXJyeSwgaXNFbXB0eSwgbWFwIGFzIG0sIHJldmVyc2UgfSBmcm9tICdyYW1kYSdcbmNvbnN0IG1hcCA9IGFkZEluZGV4KG0pXG5pbXBvcnQgdGNvbWIgZnJvbSAndGNvbWInXG5pbXBvcnQgeyBQaWxlLCBMZW5zZXMgfSBmcm9tICd0eXBlcydcbmltcG9ydCBjYXJkIGZyb20gJy4vY2FyZCdcbmltcG9ydCBkb3dudHVybmVkQ2FyZCBmcm9tICcuL2Rvd250dXJuZWQtY2FyZCdcbmltcG9ydCB7IEFjdGlvbiB9IGZyb20gJ2FjdGlvbnMnXG5cblxuXG5leHBvcnQgZGVmYXVsdFxuY3VycnkoKCBhY3Rpb24kLCBwaWxlOiBQaWxlLCBwaWxlSWR4ICkgPT4ge1xuICBjb25zdCBjcmVhdGVQaWxlID0gbWFwKCggbW9kZWwsIGNhcmRJZHggKSA9PiBjYXJkKCBhY3Rpb24kLCBtb2RlbCwgWyAndGFibGUnLCAncGlsZXMnLCBwaWxlSWR4LCAndXB0dXJuZWQnLCBjYXJkSWR4IF0pKVxuXG4gIGlmKCBpc0VtcHR5KCBwaWxlLnVwdHVybmVkICkgJiYgIWlzRW1wdHkoIHBpbGUuZG93bnR1cm5lZCApKVxuICAgIGFjdGlvbiQoIEFjdGlvbi5TaG93SGlkZGVuUGlsZSggcGlsZUlkeCApKVxuXG4gIGNvbnN0IGVtcHR5ID0gaXNFbXB0eSggY29uY2F0KCBwaWxlLnVwdHVybmVkLCBwaWxlLmRvd250dXJuZWQgKSlcbiAgPyBbIGgoICdkaXYuZW1wdHknLCB7IG9uOiB7IGNsaWNrOiBbIGFjdGlvbiQsIEFjdGlvbi5Nb3ZlKFsgJ3RhYmxlJywgJ3BpbGVzJywgcGlsZUlkeCwgJ3VwdHVybmVkJywgMCBdLCAnZW1wdHknICkgXX19KSBdXG4gIDogbnVsbFxuXG4gIHJldHVybiBoKCAnZGl2LnBpbGUnLCBlbXB0eSB8fCBbXG4gICAgLi4ucGlsZS5kb3dudHVybmVkLm1hcCggZG93bnR1cm5lZENhcmQgKVxuICAsIC4uLmNyZWF0ZVBpbGUoIHBpbGUudXB0dXJuZWQgKVxuICBdKVxufSlcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2NvbXBvbmVudHMvcGlsZS5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _h = __webpack_require__(10);\n\nvar _h2 = _interopRequireDefault(_h);\n\nvar _ramda = __webpack_require__(1);\n\nvar _tcomb = __webpack_require__(13);\n\nvar _tcomb2 = _interopRequireDefault(_tcomb);\n\nvar _types = __webpack_require__(69);\n\nvar _card = __webpack_require__(85);\n\nvar _card2 = _interopRequireDefault(_card);\n\nvar _actions = __webpack_require__(74);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar log = function log(a) {\n  console.log(a);return a;\n};\n\nexports.default = function (action$, wasteVisible) {\n  _tcomb2.default.assert(_types.VisibleWaste.is(wasteVisible), 'Invalid argument wasteVisible (expected a ' + _tcomb2.default.getTypeName(_types.VisibleWaste) + ')');\n\n  return (0, _h2.default)('div.waste', wasteVisible.map(function (model, idx) {\n    return (0, _card2.default)(action$, model, log(idx === wasteVisible.length - 1) && ['table', 'wasteVisible', idx]);\n  }));\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy93YXN0ZS5qcz80ZjJiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0EsSUFBTSxNQUFNLFNBQU4sR0FBTSxJQUFLO0FBQUUsVUFBUSxHQUFSLENBQVksQ0FBWixFQUFnQixPQUFPLENBQVA7QUFBVSxDQUE3Qzs7a0JBR0EsVUFBRSxPQUFGLEVBQVcsWUFBWCxFQUEyQztBQUFBOztBQUMxQyxTQUFPLGlCQUFHLFdBQUgsRUFDSixhQUFhLEdBQWIsQ0FBaUIsVUFBRSxLQUFGLEVBQVMsR0FBVDtBQUFBLFdBQ2Ysb0JBQU0sT0FBTixFQUFlLEtBQWYsRUFDRSxJQUFJLFFBQVEsYUFBYSxNQUFiLEdBQW9CLENBQWhDLEtBQXNDLENBQUUsT0FBRixFQUFXLGNBQVgsRUFBMkIsR0FBM0IsQ0FEeEMsQ0FEZTtBQUFBLEdBQWpCLENBREksQ0FBUDtBQU9BLEMiLCJmaWxlIjoiODguanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCBoIGZyb20gJ3NuYWJiZG9tL2gnXG5pbXBvcnQgeyBpc0VtcHR5IH0gZnJvbSAncmFtZGEnXG5pbXBvcnQgdGNvbWIgZnJvbSAndGNvbWInXG5pbXBvcnQgeyBWaXNpYmxlV2FzdGUgfSBmcm9tICd0eXBlcydcbmltcG9ydCBjYXJkIGZyb20gJy4vY2FyZCdcbmltcG9ydCB7IEFjdGlvbiB9IGZyb20gJ2FjdGlvbnMnXG5jb25zdCBsb2cgPSBhID0+IHsgY29uc29sZS5sb2coYSk7IHJldHVybiBhIH1cblxuZXhwb3J0IGRlZmF1bHRcbiggYWN0aW9uJCwgd2FzdGVWaXNpYmxlOiBWaXNpYmxlV2FzdGUgKSA9PiB7XG5cdHJldHVybiBoKCAnZGl2Lndhc3RlJ1xuICAsIHdhc3RlVmlzaWJsZS5tYXAoKCBtb2RlbCwgaWR4ICkgPT5cbiAgICAgIGNhcmQoIGFjdGlvbiQsIG1vZGVsXG4gICAgICAsIGxvZyhpZHggPT09IHdhc3RlVmlzaWJsZS5sZW5ndGgtMSkgJiYgWyAndGFibGUnLCAnd2FzdGVWaXNpYmxlJywgaWR4IF1cbiAgICAgIClcbiAgICApXG4gIClcbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2NvbXBvbmVudHMvd2FzdGUuanNcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	eval("// jshint newcap: false\n/* global require, module, document, Node */\n'use strict';\n\nvar VNode = __webpack_require__(11);\nvar is = __webpack_require__(12);\nvar domApi = __webpack_require__(90);\n\nfunction isUndef(s) { return s === undefined; }\nfunction isDef(s) { return s !== undefined; }\n\nvar emptyNode = VNode('', {}, [], undefined, undefined);\n\nfunction sameVnode(vnode1, vnode2) {\n  return vnode1.key === vnode2.key && vnode1.sel === vnode2.sel;\n}\n\nfunction createKeyToOldIdx(children, beginIdx, endIdx) {\n  var i, map = {}, key;\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n    if (isDef(key)) map[key] = i;\n  }\n  return map;\n}\n\nvar hooks = ['create', 'update', 'remove', 'destroy', 'pre', 'post'];\n\nfunction init(modules, api) {\n  var i, j, cbs = {};\n\n  if (isUndef(api)) api = domApi;\n\n  for (i = 0; i < hooks.length; ++i) {\n    cbs[hooks[i]] = [];\n    for (j = 0; j < modules.length; ++j) {\n      if (modules[j][hooks[i]] !== undefined) cbs[hooks[i]].push(modules[j][hooks[i]]);\n    }\n  }\n\n  function emptyNodeAt(elm) {\n    return VNode(api.tagName(elm).toLowerCase(), {}, [], undefined, elm);\n  }\n\n  function createRmCb(childElm, listeners) {\n    return function() {\n      if (--listeners === 0) {\n        var parent = api.parentNode(childElm);\n        api.removeChild(parent, childElm);\n      }\n    };\n  }\n\n  function createElm(vnode, insertedVnodeQueue) {\n    var i, data = vnode.data;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.init)) {\n        i(vnode);\n        data = vnode.data;\n      }\n    }\n    var elm, children = vnode.children, sel = vnode.sel;\n    if (isDef(sel)) {\n      // Parse selector\n      var hashIdx = sel.indexOf('#');\n      var dotIdx = sel.indexOf('.', hashIdx);\n      var hash = hashIdx > 0 ? hashIdx : sel.length;\n      var dot = dotIdx > 0 ? dotIdx : sel.length;\n      var tag = hashIdx !== -1 || dotIdx !== -1 ? sel.slice(0, Math.min(hash, dot)) : sel;\n      elm = vnode.elm = isDef(data) && isDef(i = data.ns) ? api.createElementNS(i, tag)\n                                                          : api.createElement(tag);\n      if (hash < dot) elm.id = sel.slice(hash + 1, dot);\n      if (dotIdx > 0) elm.className = sel.slice(dot+1).replace(/\\./g, ' ');\n      if (is.array(children)) {\n        for (i = 0; i < children.length; ++i) {\n          api.appendChild(elm, createElm(children[i], insertedVnodeQueue));\n        }\n      } else if (is.primitive(vnode.text)) {\n        api.appendChild(elm, api.createTextNode(vnode.text));\n      }\n      for (i = 0; i < cbs.create.length; ++i) cbs.create[i](emptyNode, vnode);\n      i = vnode.data.hook; // Reuse variable\n      if (isDef(i)) {\n        if (i.create) i.create(emptyNode, vnode);\n        if (i.insert) insertedVnodeQueue.push(vnode);\n      }\n    } else {\n      elm = vnode.elm = api.createTextNode(vnode.text);\n    }\n    return vnode.elm;\n  }\n\n  function addVnodes(parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      api.insertBefore(parentElm, createElm(vnodes[startIdx], insertedVnodeQueue), before);\n    }\n  }\n\n  function invokeDestroyHook(vnode) {\n    var i, j, data = vnode.data;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) i(vnode);\n      for (i = 0; i < cbs.destroy.length; ++i) cbs.destroy[i](vnode);\n      if (isDef(i = vnode.children)) {\n        for (j = 0; j < vnode.children.length; ++j) {\n          invokeDestroyHook(vnode.children[j]);\n        }\n      }\n    }\n  }\n\n  function removeVnodes(parentElm, vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      var i, listeners, rm, ch = vnodes[startIdx];\n      if (isDef(ch)) {\n        if (isDef(ch.sel)) {\n          invokeDestroyHook(ch);\n          listeners = cbs.remove.length + 1;\n          rm = createRmCb(ch.elm, listeners);\n          for (i = 0; i < cbs.remove.length; ++i) cbs.remove[i](ch, rm);\n          if (isDef(i = ch.data) && isDef(i = i.hook) && isDef(i = i.remove)) {\n            i(ch, rm);\n          } else {\n            rm();\n          }\n        } else { // Text node\n          api.removeChild(parentElm, ch.elm);\n        }\n      }\n    }\n  }\n\n  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue) {\n    var oldStartIdx = 0, newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx, idxInOld, elmToMove, before;\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n        api.insertBefore(parentElm, oldStartVnode.elm, api.nextSibling(oldEndVnode.elm));\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n        api.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n        idxInOld = oldKeyToIdx[newStartVnode.key];\n        if (isUndef(idxInOld)) { // New element\n          api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);\n          newStartVnode = newCh[++newStartIdx];\n        } else {\n          elmToMove = oldCh[idxInOld];\n          patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n          oldCh[idxInOld] = undefined;\n          api.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);\n          newStartVnode = newCh[++newStartIdx];\n        }\n      }\n    }\n    if (oldStartIdx > oldEndIdx) {\n      before = isUndef(newCh[newEndIdx+1]) ? null : newCh[newEndIdx+1].elm;\n      addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n\n  function patchVnode(oldVnode, vnode, insertedVnodeQueue) {\n    var i, hook;\n    if (isDef(i = vnode.data) && isDef(hook = i.hook) && isDef(i = hook.prepatch)) {\n      i(oldVnode, vnode);\n    }\n    var elm = vnode.elm = oldVnode.elm, oldCh = oldVnode.children, ch = vnode.children;\n    if (oldVnode === vnode) return;\n    if (!sameVnode(oldVnode, vnode)) {\n      var parentElm = api.parentNode(oldVnode.elm);\n      elm = createElm(vnode, insertedVnodeQueue);\n      api.insertBefore(parentElm, elm, oldVnode.elm);\n      removeVnodes(parentElm, [oldVnode], 0, 0);\n      return;\n    }\n    if (isDef(vnode.data)) {\n      for (i = 0; i < cbs.update.length; ++i) cbs.update[i](oldVnode, vnode);\n      i = vnode.data.hook;\n      if (isDef(i) && isDef(i = i.update)) i(oldVnode, vnode);\n    }\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) && isDef(ch)) {\n        if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue);\n      } else if (isDef(ch)) {\n        if (isDef(oldVnode.text)) api.setTextContent(elm, '');\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) {\n        api.setTextContent(elm, '');\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      api.setTextContent(elm, vnode.text);\n    }\n    if (isDef(hook) && isDef(i = hook.postpatch)) {\n      i(oldVnode, vnode);\n    }\n  }\n\n  return function(oldVnode, vnode) {\n    var i, elm, parent;\n    var insertedVnodeQueue = [];\n    for (i = 0; i < cbs.pre.length; ++i) cbs.pre[i]();\n\n    if (isUndef(oldVnode.sel)) {\n      oldVnode = emptyNodeAt(oldVnode);\n    }\n\n    if (sameVnode(oldVnode, vnode)) {\n      patchVnode(oldVnode, vnode, insertedVnodeQueue);\n    } else {\n      elm = oldVnode.elm;\n      parent = api.parentNode(elm);\n\n      createElm(vnode, insertedVnodeQueue);\n\n      if (parent !== null) {\n        api.insertBefore(parent, vnode.elm, api.nextSibling(elm));\n        removeVnodes(parent, [oldVnode], 0, 0);\n      }\n    }\n\n    for (i = 0; i < insertedVnodeQueue.length; ++i) {\n      insertedVnodeQueue[i].data.hook.insert(insertedVnodeQueue[i]);\n    }\n    for (i = 0; i < cbs.post.length; ++i) cbs.post[i]();\n    return vnode;\n  };\n}\n\nmodule.exports = {init: init};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3NuYWJiZG9tL3NuYWJiZG9tLmpzPzFiMjIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsd0JBQXdCO0FBQzdDLG1CQUFtQix3QkFBd0I7O0FBRTNDLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxhQUFhLGtCQUFrQjtBQUMvQjtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRDtBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxQkFBcUI7QUFDeEM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsaUJBQWlCLHVCQUF1QjtBQUN4QywwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLG9CQUFvQjtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0JBQXdCO0FBQ3pDO0FBQ0EsbUJBQW1CLDJCQUEyQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxvQkFBb0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTLE9BQU87QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZDQUE2QztBQUM3QyxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU8sa0RBQWtEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxrREFBa0Q7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7O0FBRW5DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLCtCQUErQjtBQUM5QztBQUNBO0FBQ0EsZUFBZSxxQkFBcUI7QUFDcEM7QUFDQTtBQUNBOztBQUVBLGtCQUFrQiIsImZpbGUiOiI4OS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGpzaGludCBuZXdjYXA6IGZhbHNlXG4vKiBnbG9iYWwgcmVxdWlyZSwgbW9kdWxlLCBkb2N1bWVudCwgTm9kZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVk5vZGUgPSByZXF1aXJlKCcuL3Zub2RlJyk7XG52YXIgaXMgPSByZXF1aXJlKCcuL2lzJyk7XG52YXIgZG9tQXBpID0gcmVxdWlyZSgnLi9odG1sZG9tYXBpJyk7XG5cbmZ1bmN0aW9uIGlzVW5kZWYocykgeyByZXR1cm4gcyA9PT0gdW5kZWZpbmVkOyB9XG5mdW5jdGlvbiBpc0RlZihzKSB7IHJldHVybiBzICE9PSB1bmRlZmluZWQ7IH1cblxudmFyIGVtcHR5Tm9kZSA9IFZOb2RlKCcnLCB7fSwgW10sIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcblxuZnVuY3Rpb24gc2FtZVZub2RlKHZub2RlMSwgdm5vZGUyKSB7XG4gIHJldHVybiB2bm9kZTEua2V5ID09PSB2bm9kZTIua2V5ICYmIHZub2RlMS5zZWwgPT09IHZub2RlMi5zZWw7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUtleVRvT2xkSWR4KGNoaWxkcmVuLCBiZWdpbklkeCwgZW5kSWR4KSB7XG4gIHZhciBpLCBtYXAgPSB7fSwga2V5O1xuICBmb3IgKGkgPSBiZWdpbklkeDsgaSA8PSBlbmRJZHg7ICsraSkge1xuICAgIGtleSA9IGNoaWxkcmVuW2ldLmtleTtcbiAgICBpZiAoaXNEZWYoa2V5KSkgbWFwW2tleV0gPSBpO1xuICB9XG4gIHJldHVybiBtYXA7XG59XG5cbnZhciBob29rcyA9IFsnY3JlYXRlJywgJ3VwZGF0ZScsICdyZW1vdmUnLCAnZGVzdHJveScsICdwcmUnLCAncG9zdCddO1xuXG5mdW5jdGlvbiBpbml0KG1vZHVsZXMsIGFwaSkge1xuICB2YXIgaSwgaiwgY2JzID0ge307XG5cbiAgaWYgKGlzVW5kZWYoYXBpKSkgYXBpID0gZG9tQXBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7ICsraSkge1xuICAgIGNic1tob29rc1tpXV0gPSBbXTtcbiAgICBmb3IgKGogPSAwOyBqIDwgbW9kdWxlcy5sZW5ndGg7ICsraikge1xuICAgICAgaWYgKG1vZHVsZXNbal1baG9va3NbaV1dICE9PSB1bmRlZmluZWQpIGNic1tob29rc1tpXV0ucHVzaChtb2R1bGVzW2pdW2hvb2tzW2ldXSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW1wdHlOb2RlQXQoZWxtKSB7XG4gICAgcmV0dXJuIFZOb2RlKGFwaS50YWdOYW1lKGVsbSkudG9Mb3dlckNhc2UoKSwge30sIFtdLCB1bmRlZmluZWQsIGVsbSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVSbUNiKGNoaWxkRWxtLCBsaXN0ZW5lcnMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS1saXN0ZW5lcnMgPT09IDApIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IGFwaS5wYXJlbnROb2RlKGNoaWxkRWxtKTtcbiAgICAgICAgYXBpLnJlbW92ZUNoaWxkKHBhcmVudCwgY2hpbGRFbG0pO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbG0odm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIHZhciBpLCBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkge1xuICAgICAgICBpKHZub2RlKTtcbiAgICAgICAgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBlbG0sIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW4sIHNlbCA9IHZub2RlLnNlbDtcbiAgICBpZiAoaXNEZWYoc2VsKSkge1xuICAgICAgLy8gUGFyc2Ugc2VsZWN0b3JcbiAgICAgIHZhciBoYXNoSWR4ID0gc2VsLmluZGV4T2YoJyMnKTtcbiAgICAgIHZhciBkb3RJZHggPSBzZWwuaW5kZXhPZignLicsIGhhc2hJZHgpO1xuICAgICAgdmFyIGhhc2ggPSBoYXNoSWR4ID4gMCA/IGhhc2hJZHggOiBzZWwubGVuZ3RoO1xuICAgICAgdmFyIGRvdCA9IGRvdElkeCA+IDAgPyBkb3RJZHggOiBzZWwubGVuZ3RoO1xuICAgICAgdmFyIHRhZyA9IGhhc2hJZHggIT09IC0xIHx8IGRvdElkeCAhPT0gLTEgPyBzZWwuc2xpY2UoMCwgTWF0aC5taW4oaGFzaCwgZG90KSkgOiBzZWw7XG4gICAgICBlbG0gPSB2bm9kZS5lbG0gPSBpc0RlZihkYXRhKSAmJiBpc0RlZihpID0gZGF0YS5ucykgPyBhcGkuY3JlYXRlRWxlbWVudE5TKGksIHRhZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGFwaS5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICBpZiAoaGFzaCA8IGRvdCkgZWxtLmlkID0gc2VsLnNsaWNlKGhhc2ggKyAxLCBkb3QpO1xuICAgICAgaWYgKGRvdElkeCA+IDApIGVsbS5jbGFzc05hbWUgPSBzZWwuc2xpY2UoZG90KzEpLnJlcGxhY2UoL1xcLi9nLCAnICcpO1xuICAgICAgaWYgKGlzLmFycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBhcGkuYXBwZW5kQ2hpbGQoZWxtLCBjcmVhdGVFbG0oY2hpbGRyZW5baV0sIGluc2VydGVkVm5vZGVRdWV1ZSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzLnByaW1pdGl2ZSh2bm9kZS50ZXh0KSkge1xuICAgICAgICBhcGkuYXBwZW5kQ2hpbGQoZWxtLCBhcGkuY3JlYXRlVGV4dE5vZGUodm5vZGUudGV4dCkpO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kpIGNicy5jcmVhdGVbaV0oZW1wdHlOb2RlLCB2bm9kZSk7XG4gICAgICBpID0gdm5vZGUuZGF0YS5ob29rOyAvLyBSZXVzZSB2YXJpYWJsZVxuICAgICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICAgIGlmIChpLmNyZWF0ZSkgaS5jcmVhdGUoZW1wdHlOb2RlLCB2bm9kZSk7XG4gICAgICAgIGlmIChpLmluc2VydCkgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbG0gPSB2bm9kZS5lbG0gPSBhcGkuY3JlYXRlVGV4dE5vZGUodm5vZGUudGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB2bm9kZS5lbG07XG4gIH1cblxuICBmdW5jdGlvbiBhZGRWbm9kZXMocGFyZW50RWxtLCBiZWZvcmUsIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgYXBpLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIGNyZWF0ZUVsbSh2bm9kZXNbc3RhcnRJZHhdLCBpbnNlcnRlZFZub2RlUXVldWUpLCBiZWZvcmUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZURlc3Ryb3lIb29rKHZub2RlKSB7XG4gICAgdmFyIGksIGosIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmRlc3Ryb3kpKSBpKHZub2RlKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSkgY2JzLmRlc3Ryb3lbaV0odm5vZGUpO1xuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jaGlsZHJlbikpIHtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2sodm5vZGUuY2hpbGRyZW5bal0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4KSB7XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgdmFyIGksIGxpc3RlbmVycywgcm0sIGNoID0gdm5vZGVzW3N0YXJ0SWR4XTtcbiAgICAgIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKGlzRGVmKGNoLnNlbCkpIHtcbiAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhjaCk7XG4gICAgICAgICAgbGlzdGVuZXJzID0gY2JzLnJlbW92ZS5sZW5ndGggKyAxO1xuICAgICAgICAgIHJtID0gY3JlYXRlUm1DYihjaC5lbG0sIGxpc3RlbmVycyk7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5yZW1vdmUubGVuZ3RoOyArK2kpIGNicy5yZW1vdmVbaV0oY2gsIHJtKTtcbiAgICAgICAgICBpZiAoaXNEZWYoaSA9IGNoLmRhdGEpICYmIGlzRGVmKGkgPSBpLmhvb2spICYmIGlzRGVmKGkgPSBpLnJlbW92ZSkpIHtcbiAgICAgICAgICAgIGkoY2gsIHJtKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcm0oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7IC8vIFRleHQgbm9kZVxuICAgICAgICAgIGFwaS5yZW1vdmVDaGlsZChwYXJlbnRFbG0sIGNoLmVsbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDaGlsZHJlbihwYXJlbnRFbG0sIG9sZENoLCBuZXdDaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgdmFyIG9sZFN0YXJ0SWR4ID0gMCwgbmV3U3RhcnRJZHggPSAwO1xuICAgIHZhciBvbGRFbmRJZHggPSBvbGRDaC5sZW5ndGggLSAxO1xuICAgIHZhciBvbGRTdGFydFZub2RlID0gb2xkQ2hbMF07XG4gICAgdmFyIG9sZEVuZFZub2RlID0gb2xkQ2hbb2xkRW5kSWR4XTtcbiAgICB2YXIgbmV3RW5kSWR4ID0gbmV3Q2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWzBdO1xuICAgIHZhciBuZXdFbmRWbm9kZSA9IG5ld0NoW25ld0VuZElkeF07XG4gICAgdmFyIG9sZEtleVRvSWR4LCBpZHhJbk9sZCwgZWxtVG9Nb3ZlLCBiZWZvcmU7XG5cbiAgICB3aGlsZSAob2xkU3RhcnRJZHggPD0gb2xkRW5kSWR4ICYmIG5ld1N0YXJ0SWR4IDw9IG5ld0VuZElkeCkge1xuICAgICAgaWYgKGlzVW5kZWYob2xkU3RhcnRWbm9kZSkpIHtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdOyAvLyBWbm9kZSBoYXMgYmVlbiBtb3ZlZCBsZWZ0XG4gICAgICB9IGVsc2UgaWYgKGlzVW5kZWYob2xkRW5kVm5vZGUpKSB7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSkpIHtcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCByaWdodFxuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBhcGkuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIGFwaS5uZXh0U2libGluZyhvbGRFbmRWbm9kZS5lbG0pKTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCBsZWZ0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGFwaS5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRFbmRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1VuZGVmKG9sZEtleVRvSWR4KSkgb2xkS2V5VG9JZHggPSBjcmVhdGVLZXlUb09sZElkeChvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgICAgIGlkeEluT2xkID0gb2xkS2V5VG9JZHhbbmV3U3RhcnRWbm9kZS5rZXldO1xuICAgICAgICBpZiAoaXNVbmRlZihpZHhJbk9sZCkpIHsgLy8gTmV3IGVsZW1lbnRcbiAgICAgICAgICBhcGkuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSksIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWxtVG9Nb3ZlID0gb2xkQ2hbaWR4SW5PbGRdO1xuICAgICAgICAgIHBhdGNoVm5vZGUoZWxtVG9Nb3ZlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgIG9sZENoW2lkeEluT2xkXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBhcGkuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgZWxtVG9Nb3ZlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAob2xkU3RhcnRJZHggPiBvbGRFbmRJZHgpIHtcbiAgICAgIGJlZm9yZSA9IGlzVW5kZWYobmV3Q2hbbmV3RW5kSWR4KzFdKSA/IG51bGwgOiBuZXdDaFtuZXdFbmRJZHgrMV0uZWxtO1xuICAgICAgYWRkVm5vZGVzKHBhcmVudEVsbSwgYmVmb3JlLCBuZXdDaCwgbmV3U3RhcnRJZHgsIG5ld0VuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICB9IGVsc2UgaWYgKG5ld1N0YXJ0SWR4ID4gbmV3RW5kSWR4KSB7XG4gICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtLCBvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGF0Y2hWbm9kZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIHZhciBpLCBob29rO1xuICAgIGlmIChpc0RlZihpID0gdm5vZGUuZGF0YSkgJiYgaXNEZWYoaG9vayA9IGkuaG9vaykgJiYgaXNEZWYoaSA9IGhvb2sucHJlcGF0Y2gpKSB7XG4gICAgICBpKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIHZhciBlbG0gPSB2bm9kZS5lbG0gPSBvbGRWbm9kZS5lbG0sIG9sZENoID0gb2xkVm5vZGUuY2hpbGRyZW4sIGNoID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaWYgKG9sZFZub2RlID09PSB2bm9kZSkgcmV0dXJuO1xuICAgIGlmICghc2FtZVZub2RlKG9sZFZub2RlLCB2bm9kZSkpIHtcbiAgICAgIHZhciBwYXJlbnRFbG0gPSBhcGkucGFyZW50Tm9kZShvbGRWbm9kZS5lbG0pO1xuICAgICAgZWxtID0gY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgYXBpLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIGVsbSwgb2xkVm5vZGUuZWxtKTtcbiAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0sIFtvbGRWbm9kZV0sIDAsIDApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNEZWYodm5vZGUuZGF0YSkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMudXBkYXRlLmxlbmd0aDsgKytpKSBjYnMudXBkYXRlW2ldKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgICBpID0gdm5vZGUuZGF0YS5ob29rO1xuICAgICAgaWYgKGlzRGVmKGkpICYmIGlzRGVmKGkgPSBpLnVwZGF0ZSkpIGkob2xkVm5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgaWYgKGlzVW5kZWYodm5vZGUudGV4dCkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRDaCkgJiYgaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChvbGRDaCAhPT0gY2gpIHVwZGF0ZUNoaWxkcmVuKGVsbSwgb2xkQ2gsIGNoLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSBhcGkuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7XG4gICAgICAgIGFkZFZub2RlcyhlbG0sIG51bGwsIGNoLCAwLCBjaC5sZW5ndGggLSAxLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRDaCkpIHtcbiAgICAgICAgcmVtb3ZlVm5vZGVzKGVsbSwgb2xkQ2gsIDAsIG9sZENoLmxlbmd0aCAtIDEpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkge1xuICAgICAgICBhcGkuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvbGRWbm9kZS50ZXh0ICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICBhcGkuc2V0VGV4dENvbnRlbnQoZWxtLCB2bm9kZS50ZXh0KTtcbiAgICB9XG4gICAgaWYgKGlzRGVmKGhvb2spICYmIGlzRGVmKGkgPSBob29rLnBvc3RwYXRjaCkpIHtcbiAgICAgIGkob2xkVm5vZGUsIHZub2RlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24ob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgdmFyIGksIGVsbSwgcGFyZW50O1xuICAgIHZhciBpbnNlcnRlZFZub2RlUXVldWUgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnByZS5sZW5ndGg7ICsraSkgY2JzLnByZVtpXSgpO1xuXG4gICAgaWYgKGlzVW5kZWYob2xkVm5vZGUuc2VsKSkge1xuICAgICAgb2xkVm5vZGUgPSBlbXB0eU5vZGVBdChvbGRWbm9kZSk7XG4gICAgfVxuXG4gICAgaWYgKHNhbWVWbm9kZShvbGRWbm9kZSwgdm5vZGUpKSB7XG4gICAgICBwYXRjaFZub2RlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxtID0gb2xkVm5vZGUuZWxtO1xuICAgICAgcGFyZW50ID0gYXBpLnBhcmVudE5vZGUoZWxtKTtcblxuICAgICAgY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuXG4gICAgICBpZiAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgICAgIGFwaS5pbnNlcnRCZWZvcmUocGFyZW50LCB2bm9kZS5lbG0sIGFwaS5uZXh0U2libGluZyhlbG0pKTtcbiAgICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudCwgW29sZFZub2RlXSwgMCwgMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGluc2VydGVkVm5vZGVRdWV1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlW2ldLmRhdGEuaG9vay5pbnNlcnQoaW5zZXJ0ZWRWbm9kZVF1ZXVlW2ldKTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGNicy5wb3N0Lmxlbmd0aDsgKytpKSBjYnMucG9zdFtpXSgpO1xuICAgIHJldHVybiB2bm9kZTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7aW5pdDogaW5pdH07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zbmFiYmRvbS9zbmFiYmRvbS5qc1xuICoqIG1vZHVsZSBpZCA9IDg5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 90 */
/***/ function(module, exports) {

	eval("function createElement(tagName){\n  return document.createElement(tagName);\n}\n\nfunction createElementNS(namespaceURI, qualifiedName){\n  return document.createElementNS(namespaceURI, qualifiedName);\n}\n\nfunction createTextNode(text){\n  return document.createTextNode(text);\n}\n\n\nfunction insertBefore(parentNode, newNode, referenceNode){\n  parentNode.insertBefore(newNode, referenceNode);\n}\n\n\nfunction removeChild(node, child){\n  node.removeChild(child);\n}\n\nfunction appendChild(node, child){\n  node.appendChild(child);\n}\n\nfunction parentNode(node){\n  return node.parentElement;\n}\n\nfunction nextSibling(node){\n  return node.nextSibling;\n}\n\nfunction tagName(node){\n  return node.tagName;\n}\n\nfunction setTextContent(node, text){\n  node.textContent = text;\n}\n\nmodule.exports = {\n  createElement: createElement,\n  createElementNS: createElementNS,\n  createTextNode: createTextNode,\n  appendChild: appendChild,\n  removeChild: removeChild,\n  insertBefore: insertBefore,\n  parentNode: parentNode,\n  nextSibling: nextSibling,\n  tagName: tagName,\n  setTextContent: setTextContent\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3NuYWJiZG9tL2h0bWxkb21hcGkuanM/M2MyOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiOTAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBjcmVhdGVFbGVtZW50KHRhZ05hbWUpe1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZVVSSSwgcXVhbGlmaWVkTmFtZSl7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlVVJJLCBxdWFsaWZpZWROYW1lKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUodGV4dCl7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcbn1cblxuXG5mdW5jdGlvbiBpbnNlcnRCZWZvcmUocGFyZW50Tm9kZSwgbmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSl7XG4gIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpO1xufVxuXG5cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkKG5vZGUsIGNoaWxkKXtcbiAgbm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIGFwcGVuZENoaWxkKG5vZGUsIGNoaWxkKXtcbiAgbm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIHBhcmVudE5vZGUobm9kZSl7XG4gIHJldHVybiBub2RlLnBhcmVudEVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIG5leHRTaWJsaW5nKG5vZGUpe1xuICByZXR1cm4gbm9kZS5uZXh0U2libGluZztcbn1cblxuZnVuY3Rpb24gdGFnTmFtZShub2RlKXtcbiAgcmV0dXJuIG5vZGUudGFnTmFtZTtcbn1cblxuZnVuY3Rpb24gc2V0VGV4dENvbnRlbnQobm9kZSwgdGV4dCl7XG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCxcbiAgY3JlYXRlRWxlbWVudE5TOiBjcmVhdGVFbGVtZW50TlMsXG4gIGNyZWF0ZVRleHROb2RlOiBjcmVhdGVUZXh0Tm9kZSxcbiAgYXBwZW5kQ2hpbGQ6IGFwcGVuZENoaWxkLFxuICByZW1vdmVDaGlsZDogcmVtb3ZlQ2hpbGQsXG4gIGluc2VydEJlZm9yZTogaW5zZXJ0QmVmb3JlLFxuICBwYXJlbnROb2RlOiBwYXJlbnROb2RlLFxuICBuZXh0U2libGluZzogbmV4dFNpYmxpbmcsXG4gIHRhZ05hbWU6IHRhZ05hbWUsXG4gIHNldFRleHRDb250ZW50OiBzZXRUZXh0Q29udGVudFxufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NuYWJiZG9tL2h0bWxkb21hcGkuanNcbiAqKiBtb2R1bGUgaWQgPSA5MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 91 */
/***/ function(module, exports) {

	eval("function updateClass(oldVnode, vnode) {\n  var cur, name, elm = vnode.elm,\n      oldClass = oldVnode.data.class || {},\n      klass = vnode.data.class || {};\n  for (name in oldClass) {\n    if (!klass[name]) {\n      elm.classList.remove(name);\n    }\n  }\n  for (name in klass) {\n    cur = klass[name];\n    if (cur !== oldClass[name]) {\n      elm.classList[cur ? 'add' : 'remove'](name);\n    }\n  }\n}\n\nmodule.exports = {create: updateClass, update: updateClass};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3NuYWJiZG9tL21vZHVsZXMvY2xhc3MuanM/YWM1NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQiIsImZpbGUiOiI5MS5qcyIsInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIHVwZGF0ZUNsYXNzKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgY3VyLCBuYW1lLCBlbG0gPSB2bm9kZS5lbG0sXG4gICAgICBvbGRDbGFzcyA9IG9sZFZub2RlLmRhdGEuY2xhc3MgfHwge30sXG4gICAgICBrbGFzcyA9IHZub2RlLmRhdGEuY2xhc3MgfHwge307XG4gIGZvciAobmFtZSBpbiBvbGRDbGFzcykge1xuICAgIGlmICgha2xhc3NbbmFtZV0pIHtcbiAgICAgIGVsbS5jbGFzc0xpc3QucmVtb3ZlKG5hbWUpO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4ga2xhc3MpIHtcbiAgICBjdXIgPSBrbGFzc1tuYW1lXTtcbiAgICBpZiAoY3VyICE9PSBvbGRDbGFzc1tuYW1lXSkge1xuICAgICAgZWxtLmNsYXNzTGlzdFtjdXIgPyAnYWRkJyA6ICdyZW1vdmUnXShuYW1lKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7Y3JlYXRlOiB1cGRhdGVDbGFzcywgdXBkYXRlOiB1cGRhdGVDbGFzc307XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zbmFiYmRvbS9tb2R1bGVzL2NsYXNzLmpzXG4gKiogbW9kdWxlIGlkID0gOTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 92 */
/***/ function(module, exports) {

	eval("function updateProps(oldVnode, vnode) {\n  var key, cur, old, elm = vnode.elm,\n      oldProps = oldVnode.data.props || {}, props = vnode.data.props || {};\n  for (key in oldProps) {\n    if (!props[key]) {\n      delete elm[key];\n    }\n  }\n  for (key in props) {\n    cur = props[key];\n    old = oldProps[key];\n    if (old !== cur && (key !== 'value' || elm[key] !== cur)) {\n      elm[key] = cur;\n    }\n  }\n}\n\nmodule.exports = {create: updateProps, update: updateProps};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3NuYWJiZG9tL21vZHVsZXMvcHJvcHMuanM/YWZmNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQiIsImZpbGUiOiI5Mi5qcyIsInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIHVwZGF0ZVByb3BzKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIga2V5LCBjdXIsIG9sZCwgZWxtID0gdm5vZGUuZWxtLFxuICAgICAgb2xkUHJvcHMgPSBvbGRWbm9kZS5kYXRhLnByb3BzIHx8IHt9LCBwcm9wcyA9IHZub2RlLmRhdGEucHJvcHMgfHwge307XG4gIGZvciAoa2V5IGluIG9sZFByb3BzKSB7XG4gICAgaWYgKCFwcm9wc1trZXldKSB7XG4gICAgICBkZWxldGUgZWxtW2tleV07XG4gICAgfVxuICB9XG4gIGZvciAoa2V5IGluIHByb3BzKSB7XG4gICAgY3VyID0gcHJvcHNba2V5XTtcbiAgICBvbGQgPSBvbGRQcm9wc1trZXldO1xuICAgIGlmIChvbGQgIT09IGN1ciAmJiAoa2V5ICE9PSAndmFsdWUnIHx8IGVsbVtrZXldICE9PSBjdXIpKSB7XG4gICAgICBlbG1ba2V5XSA9IGN1cjtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7Y3JlYXRlOiB1cGRhdGVQcm9wcywgdXBkYXRlOiB1cGRhdGVQcm9wc307XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zbmFiYmRvbS9tb2R1bGVzL3Byb3BzLmpzXG4gKiogbW9kdWxlIGlkID0gOTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	eval("var is = __webpack_require__(12);\n\nfunction arrInvoker(arr) {\n  return function() {\n    if (!arr.length) return;\n    // Special case when length is two, for performance\n    arr.length === 2 ? arr[0](arr[1]) : arr[0].apply(undefined, arr.slice(1));\n  };\n}\n\nfunction fnInvoker(o) {\n  return function(ev) { \n    if (o.fn === null) return;\n    o.fn(ev); \n  };\n}\n\nfunction updateEventListeners(oldVnode, vnode) {\n  var name, cur, old, elm = vnode.elm,\n      oldOn = oldVnode.data.on || {}, on = vnode.data.on;\n  if (!on) return;\n  for (name in on) {\n    cur = on[name];\n    old = oldOn[name];\n    if (old === undefined) {\n      if (is.array(cur)) {\n        elm.addEventListener(name, arrInvoker(cur));\n      } else {\n        cur = {fn: cur};\n        on[name] = cur;\n        elm.addEventListener(name, fnInvoker(cur));\n      }\n    } else if (is.array(old)) {\n      // Deliberately modify old array since it's captured in closure created with `arrInvoker`\n      old.length = cur.length;\n      for (var i = 0; i < old.length; ++i) old[i] = cur[i];\n      on[name]  = old;\n    } else {\n      old.fn = cur;\n      on[name] = old;\n    }\n  }\n  if (oldOn) {\n    for (name in oldOn) {\n      if (on[name] === undefined) {\n        var old = oldOn[name];\n        if (is.array(old)) {\n          old.length = 0;\n        }\n        else {\n          old.fn = null;\n        }\n      }\n    }\n  }\n}\n\nmodule.exports = {create: updateEventListeners, update: updateEventListeners};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3NuYWJiZG9tL21vZHVsZXMvZXZlbnRsaXN0ZW5lcnMuanM/ZTE5YyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCO0FBQ0E7QUFDQSxhO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQiIsImZpbGUiOiI5My5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBpcyA9IHJlcXVpcmUoJy4uL2lzJyk7XG5cbmZ1bmN0aW9uIGFyckludm9rZXIoYXJyKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIWFyci5sZW5ndGgpIHJldHVybjtcbiAgICAvLyBTcGVjaWFsIGNhc2Ugd2hlbiBsZW5ndGggaXMgdHdvLCBmb3IgcGVyZm9ybWFuY2VcbiAgICBhcnIubGVuZ3RoID09PSAyID8gYXJyWzBdKGFyclsxXSkgOiBhcnJbMF0uYXBwbHkodW5kZWZpbmVkLCBhcnIuc2xpY2UoMSkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBmbkludm9rZXIobykge1xuICByZXR1cm4gZnVuY3Rpb24oZXYpIHsgXG4gICAgaWYgKG8uZm4gPT09IG51bGwpIHJldHVybjtcbiAgICBvLmZuKGV2KTsgXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUV2ZW50TGlzdGVuZXJzKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgbmFtZSwgY3VyLCBvbGQsIGVsbSA9IHZub2RlLmVsbSxcbiAgICAgIG9sZE9uID0gb2xkVm5vZGUuZGF0YS5vbiB8fCB7fSwgb24gPSB2bm9kZS5kYXRhLm9uO1xuICBpZiAoIW9uKSByZXR1cm47XG4gIGZvciAobmFtZSBpbiBvbikge1xuICAgIGN1ciA9IG9uW25hbWVdO1xuICAgIG9sZCA9IG9sZE9uW25hbWVdO1xuICAgIGlmIChvbGQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGlzLmFycmF5KGN1cikpIHtcbiAgICAgICAgZWxtLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgYXJySW52b2tlcihjdXIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1ciA9IHtmbjogY3VyfTtcbiAgICAgICAgb25bbmFtZV0gPSBjdXI7XG4gICAgICAgIGVsbS5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGZuSW52b2tlcihjdXIpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzLmFycmF5KG9sZCkpIHtcbiAgICAgIC8vIERlbGliZXJhdGVseSBtb2RpZnkgb2xkIGFycmF5IHNpbmNlIGl0J3MgY2FwdHVyZWQgaW4gY2xvc3VyZSBjcmVhdGVkIHdpdGggYGFyckludm9rZXJgXG4gICAgICBvbGQubGVuZ3RoID0gY3VyLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2xkLmxlbmd0aDsgKytpKSBvbGRbaV0gPSBjdXJbaV07XG4gICAgICBvbltuYW1lXSAgPSBvbGQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9sZC5mbiA9IGN1cjtcbiAgICAgIG9uW25hbWVdID0gb2xkO1xuICAgIH1cbiAgfVxuICBpZiAob2xkT24pIHtcbiAgICBmb3IgKG5hbWUgaW4gb2xkT24pIHtcbiAgICAgIGlmIChvbltuYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBvbGQgPSBvbGRPbltuYW1lXTtcbiAgICAgICAgaWYgKGlzLmFycmF5KG9sZCkpIHtcbiAgICAgICAgICBvbGQubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBvbGQuZm4gPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge2NyZWF0ZTogdXBkYXRlRXZlbnRMaXN0ZW5lcnMsIHVwZGF0ZTogdXBkYXRlRXZlbnRMaXN0ZW5lcnN9O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc25hYmJkb20vbW9kdWxlcy9ldmVudGxpc3RlbmVycy5qc1xuICoqIG1vZHVsZSBpZCA9IDkzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 94 */
/***/ function(module, exports) {

	eval("var raf = (typeof window !== 'undefined' && window.requestAnimationFrame) || setTimeout;\nvar nextFrame = function(fn) { raf(function() { raf(fn); }); };\n\nfunction setNextFrame(obj, prop, val) {\n  nextFrame(function() { obj[prop] = val; });\n}\n\nfunction updateStyle(oldVnode, vnode) {\n  var cur, name, elm = vnode.elm,\n      oldStyle = oldVnode.data.style || {},\n      style = vnode.data.style || {},\n      oldHasDel = 'delayed' in oldStyle;\n  for (name in oldStyle) {\n    if (!style[name]) {\n      elm.style[name] = '';\n    }\n  }\n  for (name in style) {\n    cur = style[name];\n    if (name === 'delayed') {\n      for (name in style.delayed) {\n        cur = style.delayed[name];\n        if (!oldHasDel || cur !== oldStyle.delayed[name]) {\n          setNextFrame(elm.style, name, cur);\n        }\n      }\n    } else if (name !== 'remove' && cur !== oldStyle[name]) {\n      elm.style[name] = cur;\n    }\n  }\n}\n\nfunction applyDestroyStyle(vnode) {\n  var style, name, elm = vnode.elm, s = vnode.data.style;\n  if (!s || !(style = s.destroy)) return;\n  for (name in style) {\n    elm.style[name] = style[name];\n  }\n}\n\nfunction applyRemoveStyle(vnode, rm) {\n  var s = vnode.data.style;\n  if (!s || !s.remove) {\n    rm();\n    return;\n  }\n  var name, elm = vnode.elm, idx, i = 0, maxDur = 0,\n      compStyle, style = s.remove, amount = 0, applied = [];\n  for (name in style) {\n    applied.push(name);\n    elm.style[name] = style[name];\n  }\n  compStyle = getComputedStyle(elm);\n  var props = compStyle['transition-property'].split(', ');\n  for (; i < props.length; ++i) {\n    if(applied.indexOf(props[i]) !== -1) amount++;\n  }\n  elm.addEventListener('transitionend', function(ev) {\n    if (ev.target === elm) --amount;\n    if (amount === 0) rm();\n  });\n}\n\nmodule.exports = {create: updateStyle, update: updateStyle, destroy: applyDestroyStyle, remove: applyRemoveStyle};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3NuYWJiZG9tL21vZHVsZXMvc3R5bGUuanM/NjYyNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLDhCQUE4QixpQkFBaUIsU0FBUyxFQUFFLEVBQUU7O0FBRTVEO0FBQ0Esd0JBQXdCLGlCQUFpQixFQUFFO0FBQzNDOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSxrQkFBa0IiLCJmaWxlIjoiOTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcmFmID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHx8IHNldFRpbWVvdXQ7XG52YXIgbmV4dEZyYW1lID0gZnVuY3Rpb24oZm4pIHsgcmFmKGZ1bmN0aW9uKCkgeyByYWYoZm4pOyB9KTsgfTtcblxuZnVuY3Rpb24gc2V0TmV4dEZyYW1lKG9iaiwgcHJvcCwgdmFsKSB7XG4gIG5leHRGcmFtZShmdW5jdGlvbigpIHsgb2JqW3Byb3BdID0gdmFsOyB9KTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlU3R5bGUob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBjdXIsIG5hbWUsIGVsbSA9IHZub2RlLmVsbSxcbiAgICAgIG9sZFN0eWxlID0gb2xkVm5vZGUuZGF0YS5zdHlsZSB8fCB7fSxcbiAgICAgIHN0eWxlID0gdm5vZGUuZGF0YS5zdHlsZSB8fCB7fSxcbiAgICAgIG9sZEhhc0RlbCA9ICdkZWxheWVkJyBpbiBvbGRTdHlsZTtcbiAgZm9yIChuYW1lIGluIG9sZFN0eWxlKSB7XG4gICAgaWYgKCFzdHlsZVtuYW1lXSkge1xuICAgICAgZWxtLnN0eWxlW25hbWVdID0gJyc7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBzdHlsZSkge1xuICAgIGN1ciA9IHN0eWxlW25hbWVdO1xuICAgIGlmIChuYW1lID09PSAnZGVsYXllZCcpIHtcbiAgICAgIGZvciAobmFtZSBpbiBzdHlsZS5kZWxheWVkKSB7XG4gICAgICAgIGN1ciA9IHN0eWxlLmRlbGF5ZWRbbmFtZV07XG4gICAgICAgIGlmICghb2xkSGFzRGVsIHx8IGN1ciAhPT0gb2xkU3R5bGUuZGVsYXllZFtuYW1lXSkge1xuICAgICAgICAgIHNldE5leHRGcmFtZShlbG0uc3R5bGUsIG5hbWUsIGN1cik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5hbWUgIT09ICdyZW1vdmUnICYmIGN1ciAhPT0gb2xkU3R5bGVbbmFtZV0pIHtcbiAgICAgIGVsbS5zdHlsZVtuYW1lXSA9IGN1cjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlEZXN0cm95U3R5bGUodm5vZGUpIHtcbiAgdmFyIHN0eWxlLCBuYW1lLCBlbG0gPSB2bm9kZS5lbG0sIHMgPSB2bm9kZS5kYXRhLnN0eWxlO1xuICBpZiAoIXMgfHwgIShzdHlsZSA9IHMuZGVzdHJveSkpIHJldHVybjtcbiAgZm9yIChuYW1lIGluIHN0eWxlKSB7XG4gICAgZWxtLnN0eWxlW25hbWVdID0gc3R5bGVbbmFtZV07XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlSZW1vdmVTdHlsZSh2bm9kZSwgcm0pIHtcbiAgdmFyIHMgPSB2bm9kZS5kYXRhLnN0eWxlO1xuICBpZiAoIXMgfHwgIXMucmVtb3ZlKSB7XG4gICAgcm0oKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG5hbWUsIGVsbSA9IHZub2RlLmVsbSwgaWR4LCBpID0gMCwgbWF4RHVyID0gMCxcbiAgICAgIGNvbXBTdHlsZSwgc3R5bGUgPSBzLnJlbW92ZSwgYW1vdW50ID0gMCwgYXBwbGllZCA9IFtdO1xuICBmb3IgKG5hbWUgaW4gc3R5bGUpIHtcbiAgICBhcHBsaWVkLnB1c2gobmFtZSk7XG4gICAgZWxtLnN0eWxlW25hbWVdID0gc3R5bGVbbmFtZV07XG4gIH1cbiAgY29tcFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbG0pO1xuICB2YXIgcHJvcHMgPSBjb21wU3R5bGVbJ3RyYW5zaXRpb24tcHJvcGVydHknXS5zcGxpdCgnLCAnKTtcbiAgZm9yICg7IGkgPCBwcm9wcy5sZW5ndGg7ICsraSkge1xuICAgIGlmKGFwcGxpZWQuaW5kZXhPZihwcm9wc1tpXSkgIT09IC0xKSBhbW91bnQrKztcbiAgfVxuICBlbG0uYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGZ1bmN0aW9uKGV2KSB7XG4gICAgaWYgKGV2LnRhcmdldCA9PT0gZWxtKSAtLWFtb3VudDtcbiAgICBpZiAoYW1vdW50ID09PSAwKSBybSgpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7Y3JlYXRlOiB1cGRhdGVTdHlsZSwgdXBkYXRlOiB1cGRhdGVTdHlsZSwgZGVzdHJveTogYXBwbHlEZXN0cm95U3R5bGUsIHJlbW92ZTogYXBwbHlSZW1vdmVTdHlsZX07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zbmFiYmRvbS9tb2R1bGVzL3N0eWxlLmpzXG4gKiogbW9kdWxlIGlkID0gOTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }
/******/ ]);